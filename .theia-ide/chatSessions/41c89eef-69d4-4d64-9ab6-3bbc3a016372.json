{
  "version": 1,
  "title": "Command Tree Diagnostic Logging for Race Condition",
  "pinnedAgentId": "Coder",
  "saveDate": 1769614397394,
  "model": {
    "sessionId": "41c89eef-69d4-4d64-9ab6-3bbc3a016372",
    "location": "panel",
    "hierarchy": {
      "rootBranchId": "a2c2c6f9-b878-46a9-9b5e-6a845451a33e",
      "branches": {
        "a2c2c6f9-b878-46a9-9b5e-6a845451a33e": {
          "id": "a2c2c6f9-b878-46a9-9b5e-6a845451a33e",
          "items": [
            {
              "requestId": "44acca1a-222b-4f9c-be51-07e07c09f9fb"
            }
          ],
          "activeBranchIndex": 0
        }
      }
    },
    "requests": [
      {
        "id": "44acca1a-222b-4f9c-be51-07e07c09f9fb",
        "text": "@Coder \n## Plan: Add Diagnostic Logging for Async Child Creation Race Condition\n\n### Goal\nAdd logging statements prefixed with \"JF:\" to diagnose the race condition where `expandSubTree` proceeds before async child creation completes.\n\n### File to Modify\n`app/packages/capture/src/browser/command-tree/command-tree-model.ts`\n\n### Step 1: Add logging in `doExpandSubTree` method\n\nLocate the `doExpandSubTree` method (around line 3665). After each call to `this.ensureLazyChildrenLoaded(expandedNode)`, add a log statement.\n\n**Location 1** (around line 3679, after `await this.ensureLazyChildrenLoaded(expandedNode);`):\n\n\n```typescript\nawait this.ensureLazyChildrenLoaded(expandedNode);\nconsole.log(`JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, children count: ${expandedNode.children.length}, children ids: ${expandedNode.children.map(c => c.id).join(', ')}`);\nnextLevelNodes.push(...expandedNode.children);\n```\n\n\n\n**Location 2** (around line 3687, after the second `await this.ensureLazyChildrenLoaded(currentNode);`):\n\n\n```typescript\nawait this.ensureLazyChildrenLoaded(currentNode);\nconsole.log(`JF: doExpandSubTree - after ensureLazyChildrenLoaded (already expanded) for ${currentNode.id}, children count: ${currentNode.children.length}, children ids: ${currentNode.children.map(c => c.id).join(', ')}`);\nnextLevelNodes.push(...currentNode.children);\n```\n\n\n\n### Step 2: Add logging in `createChildEventNodesForRange` function\n\nLocate the `createChildEventNodesForRange` async function (around line 3140).\n\n**At the start of the function** (after the function signature and before `const stateTracker`):\n\n\n```typescript\nconsole.log(`JF: createChildEventNodesForRange START for parent ${parentNode.id}, apiEventCommandArray length: ${apiEventCommandArray.length}`);\n```\n\n\n\n**At the end of the function** (just before the final `return childCommandIndex;`):\n\n\n```typescript\nconsole.log(`JF: createChildEventNodesForRange END for parent ${parentNode.id}, final children count: ${parentNode.children.length}`);\nreturn childCommandIndex;\n```\n\n\n\n### Step 3: Add logging in `createLazyLoadingNode` function\n\nLocate the `createLazyLoadingNode` function (around line 3886).\n\n**After the `await load(batchQuery);` call completes** (around line 3904, after the try-catch-finally block but before `CompositeTreeNode.removeChild`):\n\n\n```typescript\n} finally {\n    loadingInProgress = false;\n}\nconsole.log(`JF: createLazyLoadingNode - load completed for parent ${parent.id}, children count before removeChild: ${parent.children.length}`);\nCompositeTreeNode.removeChild(parent, loadingNode);\n```\n\n\n\n### Step 4: Add logging in node creation functions that use async child creation\n\n**In `CommandCommandBufferInstanceNode.create`** (around line 1018, in the `.then()` callback):\n\n\n```typescript\ncreateChildEventNodesForRange<AllRangeTypes>(...)\n    .then(() => {\n        console.log(`JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\n    })\n    .catch(error => {\n```\n\n\n\n**In `CommandDebugLabelGroupNode.create`** (around line 730, in the `.then()` callback):\n\n\n```typescript\ncreateChildEventNodesForRange<AllRangeTypes>(...)\n    .then(() => {\n        console.log(`JF: CommandDebugLabelGroupNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\n    })\n    .catch(error => {\n```\n\n\n\n**In `CommandRenderSubpassInstanceNode.create`** (around line 1669, in the `.then()` callback):\n\n\n```typescript\ncreateChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(...)\n    .then(() => {\n        console.log(`JF: CommandRenderSubpassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\n    })\n    .catch(error => {\n```\n\n\n\n**In `CommandDynamicRenderPassInstanceNode.create`** (around line 1766, in the `.then()` callback):\n\n\n```typescript\ncreateChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(...)\n    .then(() => {\n        console.log(`JF: CommandDynamicRenderPassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\n    })\n    .catch(error => {\n```\n\n\n\n### Summary of Changes\n\nAll changes are in `app/packages/capture/src/browser/command-tree/command-tree-model.ts`:\n\n1. Two log statements in `doExpandSubTree` method after `ensureLazyChildrenLoaded` calls\n2. Two log statements in `createChildEventNodesForRange` function (start and end)\n3. One log statement in `createLazyLoadingNode` function after load completes\n4. Four log statements in node creation `.then()` callbacks:\n   - `CommandCommandBufferInstanceNode.create`\n   - `CommandDebugLabelGroupNode.create`\n   - `CommandRenderSubpassInstanceNode.create`\n   - `CommandDynamicRenderPassInstanceNode.create`\n\n### Expected Output\n\nWhen running \"Expand Subtree\" on a frame, the logs should show timing like:\n\n\n```\n```\nJF: createChildEventNodesForRange START for parent X\nJF: doExpandSubTree - after ensureLazyChildrenLoaded for X, children count: 2\nJF: createChildEventNodesForRange END for parent X, children count: 10  <-- This comes AFTER doExpandSubTree moved on\n```\n\n\n\nThis would confirm the race condition where `doExpandSubTree` proceeds before async child creation finishes.",
        "agentId": "Coder",
        "changeSet": {
          "title": "Changes proposed",
          "elements": [
            {
              "kind": "file",
              "uri": "file:///home/johannes/Git/sokatoa/app/packages/capture/src/browser/command-tree/command-tree-model.ts",
              "name": "command-tree-model.ts",
              "icon": "ts-icon medium-blue theia-file-icons-js",
              "additionalInfo": "app/packages/capture/src/browser/command-tree",
              "state": "stale",
              "type": "modify",
              "data": {
                "targetState": "/********************************************************************************\n    Copyright 2024-2026 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\nimport { GFXRQueryBuilderService } from '@sokatoa/gfxr-consumer/lib/';\nimport {\n    DynamicStateEntry,\n    PipelineBindPoint,\n    PipelineBindPointShaderStageFlags,\n    StateType\n} from '@sokatoa/gfxr-consumer/lib/browser/gfxr-data-service';\nimport { PartialRecord } from '@sokatoa/platform/lib';\nimport { BulkTree, BulkTreeModel, ResourceTreeNode, SokatoaLifecycleTreeNode } from '@sokatoa/platform/lib/browser';\nimport { GroupByOptions, MiscPreferences, MiscPrefs } from '@sokatoa/platform/lib/browser/misc-preferences';\nimport { TreeStructureChangeEmitter } from '@sokatoa/platform/lib/browser/tree-table/tree-table-widget';\nimport { ImageAccessorService } from '@sokatoa/platform/lib/common';\nimport { CompressedFileService, usesCompressionExtension } from '@sokatoa/platform/lib/common/compressed-file-service';\nimport { asError } from '@sokatoa/platform/lib/common/error-utils';\nimport { ApiResources, DescriptorResource, DrawApiResult } from '@sokatoa/platform/lib/common/gfxr-apis';\nimport { CancellationToken, Disposable, Emitter, Event, Path, URI } from '@theia/core';\nimport {\n    CompositeTreeNode,\n    DepthFirstTreeIterator,\n    ExpandableTreeNode,\n    SelectableTreeNode,\n    TreeModelImpl,\n    TreeNode\n} from '@theia/core/lib/browser';\nimport { RGBA } from '@theia/core/lib/common/color';\nimport { inject, injectable, postConstruct } from '@theia/core/shared/inversify';\nimport { PNG } from 'pngjs/browser';\nimport { lookupResourceFormat, UncompressedResourceFormat } from '../../common/format-handler';\nimport { extractData } from '../../common/geometry-utils';\nimport { GfxrScreenshotService, requestThumbnails, ScreenshotType, ThumbnailRequestOptions } from '../../common/gfxr-screenshot-service';\nimport { convertDataToImageData } from '../../common/host-side-conversion/vulkan-image';\nimport { FrameRangeSelectionService } from '../capture-widget/frame-range-selection-service';\nimport { placeholderScale } from '../graphics-pipeline-widget/graphics-pipeline-screenshot-requests';\nimport {\n    CaptureDatasetWidgetContext,\n    CaptureDatasetWidgetProfile,\n    CaptureDatasetWidgetReplayContext\n} from '../profile-ui/capture-dataset-widget-types';\nimport { CommandTreePreferenceState } from './command-tree-model-preferences';\nimport {\n    CommandTreeAccelerationStructureBuildInstance,\n    CommandTreeAccelerationStructureCopyInstance,\n    CommandTreeApiEvent,\n    CommandTreeCommandBufferInstance,\n    CommandTreeDataWithFunctionAndDebugNames,\n    CommandTreeDebugLabelGroupInstance,\n    CommandTreeDynamicRenderPassInstance,\n    CommandTreeFrame,\n    CommandTreeQueueDebugLabelGroup,\n    CommandTreeQueueDebugLabelInsert,\n    CommandTreeQueuePresent,\n    CommandTreeQueueSubmit,\n    CommandTreeRenderPassInstance,\n    CommandTreeRenderSubpassInstance,\n    CommandTreeSecondaryCommandBufferInstance,\n    CommandTreeTransferCommandInstance,\n    overrideDynamicState,\n    queryClusterInstanceDynamicState,\n    queryClusterInstanceDynamicStateBatched,\n    queryDispatchInstanceDynamicState,\n    queryDispatchInstanceDynamicStateBatched,\n    queryDrawInstanceDynamicState,\n    queryDrawInstanceDynamicStateBatched,\n    queryMeshTaskInstanceDynamicState,\n    queryMeshTaskInstanceDynamicStateBatched,\n    queryRaytracingInstanceDynamicState,\n    queryRaytracingInstanceDynamicStateBatched,\n    querySecondaryCommandBufferEndDynamicState,\n    QueryTreeDataOptions\n} from './command-tree-service';\nimport { LazyLoadableNode, triggerLazyLoadAndWaitForRemoval } from './lazy-load-utils';\nimport { CommandTreeDataQueriedRootProvider } from './providers/command-tree-root-provider';\n\n// Extension names\nconst VK_NV_COMMAND_BUFFER_INHERITANCE = 'VK_NV_command_buffer_inheritance';\nconst VK_NV_INHERITED_VIEWPORT_SCISSOR = 'VK_NV_inherited_viewport_scissor';\n\n/**\n * Helper type to make TreeNode.parent writable during node construction.\n * TreeNode.parent is readonly, but during tree construction we need to update it.\n */\ninterface MutableParent {\n    parent: CompositeTreeNode | undefined;\n}\n\n/**\n * Check if VK_NV_command_buffer_inheritance extension is enabled for a device.\n * This extension enables full state inheritance between command buffers and leak-back.\n */\nfunction hasCommandBufferInheritance(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_COMMAND_BUFFER_INHERITANCE) ?? false;\n}\n\n/**\n * Check if VK_NV_inherited_viewport_scissor extension is enabled for a device.\n * This extension enables limited viewport/scissor inheritance for secondary command buffers.\n */\nfunction hasInheritedViewportScissor(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_INHERITED_VIEWPORT_SCISSOR) ?? false;\n}\n\n/**\n * Filter dynamic state to only viewport and scissor entries.\n * Used for VK_NV_inherited_viewport_scissor extension.\n */\nasync function filterDynamicStateForViewportScissor(statePromise: Promise<DynamicStateEntry[]>): Promise<DynamicStateEntry[]> {\n    const state = await statePromise;\n    return state.filter(entry => entry.stateType === StateType.VIEWPORT || entry.stateType === StateType.SCISSOR);\n}\n\n/**\n * Tracks dynamic state that may be updated as secondary command buffers execute\n * (when VK_NV_command_buffer_inheritance is enabled).\n */\nclass DynamicStateTracker {\n    private currentStatePromise: Promise<DynamicStateEntry[]>;\n\n    constructor(initialState: Promise<DynamicStateEntry[]>) {\n        this.currentStatePromise = initialState;\n    }\n\n    getCurrentState(): Promise<DynamicStateEntry[]> {\n        return this.currentStatePromise;\n    }\n\n    updateState(newState: Promise<DynamicStateEntry[]>): void {\n        this.currentStatePromise = newState;\n    }\n}\n\n/** Internal context for a command tree model.\n *\n * contains all the fixed data needed for the model,\n * e.g. services, etc.\n */\ninterface CommandTreeContext {\n    dbId: number;\n    data: CommandTreeDataWithFunctionAndDebugNames;\n    screenshotService: GfxrScreenshotService;\n    fileService: CompressedFileService;\n    profile: CaptureDatasetWidgetProfile;\n    context: CaptureDatasetWidgetContext;\n    tree: CommandTree;\n    gfxrQueryBuilderService: GFXRQueryBuilderService;\n    imageAccessorService: ImageAccessorService;\n    createDrawOrDispatchChildren: boolean;\n    rootNode: CommandRootNode;\n    deviceExtensions: Map<number, Set<string>>;\n}\n\n/**\n * Helper function to look up the debug name for an object at a specific API event.\n * Finds the most recent debug name that was set at or before the target API event.\n * @param debugNameLookup - Map of objectHandle to array of {apiEvent, name} sorted by apiEvent\n * @param objectHandle - The object handle to look up\n * @param targetApiEvent - The API event at which we want to know the object's name\n * @returns The debug name if found, undefined otherwise\n */\nfunction getDebugNameAtApiEvent(\n    debugNameLookup: Map<number, Array<{ apiEvent: number; name: string }>>,\n    objectHandle: number | null | undefined,\n    targetApiEvent: number\n): string | undefined {\n    if (typeof objectHandle !== 'number') {\n        return undefined;\n    }\n\n    const entries = debugNameLookup.get(objectHandle);\n    if (!entries || entries.length === 0) {\n        return undefined;\n    }\n\n    // Binary search for the most recent name at or before targetApiEvent\n    let left = 0;\n    let right = entries.length - 1;\n    let result: string | undefined = undefined;\n\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (entries[mid].apiEvent <= targetApiEvent) {\n            result = entries[mid].name;\n            left = mid + 1; // Look for a more recent name\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n\nexport interface CommandRootNode extends ResourceTreeNode<CommandTreeDataWithFunctionAndDebugNames>, CompositeTreeNode, ExpandableTreeNode {\n    resourceType: typeof CommandRootNode.RESOURCE_TYPE;\n    children: CommandFrameNode[];\n    dbId: number;\n    profile: CaptureDatasetWidgetProfile;\n    tree?: CommandTree; // Back-reference to the tree that owns this root\n    // Cached maps for queue debug labels to avoid rebuilding for each frame\n    queueDebugLabelGroupsBySubmitId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelGroupsByPresentId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelInsertsByApiEvent: Map<number, CommandTreeQueueDebugLabelInsert>;\n}\n\nexport namespace CommandRootNode {\n    export const ID = 'sokatoa-command-tree-widget';\n\n    export const RESOURCE_TYPE = '__root__';\n\n    export function is(node: TreeNode | undefined): node is CommandRootNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRootNode.RESOURCE_TYPE);\n    }\n\n    export function create(\n        dbId: number,\n        data: CommandTreeDataWithFunctionAndDebugNames,\n        screenshotService: GfxrScreenshotService,\n        profile: CaptureDatasetWidgetProfile,\n        context: CaptureDatasetWidgetContext,\n        tree: CommandTree,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        imageAccessorService: ImageAccessorService,\n        fileService: CompressedFileService,\n        createDrawOrDispatchChildren: boolean,\n        deviceExtensions: Map<number, Set<string>>\n    ): CommandRootNode {\n        // Build maps for queue debug labels once for all frames\n        const queueDebugLabelGroupsBySubmitId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelGroupsByPresentId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelInsertsByApiEvent = new Map<number, CommandTreeQueueDebugLabelInsert>();\n\n        for (const group of Object.values(data.queueDebugLabelGroups)) {\n            if (group) {\n                for (const submitId of group.queueSubmitIds) {\n                    queueDebugLabelGroupsBySubmitId.set(submitId, group);\n                }\n                for (const presentId of group.queuePresentIds) {\n                    queueDebugLabelGroupsByPresentId.set(presentId, group);\n                }\n            }\n        }\n\n        for (const insert of Object.values(data.queueDebugLabelInserts)) {\n            if (insert) {\n                queueDebugLabelInsertsByApiEvent.set(insert.apiEvent, insert);\n            }\n        }\n\n        const rootNode: CommandRootNode = {\n            visible: false,\n            id: CommandRootNode.ID,\n            name: 'ProfileTree',\n            parent: undefined,\n            expanded: true,\n            children: [],\n            resourceType: CommandRootNode.RESOURCE_TYPE,\n            resource: data,\n            dbId,\n            profile,\n            queueDebugLabelGroupsBySubmitId,\n            queueDebugLabelGroupsByPresentId,\n            queueDebugLabelInsertsByApiEvent\n        };\n        const ctx: CommandTreeContext = {\n            dbId,\n            data,\n            screenshotService,\n            fileService,\n            profile,\n            context,\n            tree,\n            gfxrQueryBuilderService,\n            imageAccessorService,\n            createDrawOrDispatchChildren,\n            rootNode,\n            deviceExtensions\n        };\n        const modelBuildStart = Date.now();\n        const frames = Object.values(data.frames);\n        rootNode.children = frames.flatMap(child => (child ? CommandFrameNode.create(ctx, child, rootNode) : []));\n        console.debug(`Model loaded in ${Date.now() - modelBuildStart} ms`);\n        return rootNode;\n    }\n}\n\nexport interface DebugMarker {\n    name: string;\n    color?: RGBA;\n}\n\nexport interface WithDebugMarker {\n    debugMarker?: DebugMarker;\n}\n\nexport namespace WithDebugMarker {\n    /** Type guard for a `node` that is or has a debug marker. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugMarker> {\n        return 'debugMarker' in node && node.debugMarker !== undefined;\n    }\n}\n\nexport interface WithDebugName {\n    debugName?: string;\n}\n\nexport namespace WithDebugName {\n    /** Type guard for a `node` that has a debug name. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugName> {\n        return 'debugName' in node && node.debugName !== undefined;\n    }\n}\n\ninterface LabelData {\n    labelName: string | undefined | null;\n    colorR: number | undefined | null;\n    colorG: number | undefined | null;\n    colorB: number | undefined | null;\n    colorA: number | undefined | null;\n}\n\nfunction setDebugMarkerData(node: WithDebugMarker, labelData: LabelData): void {\n    const name = labelData.labelName ?? 'Debug marker';\n    const color = {\n        r: (labelData.colorR ?? 1) * 255,\n        g: (labelData.colorG ?? 1) * 255,\n        b: (labelData.colorB ?? 1) * 255,\n        a: (labelData.colorA ?? 1) * 255\n    };\n\n    node.debugMarker = { name };\n    if (color.a !== 0 || color.b !== 0 || color.g !== 0 || color.r !== 0) {\n        node.debugMarker.color = color;\n    }\n}\n\nexport interface CommandFrameNode extends ResourceTreeNode<CommandTreeFrame>, ExpandableTreeNode, SelectableTreeNode {\n    label: string;\n    frameIndex: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandFrameNode.RESOURCE_TYPE;\n    thumbnail?: string;\n}\n\nexport namespace CommandFrameNode {\n    export const RESOURCE_TYPE = 'frame';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandFrameNode {\n        return ResourceTreeNode.hasResourceType(node, CommandFrameNode.RESOURCE_TYPE);\n    }\n\n    export function getId(frame: CommandTreeFrame): string {\n        return frame.frameIndex.toString();\n    }\n\n    export function create(ctx: CommandTreeContext, element: CommandTreeFrame, parent: CompositeTreeNode): CommandFrameNode {\n        const node: CommandFrameNode & SokatoaLifecycleTreeNode = {\n            id: getId(element),\n            frameIndex: element.frameIndex,\n            label: `Frame ${element.frameIndex}`,\n            children: [],\n            expanded: false,\n            selected: false,\n            parent,\n            resourceType: CommandFrameNode.RESOURCE_TYPE,\n            resource: element\n        };\n\n        const root = ctx.rootNode;\n\n        const children: CommandTreeNode[] = [];\n        let queueSubmitIndex = 0;\n        let queuePresentIndex = 0;\n        let accelerationStructureBuildIndex = 0;\n        let accelerationStructureCopyIndex = 0;\n\n        // Track current active debug label group and its children\n        let activeDebugLabelGroup: CommandTreeQueueDebugLabelGroup | undefined;\n        let activeGroupChildren: (CommandQueueSubmitNode | CommandQueuePresentNode)[] = [];\n        let queueDebugLabelGroupInstanceIndex = 0;\n\n        // Helper to finalize the active group and add it to children\n        const finalizeActiveGroup = (): void => {\n            if (activeDebugLabelGroup && activeGroupChildren.length > 0) {\n                children.push(\n                    CommandQueueDebugLabelGroupNode.create(\n                        ctx,\n                        activeDebugLabelGroup,\n                        node,\n                        activeGroupChildren,\n                        queueDebugLabelGroupInstanceIndex++\n                    )\n                );\n                activeDebugLabelGroup = undefined;\n                activeGroupChildren = [];\n            }\n        };\n\n        for (let id = element.beginApiEvent; id <= (element.endApiEvent ?? element.beginApiEvent); id++) {\n            // Check for queue debug label insert at this apiEvent\n            const queueDebugLabelInsert = root.queueDebugLabelInsertsByApiEvent.get(id);\n            if (queueDebugLabelInsert) {\n                // Inserts can appear in the middle of groups, so finalize any active group first\n                finalizeActiveGroup();\n                children.push(CommandQueueDebugLabelNode.create(ctx, queueDebugLabelInsert, node));\n            }\n\n            const apiEvent = root.resource.apiEvents[id];\n            if (apiEvent) {\n                if (apiEvent.submissionId && element.queueSubmitIds.includes(apiEvent.submissionId)) {\n                    const queueSubmit = root.resource.queueSubmits[apiEvent.submissionId];\n                    if (queueSubmit) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsBySubmitId.get(apiEvent.submissionId);\n\n                        // Check if this submit is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queueSubmit not found for submissionId ${apiEvent.submissionId}`);\n                    }\n                } else if (apiEvent.presentId && element.queuePresentIds.includes(apiEvent.presentId)) {\n                    const queuePresent = root.resource.queuePresents[apiEvent.presentId];\n                    if (queuePresent) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsByPresentId.get(apiEvent.presentId);\n\n                        // Check if this present is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queuePresent not found for presentId ${apiEvent.presentId}`);\n                    }\n                } else if (\n                    apiEvent.accelerationStructureBuildInstanceId &&\n                    element.accelerationStructureBuildIds.includes(apiEvent.accelerationStructureBuildInstanceId)\n                ) {\n                    // Acceleration structure builds interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureBuild =\n                        root.resource.topLevelAccelerationStructureBuilds[apiEvent.accelerationStructureBuildInstanceId];\n                    if (accelerationStructureBuild) {\n                        children.push(\n                            CommandAccelerationStructureBuildNode.create(\n                                accelerationStructureBuild,\n                                node,\n                                accelerationStructureBuildIndex++\n                            )\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureBuildInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureBuild not found for accelerationStructureBuildInstanceId ${iId}`\n                        );\n                    }\n                } else if (\n                    apiEvent.accelerationStructureCopyInstanceId &&\n                    element.accelerationStructureCopyIds.includes(apiEvent.accelerationStructureCopyInstanceId)\n                ) {\n                    // Acceleration structure copies interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureCopy =\n                        root.resource.topLevelAccelerationStructureCopies[apiEvent.accelerationStructureCopyInstanceId];\n                    if (accelerationStructureCopy) {\n                        children.push(\n                            CommandAccelerationStructureCopyNode.create(accelerationStructureCopy, node, accelerationStructureCopyIndex++)\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureCopyInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureCopy not found for accelerationStructureCopyInstanceId ${iId}`\n                        );\n                    }\n                }\n            }\n        }\n\n        // Finalize any remaining active debug label group at the end\n        finalizeActiveGroup();\n\n        node.children = children;\n\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        const request: ThumbnailRequestOptions = {\n            profileOrReplay: replay ?? ctx.profile,\n            startFrame: element.frameIndex,\n            endFrame: element.frameIndex,\n            requesterDbgName: `Command tree frame ${element.frameIndex}`,\n            onScreenshotReady: result => {\n                ctx.imageAccessorService\n                    .accessImage(new URL(URI.fromFilePath(result.path).toString()))\n                    .then(url => {\n                        node.thumbnail = url.url.toString();\n                        ctx.tree.addToDispose(url);\n                        void ctx.tree.refresh(node);\n                    })\n                    .catch(reason => {\n                        const error = asError(reason);\n                        console.error(error);\n                    });\n            },\n            onRequestComplete: (success, message) => {\n                if (!success) {\n                    console.error(`Request for frame thumbnails failed: ${message}`);\n                }\n            }\n        };\n        const onWillRender = (): void => {\n            requestThumbnails(ctx.screenshotService, request);\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', onWillRender);\n        };\n        SokatoaLifecycleTreeNode.register(node, 'onWillRender', onWillRender);\n        return node;\n    }\n\n    /**\n     * Retrieve the `CommandFrameNode` that is or contains the given `node`.\n     * Returns `undefined` in the case that the `node` is an ancestor of or\n     * otherwise not contained in an `CommandFrameNode`.\n     */\n    export function getCommandFrameNodeContaining(node: TreeNode): CommandFrameNode | undefined {\n        return CommandFrameNode.is(node) ? node : node.parent ? CommandFrameNode.getCommandFrameNodeContaining(node.parent) : undefined;\n    }\n}\n\nexport interface CommandEmptyNode extends LazyLoadableNode {\n    label: string;\n}\n\nexport namespace CommandEmptyNode {\n    export const GENERALIZED_TYPE = 'empty';\n\n    export function is(node: unknown): node is CommandEmptyNode {\n        return TreeNode.is(node) && node.id.endsWith('_empty');\n    }\n\n    export function getId(parent: CompositeTreeNode): string {\n        return `${parent.id}_empty`;\n    }\n\n    export function create(parent: CompositeTreeNode, load: CommandEmptyNode['load']): CommandEmptyNode {\n        return {\n            id: getId(parent),\n            label: 'Loading...',\n            parent,\n            load\n        };\n    }\n}\n\nexport interface CommandApiEventNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandApiEventNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandApiEventNode {\n    export const RESOURCE_TYPE = 'api-event';\n    export const GENERALIZED_TYPE = RESOURCE_TYPE;\n\n    export function is(node: TreeNode | undefined): node is CommandApiEventNode {\n        return ResourceTreeNode.hasResourceType(node, CommandApiEventNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEventId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex?: number\n    ): CommandApiEventNode {\n        const root = ctx.rootNode;\n        const node: CommandApiEventNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEventId,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex ?? ''}`,\n            parent,\n            resourceType: CommandApiEventNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId,\n            selected: false\n        };\n        // set debug marker data if node is a debug marker\n        if (element.debugLabelId) {\n            const labelData = root.resource.debugLabels[element.debugLabelId];\n            if (labelData) {\n                setDebugMarkerData(node, labelData);\n            }\n        }\n        return node;\n    }\n}\n\nexport interface CommandDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeDebugLabelGroupInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'debug-label-group';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDebugLabelGroupInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDebugLabelGroupInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDebugLabelGroupNode = {\n            id: getId(element, parent),\n            debugLabelInstanceId: element.labelId,\n            label: `${root.resource.functionNameLookup[element.functionNameId ?? -1] ?? '<not defined>'}`,\n            parent,\n            resourceType: CommandDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this debug label range\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this debug label group, add it to array\n            // - not self\n            // - only commands with same command buffer id\n            if (event && event.debugLabelId !== element.labelId && event.commandBufferInstanceId === element.commandBufferInstance) {\n                apiEventCommandArray.push(event);\n            }\n        }\n        // get array of debug label ranges with api event numbers within this debug label range\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this debug label range\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderPassInstance'\n        );\n        // get array of render subpass ranges with api event numbers within this debug label range\n        const renderSubpassInstances = createRangeInstanceArray(\n            element.renderSubpassInstanceIds,\n            root.resource.renderSubpassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderSubpassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this debug label range\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('subpassIndex' in rangeElement) {\n                    const renderSubpassInstanceNode = CommandRenderSubpassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderSubpassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            renderSubpassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                console.log(`JF: CommandDebugLabelGroupNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for debug label group:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `debug label group ${element.labelId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelGroup>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'queue-debug-label-group';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelGroup, parent: CompositeTreeNode, instanceIndex: number): string {\n        return `${parent.id}_qdl_group_${element.labelId}_${instanceIndex}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelGroup,\n        parent: CompositeTreeNode,\n        children: (CommandQueueSubmitNode | CommandQueuePresentNode)[],\n        instanceIndex: number\n    ): CommandQueueDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelGroupNode = {\n            id: getId(element, parent, instanceIndex),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label Group',\n            queue: element.queue!,\n            parent,\n            resourceType: CommandQueueDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        // Update parent references for children since they were created with a different parent\n        // and are now being reparented to this debug label group node\n        for (const child of children) {\n            // Cast away readonly to update parent during node construction\n            (child as MutableParent).parent = node;\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelInsert>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    apiEventId: number;\n    resourceType: typeof CommandQueueDebugLabelNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelNode {\n    export const RESOURCE_TYPE = 'queue-debug-label';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelInsert, parent: CompositeTreeNode): string {\n        return `${parent.id}_qdl_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelInsert,\n        parent: CompositeTreeNode\n    ): CommandQueueDebugLabelNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelNode = {\n            id: getId(element, parent),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label',\n            queue: element.queue!,\n            apiEventId: element.apiEvent,\n            parent,\n            resourceType: CommandQueueDebugLabelNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandCommandBufferInstanceNode\n    extends ResourceTreeNode<CommandTreeCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    commandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandCommandBufferInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandCommandBufferInstanceNode {\n    export const RESOURCE_TYPE = 'command-buffer-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandCommandBufferInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandCommandBufferInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeCommandBufferInstance,\n        parent: CompositeTreeNode,\n        commandBufferIndex: number,\n        baseDynamicStatePromise?: Promise<DynamicStateEntry[]>\n    ): CommandCommandBufferInstanceNode {\n        const node: CommandCommandBufferInstanceNode = {\n            id: getId(element, parent),\n            commandBufferInstanceId: element.instanceId,\n            label: `Command Buffer ${commandBufferIndex}`,\n            parent,\n            resourceType: CommandCommandBufferInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this command buffer\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this command buffer, add it to array\n            // - omit commands that reference render pass id\n            // - if api event is a debug label, check the debug label itself for a render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                event.commandBufferInstanceId === element.instanceId &&\n                event.renderPassInstanceId === undefined &&\n                event.dynamicRenderPassInstanceId === undefined &&\n                (event.debugLabelId === undefined ||\n                    (debugLabel?.beginApiEvent === event.apiEventId &&\n                        debugLabel?.beginRenderPassInstance === undefined &&\n                        debugLabel?.beginDynamicRenderPassInstance === undefined) ||\n                    (debugLabel?.endApiEvent === event.apiEventId &&\n                        debugLabel?.endRenderPassInstance === undefined &&\n                        debugLabel?.endDynamicRenderPassInstance === undefined))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this command buffer\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this command buffer\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'RenderPassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this command buffer\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        const emptyDynamicStatePromise = new Promise<DynamicStateEntry[]>(resolve => resolve([]));\n        const effectiveBaseState = baseDynamicStatePromise ?? emptyDynamicStatePromise;\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            effectiveBaseState,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        effectiveBaseState\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                console.log(`JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for command buffer:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `command buffer ${commandBufferIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandSecondaryCommandBufferExecutionNode\n    extends ResourceTreeNode<CommandTreeSecondaryCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    parentCommandBufferInstanceId: number;\n    secondaryCommandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n}\n\nexport namespace CommandSecondaryCommandBufferExecutionNode {\n    export const RESOURCE_TYPE = 'secondary-command-buffer-execution';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: unknown): node is CommandSecondaryCommandBufferExecutionNode {\n        return (\n            ExpandableTreeNode.is(node) && SelectableTreeNode.is(node) && ResourceTreeNode.is(node, 'secondary-command-buffer-execution')\n        );\n    }\n\n    export function getId(element: CommandTreeSecondaryCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_secondary_${element.secondaryCommandBufferInstance}_${element.executionId}_${element.executionIndex}`;\n    }\n\n    export async function create(\n        ctx: CommandTreeContext,\n        elements: CommandTreeSecondaryCommandBufferInstance[],\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n        stateTracker?: DynamicStateTracker\n    ): Promise<CommandSecondaryCommandBufferExecutionNode> {\n        if (elements.length === 0) {\n            throw new Error('elements array must not be empty');\n        }\n        // Use the first element for the node's resource (they all share the same executionId and apiEvent)\n        const element = elements[0];\n        const node: CommandSecondaryCommandBufferExecutionNode = {\n            id: getId(element, parent),\n            parentCommandBufferInstanceId: element.parentCommandBufferInstance || 0,\n            secondaryCommandBufferInstanceId: element.secondaryCommandBufferInstance || 0,\n            label: `Secondary Command Buffer Execution ${commandIndex}`,\n            parent,\n            resourceType: 'secondary-command-buffer-execution',\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        createLazyLoadingNode(ctx.tree, node, async () => {\n            // Sort elements by executionIndex to maintain proper order\n            const sortedElements = [...elements].sort((a, b) => (a.executionIndex || 0) - (b.executionIndex || 0));\n\n            // Get device and check extensions\n            const firstSecondary = sortedElements[0]?.secondaryCommandBufferInstance;\n            let deviceExtensions: Set<string> | undefined;\n\n            if (firstSecondary !== undefined) {\n                const commandBufferInstance = root.resource.commandBufferInstances[firstSecondary];\n                const device = commandBufferInstance?.device;\n                if (typeof device === 'number') {\n                    deviceExtensions = ctx.deviceExtensions.get(device);\n                }\n            }\n\n            const hasInheritance = hasCommandBufferInheritance(deviceExtensions);\n            const hasViewportScissorOnly = hasInheritedViewportScissor(deviceExtensions) && !hasInheritance;\n\n            // Calculate effective base state for INHERITANCE INTO secondary\n            let effectiveBaseState: Promise<DynamicStateEntry[]>;\n            if (hasInheritance) {\n                effectiveBaseState = baseDynamicStatePromise;\n            } else if (hasViewportScissorOnly) {\n                effectiveBaseState = filterDynamicStateForViewportScissor(baseDynamicStatePromise);\n            } else {\n                effectiveBaseState = Promise.resolve([]);\n            }\n\n            // Create a CommandCommandBufferInstanceNode for each secondary command buffer in the execution\n            const childNodes: CommandCommandBufferInstanceNode[] = [];\n            sortedElements.forEach((secondaryInstance, index) => {\n                if (secondaryInstance.secondaryCommandBufferInstance) {\n                    const commandBufferInstance = root.resource.commandBufferInstances[secondaryInstance.secondaryCommandBufferInstance];\n                    if (commandBufferInstance) {\n                        const childNode = CommandCommandBufferInstanceNode.create(\n                            ctx,\n                            commandBufferInstance,\n                            node,\n                            index,\n                            effectiveBaseState\n                        );\n                        childNodes.push(childNode);\n                    } else {\n                        console.warn(\n                            `Command buffer instance ${secondaryInstance.secondaryCommandBufferInstance} ` +\n                                'not found in root.resource.commandBufferInstances'\n                        );\n                    }\n                }\n            });\n            CompositeTreeNode.addChildren(node, childNodes);\n\n            // Handle LEAK-BACK: Update parent's state tracker if extension is enabled\n            if (hasInheritance && stateTracker && element.executionId) {\n                const db = ctx.gfxrQueryBuilderService.builderFor(ctx.dbId);\n                const endStatePromise = querySecondaryCommandBufferEndDynamicState(db, [element.executionId]);\n                stateTracker.updateState(endStatePromise);\n            }\n        });\n\n        // Register for thumbnail updates\n        registerThumbnailUpdate(ctx, node, `secondary command buffer execution ${node.resource.executionId}`);\n        return node;\n    }\n}\n\nexport interface CommandQueueSubmitNode\n    extends ResourceTreeNode<CommandTreeQueueSubmit>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    submissionId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueSubmitNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueSubmitNode {\n    export const RESOURCE_TYPE = 'queue-submit';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueSubmitNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueSubmitNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueSubmit, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.submissionId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueSubmit,\n        parent: CompositeTreeNode,\n        queueSubmitIndex: number\n    ): CommandQueueSubmitNode {\n        const root = ctx.rootNode;\n        const node: CommandQueueSubmitNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            threadId: element.threadId || 0,\n            submissionId: element.submissionId,\n            label: `Queue Submit ${queueSubmitIndex}`,\n            queue: element.queue,\n            parent,\n            resourceType: CommandQueueSubmitNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        const children =\n            element.queueSubmitBuffers\n                ?.filter(b => b.commandBufferInstance)\n                .flatMap(b => {\n                    const instance = root.resource.commandBufferInstances[b.commandBufferInstance!];\n                    if (!instance) {\n                        console.warn(`CommandQueueSubmitNode.create: commandBufferInstance not found for id ${b.commandBufferInstance}`);\n                        return [];\n                    }\n                    return instance;\n                }) ?? [];\n        let commandBufferIndex = 0;\n        node.children = children.map(child => CommandCommandBufferInstanceNode.create(ctx, child, node, commandBufferIndex++));\n\n        registerThumbnailUpdate(ctx, node, `queue submit ${queueSubmitIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueuePresentNode extends ResourceTreeNode<CommandTreeQueuePresent>, SelectableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    resourceType: typeof CommandQueuePresentNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueuePresentNode {\n    export const RESOURCE_TYPE = 'queue-present';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueuePresentNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueuePresentNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueuePresent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEvent}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueuePresent,\n        parent: CompositeTreeNode,\n        queuePresentIndex: number\n    ): CommandQueuePresentNode {\n        const root = ctx.rootNode;\n        const node: CommandQueuePresentNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            label: `Queue Present ${queuePresentIndex}`,\n            parent,\n            resourceType: CommandQueuePresentNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            queue: element.queue,\n            selected: false\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureBuildNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureBuildInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    buildInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureBuildNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureBuildNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-build';\n    export const GENERALIZED_TYPE = 'acceleration-structure-build';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureBuildNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureBuildNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureBuildInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.buildApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureBuildInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureBuildNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureBuildNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            buildInstanceId: element.instanceId,\n            apiEventId: element.buildApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureBuildNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureCopyNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureCopyInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    copyInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureCopyNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureCopyNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-copy';\n    export const GENERALIZED_TYPE = 'acceleration-structure-copy';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureCopyNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureCopyNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureCopyInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.copyApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureCopyInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureCopyNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureCopyNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            copyInstanceId: element.instanceId,\n            apiEventId: element.copyApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureCopyNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandTransferCommandNode\n    extends ResourceTreeNode<CommandTreeTransferCommandInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    transferCommandInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandTransferCommandNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandTransferCommandNode {\n    export const RESOURCE_TYPE = 'transfer-command';\n    export const GENERALIZED_TYPE = 'transfer-command';\n\n    export function is(node: TreeNode | undefined): node is CommandTransferCommandNode {\n        return ResourceTreeNode.hasResourceType(node, CommandTransferCommandNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeTransferCommandInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.transferApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeTransferCommandInstance,\n        parent: CompositeTreeNode,\n        transferCommandIndex: number\n    ): CommandTransferCommandNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandTransferCommandNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            transferCommandInstanceId: element.instanceId,\n            apiEventId: element.transferApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${transferCommandIndex}`,\n            parent,\n            resourceType: CommandTransferCommandNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nfunction setThumbnailUrl(\n    ctx: CommandTreeContext,\n    resources: ApiResources[],\n    node: TreeNode & { thumbnail?: string },\n    requesterDbgName: string\n): void {\n    if (resources.length > 0) {\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        ctx.screenshotService.requestScreenshots({\n            profileOrReplay: replay ?? ctx.profile,\n            scale: placeholderScale,\n            screenshotType: ScreenshotType.API_EVENT,\n            requestData: resources,\n            moreRequests: true,\n            requesterDbgName,\n            options: {\n                DumpDepth: true\n            },\n            onScreenshotReady: result => {\n                if (result.resultData.resultType === ScreenshotType.API_EVENT && DrawApiResult.is(result.resultData.apiResult)) {\n                    const images = [...(result.resultData.apiResult.colorAttachments || [])];\n                    if (result.resultData.apiResult.depthAttachment) {\n                        images.push(result.resultData.apiResult.depthAttachment);\n                    }\n                    if (images.length > 0) {\n                        const possibleImage = images[0].subresources?.[0];\n                        if (possibleImage) {\n                            if (usesCompressionExtension(possibleImage.file)) {\n                                // Use VkImageConversionService to get a png\n                                // Do the same as the else case, but with the new png file\n                                const format = lookupResourceFormat(images[0].format);\n                                if (UncompressedResourceFormat.is(format)) {\n                                    ctx.fileService\n                                        .read(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString(), {\n                                            uncompressedSize: possibleImage.size\n                                        })\n                                        .then(async content => {\n                                            const extractedData = await extractData(format, content);\n                                            const dim = {\n                                                width: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[0]\n                                                    : possibleImage.dimensions[0] * placeholderScale,\n                                                height: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[1]\n                                                    : possibleImage.dimensions[1] * placeholderScale\n                                            };\n                                            const conversionResult = await convertDataToImageData(extractedData, format, dim, {\n                                                channelOptions: { alpha: { disabled: true } }\n                                            });\n                                            const png = new PNG({\n                                                width: conversionResult.dimensions.width,\n                                                height: conversionResult.dimensions.height\n                                            });\n                                            png.data = conversionResult.data;\n                                            const pngBuffer = PNG.sync.write(png);\n                                            node.thumbnail = `data:image/png;base64, ${pngBuffer.toString('base64')}`;\n                                            void ctx.tree.refresh(node.parent);\n                                        })\n                                        .catch(reason => {\n                                            const error = asError(reason);\n                                            console.error(error);\n                                        });\n                                }\n                            } else {\n                                ctx.imageAccessorService\n                                    .accessImage(new URL(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString()))\n                                    .then(url => {\n                                        node.thumbnail = url.url.toString();\n                                        ctx.tree.addToDispose(url);\n                                        void ctx.tree.refresh(node.parent);\n                                    })\n                                    .catch(reason => {\n                                        const error = asError(reason);\n                                        console.error(error);\n                                    });\n                            }\n                        }\n                    }\n                }\n            },\n            onRequestComplete: (result, message) => {\n                if (!result) {\n                    console.error(message);\n                }\n            }\n        });\n    }\n}\n\n/**\n * Registers a thumbnail update callback that triggers on the node's first render.\n * When triggered, finds the last draw instance and requests a screenshot for it.\n *\n * @param ctx - Command tree context\n * @param node - Node to register thumbnail update for\n * @param descriptionContext - Description for the requester debug name (e.g., \"render pass 5\", \"dynamic render pass\")\n */\nfunction registerThumbnailUpdate(\n    ctx: CommandTreeContext,\n    node: CommandTreeNode & { thumbnail?: string },\n    descriptionContext: string\n): void {\n    const updateThumbnail = (): void => {\n        const lastDraw = findLastDrawInstanceNode(node);\n        if (lastDraw) {\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', updateThumbnail);\n            const requesterDbgName = `Command tree ${descriptionContext} last draw: ${lastDraw.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(lastDraw), node, requesterDbgName);\n        }\n    };\n    SokatoaLifecycleTreeNode.register(node, 'onWillRender', updateThumbnail);\n}\n\nexport interface CommandRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    renderPassInstanceId: number;\n    renderPassId?: number;\n    renderSubpassEventIds: number[];\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderPassInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.instanceId,\n            renderPassId: element.renderPass,\n            renderSubpassEventIds: [],\n            label: `Render Pass ${element.passIndex}`,\n            parent,\n            resourceType: CommandRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        // A render pass will only contain render subpasses and will always contain at least one subpass\n        const renderSubpassInstances = element.renderSubpassInstanceIds.flatMap(id => {\n            const instance = root.resource.renderSubpassInstances[id];\n            if (!instance) {\n                console.warn(`CommandRenderPassInstanceNode.create: renderSubpassInstance not found for id ${id}`);\n                return [];\n            }\n            return instance;\n        });\n        renderSubpassInstances.forEach(subpass => {\n            if (subpass.beginApiEvent !== node.resource.beginApiEvent) {\n                node.renderSubpassEventIds.push(subpass.beginApiEvent);\n            }\n        });\n        node.children.push(\n            ...renderSubpassInstances.map(instance => {\n                const subpassNode = CommandRenderSubpassInstanceNode.create(ctx, instance, node, baseDynamicStatePromise);\n                return subpassNode;\n            })\n        );\n\n        registerThumbnailUpdate(ctx, node, `render pass ${node.renderPassId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandRenderSubpassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderSubpassInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    renderPassInstanceId: number;\n    renderSubpassInstanceId: number;\n    renderSubpassIndex: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderSubpassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderSubpassInstanceNode {\n    export const RESOURCE_TYPE = 'render-subpass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderSubpassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderSubpassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderSubpassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderSubpassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderSubpassInstanceNode {\n        const node: CommandRenderSubpassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.renderPassInstance,\n            renderSubpassInstanceId: element.instanceId,\n            renderSubpassIndex: element.subpassIndex,\n            label: `Subpass ${element.subpassIndex}`,\n            parent,\n            resourceType: CommandRenderSubpassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this render subpass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference render subpass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a render subpass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.renderSubpassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginRenderSubpassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endRenderSubpassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this render subpass\n        const debugLabelGroupInstances = {\n            array: element.debugLabelGroupInstanceIds.flatMap(id => {\n                const result = root.resource.debugLabelGroupInstances[id];\n                if (!result) {\n                    console.warn(`Missing debugLabelGroupInstances for ${id}.`);\n                    return [];\n                }\n                return result;\n            }),\n            getSortNumber: (debugLabelGroupInstance: CommandTreeDebugLabelGroupInstance) => debugLabelGroupInstance.beginApiEvent\n        };\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                console.log(`JF: CommandRenderSubpassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'render subpass');\n\n        return node;\n    }\n}\n\nexport interface CommandDynamicRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeDynamicRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    dynamicRenderPassInstanceId: number;\n    dynamicRenderPassId?: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDynamicRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'dynamic-render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDynamicRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDynamicRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDynamicRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDynamicRenderPassInstanceNode {\n        const node: CommandDynamicRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dynamicRenderPassInstanceId: element.instanceId,\n            label: `Dynamic Render Pass ${element.dynamicPassIndex}`,\n            parent,\n            resourceType: CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this dynamic render pass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this dynamic render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference dynamic render pass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a dynamic render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.dynamicRenderPassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginDynamicRenderPassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endDynamicRenderPassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this dynamic render pass\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDynamicRenderPassInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                console.log(`JF: CommandDynamicRenderPassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'dynamic render pass');\n\n        return node;\n    }\n}\n\nasync function createChildEventNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    stateTracker: DynamicStateTracker\n): Promise<number> {\n    let endCommandIndex = commandIndex;\n    const baseDynamicStatePromise = stateTracker.getCurrentState();\n\n    if (command.secondaryCommandBufferExecutionId) {\n        // Look up the execution to get the apiEvent, which is the key for secondaryCommandBufferInstances\n        const execution = root.resource.secondaryCommandBufferExecutions[command.secondaryCommandBufferExecutionId];\n        if (execution) {\n            const secondaryInstances = root.resource.secondaryCommandBufferInstances[execution.apiEvent];\n            if (secondaryInstances && secondaryInstances.length > 0) {\n                const node = await CommandSecondaryCommandBufferExecutionNode.create(\n                    ctx,\n                    secondaryInstances,\n                    parentNode,\n                    endCommandIndex++,\n                    baseDynamicStatePromise,\n                    stateTracker\n                );\n                parentNode.children.push(node);\n            }\n        }\n    } else {\n        endCommandIndex = createDrawOrDispatchChildNode(ctx, command, root, parentNode, commandIndex, baseDynamicStatePromise);\n    }\n    return endCommandIndex;\n}\n\nfunction createDrawOrDispatchChildNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n): number {\n    let currentCommandIndex = commandIndex;\n    let accelerationStructureBuildIndex = 0;\n    let accelerationStructureCopyIndex = 0;\n    if (command) {\n        if (command.drawInstanceId && root.resource.drawInstances[command.drawInstanceId]) {\n            parentNode.children.push(\n                CommandDrawInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.dispatchInstanceId && root.resource.dispatchInstances[command.dispatchInstanceId]) {\n            parentNode.children.push(\n                CommandDispatchInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.meshTaskInstanceId && root.resource.meshTaskInstances[command.meshTaskInstanceId]) {\n            parentNode.children.push(\n                CommandMeshTaskInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.clusterInstanceId && root.resource.clusterInstances[command.clusterInstanceId]) {\n            parentNode.children.push(\n                CommandClusterInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.raytracingInstanceId && root.resource.raytracingInstances[command.raytracingInstanceId]) {\n            parentNode.children.push(\n                CommandRaytracingInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (\n            command.accelerationStructureBuildInstanceId &&\n            root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureBuildNode.create(\n                    root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]!,\n                    parentNode,\n                    accelerationStructureBuildIndex++\n                )\n            );\n        } else if (\n            command.accelerationStructureCopyInstanceId &&\n            root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureCopyNode.create(\n                    root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]!,\n                    parentNode,\n                    accelerationStructureCopyIndex++\n                )\n            );\n        } else if (command.transferCommandInstanceId && root.resource.transferCommands[command.transferCommandInstanceId]) {\n            parentNode.children.push(\n                CommandTransferCommandNode.create(\n                    root.resource.transferCommands[command.transferCommandInstanceId]!,\n                    parentNode,\n                    currentCommandIndex++\n                )\n            );\n        } else if (command.debugLabelId && root.resource.debugLabels[command.debugLabelId]) {\n            // Only add debug label nodes if this is the BEGIN event (not END event)\n            // The END event has debugLabelId set but should not create a node\n            const debugLabel = root.resource.debugLabels[command.debugLabelId];\n            if (debugLabel && debugLabel.beginApiEvent === command.apiEventId) {\n                // Check if this is a group (has both begin and end and they differ) or just an insert\n                if (debugLabel.endApiEvent && debugLabel.beginApiEvent !== debugLabel.endApiEvent) {\n                    // This is a debug label group - it should be handled by the range processing logic\n                    // Don't create any node here, just skip it\n                    // (The group will be created if it's in debugLabelGroupInstances, or omitted if it crosses boundaries)\n                } else {\n                    // This is a debug label insert - create as simple API event node\n                    parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode));\n                }\n            }\n        } else if (command.commandInstanceId && root.resource.commandInstances[command.commandInstanceId]) {\n            parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode, currentCommandIndex++));\n        }\n    }\n    return currentCommandIndex;\n}\n\nexport interface CommandDrawInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    drawInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDrawInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandDrawInstanceNode {\n    export const RESOURCE_TYPE = 'draw-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDrawInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDrawInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_draw_${element.drawInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDrawInstanceNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDrawInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            drawInstanceId: element.drawInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDrawInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query draw instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n            const requesterDbgName = `Command draw instance ${node.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(node), node, requesterDbgName);\n        });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDrawInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const drawInstanceDynamicStatePromise = batchQuery\n                ? queryDrawInstanceDynamicStateBatched(db, [node.resource.drawInstanceId || 0])\n                : queryDrawInstanceDynamicState(db, [node.resource.drawInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                drawInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.GRAPHICS\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandDispatchInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    dispatchInstanceId: number;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandDispatchInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n    thumbnail?: string;\n}\n\nexport namespace CommandDispatchInstanceNode {\n    export const RESOURCE_TYPE = 'dispatch-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDispatchInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDispatchInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_dispatch_${element.dispatchInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDispatchInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandDispatchInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dispatchInstanceId: element.dispatchInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDispatchInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query dispatch instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for dispatch nodes\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command dispatch instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDispatchInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const dispatchInstanceDynamicStatePromise = batchQuery\n                ? queryDispatchInstanceDynamicStateBatched(db, [node.resource.dispatchInstanceId || 0])\n                : queryDispatchInstanceDynamicState(db, [node.resource.dispatchInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                dispatchInstanceDynamicStatePromise,\n                PipelineBindPoint.COMPUTE,\n                PipelineBindPointShaderStageFlags.COMPUTE\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandMeshTaskInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    meshTaskInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandMeshTaskInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandMeshTaskInstanceNode {\n    export const RESOURCE_TYPE = 'mesh-task-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandMeshTaskInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandMeshTaskInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_meshtask_${element.meshTaskInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandMeshTaskInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandMeshTaskInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            meshTaskInstanceId: element.meshTaskInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandMeshTaskInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query mesh instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for mesh task dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command mesh instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandMeshTaskInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const meshTaskInstanceDynamicStatePromise = batchQuery\n                ? queryMeshTaskInstanceDynamicStateBatched(db, [node.resource.meshTaskInstanceId || 0])\n                : queryMeshTaskInstanceDynamicState(db, [node.resource.meshTaskInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                meshTaskInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.TASK_MESH\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandClusterInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    clusterInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandClusterInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandClusterInstanceNode {\n    export const RESOURCE_TYPE = 'cluster-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandClusterInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandClusterInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_cluster_${element.clusterInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandClusterInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandClusterInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            clusterInstanceId: element.clusterInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandClusterInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query cluster instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for cluster dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command cluster instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandClusterInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const clusterInstanceDynamicStatePromise = batchQuery\n                ? queryClusterInstanceDynamicStateBatched(db, [node.resource.clusterInstanceId || 0])\n                : queryClusterInstanceDynamicState(db, [node.resource.clusterInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                clusterInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.CLUSTER\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandRaytracingInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    raytracingInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandRaytracingInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandRaytracingInstanceNode {\n    export const RESOURCE_TYPE = 'raytracing-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandRaytracingInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRaytracingInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_raytracing_${element.raytracingInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRaytracingInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRaytracingInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            raytracingInstanceId: element.raytracingInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandRaytracingInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query raytracing instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for raytracing dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command raytracing instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandRaytracingInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const raytracingInstanceDynamicStatePromise = batchQuery\n                ? queryRaytracingInstanceDynamicStateBatched(db, [node.resource.raytracingInstanceId || 0])\n                : queryRaytracingInstanceDynamicState(db, [node.resource.raytracingInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                raytracingInstanceDynamicStatePromise,\n                PipelineBindPoint.RAY_TRACING,\n                PipelineBindPointShaderStageFlags.RAY_TRACING\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport function getQueueSubmitId(node: CommandTreeNode): number | undefined {\n    let currentNode: CompositeTreeNode | undefined;\n    if (\n        CommandEmptyNode.is(node) ||\n        CommandApiEventNode.is(node) ||\n        CommandTreeDrawOrDispatchNode.is(node) ||\n        CommandAccelerationStructureBuildNode.is(node) ||\n        CommandAccelerationStructureCopyNode.is(node) ||\n        CommandTransferCommandNode.is(node)\n    ) {\n        currentNode = node.parent;\n    } else if (CommandQueuePresentNode.is(node) || CommandQueueDebugLabelNode.is(node)) {\n        return undefined;\n    } else {\n        currentNode = node;\n    }\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(currentNode, CommandQueueSubmitNode.is);\n    return queueSubmitNode ? queueSubmitNode.resource.submissionId : undefined;\n}\n\nexport function findLastDrawInstanceNode(node: CommandTreeNode): CommandDrawInstanceNode | undefined {\n    if (CommandDrawInstanceNode.is(node)) {\n        return node;\n    }\n    let lastDraw: CommandDrawInstanceNode | undefined;\n    if (!CommandDrawInstanceNode.is(node) && ExpandableTreeNode.is(node)) {\n        for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n            lastDraw = findLastDrawInstanceNode(node.children[commandIndex]);\n            if (lastDraw) {\n                break;\n            }\n        }\n    }\n    return lastDraw;\n}\n\nexport function createExecuteCommandsApiResources(\n    node: CommandSecondaryCommandBufferExecutionNode,\n    primaryNode: CommandCommandBufferInstanceNode,\n    queueSubmitNode: CommandQueueSubmitNode,\n    specificSecondaryCommandBufferBeginId?: number // If provided, only include this specific secondary CB\n): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    // findParentNode checks the given node for its type so we have to start looking from this node's parent\n    // otherwise we run into infinite recursion\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node.parent,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n\n    // Collect secondary command buffer begin IDs from the children\n    const commandBufferBeginIds: number[] = [];\n    if (specificSecondaryCommandBufferBeginId !== undefined) {\n        // Only include the specific secondary CB that was requested\n        commandBufferBeginIds.push(specificSecondaryCommandBufferBeginId);\n    } else {\n        // Include all secondary CBs (for when the execution node itself requests a thumbnail)\n        for (const child of node.children) {\n            if (CommandCommandBufferInstanceNode.is(child)) {\n                commandBufferBeginIds.push(child.resource.beginApiEvent);\n            }\n        }\n    }\n\n    const resources: ApiResources[] = [];\n    if (secondaryCommandBufferExecutionNode) {\n        const renderpassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n            renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n            CommandSecondaryCommandBufferExecutionNode.is\n        );\n\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: secondaryCommandBufferExecutionNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n                renderpassSecondaryCommandBufferExecutionNode &&\n                renderpassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n        const executionResources = createExecuteCommandsApiResources(secondaryCommandBufferExecutionNode, primaryNode, queueSubmitNode);\n        if (executionResources.length > 0) {\n            resources.push(...executionResources);\n        }\n    } else {\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: primaryNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                renderPassInstanceNode || dynamicRenderPassInstanceNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n    }\n    return resources;\n}\n\nexport function createDrawApiResources(node: CommandDrawInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    // This will find the immediate parent command buffer (secondary if in a secondary CB, primary otherwise)\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n\n    const resources: ApiResources[] = [];\n    if (\n        (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n        queueSubmitNode &&\n        commandBufferInstanceNode &&\n        primaryCommandBufferInstanceNode\n    ) {\n        if (secondaryCommandBufferExecutionNode) {\n            const renderPassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n                CommandSecondaryCommandBufferExecutionNode.is\n            );\n\n            // Add draw resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses:\n                    renderPassSecondaryCommandBufferExecutionNode &&\n                    renderPassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                        ? [\n                              {\n                                  beginId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                                  subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                                  endId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                        dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                              }\n                          ]\n                        : []\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses: [\n                    {\n                        beginId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                        subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                        endId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.endApiEvent || dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                    }\n                ]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createComputeApiResources(node: CommandDispatchInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add dispatch resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createTraceRaysApiResources(node: CommandRaytracingInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTransferNode = CommandAccelerationStructureBuildNode | CommandAccelerationStructureCopyNode | CommandTransferCommandNode;\n\nexport function createTransferApiResources(node: CommandTransferNode): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    let transferEvent: number = 0;\n    if (CommandAccelerationStructureBuildNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureBuildNode).resource.buildApiEvent;\n    } else if (CommandAccelerationStructureCopyNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureCopyNode).resource.copyApiEvent;\n    } else if (CommandTransferCommandNode.is(node)) {\n        transferEvent = (node as CommandTransferCommandNode).resource.transferApiEvent;\n    }\n\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTreeNode =\n    | CommandFrameNode\n    | CommandEmptyNode\n    | CommandApiEventNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandQueuePresentNode\n    | CommandQueueDebugLabelGroupNode\n    | CommandQueueDebugLabelNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandEmptyNode.is(node) ||\n            CommandApiEventNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandQueuePresentNode.is(node) ||\n            CommandQueueDebugLabelGroupNode.is(node) ||\n            CommandQueueDebugLabelNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n\n    export function findApiEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandSecondaryCommandBufferExecutionNode.is(current)) {\n            // For secondary command buffer execution nodes, return the VkCmdExecuteCommands apiEvent\n            // rather than the VkCommandBufferBegin apiEvent\n            return current.resource.apiEvent;\n        } else if (CommandTreeRangeNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (\n            CommandApiEventNode.is(current) ||\n            CommandQueueSubmitNode.is(current) ||\n            CommandQueuePresentNode.is(current) ||\n            CommandQueueDebugLabelNode.is(current)\n        ) {\n            return current.apiEventId;\n        } else if (CommandQueueDebugLabelGroupNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (CommandAccelerationStructureBuildNode.is(current)) {\n            return current.resource.buildApiEvent;\n        } else if (CommandAccelerationStructureCopyNode.is(current)) {\n            return current.resource.copyApiEvent;\n        } else if (CommandTransferCommandNode.is(current)) {\n            return current.apiEventId;\n        } else if (CommandTreeDrawOrDispatchNode.is(current)) {\n            return current.resource.apiEventId;\n        }\n        return undefined;\n    }\n\n    export function findFilterEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandFrameNode.is(current)) {\n            return current.resource.beginApiEvent;\n        }\n        let maybeQueueSubmitOrPresent: TreeNode | undefined = current;\n        while (\n            maybeQueueSubmitOrPresent !== undefined &&\n            !(\n                CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueuePresentNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)\n            )\n        ) {\n            maybeQueueSubmitOrPresent = maybeQueueSubmitOrPresent.parent;\n        }\n        let queueSubmitEventId: number | undefined;\n        if (maybeQueueSubmitOrPresent !== undefined) {\n            if (CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) || CommandQueuePresentNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            } else if (CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.resource.beginApiEvent;\n            } else if (CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            }\n        }\n        return queueSubmitEventId;\n    }\n\n    export function findRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const renderPassNode = findParentNode<CommandRenderPassInstanceNode>(current, CommandRenderPassInstanceNode.is);\n        return renderPassNode ? renderPassNode.renderPassInstanceId : undefined;\n    }\n\n    export function findDynamicRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const dynamicRenderPassNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n            current,\n            CommandDynamicRenderPassInstanceNode.is\n        );\n        return dynamicRenderPassNode ? dynamicRenderPassNode.dynamicRenderPassInstanceId : undefined;\n    }\n\n    export function findDrawInstanceId(current?: CommandTreeNode): number | undefined {\n        const drawInstanceNode = findParentNode<CommandDrawInstanceNode>(current, CommandDrawInstanceNode.is);\n        return drawInstanceNode ? drawInstanceNode.drawInstanceId : undefined;\n    }\n\n    export function findDispatchInstanceId(current?: CommandTreeNode): number | undefined {\n        const dispatchInstanceNode = findParentNode<CommandDispatchInstanceNode>(current, CommandDispatchInstanceNode.is);\n        return dispatchInstanceNode ? dispatchInstanceNode.dispatchInstanceId : undefined;\n    }\n\n    export function findMeshTaskInstanceId(current?: CommandTreeNode): number | undefined {\n        const meshTaskInstanceNode = findParentNode<CommandMeshTaskInstanceNode>(current, CommandMeshTaskInstanceNode.is);\n        return meshTaskInstanceNode ? meshTaskInstanceNode.meshTaskInstanceId : undefined;\n    }\n\n    export function findClusterInstanceId(current?: CommandTreeNode): number | undefined {\n        const clusterInstanceNode = findParentNode<CommandClusterInstanceNode>(current, CommandClusterInstanceNode.is);\n        return clusterInstanceNode ? clusterInstanceNode.clusterInstanceId : undefined;\n    }\n\n    export function findRaytracingInstanceId(current?: CommandTreeNode): number | undefined {\n        const raytracingInstanceNode = findParentNode<CommandRaytracingInstanceNode>(current, CommandRaytracingInstanceNode.is);\n        return raytracingInstanceNode ? raytracingInstanceNode.raytracingInstanceId : undefined;\n    }\n\n    export function findAccelerationBuildInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelBuildNode = findParentNode<CommandAccelerationStructureBuildNode>(current, CommandAccelerationStructureBuildNode.is);\n        return accelBuildNode ? accelBuildNode.buildInstanceId : undefined;\n    }\n\n    export function findAccelerationCopyInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelCopyNode = findParentNode<CommandAccelerationStructureCopyNode>(current, CommandAccelerationStructureCopyNode.is);\n        return accelCopyNode ? accelCopyNode.copyInstanceId : undefined;\n    }\n\n    export function findTransferCommandInstanceId(current?: CommandTreeNode): number | undefined {\n        const transferCommandNode = findParentNode<CommandTransferCommandNode>(current, CommandTransferCommandNode.is);\n        return transferCommandNode ? transferCommandNode.transferCommandInstanceId : undefined;\n    }\n\n    export function findMergedDynamicStatePromise(\n        current: CommandTreeNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> | undefined {\n        let maybeDrawOrDispatchInstance: TreeNode | undefined = current;\n        while (maybeDrawOrDispatchInstance !== undefined && !CommandTreeDrawOrDispatchNode.is(maybeDrawOrDispatchInstance)) {\n            maybeDrawOrDispatchInstance = maybeDrawOrDispatchInstance.parent;\n        }\n        let mergedDynamicStatePromise: Promise<DynamicStateEntry[]> | undefined;\n        if (maybeDrawOrDispatchInstance !== undefined && CommandDrawInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDrawInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandDispatchInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDispatchInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandMeshTaskInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandMeshTaskInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandClusterInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandClusterInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandRaytracingInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandRaytracingInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        }\n        return mergedDynamicStatePromise;\n    }\n\n    export function getRoot(node?: CompositeTreeNode | CommandRootNode | CommandTreeNode): CommandRootNode | undefined {\n        return findParentNode<CommandRootNode>(node, CommandRootNode.is);\n    }\n\n    export function getDbId(node: CommandRootNode | CommandTreeNode): number {\n        return getRoot(node)?.dbId ?? -1;\n    }\n\n    type GeneralizableNodes =\n        | typeof CommandApiEventNode\n        | typeof CommandClusterInstanceNode\n        | typeof CommandCommandBufferInstanceNode\n        | typeof CommandDispatchInstanceNode\n        | typeof CommandDrawInstanceNode\n        | typeof CommandEmptyNode\n        | typeof CommandFrameNode\n        | typeof CommandMeshTaskInstanceNode\n        | typeof CommandQueuePresentNode\n        | typeof CommandQueueSubmitNode\n        | typeof CommandQueueDebugLabelGroupNode\n        | typeof CommandQueueDebugLabelNode\n        | typeof CommandAccelerationStructureBuildNode\n        | typeof CommandAccelerationStructureCopyNode\n        | typeof CommandTransferCommandNode\n        | typeof CommandRaytracingInstanceNode\n        | typeof CommandRenderPassInstanceNode\n        | typeof CommandRenderSubpassInstanceNode\n        | typeof CommandDynamicRenderPassInstanceNode\n        | typeof CommandDebugLabelGroupNode;\n\n    /**\n     * An aggregate type label for command-tree nodes, roughly corresponding to some of the union\n     * types defined in this module.\n     */\n    export type GeneralizedType = GeneralizableNodes['GENERALIZED_TYPE'];\n\n    /**\n     * Query the generalized type of a given node, if it is a Command Tree node.\n     *\n     * @param node a tree node that may or may not be a `CommandTreeNode`\n     * @return its generalized type, or `undefined` if it isn't a `CommandTreeNode`\n     */\n    export function getGeneralizedNodeType(node: TreeNode): GeneralizedType | undefined {\n        const resourceType = 'resourceType' in node ? node.resourceType : undefined;\n        if (!resourceType) {\n            return CommandEmptyNode.is(node) ? 'empty' : undefined;\n        }\n\n        switch (resourceType) {\n            case 'frame':\n            case 'command-buffer-instance':\n            case 'render-pass-instance':\n            case 'render-subpass-instance':\n            case 'secondary-command-buffer-execution':\n            case 'debug-label-group':\n                return 'range';\n            case 'queue-submit':\n            case 'queue-present':\n                return 'queue';\n            case 'acceleration-structure-build':\n                return 'acceleration-structure-build';\n            case 'acceleration-structure-copy':\n                return 'acceleration-structure-copy';\n            case 'transfer-command':\n                return 'transfer-command';\n            case 'draw-instance':\n            case 'dispatch-instance':\n            case 'mesh-task-instance':\n            case 'cluster-instance':\n            case 'raytracing-instance':\n                return 'draw-or-dispatch';\n            case 'api-event':\n                return 'api-event';\n            default:\n                return undefined;\n        }\n    }\n\n    /** Type assertion for a range-type node. */\n    export function generalize(node: TreeNode, type: 'range'): asserts node is CommandTreeRangeNode;\n    /** Type assertion for a queue-type node. */\n    export function generalize(node: TreeNode, type: 'queue'): asserts node is CommandQueueSubmitNode | CommandQueuePresentNode;\n    /** Type assertion for a queue-debug-label-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'queue-debug-label'\n    ): asserts node is CommandQueueDebugLabelGroupNode | CommandQueueDebugLabelNode;\n    /** Type assertion for a acceleration-structure-build-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-build'): asserts node is CommandAccelerationStructureBuildNode;\n    /** Type assertion for a acceleration-structure-copy-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-copy'): asserts node is CommandAccelerationStructureCopyNode;\n    /** Type assertion for a transfer-command-type node. */\n    export function generalize(node: TreeNode, type: 'transfer-command'): asserts node is CommandTransferCommandNode;\n    /** Type assertion for a draw-or-dispatch-type node. */\n    export function generalize(node: TreeNode, type: 'draw-or-dispatch'): asserts node is CommandTreeDrawOrDispatchNode;\n    /** Type assertion for an api-event-type node. */\n    export function generalize(node: TreeNode, type: 'api-event'): asserts node is CommandApiEventNode;\n    /** Type assertion for a draw-or-dispatch- or api-event-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'draw-or-dispatch' | 'api-event'\n    ): asserts node is CommandTreeDrawOrDispatchNode | CommandApiEventNode;\n    /** Type assertion for an empty-type node. */\n    export function generalize(node: TreeNode, type: 'empty'): asserts node is CommandEmptyNode;\n    export function generalize(node: TreeNode, _type: GeneralizedType): asserts node is CommandTreeNode {\n        // Pass\n    }\n}\n\nexport type CommandTreeRangeNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeRangeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeRangeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n}\n\nexport type CommandTreeDrawOrDispatchNode =\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode;\n\nexport namespace CommandTreeDrawOrDispatchNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeDrawOrDispatchNode {\n        return (\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node)\n        );\n    }\n}\n\ninterface ArrayWithSortNumber<RangeType> {\n    array: RangeType[];\n    getSortNumber(element: RangeType): number;\n}\n\ntype AllRangeTypes =\n    | CommandTreeDebugLabelGroupInstance\n    | CommandTreeRenderPassInstance\n    | CommandTreeRenderSubpassInstance\n    | CommandTreeDynamicRenderPassInstance;\n\ntype CommandTreeRangeParentNode =\n    | CommandRenderPassInstanceNode\n    | CommandCommandBufferInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandDebugLabelGroupNode;\n\nfunction findNextRangeElementToProcess<RangeType>(...arrays: ArrayWithSortNumber<RangeType>[]): RangeType | undefined {\n    // designate which array is the api event array vs a range array\n    // when processing a range, shift off any api events that are within the range\n    // so they aren't processed (because they actually reside within a sub-group)\n\n    const arraysToProcess: ArrayWithSortNumber<RangeType>[] = [];\n    arrays.forEach(arr => {\n        if (arr.array.length) {\n            arraysToProcess.push(arr);\n        }\n    });\n\n    if (!arraysToProcess.length) {\n        return undefined;\n    }\n\n    // get the sort number of the first element of each array and sort them\n    const sortedElements = arraysToProcess\n        .map(array => ({ subarray: array.array, sortNumber: array.getSortNumber(array.array[0]) }))\n        .sort((a, b) => a.sortNumber - b.sortNumber);\n\n    return sortedElements[0].subarray.shift();\n}\n\n/**\n * Process commands and ranges together in API event order.\n * For each range element, creates child nodes for commands that come before it,\n * skips commands that fall within the range, and creates a node for the range itself.\n * After processing all ranges, any remaining commands are processed.\n *\n * @param ctx - Command tree context\n * @param root - Root node\n * @param parentNode - Parent node to add children to\n * @param apiEventCommandArray - Array of commands sorted by API event ID (will be mutated)\n * @param childCommandIndex - Starting index for child commands\n * @param baseDynamicStatePromise - Promise for dynamic state\n * @param createRangeNode - Callback to create a node for each range element\n * @param rangeArrays - Variable number of range arrays to process together\n * @returns The final child command index\n */\nasync function createChildEventNodesForRange<RangeType extends { beginApiEvent: number; endApiEvent?: number }>(\n    ctx: CommandTreeContext,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    apiEventCommandArray: CommandTreeApiEvent[],\n    childCommandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n    createRangeNode: (rangeElement: RangeType, parentNode: CommandTreeRangeParentNode) => void,\n    ...rangeArrays: ArrayWithSortNumber<RangeType>[]\n): Promise<number> {\n    console.log(`JF: createChildEventNodesForRange START for parent ${parentNode.id}, apiEventCommandArray length: ${apiEventCommandArray.length}`);\n    const stateTracker = new DynamicStateTracker(baseDynamicStatePromise);\n    let nextRangeElement: RangeType | undefined;\n    let priorRangeEndApiEvent: number | undefined;\n\n    while ((nextRangeElement = findNextRangeElementToProcess<RangeType>(...rangeArrays))) {\n        // create a node for any command that comes BEFORE the next range element\n        while (apiEventCommandArray.length && apiEventCommandArray[0].apiEventId < nextRangeElement.beginApiEvent) {\n            const command = apiEventCommandArray.shift();\n            childCommandIndex = await createChildEventNode(ctx, command!, root, parentNode, childCommandIndex, stateTracker);\n        }\n\n        // shift off any command that falls WITHIN next range since it will be processed when creating next range node\n        while (\n            apiEventCommandArray.length &&\n            nextRangeElement.endApiEvent !== undefined &&\n            apiEventCommandArray[0].apiEventId >= nextRangeElement.beginApiEvent &&\n            apiEventCommandArray[0].apiEventId <= nextRangeElement.endApiEvent\n        ) {\n            apiEventCommandArray.shift();\n        }\n\n        // skip next range if it falls within the prior range since it will be processed when creating prior range node\n        if (\n            priorRangeEndApiEvent !== undefined &&\n            nextRangeElement.endApiEvent !== undefined &&\n            nextRangeElement.endApiEvent <= priorRangeEndApiEvent\n        ) {\n            continue;\n        }\n        priorRangeEndApiEvent = nextRangeElement.endApiEvent;\n\n        // create a node for the next range element\n        createRangeNode(nextRangeElement, parentNode);\n    }\n\n    // process any remaining command elements after all range elements have been processed\n    for (const command of apiEventCommandArray) {\n        childCommandIndex = await createChildEventNode(ctx, command, root, parentNode, childCommandIndex, stateTracker);\n    }\n\n    console.log(`JF: createChildEventNodesForRange END for parent ${parentNode.id}, final children count: ${parentNode.children.length}`);\n    return childCommandIndex;\n    }\n\n/**\n * Find node from descendent node for which isNode is true\n */\nexport const findParentNode = <T extends TreeNode>(\n    node: TreeNode | undefined,\n    isNode: (node: TreeNode | undefined) => node is T\n): T | undefined => {\n    let targetNode: TreeNode | undefined = node;\n    while (targetNode && targetNode.parent && !isNode(targetNode)) {\n        targetNode = targetNode.parent;\n    }\n\n    return targetNode && isNode(targetNode) ? targetNode : undefined;\n};\n\n/**\n * Find the primary command buffer instance node from a given command buffer instance node.\n * If the given node is in a secondary command buffer, traverses up through nested secondary\n * command buffers until finding the primary command buffer (one with no parent execution node).\n * If the given node is already in a primary command buffer, returns it as-is.\n */\nexport const findPrimaryCommandBufferInstanceNode = (\n    commandBufferInstanceNode: CommandCommandBufferInstanceNode | undefined,\n    secondaryCommandBufferExecutionNode: CommandSecondaryCommandBufferExecutionNode | undefined\n): CommandCommandBufferInstanceNode | undefined => {\n    let primaryCommandBufferInstanceNode = commandBufferInstanceNode;\n    if (secondaryCommandBufferExecutionNode) {\n        let currentExecution: CommandSecondaryCommandBufferExecutionNode | undefined = secondaryCommandBufferExecutionNode;\n        while (currentExecution) {\n            const parentCB: CommandCommandBufferInstanceNode | undefined = findParentNode<CommandCommandBufferInstanceNode>(\n                currentExecution,\n                CommandCommandBufferInstanceNode.is\n            );\n            if (parentCB) {\n                primaryCommandBufferInstanceNode = parentCB;\n                // Check if this CB is also inside another secondary execution (nested case)\n                currentExecution = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                    parentCB.parent,\n                    CommandSecondaryCommandBufferExecutionNode.is\n                );\n            } else {\n                break;\n            }\n        }\n    }\n    return primaryCommandBufferInstanceNode;\n};\n\n/**\n * find a frame node from descendent node or self\n */\nexport const findFrameNode = (node: TreeNode): CommandFrameNode | undefined => findParentNode<CommandFrameNode>(node, CommandFrameNode.is);\n\n@injectable()\nexport class CommandTree extends BulkTree implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTree {\n        return tree instanceof CommandTree;\n    }\n\n    @inject(CaptureDatasetWidgetProfile)\n    protected readonly profile: CaptureDatasetWidgetProfile;\n    @inject(CaptureDatasetWidgetContext)\n    protected readonly context: CaptureDatasetWidgetContext;\n\n    @inject(CommandTreeDataQueriedRootProvider)\n    protected readonly rootProvider: CommandTreeDataQueriedRootProvider;\n    @inject(GFXRQueryBuilderService)\n    protected readonly gfxrQueryBuilderService: GFXRQueryBuilderService;\n\n    protected override _root: CommandRootNode | undefined;\n\n    // Back-reference to the model that manages this tree\n    model?: CommandTreeModel;\n\n    protected readonly onStructureChangedEmitter = new Emitter<TreeNode | undefined>();\n    readonly onStructureChanged = this.onStructureChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this._root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        super.root = root;\n        // Set back-reference from root to tree\n        if (root) {\n            root.tree = this;\n        }\n    }\n\n    async initTree(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        this.root = await this.rootProvider.provide(dbId, { tree: this }, options, createDrawOrDispatchChildren);\n\n        // tree structure is fully built at this point, report structure change\n        this.onStructureChangedEmitter.fire(undefined);\n    }\n\n    async refreshStructure(node?: CompositeTreeNode, cancellationToken?: CancellationToken): Promise<void> {\n        await this.refresh(node, cancellationToken);\n        this.fireStructureChanged(node);\n    }\n\n    fireStructureChanged(node?: TreeNode): void {\n        this.onStructureChangedEmitter.fire(node);\n    }\n\n    addToDispose(disposable: Disposable): void {\n        this.toDispose.push(disposable);\n    }\n\n    override dispose(): void {\n        this.rootProvider.dispose();\n        super.dispose();\n    }\n}\n\n@injectable()\nexport class CommandTreeModelPreferenceStateAccessImpl implements CommandTreePreferenceState.Access {\n    private readonly models = new Map<CommandTree, CommandTreeModel>();\n\n    private readonly commandTreeStateChangedEmitter = new Emitter<{ tree: CommandTree; state: CommandTreePreferenceState }>();\n    readonly onCommandTreeStateChanged = this.commandTreeStateChangedEmitter.event;\n\n    getCommandTreeState(tree: CommandTree): CommandTreePreferenceState {\n        return this.models.get(tree)?.getPreferenceState() ?? {};\n    }\n\n    fireCommandTreeStateChanged(tree: CommandTree): void {\n        this.commandTreeStateChangedEmitter.fire({ tree, state: this.getCommandTreeState(tree) });\n    }\n\n    registerCommandTreeModel(tree: CommandTree, model: CommandTreeModel): void {\n        this.models.set(tree, model);\n        this.fireCommandTreeStateChanged(tree);\n    }\n}\n\n@injectable()\nexport class CommandTreeModel extends BulkTreeModel implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTreeModel {\n        return tree instanceof CommandTreeModel;\n    }\n\n    @inject(MiscPreferences)\n    protected readonly miscPreferences: MiscPreferences;\n    @inject(CommandTree) override readonly tree: CommandTree;\n    protected _groupBy: GroupByOptions = GroupByOptions.Frame;\n    private groupByChangedEmitter = new Emitter<GroupByOptions>();\n    readonly onGroupByChanged = this.groupByChangedEmitter.event;\n    protected _isThumbnailEnabled = true;\n    protected _isApiEventIdsEnabled = true;\n    protected _isShowingEmptyRows = false;\n    protected _isVulkanEnabled = true;\n    protected _isDebugNamesEnabled = true;\n    protected _isDebugLabelsEnabled = true;\n    protected _isLinksEnabled = true;\n    protected _isThreadsEnabled = true;\n\n    @inject(FrameRangeSelectionService)\n    protected readonly frameRangeSelectionService: FrameRangeSelectionService;\n\n    @inject(CommandTreeModelPreferenceStateAccessImpl)\n    private readonly preferenceStateAccess: CommandTreeModelPreferenceStateAccessImpl;\n\n    protected isCollapsingSubTree = false;\n\n    // Proxies to prevent calls on sub tree expansion\n    protected readonly onExpansionChangedEmitterProxy = new Emitter<ExpandableTreeNode>();\n    protected readonly onChangedEmitterProxy = new Emitter<void>();\n\n    protected readonly onSubTreeExpansionChangedEmitter = new Emitter<ExpandableTreeNode>();\n    readonly onSubTreeExpansionChanged = this.onSubTreeExpansionChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this.tree.root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        this.tree.root = root;\n    }\n\n    override get onChanged(): Event<void> {\n        return this.onChangedEmitterProxy.event;\n    }\n\n    override get onExpansionChanged(): Event<ExpandableTreeNode> {\n        return this.onExpansionChangedEmitterProxy.event;\n    }\n\n    get onStructureChanged(): Event<TreeNode | undefined> {\n        return this.tree.onStructureChanged;\n    }\n\n    async initModel(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        await this.tree.initTree(dbId, createDrawOrDispatchChildren, options);\n    }\n\n    set groupBy(value: GroupByOptions) {\n        if (this._groupBy !== value) {\n            this._groupBy = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n            this.groupByChangedEmitter.fire(value);\n        }\n    }\n\n    get groupBy(): GroupByOptions {\n        return this._groupBy;\n    }\n\n    /**\n     * Obtain the tree nodes that are the top-level groups according to\n     * the current {@link groupBy} mode.\n     */\n    *groupNodes(): IterableIterator<CompositeTreeNode> {\n        if (!this.root) {\n            return;\n        }\n\n        const group = this.groupBy;\n        const treeIterator = new (class extends DepthFirstTreeIterator {\n            protected override children(node: TreeNode): TreeNode[] | undefined {\n                // Prune group nodes because we needn't look in them for more groups\n                return CommandTreeModel.isOfGroup(node, group) ? undefined : super.children(node);\n            }\n        })(this.root);\n\n        for (const next of treeIterator) {\n            if (CommandTreeModel.isOfGroup(next, group)) {\n                yield next;\n            }\n        }\n    }\n\n    set isApiEventIdsEnabled(value: boolean) {\n        if (this._isApiEventIdsEnabled !== value) {\n            this._isApiEventIdsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isApiEventIdsEnabled(): boolean {\n        return this._isApiEventIdsEnabled;\n    }\n\n    set isShowingEmptyRows(value: boolean) {\n        if (this._isShowingEmptyRows !== value) {\n            this._isShowingEmptyRows = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isShowingEmptyRows(): boolean {\n        return this._isShowingEmptyRows;\n    }\n\n    set isThumbnailEnabled(value: boolean) {\n        if (this._isThumbnailEnabled !== value) {\n            this._isThumbnailEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThumbnailEnabled(): boolean {\n        return this._isThumbnailEnabled;\n    }\n\n    set isVulkanEnabled(value: boolean) {\n        if (this._isVulkanEnabled !== value) {\n            this._isVulkanEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isVulkanEnabled(): boolean {\n        return this._isVulkanEnabled;\n    }\n\n    set isDebugNamesEnabled(value: boolean) {\n        if (this._isDebugNamesEnabled !== value) {\n            this._isDebugNamesEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugNamesEnabled(): boolean {\n        return this._isDebugNamesEnabled;\n    }\n\n    set isDebugLabelsEnabled(value: boolean) {\n        if (this._isDebugLabelsEnabled !== value) {\n            this._isDebugLabelsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugLabelsEnabled(): boolean {\n        return this._isDebugLabelsEnabled;\n    }\n\n    set isLinksEnabled(value: boolean) {\n        if (this._isLinksEnabled !== value) {\n            this._isLinksEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isLinksEnabled(): boolean {\n        return this._isLinksEnabled;\n    }\n\n    set isThreadsEnabled(value: boolean) {\n        if (this._isThreadsEnabled !== value) {\n            this._isThreadsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThreadsEnabled(): boolean {\n        return this._isThreadsEnabled;\n    }\n\n    getPreferenceState(nonDefaultOnly = false): CommandTreePreferenceState {\n        const result: CommandTreePreferenceState = {};\n\n        if (!nonDefaultOnly || this.groupBy !== this.miscPreferences[MiscPrefs.GroupBy]) {\n            result.groupBy = this.groupBy;\n        }\n        if (!nonDefaultOnly || this.isApiEventIdsEnabled !== this.miscPreferences[MiscPrefs.ShowApiEventIds]) {\n            result.isApiEventIdsEnabled = this.isApiEventIdsEnabled;\n        }\n        if (!nonDefaultOnly || this.isShowingEmptyRows !== this.miscPreferences[MiscPrefs.ShowEmptyRows]) {\n            result.isShowingEmptyRows = this.isShowingEmptyRows;\n        }\n        if (!nonDefaultOnly || this.isThumbnailEnabled !== this.miscPreferences[MiscPrefs.ShowThumbnails]) {\n            result.isThumbnailEnabled = this.isThumbnailEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugNamesEnabled !== true) {\n            result.isDebugNamesEnabled = this.isDebugNamesEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugLabelsEnabled !== true) {\n            result.isDebugLabelsEnabled = this.isDebugLabelsEnabled;\n        }\n        if (!nonDefaultOnly || this.isLinksEnabled !== true) {\n            result.isLinksEnabled = this.isLinksEnabled;\n        }\n        if (!nonDefaultOnly || this.isThreadsEnabled !== true) {\n            result.isThreadsEnabled = this.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (!nonDefaultOnly || this.isVulkanEnabled !== this.miscPreferences[MiscPrefs.ShowVulkanCalls]) {\n        //     result.isVulkanEnabled = this.isVulkanEnabled;\n        // }\n\n        return result;\n    }\n\n    override restoreState(state: CommandTreeModel.State): void {\n        if (state.groupBy !== undefined) {\n            this.groupBy = state.groupBy;\n        }\n        if (state.isApiEventIdsEnabled !== undefined) {\n            this.isApiEventIdsEnabled = state.isApiEventIdsEnabled;\n        }\n        if (state.isShowingEmptyRows !== undefined) {\n            this.isShowingEmptyRows = state.isShowingEmptyRows;\n        }\n        if (state.isThumbnailEnabled !== undefined) {\n            this.isThumbnailEnabled = state.isThumbnailEnabled;\n        }\n        if (state.isDebugNamesEnabled !== undefined) {\n            this.isDebugNamesEnabled = state.isDebugNamesEnabled;\n        }\n        if (state.isDebugLabelsEnabled !== undefined) {\n            this.isDebugLabelsEnabled = state.isDebugLabelsEnabled;\n        }\n        if (state.isLinksEnabled !== undefined) {\n            this.isLinksEnabled = state.isLinksEnabled;\n        }\n        if (state.isThreadsEnabled !== undefined) {\n            this.isThreadsEnabled = state.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (state.isVulkanEnabled !== undefined) {\n        //     this.isVulkanEnabled = state.isVulkanEnabled;\n        // }\n    }\n    override storeState(): CommandTreeModel.State {\n        return {\n            ...super.storeState(),\n            ...this.getPreferenceState(true)\n        };\n    }\n\n    @postConstruct()\n    protected override init(): void {\n        super.init();\n\n        // Set back-reference from tree to model\n        this.tree.model = this;\n\n        this.toDispose.pushAll([\n            this.onChangedEmitterProxy,\n            this.onExpansionChangedEmitterProxy,\n            this.onSubTreeExpansionChangedEmitter,\n\n            super.onChanged(() => {\n                if (!this.isCollapsingSubTree) {\n                    this.onChangedEmitterProxy.fire();\n                }\n            }),\n            super.onExpansionChanged(node => {\n                if (!this.isCollapsingSubTree) {\n                    this.onExpansionChangedEmitterProxy.fire(node);\n                }\n            })\n        ]);\n\n        this._isApiEventIdsEnabled = this.miscPreferences[MiscPrefs.ShowApiEventIds];\n        this._isShowingEmptyRows = this.miscPreferences[MiscPrefs.ShowEmptyRows];\n        this.isThumbnailEnabled = this.miscPreferences[MiscPrefs.ShowThumbnails];\n        this.groupBy = this.miscPreferences[MiscPrefs.GroupBy];\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // this.isVulkanEnabled = this.miscPreferences[MiscPrefs.ShowVulkanCalls];\n\n        this.preferenceStateAccess.registerCommandTreeModel(this.tree, this);\n    }\n\n    /**\n     * Collapses the entire tree.\n     */\n    async collapseTree(): Promise<void> {\n        const root = this.root;\n\n        if (CompositeTreeNode.is(root) && root.children.length > 0) {\n            await Promise.all(\n                root.children.filter(CompositeTreeNode.is).map((child: CompositeTreeNode) => this.expansionService.collapseAll(child))\n            );\n        }\n    }\n\n    /**\n     * Expands the given node and all its children recursively.\n     */\n    async expandSubTree(node?: Readonly<TreeNode>, includeDrawOrDispatchNodes = false): Promise<void> {\n        node ??= this.root;\n        if (!ExpandableTreeNode.is(node)) {\n            return;\n        }\n\n        try {\n            this.isCollapsingSubTree = true;\n            await this.doExpandSubTree(node, includeDrawOrDispatchNodes);\n            this.onSubTreeExpansionChangedEmitter.fire(node);\n        } finally {\n            this.isCollapsingSubTree = false;\n        }\n    }\n\n    protected async doExpandSubTree(node: TreeNode, includeDrawOrDispatchNodes: boolean): Promise<void> {\n        const YIELD_AFTER_MS = 200;\n\n        const processedNodes = new Set<TreeNode>();\n        const pendingNodes: TreeNode[] = [node];\n        let lastYieldTime = performance.now();\n\n        while (pendingNodes.length > 0) {\n            const currentLevelNodes: ExpandableTreeNode[] = [];\n            const nextLevelNodes: TreeNode[] = [];\n\n            while (pendingNodes.length > 0) {\n                const currentNode = pendingNodes.shift()!;\n                if (processedNodes.has(currentNode)) {\n                    continue;\n                }\n                processedNodes.add(currentNode);\n\n                // stop expansion at draw and dispatch nodes to avoid creation of low-utility nodes\n                // if this logic gets changed please also update enablement of ExpandSubtreeCommand accordingly\n                if (ExpandableTreeNode.is(currentNode) && (includeDrawOrDispatchNodes || !CommandTreeDrawOrDispatchNode.is(currentNode))) {\n                    currentLevelNodes.push(currentNode);\n                }\n            }\n\n            if (currentLevelNodes.length > 0) {\n                const expandedNodes = await this.expansionService.bulkExpandNodes(currentLevelNodes[Symbol.iterator]());\n                for (const expandedNode of expandedNodes) {\n                    await this.ensureLazyChildrenLoaded(expandedNode);\n                    console.log(`JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, children count: ${expandedNode.children.length}, children ids: ${expandedNode.children.map(c => c.id).join(', ')}`);\n                    nextLevelNodes.push(...expandedNode.children);\n                }\n                // Also process children of nodes that were already expanded\n                for (const currentNode of currentLevelNodes) {\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\n                        await this.ensureLazyChildrenLoaded(currentNode);\n                        console.log(`JF: doExpandSubTree - after ensureLazyChildrenLoaded (already expanded) for ${currentNode.id}, children count: ${currentNode.children.length}, children ids: ${currentNode.children.map(c => c.id).join(', ')}`);\n                        nextLevelNodes.push(...currentNode.children);\n                    }\n                }\n            }\n\n            pendingNodes.push(...nextLevelNodes);\n\n            // Yield control back to the event loop periodically based on time\n            const currentTime = performance.now();\n            if (currentTime - lastYieldTime >= YIELD_AFTER_MS) {\n                await new Promise(resolve => setTimeout(resolve, 0));\n                lastYieldTime = performance.now();\n            }\n        }\n    }\n\n    protected async ensureLazyChildrenLoaded(node: ExpandableTreeNode): Promise<void> {\n        // Find all loading nodes among children\n        const loadingNodes = node.children.filter(CommandEmptyNode.is);\n\n        if (loadingNodes.length === 0) {\n            return;\n        }\n\n        // Trigger load for all loading nodes and wait for them to complete\n        await Promise.all(loadingNodes.map(loadingNode => triggerLazyLoadAndWaitForRemoval(loadingNode)));\n    }\n\n    hasTrailingSuffixes(node: TreeNode): boolean {\n        if (CommandQueueSubmitNode.is(node)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    protected override isVisibleSelectableNode(node: TreeNode): node is SelectableTreeNode {\n        return super.isVisibleSelectableNode(node) && this.isInFrameRange(node);\n    }\n\n    protected isInFrameRange(node: TreeNode): boolean {\n        const frameNode = CommandFrameNode.getCommandFrameNodeContaining(node);\n        if (frameNode === undefined) {\n            return true; // Assume it's good\n        }\n        const range = this.frameRangeSelectionService.frameSpan;\n        if (range === undefined) {\n            return true; // No constraint\n        }\n        return frameNode.frameIndex >= range.startFrame && frameNode.frameIndex <= range.endFrame;\n    }\n}\n\nexport namespace CommandTreeModel {\n    export interface State extends TreeModelImpl.State, CommandTreePreferenceState {}\n\n    /**\n     * Test whether a `node` is of the kind that implements the given `group` mode.\n     * As groups are _a priori_ composite nodes, this additionally infers that type\n     * for the `node` if successful.\n     */\n    export function isOfGroup(node: TreeNode, group: GroupByOptions): node is CompositeTreeNode {\n        switch (group) {\n            case GroupByOptions.Frame:\n                return CommandFrameNode.is(node);\n            case GroupByOptions.RenderPass:\n                return CommandRenderPassInstanceNode.is(node) || CommandDynamicRenderPassInstanceNode.is(node);\n            case GroupByOptions.RenderSubpass:\n                return CommandRenderSubpassInstanceNode.is(node);\n            case GroupByOptions.CommandBuffer:\n                return CommandCommandBufferInstanceNode.is(node);\n            case GroupByOptions.QueueSubmission:\n                return CommandQueueSubmitNode.is(node);\n        }\n    }\n}\n\ntype TextureSupportingNode =\n    | CommandFrameNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode;\n\nexport namespace TextureSupportingNode {\n    export function is(node: CommandTreeNode): node is TextureSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node)\n        );\n    }\n    export function getLast(node: CommandTreeNode): TextureSupportingNode | undefined {\n        if (TextureSupportingNode.is(node)) {\n            return node;\n        }\n        let lastSupportingNode: TextureSupportingNode | undefined;\n        if (CompositeTreeNode.is(node)) {\n            for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n                lastSupportingNode = TextureSupportingNode.getLast(node.children[commandIndex]);\n                if (lastSupportingNode) {\n                    break;\n                }\n            }\n        }\n        return lastSupportingNode;\n    }\n}\n\n/**\n * Union type of all command tree nodes that support thumbnails.\n * Nodes with heavy thumbnail costs are commented out.\n */\ntype ThumbnailSupportingNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandDebugLabelGroupNode\n    | CommandRenderPassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDrawInstanceNode;\n// Below currently have a possibly heavy cost to getting thumbnails\n// | CommandDispatchInstanceNode\n// | CommandMeshTaskInstanceNode\n// | CommandClusterInstanceNode\n// | CommandRaytracingInstanceNode;\n\nexport namespace ThumbnailSupportingNode {\n    export function is(node: CommandTreeNode): node is ThumbnailSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node)\n        );\n    }\n}\n\nfunction getCommandTreeApiEventChildren(eventIds: Array<{ apiEvent: number }>, root: CommandRootNode): CommandTreeApiEvent[] {\n    return eventIds.reduce<CommandTreeApiEvent[]>((collected, id) => {\n        const event = root.resource.apiEvents[id.apiEvent];\n        if (event) {\n            collected.push(event);\n        } else {\n            console.warn(`No event found for ${id.apiEvent}`);\n        }\n        return collected;\n    }, []);\n}\n\nfunction getInstancesByIds<T>(ids: number[], container: PartialRecord<number, T>, source?: string, target?: string): T[] {\n    return ids.flatMap(id => {\n        const instance = container[id];\n        if (!instance) {\n            if (target) {\n                console.warn(`${source ? `${source} expected` : 'Expected'} ${target} with ${id} but found none.`);\n            }\n            return [];\n        }\n        return instance;\n    });\n}\n\n/**\n * Creates an ArrayWithSortNumber for range instances, used by createChildEventNodesForRange.\n * Fetches instances by IDs and provides sorting by beginApiEvent.\n *\n * @param ids - Array of instance IDs to fetch\n * @param container - Container object mapping IDs to instances\n * @param sourceContext - Context string for error messages (e.g., \"CommandRenderPassInstanceNode.create\")\n * @param targetName - Target instance type name for error messages (e.g., \"DebugLabelGroupInstance\")\n * @returns ArrayWithSortNumber object ready for use with getNextRangeElementToProcess\n */\nfunction createRangeInstanceArray<T extends { beginApiEvent: number }>(\n    ids: number[],\n    container: PartialRecord<number, T>,\n    sourceContext: string,\n    targetName: string\n): ArrayWithSortNumber<T> {\n    return {\n        array: getInstancesByIds(ids, container, sourceContext, targetName),\n        getSortNumber: (element: T) => element.beginApiEvent\n    };\n}\n\nexport function createLazyLoadingNode(\n    tree: CommandTree,\n    parent: ExpandableTreeNode,\n    load: (batchQuery?: boolean) => Promise<void>\n): CommandEmptyNode {\n    let loaded = false;\n    let loadingInProgress = false;\n\n    const lazyLoad: (batchQuery?: boolean) => Promise<boolean> = async (batchQuery = true) => {\n        if (loadingInProgress) {\n            return false;\n        }\n\n        if (!loaded) {\n            loaded = true;\n            loadingInProgress = true;\n            loadOnExpanded.dispose();\n            try {\n                await load(batchQuery);\n            } catch (error) {\n                console.error(`LazyLoad failed for node ${parent.id}:`, error);\n            } finally {\n                loadingInProgress = false;\n            }\n            console.log(`JF: createLazyLoadingNode - load completed for parent ${parent.id}, children count before removeChild: ${parent.children.length}`);\n            CompositeTreeNode.removeChild(parent, loadingNode);\n            await tree.refreshStructure(parent);\n            return true;\n        }\n        return false;\n    };\n\n    // create lazy loading node\n    const loadingNode: CommandEmptyNode = CommandEmptyNode.create(parent, lazyLoad);\n    CompositeTreeNode.addChild(parent, loadingNode);\n\n    // register for lazy loading when the node is expanded\n    const loadOnExpanded = SokatoaLifecycleTreeNode.register(parent, 'onWillRender', async () => {\n        if (parent.expanded) {\n            // do not batch queries for expansion manually\n            await lazyLoad(false);\n        }\n    });\n    return loadingNode;\n}\n",
                "originalState": "/********************************************************************************\n    Copyright 2024-2026 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\nimport { GFXRQueryBuilderService } from '@sokatoa/gfxr-consumer/lib/';\nimport {\n    DynamicStateEntry,\n    PipelineBindPoint,\n    PipelineBindPointShaderStageFlags,\n    StateType\n} from '@sokatoa/gfxr-consumer/lib/browser/gfxr-data-service';\nimport { PartialRecord } from '@sokatoa/platform/lib';\nimport { BulkTree, BulkTreeModel, ResourceTreeNode, SokatoaLifecycleTreeNode } from '@sokatoa/platform/lib/browser';\nimport { GroupByOptions, MiscPreferences, MiscPrefs } from '@sokatoa/platform/lib/browser/misc-preferences';\nimport { TreeStructureChangeEmitter } from '@sokatoa/platform/lib/browser/tree-table/tree-table-widget';\nimport { ImageAccessorService } from '@sokatoa/platform/lib/common';\nimport { CompressedFileService, usesCompressionExtension } from '@sokatoa/platform/lib/common/compressed-file-service';\nimport { asError } from '@sokatoa/platform/lib/common/error-utils';\nimport { ApiResources, DescriptorResource, DrawApiResult } from '@sokatoa/platform/lib/common/gfxr-apis';\nimport { CancellationToken, Disposable, Emitter, Event, Path, URI } from '@theia/core';\nimport {\n    CompositeTreeNode,\n    DepthFirstTreeIterator,\n    ExpandableTreeNode,\n    SelectableTreeNode,\n    TreeModelImpl,\n    TreeNode\n} from '@theia/core/lib/browser';\nimport { RGBA } from '@theia/core/lib/common/color';\nimport { inject, injectable, postConstruct } from '@theia/core/shared/inversify';\nimport { PNG } from 'pngjs/browser';\nimport { lookupResourceFormat, UncompressedResourceFormat } from '../../common/format-handler';\nimport { extractData } from '../../common/geometry-utils';\nimport { GfxrScreenshotService, requestThumbnails, ScreenshotType, ThumbnailRequestOptions } from '../../common/gfxr-screenshot-service';\nimport { convertDataToImageData } from '../../common/host-side-conversion/vulkan-image';\nimport { FrameRangeSelectionService } from '../capture-widget/frame-range-selection-service';\nimport { placeholderScale } from '../graphics-pipeline-widget/graphics-pipeline-screenshot-requests';\nimport {\n    CaptureDatasetWidgetContext,\n    CaptureDatasetWidgetProfile,\n    CaptureDatasetWidgetReplayContext\n} from '../profile-ui/capture-dataset-widget-types';\nimport { CommandTreePreferenceState } from './command-tree-model-preferences';\nimport {\n    CommandTreeAccelerationStructureBuildInstance,\n    CommandTreeAccelerationStructureCopyInstance,\n    CommandTreeApiEvent,\n    CommandTreeCommandBufferInstance,\n    CommandTreeDataWithFunctionAndDebugNames,\n    CommandTreeDebugLabelGroupInstance,\n    CommandTreeDynamicRenderPassInstance,\n    CommandTreeFrame,\n    CommandTreeQueueDebugLabelGroup,\n    CommandTreeQueueDebugLabelInsert,\n    CommandTreeQueuePresent,\n    CommandTreeQueueSubmit,\n    CommandTreeRenderPassInstance,\n    CommandTreeRenderSubpassInstance,\n    CommandTreeSecondaryCommandBufferInstance,\n    CommandTreeTransferCommandInstance,\n    overrideDynamicState,\n    queryClusterInstanceDynamicState,\n    queryClusterInstanceDynamicStateBatched,\n    queryDispatchInstanceDynamicState,\n    queryDispatchInstanceDynamicStateBatched,\n    queryDrawInstanceDynamicState,\n    queryDrawInstanceDynamicStateBatched,\n    queryMeshTaskInstanceDynamicState,\n    queryMeshTaskInstanceDynamicStateBatched,\n    queryRaytracingInstanceDynamicState,\n    queryRaytracingInstanceDynamicStateBatched,\n    querySecondaryCommandBufferEndDynamicState,\n    QueryTreeDataOptions\n} from './command-tree-service';\nimport { LazyLoadableNode, triggerLazyLoadAndWaitForRemoval } from './lazy-load-utils';\nimport { CommandTreeDataQueriedRootProvider } from './providers/command-tree-root-provider';\n\n// Extension names\nconst VK_NV_COMMAND_BUFFER_INHERITANCE = 'VK_NV_command_buffer_inheritance';\nconst VK_NV_INHERITED_VIEWPORT_SCISSOR = 'VK_NV_inherited_viewport_scissor';\n\n/**\n * Helper type to make TreeNode.parent writable during node construction.\n * TreeNode.parent is readonly, but during tree construction we need to update it.\n */\ninterface MutableParent {\n    parent: CompositeTreeNode | undefined;\n}\n\n/**\n * Check if VK_NV_command_buffer_inheritance extension is enabled for a device.\n * This extension enables full state inheritance between command buffers and leak-back.\n */\nfunction hasCommandBufferInheritance(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_COMMAND_BUFFER_INHERITANCE) ?? false;\n}\n\n/**\n * Check if VK_NV_inherited_viewport_scissor extension is enabled for a device.\n * This extension enables limited viewport/scissor inheritance for secondary command buffers.\n */\nfunction hasInheritedViewportScissor(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_INHERITED_VIEWPORT_SCISSOR) ?? false;\n}\n\n/**\n * Filter dynamic state to only viewport and scissor entries.\n * Used for VK_NV_inherited_viewport_scissor extension.\n */\nasync function filterDynamicStateForViewportScissor(statePromise: Promise<DynamicStateEntry[]>): Promise<DynamicStateEntry[]> {\n    const state = await statePromise;\n    return state.filter(entry => entry.stateType === StateType.VIEWPORT || entry.stateType === StateType.SCISSOR);\n}\n\n/**\n * Tracks dynamic state that may be updated as secondary command buffers execute\n * (when VK_NV_command_buffer_inheritance is enabled).\n */\nclass DynamicStateTracker {\n    private currentStatePromise: Promise<DynamicStateEntry[]>;\n\n    constructor(initialState: Promise<DynamicStateEntry[]>) {\n        this.currentStatePromise = initialState;\n    }\n\n    getCurrentState(): Promise<DynamicStateEntry[]> {\n        return this.currentStatePromise;\n    }\n\n    updateState(newState: Promise<DynamicStateEntry[]>): void {\n        this.currentStatePromise = newState;\n    }\n}\n\n/** Internal context for a command tree model.\n *\n * contains all the fixed data needed for the model,\n * e.g. services, etc.\n */\ninterface CommandTreeContext {\n    dbId: number;\n    data: CommandTreeDataWithFunctionAndDebugNames;\n    screenshotService: GfxrScreenshotService;\n    fileService: CompressedFileService;\n    profile: CaptureDatasetWidgetProfile;\n    context: CaptureDatasetWidgetContext;\n    tree: CommandTree;\n    gfxrQueryBuilderService: GFXRQueryBuilderService;\n    imageAccessorService: ImageAccessorService;\n    createDrawOrDispatchChildren: boolean;\n    rootNode: CommandRootNode;\n    deviceExtensions: Map<number, Set<string>>;\n}\n\n/**\n * Helper function to look up the debug name for an object at a specific API event.\n * Finds the most recent debug name that was set at or before the target API event.\n * @param debugNameLookup - Map of objectHandle to array of {apiEvent, name} sorted by apiEvent\n * @param objectHandle - The object handle to look up\n * @param targetApiEvent - The API event at which we want to know the object's name\n * @returns The debug name if found, undefined otherwise\n */\nfunction getDebugNameAtApiEvent(\n    debugNameLookup: Map<number, Array<{ apiEvent: number; name: string }>>,\n    objectHandle: number | null | undefined,\n    targetApiEvent: number\n): string | undefined {\n    if (typeof objectHandle !== 'number') {\n        return undefined;\n    }\n\n    const entries = debugNameLookup.get(objectHandle);\n    if (!entries || entries.length === 0) {\n        return undefined;\n    }\n\n    // Binary search for the most recent name at or before targetApiEvent\n    let left = 0;\n    let right = entries.length - 1;\n    let result: string | undefined = undefined;\n\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (entries[mid].apiEvent <= targetApiEvent) {\n            result = entries[mid].name;\n            left = mid + 1; // Look for a more recent name\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n\nexport interface CommandRootNode extends ResourceTreeNode<CommandTreeDataWithFunctionAndDebugNames>, CompositeTreeNode, ExpandableTreeNode {\n    resourceType: typeof CommandRootNode.RESOURCE_TYPE;\n    children: CommandFrameNode[];\n    dbId: number;\n    profile: CaptureDatasetWidgetProfile;\n    tree?: CommandTree; // Back-reference to the tree that owns this root\n    // Cached maps for queue debug labels to avoid rebuilding for each frame\n    queueDebugLabelGroupsBySubmitId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelGroupsByPresentId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelInsertsByApiEvent: Map<number, CommandTreeQueueDebugLabelInsert>;\n}\n\nexport namespace CommandRootNode {\n    export const ID = 'sokatoa-command-tree-widget';\n\n    export const RESOURCE_TYPE = '__root__';\n\n    export function is(node: TreeNode | undefined): node is CommandRootNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRootNode.RESOURCE_TYPE);\n    }\n\n    export function create(\n        dbId: number,\n        data: CommandTreeDataWithFunctionAndDebugNames,\n        screenshotService: GfxrScreenshotService,\n        profile: CaptureDatasetWidgetProfile,\n        context: CaptureDatasetWidgetContext,\n        tree: CommandTree,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        imageAccessorService: ImageAccessorService,\n        fileService: CompressedFileService,\n        createDrawOrDispatchChildren: boolean,\n        deviceExtensions: Map<number, Set<string>>\n    ): CommandRootNode {\n        // Build maps for queue debug labels once for all frames\n        const queueDebugLabelGroupsBySubmitId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelGroupsByPresentId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelInsertsByApiEvent = new Map<number, CommandTreeQueueDebugLabelInsert>();\n\n        for (const group of Object.values(data.queueDebugLabelGroups)) {\n            if (group) {\n                for (const submitId of group.queueSubmitIds) {\n                    queueDebugLabelGroupsBySubmitId.set(submitId, group);\n                }\n                for (const presentId of group.queuePresentIds) {\n                    queueDebugLabelGroupsByPresentId.set(presentId, group);\n                }\n            }\n        }\n\n        for (const insert of Object.values(data.queueDebugLabelInserts)) {\n            if (insert) {\n                queueDebugLabelInsertsByApiEvent.set(insert.apiEvent, insert);\n            }\n        }\n\n        const rootNode: CommandRootNode = {\n            visible: false,\n            id: CommandRootNode.ID,\n            name: 'ProfileTree',\n            parent: undefined,\n            expanded: true,\n            children: [],\n            resourceType: CommandRootNode.RESOURCE_TYPE,\n            resource: data,\n            dbId,\n            profile,\n            queueDebugLabelGroupsBySubmitId,\n            queueDebugLabelGroupsByPresentId,\n            queueDebugLabelInsertsByApiEvent\n        };\n        const ctx: CommandTreeContext = {\n            dbId,\n            data,\n            screenshotService,\n            fileService,\n            profile,\n            context,\n            tree,\n            gfxrQueryBuilderService,\n            imageAccessorService,\n            createDrawOrDispatchChildren,\n            rootNode,\n            deviceExtensions\n        };\n        const modelBuildStart = Date.now();\n        const frames = Object.values(data.frames);\n        rootNode.children = frames.flatMap(child => (child ? CommandFrameNode.create(ctx, child, rootNode) : []));\n        console.debug(`Model loaded in ${Date.now() - modelBuildStart} ms`);\n        return rootNode;\n    }\n}\n\nexport interface DebugMarker {\n    name: string;\n    color?: RGBA;\n}\n\nexport interface WithDebugMarker {\n    debugMarker?: DebugMarker;\n}\n\nexport namespace WithDebugMarker {\n    /** Type guard for a `node` that is or has a debug marker. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugMarker> {\n        return 'debugMarker' in node && node.debugMarker !== undefined;\n    }\n}\n\nexport interface WithDebugName {\n    debugName?: string;\n}\n\nexport namespace WithDebugName {\n    /** Type guard for a `node` that has a debug name. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugName> {\n        return 'debugName' in node && node.debugName !== undefined;\n    }\n}\n\ninterface LabelData {\n    labelName: string | undefined | null;\n    colorR: number | undefined | null;\n    colorG: number | undefined | null;\n    colorB: number | undefined | null;\n    colorA: number | undefined | null;\n}\n\nfunction setDebugMarkerData(node: WithDebugMarker, labelData: LabelData): void {\n    const name = labelData.labelName ?? 'Debug marker';\n    const color = {\n        r: (labelData.colorR ?? 1) * 255,\n        g: (labelData.colorG ?? 1) * 255,\n        b: (labelData.colorB ?? 1) * 255,\n        a: (labelData.colorA ?? 1) * 255\n    };\n\n    node.debugMarker = { name };\n    if (color.a !== 0 || color.b !== 0 || color.g !== 0 || color.r !== 0) {\n        node.debugMarker.color = color;\n    }\n}\n\nexport interface CommandFrameNode extends ResourceTreeNode<CommandTreeFrame>, ExpandableTreeNode, SelectableTreeNode {\n    label: string;\n    frameIndex: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandFrameNode.RESOURCE_TYPE;\n    thumbnail?: string;\n}\n\nexport namespace CommandFrameNode {\n    export const RESOURCE_TYPE = 'frame';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandFrameNode {\n        return ResourceTreeNode.hasResourceType(node, CommandFrameNode.RESOURCE_TYPE);\n    }\n\n    export function getId(frame: CommandTreeFrame): string {\n        return frame.frameIndex.toString();\n    }\n\n    export function create(ctx: CommandTreeContext, element: CommandTreeFrame, parent: CompositeTreeNode): CommandFrameNode {\n        const node: CommandFrameNode & SokatoaLifecycleTreeNode = {\n            id: getId(element),\n            frameIndex: element.frameIndex,\n            label: `Frame ${element.frameIndex}`,\n            children: [],\n            expanded: false,\n            selected: false,\n            parent,\n            resourceType: CommandFrameNode.RESOURCE_TYPE,\n            resource: element\n        };\n\n        const root = ctx.rootNode;\n\n        const children: CommandTreeNode[] = [];\n        let queueSubmitIndex = 0;\n        let queuePresentIndex = 0;\n        let accelerationStructureBuildIndex = 0;\n        let accelerationStructureCopyIndex = 0;\n\n        // Track current active debug label group and its children\n        let activeDebugLabelGroup: CommandTreeQueueDebugLabelGroup | undefined;\n        let activeGroupChildren: (CommandQueueSubmitNode | CommandQueuePresentNode)[] = [];\n        let queueDebugLabelGroupInstanceIndex = 0;\n\n        // Helper to finalize the active group and add it to children\n        const finalizeActiveGroup = (): void => {\n            if (activeDebugLabelGroup && activeGroupChildren.length > 0) {\n                children.push(\n                    CommandQueueDebugLabelGroupNode.create(\n                        ctx,\n                        activeDebugLabelGroup,\n                        node,\n                        activeGroupChildren,\n                        queueDebugLabelGroupInstanceIndex++\n                    )\n                );\n                activeDebugLabelGroup = undefined;\n                activeGroupChildren = [];\n            }\n        };\n\n        for (let id = element.beginApiEvent; id <= (element.endApiEvent ?? element.beginApiEvent); id++) {\n            // Check for queue debug label insert at this apiEvent\n            const queueDebugLabelInsert = root.queueDebugLabelInsertsByApiEvent.get(id);\n            if (queueDebugLabelInsert) {\n                // Inserts can appear in the middle of groups, so finalize any active group first\n                finalizeActiveGroup();\n                children.push(CommandQueueDebugLabelNode.create(ctx, queueDebugLabelInsert, node));\n            }\n\n            const apiEvent = root.resource.apiEvents[id];\n            if (apiEvent) {\n                if (apiEvent.submissionId && element.queueSubmitIds.includes(apiEvent.submissionId)) {\n                    const queueSubmit = root.resource.queueSubmits[apiEvent.submissionId];\n                    if (queueSubmit) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsBySubmitId.get(apiEvent.submissionId);\n\n                        // Check if this submit is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queueSubmit not found for submissionId ${apiEvent.submissionId}`);\n                    }\n                } else if (apiEvent.presentId && element.queuePresentIds.includes(apiEvent.presentId)) {\n                    const queuePresent = root.resource.queuePresents[apiEvent.presentId];\n                    if (queuePresent) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsByPresentId.get(apiEvent.presentId);\n\n                        // Check if this present is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queuePresent not found for presentId ${apiEvent.presentId}`);\n                    }\n                } else if (\n                    apiEvent.accelerationStructureBuildInstanceId &&\n                    element.accelerationStructureBuildIds.includes(apiEvent.accelerationStructureBuildInstanceId)\n                ) {\n                    // Acceleration structure builds interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureBuild =\n                        root.resource.topLevelAccelerationStructureBuilds[apiEvent.accelerationStructureBuildInstanceId];\n                    if (accelerationStructureBuild) {\n                        children.push(\n                            CommandAccelerationStructureBuildNode.create(\n                                accelerationStructureBuild,\n                                node,\n                                accelerationStructureBuildIndex++\n                            )\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureBuildInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureBuild not found for accelerationStructureBuildInstanceId ${iId}`\n                        );\n                    }\n                } else if (\n                    apiEvent.accelerationStructureCopyInstanceId &&\n                    element.accelerationStructureCopyIds.includes(apiEvent.accelerationStructureCopyInstanceId)\n                ) {\n                    // Acceleration structure copies interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureCopy =\n                        root.resource.topLevelAccelerationStructureCopies[apiEvent.accelerationStructureCopyInstanceId];\n                    if (accelerationStructureCopy) {\n                        children.push(\n                            CommandAccelerationStructureCopyNode.create(accelerationStructureCopy, node, accelerationStructureCopyIndex++)\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureCopyInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureCopy not found for accelerationStructureCopyInstanceId ${iId}`\n                        );\n                    }\n                }\n            }\n        }\n\n        // Finalize any remaining active debug label group at the end\n        finalizeActiveGroup();\n\n        node.children = children;\n\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        const request: ThumbnailRequestOptions = {\n            profileOrReplay: replay ?? ctx.profile,\n            startFrame: element.frameIndex,\n            endFrame: element.frameIndex,\n            requesterDbgName: `Command tree frame ${element.frameIndex}`,\n            onScreenshotReady: result => {\n                ctx.imageAccessorService\n                    .accessImage(new URL(URI.fromFilePath(result.path).toString()))\n                    .then(url => {\n                        node.thumbnail = url.url.toString();\n                        ctx.tree.addToDispose(url);\n                        void ctx.tree.refresh(node);\n                    })\n                    .catch(reason => {\n                        const error = asError(reason);\n                        console.error(error);\n                    });\n            },\n            onRequestComplete: (success, message) => {\n                if (!success) {\n                    console.error(`Request for frame thumbnails failed: ${message}`);\n                }\n            }\n        };\n        const onWillRender = (): void => {\n            requestThumbnails(ctx.screenshotService, request);\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', onWillRender);\n        };\n        SokatoaLifecycleTreeNode.register(node, 'onWillRender', onWillRender);\n        return node;\n    }\n\n    /**\n     * Retrieve the `CommandFrameNode` that is or contains the given `node`.\n     * Returns `undefined` in the case that the `node` is an ancestor of or\n     * otherwise not contained in an `CommandFrameNode`.\n     */\n    export function getCommandFrameNodeContaining(node: TreeNode): CommandFrameNode | undefined {\n        return CommandFrameNode.is(node) ? node : node.parent ? CommandFrameNode.getCommandFrameNodeContaining(node.parent) : undefined;\n    }\n}\n\nexport interface CommandEmptyNode extends LazyLoadableNode {\n    label: string;\n}\n\nexport namespace CommandEmptyNode {\n    export const GENERALIZED_TYPE = 'empty';\n\n    export function is(node: unknown): node is CommandEmptyNode {\n        return TreeNode.is(node) && node.id.endsWith('_empty');\n    }\n\n    export function getId(parent: CompositeTreeNode): string {\n        return `${parent.id}_empty`;\n    }\n\n    export function create(parent: CompositeTreeNode, load: CommandEmptyNode['load']): CommandEmptyNode {\n        return {\n            id: getId(parent),\n            label: 'Loading...',\n            parent,\n            load\n        };\n    }\n}\n\nexport interface CommandApiEventNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandApiEventNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandApiEventNode {\n    export const RESOURCE_TYPE = 'api-event';\n    export const GENERALIZED_TYPE = RESOURCE_TYPE;\n\n    export function is(node: TreeNode | undefined): node is CommandApiEventNode {\n        return ResourceTreeNode.hasResourceType(node, CommandApiEventNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEventId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex?: number\n    ): CommandApiEventNode {\n        const root = ctx.rootNode;\n        const node: CommandApiEventNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEventId,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex ?? ''}`,\n            parent,\n            resourceType: CommandApiEventNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId,\n            selected: false\n        };\n        // set debug marker data if node is a debug marker\n        if (element.debugLabelId) {\n            const labelData = root.resource.debugLabels[element.debugLabelId];\n            if (labelData) {\n                setDebugMarkerData(node, labelData);\n            }\n        }\n        return node;\n    }\n}\n\nexport interface CommandDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeDebugLabelGroupInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'debug-label-group';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDebugLabelGroupInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDebugLabelGroupInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDebugLabelGroupNode = {\n            id: getId(element, parent),\n            debugLabelInstanceId: element.labelId,\n            label: `${root.resource.functionNameLookup[element.functionNameId ?? -1] ?? '<not defined>'}`,\n            parent,\n            resourceType: CommandDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this debug label range\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this debug label group, add it to array\n            // - not self\n            // - only commands with same command buffer id\n            if (event && event.debugLabelId !== element.labelId && event.commandBufferInstanceId === element.commandBufferInstance) {\n                apiEventCommandArray.push(event);\n            }\n        }\n        // get array of debug label ranges with api event numbers within this debug label range\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this debug label range\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderPassInstance'\n        );\n        // get array of render subpass ranges with api event numbers within this debug label range\n        const renderSubpassInstances = createRangeInstanceArray(\n            element.renderSubpassInstanceIds,\n            root.resource.renderSubpassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderSubpassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this debug label range\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('subpassIndex' in rangeElement) {\n                    const renderSubpassInstanceNode = CommandRenderSubpassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderSubpassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            renderSubpassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for debug label group:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `debug label group ${element.labelId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelGroup>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'queue-debug-label-group';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelGroup, parent: CompositeTreeNode, instanceIndex: number): string {\n        return `${parent.id}_qdl_group_${element.labelId}_${instanceIndex}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelGroup,\n        parent: CompositeTreeNode,\n        children: (CommandQueueSubmitNode | CommandQueuePresentNode)[],\n        instanceIndex: number\n    ): CommandQueueDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelGroupNode = {\n            id: getId(element, parent, instanceIndex),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label Group',\n            queue: element.queue!,\n            parent,\n            resourceType: CommandQueueDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        // Update parent references for children since they were created with a different parent\n        // and are now being reparented to this debug label group node\n        for (const child of children) {\n            // Cast away readonly to update parent during node construction\n            (child as MutableParent).parent = node;\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelInsert>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    apiEventId: number;\n    resourceType: typeof CommandQueueDebugLabelNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelNode {\n    export const RESOURCE_TYPE = 'queue-debug-label';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelInsert, parent: CompositeTreeNode): string {\n        return `${parent.id}_qdl_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelInsert,\n        parent: CompositeTreeNode\n    ): CommandQueueDebugLabelNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelNode = {\n            id: getId(element, parent),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label',\n            queue: element.queue!,\n            apiEventId: element.apiEvent,\n            parent,\n            resourceType: CommandQueueDebugLabelNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandCommandBufferInstanceNode\n    extends ResourceTreeNode<CommandTreeCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    commandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandCommandBufferInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandCommandBufferInstanceNode {\n    export const RESOURCE_TYPE = 'command-buffer-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandCommandBufferInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandCommandBufferInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeCommandBufferInstance,\n        parent: CompositeTreeNode,\n        commandBufferIndex: number,\n        baseDynamicStatePromise?: Promise<DynamicStateEntry[]>\n    ): CommandCommandBufferInstanceNode {\n        const node: CommandCommandBufferInstanceNode = {\n            id: getId(element, parent),\n            commandBufferInstanceId: element.instanceId,\n            label: `Command Buffer ${commandBufferIndex}`,\n            parent,\n            resourceType: CommandCommandBufferInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this command buffer\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this command buffer, add it to array\n            // - omit commands that reference render pass id\n            // - if api event is a debug label, check the debug label itself for a render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                event.commandBufferInstanceId === element.instanceId &&\n                event.renderPassInstanceId === undefined &&\n                event.dynamicRenderPassInstanceId === undefined &&\n                (event.debugLabelId === undefined ||\n                    (debugLabel?.beginApiEvent === event.apiEventId &&\n                        debugLabel?.beginRenderPassInstance === undefined &&\n                        debugLabel?.beginDynamicRenderPassInstance === undefined) ||\n                    (debugLabel?.endApiEvent === event.apiEventId &&\n                        debugLabel?.endRenderPassInstance === undefined &&\n                        debugLabel?.endDynamicRenderPassInstance === undefined))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this command buffer\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this command buffer\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'RenderPassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this command buffer\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        const emptyDynamicStatePromise = new Promise<DynamicStateEntry[]>(resolve => resolve([]));\n        const effectiveBaseState = baseDynamicStatePromise ?? emptyDynamicStatePromise;\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            effectiveBaseState,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        effectiveBaseState\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for command buffer:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `command buffer ${commandBufferIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandSecondaryCommandBufferExecutionNode\n    extends ResourceTreeNode<CommandTreeSecondaryCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    parentCommandBufferInstanceId: number;\n    secondaryCommandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n}\n\nexport namespace CommandSecondaryCommandBufferExecutionNode {\n    export const RESOURCE_TYPE = 'secondary-command-buffer-execution';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: unknown): node is CommandSecondaryCommandBufferExecutionNode {\n        return (\n            ExpandableTreeNode.is(node) && SelectableTreeNode.is(node) && ResourceTreeNode.is(node, 'secondary-command-buffer-execution')\n        );\n    }\n\n    export function getId(element: CommandTreeSecondaryCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_secondary_${element.secondaryCommandBufferInstance}_${element.executionId}_${element.executionIndex}`;\n    }\n\n    export async function create(\n        ctx: CommandTreeContext,\n        elements: CommandTreeSecondaryCommandBufferInstance[],\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n        stateTracker?: DynamicStateTracker\n    ): Promise<CommandSecondaryCommandBufferExecutionNode> {\n        if (elements.length === 0) {\n            throw new Error('elements array must not be empty');\n        }\n        // Use the first element for the node's resource (they all share the same executionId and apiEvent)\n        const element = elements[0];\n        const node: CommandSecondaryCommandBufferExecutionNode = {\n            id: getId(element, parent),\n            parentCommandBufferInstanceId: element.parentCommandBufferInstance || 0,\n            secondaryCommandBufferInstanceId: element.secondaryCommandBufferInstance || 0,\n            label: `Secondary Command Buffer Execution ${commandIndex}`,\n            parent,\n            resourceType: 'secondary-command-buffer-execution',\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        createLazyLoadingNode(ctx.tree, node, async () => {\n            // Sort elements by executionIndex to maintain proper order\n            const sortedElements = [...elements].sort((a, b) => (a.executionIndex || 0) - (b.executionIndex || 0));\n\n            // Get device and check extensions\n            const firstSecondary = sortedElements[0]?.secondaryCommandBufferInstance;\n            let deviceExtensions: Set<string> | undefined;\n\n            if (firstSecondary !== undefined) {\n                const commandBufferInstance = root.resource.commandBufferInstances[firstSecondary];\n                const device = commandBufferInstance?.device;\n                if (typeof device === 'number') {\n                    deviceExtensions = ctx.deviceExtensions.get(device);\n                }\n            }\n\n            const hasInheritance = hasCommandBufferInheritance(deviceExtensions);\n            const hasViewportScissorOnly = hasInheritedViewportScissor(deviceExtensions) && !hasInheritance;\n\n            // Calculate effective base state for INHERITANCE INTO secondary\n            let effectiveBaseState: Promise<DynamicStateEntry[]>;\n            if (hasInheritance) {\n                effectiveBaseState = baseDynamicStatePromise;\n            } else if (hasViewportScissorOnly) {\n                effectiveBaseState = filterDynamicStateForViewportScissor(baseDynamicStatePromise);\n            } else {\n                effectiveBaseState = Promise.resolve([]);\n            }\n\n            // Create a CommandCommandBufferInstanceNode for each secondary command buffer in the execution\n            const childNodes: CommandCommandBufferInstanceNode[] = [];\n            sortedElements.forEach((secondaryInstance, index) => {\n                if (secondaryInstance.secondaryCommandBufferInstance) {\n                    const commandBufferInstance = root.resource.commandBufferInstances[secondaryInstance.secondaryCommandBufferInstance];\n                    if (commandBufferInstance) {\n                        const childNode = CommandCommandBufferInstanceNode.create(\n                            ctx,\n                            commandBufferInstance,\n                            node,\n                            index,\n                            effectiveBaseState\n                        );\n                        childNodes.push(childNode);\n                    } else {\n                        console.warn(\n                            `Command buffer instance ${secondaryInstance.secondaryCommandBufferInstance} ` +\n                                'not found in root.resource.commandBufferInstances'\n                        );\n                    }\n                }\n            });\n            CompositeTreeNode.addChildren(node, childNodes);\n\n            // Handle LEAK-BACK: Update parent's state tracker if extension is enabled\n            if (hasInheritance && stateTracker && element.executionId) {\n                const db = ctx.gfxrQueryBuilderService.builderFor(ctx.dbId);\n                const endStatePromise = querySecondaryCommandBufferEndDynamicState(db, [element.executionId]);\n                stateTracker.updateState(endStatePromise);\n            }\n        });\n\n        // Register for thumbnail updates\n        registerThumbnailUpdate(ctx, node, `secondary command buffer execution ${node.resource.executionId}`);\n        return node;\n    }\n}\n\nexport interface CommandQueueSubmitNode\n    extends ResourceTreeNode<CommandTreeQueueSubmit>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    submissionId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueSubmitNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueSubmitNode {\n    export const RESOURCE_TYPE = 'queue-submit';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueSubmitNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueSubmitNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueSubmit, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.submissionId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueSubmit,\n        parent: CompositeTreeNode,\n        queueSubmitIndex: number\n    ): CommandQueueSubmitNode {\n        const root = ctx.rootNode;\n        const node: CommandQueueSubmitNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            threadId: element.threadId || 0,\n            submissionId: element.submissionId,\n            label: `Queue Submit ${queueSubmitIndex}`,\n            queue: element.queue,\n            parent,\n            resourceType: CommandQueueSubmitNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        const children =\n            element.queueSubmitBuffers\n                ?.filter(b => b.commandBufferInstance)\n                .flatMap(b => {\n                    const instance = root.resource.commandBufferInstances[b.commandBufferInstance!];\n                    if (!instance) {\n                        console.warn(`CommandQueueSubmitNode.create: commandBufferInstance not found for id ${b.commandBufferInstance}`);\n                        return [];\n                    }\n                    return instance;\n                }) ?? [];\n        let commandBufferIndex = 0;\n        node.children = children.map(child => CommandCommandBufferInstanceNode.create(ctx, child, node, commandBufferIndex++));\n\n        registerThumbnailUpdate(ctx, node, `queue submit ${queueSubmitIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueuePresentNode extends ResourceTreeNode<CommandTreeQueuePresent>, SelectableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    resourceType: typeof CommandQueuePresentNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueuePresentNode {\n    export const RESOURCE_TYPE = 'queue-present';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueuePresentNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueuePresentNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueuePresent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEvent}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueuePresent,\n        parent: CompositeTreeNode,\n        queuePresentIndex: number\n    ): CommandQueuePresentNode {\n        const root = ctx.rootNode;\n        const node: CommandQueuePresentNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            label: `Queue Present ${queuePresentIndex}`,\n            parent,\n            resourceType: CommandQueuePresentNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            queue: element.queue,\n            selected: false\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureBuildNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureBuildInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    buildInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureBuildNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureBuildNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-build';\n    export const GENERALIZED_TYPE = 'acceleration-structure-build';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureBuildNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureBuildNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureBuildInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.buildApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureBuildInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureBuildNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureBuildNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            buildInstanceId: element.instanceId,\n            apiEventId: element.buildApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureBuildNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureCopyNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureCopyInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    copyInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureCopyNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureCopyNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-copy';\n    export const GENERALIZED_TYPE = 'acceleration-structure-copy';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureCopyNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureCopyNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureCopyInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.copyApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureCopyInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureCopyNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureCopyNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            copyInstanceId: element.instanceId,\n            apiEventId: element.copyApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureCopyNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandTransferCommandNode\n    extends ResourceTreeNode<CommandTreeTransferCommandInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    transferCommandInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandTransferCommandNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandTransferCommandNode {\n    export const RESOURCE_TYPE = 'transfer-command';\n    export const GENERALIZED_TYPE = 'transfer-command';\n\n    export function is(node: TreeNode | undefined): node is CommandTransferCommandNode {\n        return ResourceTreeNode.hasResourceType(node, CommandTransferCommandNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeTransferCommandInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.transferApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeTransferCommandInstance,\n        parent: CompositeTreeNode,\n        transferCommandIndex: number\n    ): CommandTransferCommandNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandTransferCommandNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            transferCommandInstanceId: element.instanceId,\n            apiEventId: element.transferApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${transferCommandIndex}`,\n            parent,\n            resourceType: CommandTransferCommandNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nfunction setThumbnailUrl(\n    ctx: CommandTreeContext,\n    resources: ApiResources[],\n    node: TreeNode & { thumbnail?: string },\n    requesterDbgName: string\n): void {\n    if (resources.length > 0) {\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        ctx.screenshotService.requestScreenshots({\n            profileOrReplay: replay ?? ctx.profile,\n            scale: placeholderScale,\n            screenshotType: ScreenshotType.API_EVENT,\n            requestData: resources,\n            moreRequests: true,\n            requesterDbgName,\n            options: {\n                DumpDepth: true\n            },\n            onScreenshotReady: result => {\n                if (result.resultData.resultType === ScreenshotType.API_EVENT && DrawApiResult.is(result.resultData.apiResult)) {\n                    const images = [...(result.resultData.apiResult.colorAttachments || [])];\n                    if (result.resultData.apiResult.depthAttachment) {\n                        images.push(result.resultData.apiResult.depthAttachment);\n                    }\n                    if (images.length > 0) {\n                        const possibleImage = images[0].subresources?.[0];\n                        if (possibleImage) {\n                            if (usesCompressionExtension(possibleImage.file)) {\n                                // Use VkImageConversionService to get a png\n                                // Do the same as the else case, but with the new png file\n                                const format = lookupResourceFormat(images[0].format);\n                                if (UncompressedResourceFormat.is(format)) {\n                                    ctx.fileService\n                                        .read(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString(), {\n                                            uncompressedSize: possibleImage.size\n                                        })\n                                        .then(async content => {\n                                            const extractedData = await extractData(format, content);\n                                            const dim = {\n                                                width: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[0]\n                                                    : possibleImage.dimensions[0] * placeholderScale,\n                                                height: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[1]\n                                                    : possibleImage.dimensions[1] * placeholderScale\n                                            };\n                                            const conversionResult = await convertDataToImageData(extractedData, format, dim, {\n                                                channelOptions: { alpha: { disabled: true } }\n                                            });\n                                            const png = new PNG({\n                                                width: conversionResult.dimensions.width,\n                                                height: conversionResult.dimensions.height\n                                            });\n                                            png.data = conversionResult.data;\n                                            const pngBuffer = PNG.sync.write(png);\n                                            node.thumbnail = `data:image/png;base64, ${pngBuffer.toString('base64')}`;\n                                            void ctx.tree.refresh(node.parent);\n                                        })\n                                        .catch(reason => {\n                                            const error = asError(reason);\n                                            console.error(error);\n                                        });\n                                }\n                            } else {\n                                ctx.imageAccessorService\n                                    .accessImage(new URL(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString()))\n                                    .then(url => {\n                                        node.thumbnail = url.url.toString();\n                                        ctx.tree.addToDispose(url);\n                                        void ctx.tree.refresh(node.parent);\n                                    })\n                                    .catch(reason => {\n                                        const error = asError(reason);\n                                        console.error(error);\n                                    });\n                            }\n                        }\n                    }\n                }\n            },\n            onRequestComplete: (result, message) => {\n                if (!result) {\n                    console.error(message);\n                }\n            }\n        });\n    }\n}\n\n/**\n * Registers a thumbnail update callback that triggers on the node's first render.\n * When triggered, finds the last draw instance and requests a screenshot for it.\n *\n * @param ctx - Command tree context\n * @param node - Node to register thumbnail update for\n * @param descriptionContext - Description for the requester debug name (e.g., \"render pass 5\", \"dynamic render pass\")\n */\nfunction registerThumbnailUpdate(\n    ctx: CommandTreeContext,\n    node: CommandTreeNode & { thumbnail?: string },\n    descriptionContext: string\n): void {\n    const updateThumbnail = (): void => {\n        const lastDraw = findLastDrawInstanceNode(node);\n        if (lastDraw) {\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', updateThumbnail);\n            const requesterDbgName = `Command tree ${descriptionContext} last draw: ${lastDraw.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(lastDraw), node, requesterDbgName);\n        }\n    };\n    SokatoaLifecycleTreeNode.register(node, 'onWillRender', updateThumbnail);\n}\n\nexport interface CommandRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    renderPassInstanceId: number;\n    renderPassId?: number;\n    renderSubpassEventIds: number[];\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderPassInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.instanceId,\n            renderPassId: element.renderPass,\n            renderSubpassEventIds: [],\n            label: `Render Pass ${element.passIndex}`,\n            parent,\n            resourceType: CommandRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        // A render pass will only contain render subpasses and will always contain at least one subpass\n        const renderSubpassInstances = element.renderSubpassInstanceIds.flatMap(id => {\n            const instance = root.resource.renderSubpassInstances[id];\n            if (!instance) {\n                console.warn(`CommandRenderPassInstanceNode.create: renderSubpassInstance not found for id ${id}`);\n                return [];\n            }\n            return instance;\n        });\n        renderSubpassInstances.forEach(subpass => {\n            if (subpass.beginApiEvent !== node.resource.beginApiEvent) {\n                node.renderSubpassEventIds.push(subpass.beginApiEvent);\n            }\n        });\n        node.children.push(\n            ...renderSubpassInstances.map(instance => {\n                const subpassNode = CommandRenderSubpassInstanceNode.create(ctx, instance, node, baseDynamicStatePromise);\n                return subpassNode;\n            })\n        );\n\n        registerThumbnailUpdate(ctx, node, `render pass ${node.renderPassId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandRenderSubpassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderSubpassInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    renderPassInstanceId: number;\n    renderSubpassInstanceId: number;\n    renderSubpassIndex: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderSubpassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderSubpassInstanceNode {\n    export const RESOURCE_TYPE = 'render-subpass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderSubpassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderSubpassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderSubpassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderSubpassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderSubpassInstanceNode {\n        const node: CommandRenderSubpassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.renderPassInstance,\n            renderSubpassInstanceId: element.instanceId,\n            renderSubpassIndex: element.subpassIndex,\n            label: `Subpass ${element.subpassIndex}`,\n            parent,\n            resourceType: CommandRenderSubpassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this render subpass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference render subpass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a render subpass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.renderSubpassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginRenderSubpassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endRenderSubpassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this render subpass\n        const debugLabelGroupInstances = {\n            array: element.debugLabelGroupInstanceIds.flatMap(id => {\n                const result = root.resource.debugLabelGroupInstances[id];\n                if (!result) {\n                    console.warn(`Missing debugLabelGroupInstances for ${id}.`);\n                    return [];\n                }\n                return result;\n            }),\n            getSortNumber: (debugLabelGroupInstance: CommandTreeDebugLabelGroupInstance) => debugLabelGroupInstance.beginApiEvent\n        };\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'render subpass');\n\n        return node;\n    }\n}\n\nexport interface CommandDynamicRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeDynamicRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    dynamicRenderPassInstanceId: number;\n    dynamicRenderPassId?: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDynamicRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'dynamic-render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDynamicRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDynamicRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDynamicRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDynamicRenderPassInstanceNode {\n        const node: CommandDynamicRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dynamicRenderPassInstanceId: element.instanceId,\n            label: `Dynamic Render Pass ${element.dynamicPassIndex}`,\n            parent,\n            resourceType: CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this dynamic render pass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this dynamic render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference dynamic render pass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a dynamic render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.dynamicRenderPassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginDynamicRenderPassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endDynamicRenderPassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this dynamic render pass\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDynamicRenderPassInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'dynamic render pass');\n\n        return node;\n    }\n}\n\nasync function createChildEventNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    stateTracker: DynamicStateTracker\n): Promise<number> {\n    let endCommandIndex = commandIndex;\n    const baseDynamicStatePromise = stateTracker.getCurrentState();\n\n    if (command.secondaryCommandBufferExecutionId) {\n        // Look up the execution to get the apiEvent, which is the key for secondaryCommandBufferInstances\n        const execution = root.resource.secondaryCommandBufferExecutions[command.secondaryCommandBufferExecutionId];\n        if (execution) {\n            const secondaryInstances = root.resource.secondaryCommandBufferInstances[execution.apiEvent];\n            if (secondaryInstances && secondaryInstances.length > 0) {\n                const node = await CommandSecondaryCommandBufferExecutionNode.create(\n                    ctx,\n                    secondaryInstances,\n                    parentNode,\n                    endCommandIndex++,\n                    baseDynamicStatePromise,\n                    stateTracker\n                );\n                parentNode.children.push(node);\n            }\n        }\n    } else {\n        endCommandIndex = createDrawOrDispatchChildNode(ctx, command, root, parentNode, commandIndex, baseDynamicStatePromise);\n    }\n    return endCommandIndex;\n}\n\nfunction createDrawOrDispatchChildNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n): number {\n    let currentCommandIndex = commandIndex;\n    let accelerationStructureBuildIndex = 0;\n    let accelerationStructureCopyIndex = 0;\n    if (command) {\n        if (command.drawInstanceId && root.resource.drawInstances[command.drawInstanceId]) {\n            parentNode.children.push(\n                CommandDrawInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.dispatchInstanceId && root.resource.dispatchInstances[command.dispatchInstanceId]) {\n            parentNode.children.push(\n                CommandDispatchInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.meshTaskInstanceId && root.resource.meshTaskInstances[command.meshTaskInstanceId]) {\n            parentNode.children.push(\n                CommandMeshTaskInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.clusterInstanceId && root.resource.clusterInstances[command.clusterInstanceId]) {\n            parentNode.children.push(\n                CommandClusterInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.raytracingInstanceId && root.resource.raytracingInstances[command.raytracingInstanceId]) {\n            parentNode.children.push(\n                CommandRaytracingInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (\n            command.accelerationStructureBuildInstanceId &&\n            root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureBuildNode.create(\n                    root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]!,\n                    parentNode,\n                    accelerationStructureBuildIndex++\n                )\n            );\n        } else if (\n            command.accelerationStructureCopyInstanceId &&\n            root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureCopyNode.create(\n                    root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]!,\n                    parentNode,\n                    accelerationStructureCopyIndex++\n                )\n            );\n        } else if (command.transferCommandInstanceId && root.resource.transferCommands[command.transferCommandInstanceId]) {\n            parentNode.children.push(\n                CommandTransferCommandNode.create(\n                    root.resource.transferCommands[command.transferCommandInstanceId]!,\n                    parentNode,\n                    currentCommandIndex++\n                )\n            );\n        } else if (command.debugLabelId && root.resource.debugLabels[command.debugLabelId]) {\n            // Only add debug label nodes if this is the BEGIN event (not END event)\n            // The END event has debugLabelId set but should not create a node\n            const debugLabel = root.resource.debugLabels[command.debugLabelId];\n            if (debugLabel && debugLabel.beginApiEvent === command.apiEventId) {\n                // Check if this is a group (has both begin and end and they differ) or just an insert\n                if (debugLabel.endApiEvent && debugLabel.beginApiEvent !== debugLabel.endApiEvent) {\n                    // This is a debug label group - it should be handled by the range processing logic\n                    // Don't create any node here, just skip it\n                    // (The group will be created if it's in debugLabelGroupInstances, or omitted if it crosses boundaries)\n                } else {\n                    // This is a debug label insert - create as simple API event node\n                    parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode));\n                }\n            }\n        } else if (command.commandInstanceId && root.resource.commandInstances[command.commandInstanceId]) {\n            parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode, currentCommandIndex++));\n        }\n    }\n    return currentCommandIndex;\n}\n\nexport interface CommandDrawInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    drawInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDrawInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandDrawInstanceNode {\n    export const RESOURCE_TYPE = 'draw-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDrawInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDrawInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_draw_${element.drawInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDrawInstanceNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDrawInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            drawInstanceId: element.drawInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDrawInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query draw instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n            const requesterDbgName = `Command draw instance ${node.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(node), node, requesterDbgName);\n        });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDrawInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const drawInstanceDynamicStatePromise = batchQuery\n                ? queryDrawInstanceDynamicStateBatched(db, [node.resource.drawInstanceId || 0])\n                : queryDrawInstanceDynamicState(db, [node.resource.drawInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                drawInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.GRAPHICS\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandDispatchInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    dispatchInstanceId: number;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandDispatchInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n    thumbnail?: string;\n}\n\nexport namespace CommandDispatchInstanceNode {\n    export const RESOURCE_TYPE = 'dispatch-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDispatchInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDispatchInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_dispatch_${element.dispatchInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDispatchInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandDispatchInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dispatchInstanceId: element.dispatchInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDispatchInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query dispatch instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for dispatch nodes\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command dispatch instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDispatchInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const dispatchInstanceDynamicStatePromise = batchQuery\n                ? queryDispatchInstanceDynamicStateBatched(db, [node.resource.dispatchInstanceId || 0])\n                : queryDispatchInstanceDynamicState(db, [node.resource.dispatchInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                dispatchInstanceDynamicStatePromise,\n                PipelineBindPoint.COMPUTE,\n                PipelineBindPointShaderStageFlags.COMPUTE\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandMeshTaskInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    meshTaskInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandMeshTaskInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandMeshTaskInstanceNode {\n    export const RESOURCE_TYPE = 'mesh-task-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandMeshTaskInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandMeshTaskInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_meshtask_${element.meshTaskInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandMeshTaskInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandMeshTaskInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            meshTaskInstanceId: element.meshTaskInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandMeshTaskInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query mesh instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for mesh task dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command mesh instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandMeshTaskInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const meshTaskInstanceDynamicStatePromise = batchQuery\n                ? queryMeshTaskInstanceDynamicStateBatched(db, [node.resource.meshTaskInstanceId || 0])\n                : queryMeshTaskInstanceDynamicState(db, [node.resource.meshTaskInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                meshTaskInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.TASK_MESH\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandClusterInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    clusterInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandClusterInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandClusterInstanceNode {\n    export const RESOURCE_TYPE = 'cluster-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandClusterInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandClusterInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_cluster_${element.clusterInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandClusterInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandClusterInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            clusterInstanceId: element.clusterInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandClusterInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query cluster instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for cluster dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command cluster instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandClusterInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const clusterInstanceDynamicStatePromise = batchQuery\n                ? queryClusterInstanceDynamicStateBatched(db, [node.resource.clusterInstanceId || 0])\n                : queryClusterInstanceDynamicState(db, [node.resource.clusterInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                clusterInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.CLUSTER\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandRaytracingInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    raytracingInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandRaytracingInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandRaytracingInstanceNode {\n    export const RESOURCE_TYPE = 'raytracing-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandRaytracingInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRaytracingInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_raytracing_${element.raytracingInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRaytracingInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRaytracingInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            raytracingInstanceId: element.raytracingInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandRaytracingInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query raytracing instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for raytracing dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command raytracing instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandRaytracingInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const raytracingInstanceDynamicStatePromise = batchQuery\n                ? queryRaytracingInstanceDynamicStateBatched(db, [node.resource.raytracingInstanceId || 0])\n                : queryRaytracingInstanceDynamicState(db, [node.resource.raytracingInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                raytracingInstanceDynamicStatePromise,\n                PipelineBindPoint.RAY_TRACING,\n                PipelineBindPointShaderStageFlags.RAY_TRACING\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport function getQueueSubmitId(node: CommandTreeNode): number | undefined {\n    let currentNode: CompositeTreeNode | undefined;\n    if (\n        CommandEmptyNode.is(node) ||\n        CommandApiEventNode.is(node) ||\n        CommandTreeDrawOrDispatchNode.is(node) ||\n        CommandAccelerationStructureBuildNode.is(node) ||\n        CommandAccelerationStructureCopyNode.is(node) ||\n        CommandTransferCommandNode.is(node)\n    ) {\n        currentNode = node.parent;\n    } else if (CommandQueuePresentNode.is(node) || CommandQueueDebugLabelNode.is(node)) {\n        return undefined;\n    } else {\n        currentNode = node;\n    }\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(currentNode, CommandQueueSubmitNode.is);\n    return queueSubmitNode ? queueSubmitNode.resource.submissionId : undefined;\n}\n\nexport function findLastDrawInstanceNode(node: CommandTreeNode): CommandDrawInstanceNode | undefined {\n    if (CommandDrawInstanceNode.is(node)) {\n        return node;\n    }\n    let lastDraw: CommandDrawInstanceNode | undefined;\n    if (!CommandDrawInstanceNode.is(node) && ExpandableTreeNode.is(node)) {\n        for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n            lastDraw = findLastDrawInstanceNode(node.children[commandIndex]);\n            if (lastDraw) {\n                break;\n            }\n        }\n    }\n    return lastDraw;\n}\n\nexport function createExecuteCommandsApiResources(\n    node: CommandSecondaryCommandBufferExecutionNode,\n    primaryNode: CommandCommandBufferInstanceNode,\n    queueSubmitNode: CommandQueueSubmitNode,\n    specificSecondaryCommandBufferBeginId?: number // If provided, only include this specific secondary CB\n): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    // findParentNode checks the given node for its type so we have to start looking from this node's parent\n    // otherwise we run into infinite recursion\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node.parent,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n\n    // Collect secondary command buffer begin IDs from the children\n    const commandBufferBeginIds: number[] = [];\n    if (specificSecondaryCommandBufferBeginId !== undefined) {\n        // Only include the specific secondary CB that was requested\n        commandBufferBeginIds.push(specificSecondaryCommandBufferBeginId);\n    } else {\n        // Include all secondary CBs (for when the execution node itself requests a thumbnail)\n        for (const child of node.children) {\n            if (CommandCommandBufferInstanceNode.is(child)) {\n                commandBufferBeginIds.push(child.resource.beginApiEvent);\n            }\n        }\n    }\n\n    const resources: ApiResources[] = [];\n    if (secondaryCommandBufferExecutionNode) {\n        const renderpassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n            renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n            CommandSecondaryCommandBufferExecutionNode.is\n        );\n\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: secondaryCommandBufferExecutionNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n                renderpassSecondaryCommandBufferExecutionNode &&\n                renderpassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n        const executionResources = createExecuteCommandsApiResources(secondaryCommandBufferExecutionNode, primaryNode, queueSubmitNode);\n        if (executionResources.length > 0) {\n            resources.push(...executionResources);\n        }\n    } else {\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: primaryNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                renderPassInstanceNode || dynamicRenderPassInstanceNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n    }\n    return resources;\n}\n\nexport function createDrawApiResources(node: CommandDrawInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    // This will find the immediate parent command buffer (secondary if in a secondary CB, primary otherwise)\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n\n    const resources: ApiResources[] = [];\n    if (\n        (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n        queueSubmitNode &&\n        commandBufferInstanceNode &&\n        primaryCommandBufferInstanceNode\n    ) {\n        if (secondaryCommandBufferExecutionNode) {\n            const renderPassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n                CommandSecondaryCommandBufferExecutionNode.is\n            );\n\n            // Add draw resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses:\n                    renderPassSecondaryCommandBufferExecutionNode &&\n                    renderPassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                        ? [\n                              {\n                                  beginId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                                  subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                                  endId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                        dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                              }\n                          ]\n                        : []\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses: [\n                    {\n                        beginId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                        subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                        endId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.endApiEvent || dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                    }\n                ]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createComputeApiResources(node: CommandDispatchInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add dispatch resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createTraceRaysApiResources(node: CommandRaytracingInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTransferNode = CommandAccelerationStructureBuildNode | CommandAccelerationStructureCopyNode | CommandTransferCommandNode;\n\nexport function createTransferApiResources(node: CommandTransferNode): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    let transferEvent: number = 0;\n    if (CommandAccelerationStructureBuildNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureBuildNode).resource.buildApiEvent;\n    } else if (CommandAccelerationStructureCopyNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureCopyNode).resource.copyApiEvent;\n    } else if (CommandTransferCommandNode.is(node)) {\n        transferEvent = (node as CommandTransferCommandNode).resource.transferApiEvent;\n    }\n\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTreeNode =\n    | CommandFrameNode\n    | CommandEmptyNode\n    | CommandApiEventNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandQueuePresentNode\n    | CommandQueueDebugLabelGroupNode\n    | CommandQueueDebugLabelNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandEmptyNode.is(node) ||\n            CommandApiEventNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandQueuePresentNode.is(node) ||\n            CommandQueueDebugLabelGroupNode.is(node) ||\n            CommandQueueDebugLabelNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n\n    export function findApiEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandSecondaryCommandBufferExecutionNode.is(current)) {\n            // For secondary command buffer execution nodes, return the VkCmdExecuteCommands apiEvent\n            // rather than the VkCommandBufferBegin apiEvent\n            return current.resource.apiEvent;\n        } else if (CommandTreeRangeNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (\n            CommandApiEventNode.is(current) ||\n            CommandQueueSubmitNode.is(current) ||\n            CommandQueuePresentNode.is(current) ||\n            CommandQueueDebugLabelNode.is(current)\n        ) {\n            return current.apiEventId;\n        } else if (CommandQueueDebugLabelGroupNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (CommandAccelerationStructureBuildNode.is(current)) {\n            return current.resource.buildApiEvent;\n        } else if (CommandAccelerationStructureCopyNode.is(current)) {\n            return current.resource.copyApiEvent;\n        } else if (CommandTransferCommandNode.is(current)) {\n            return current.apiEventId;\n        } else if (CommandTreeDrawOrDispatchNode.is(current)) {\n            return current.resource.apiEventId;\n        }\n        return undefined;\n    }\n\n    export function findFilterEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandFrameNode.is(current)) {\n            return current.resource.beginApiEvent;\n        }\n        let maybeQueueSubmitOrPresent: TreeNode | undefined = current;\n        while (\n            maybeQueueSubmitOrPresent !== undefined &&\n            !(\n                CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueuePresentNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)\n            )\n        ) {\n            maybeQueueSubmitOrPresent = maybeQueueSubmitOrPresent.parent;\n        }\n        let queueSubmitEventId: number | undefined;\n        if (maybeQueueSubmitOrPresent !== undefined) {\n            if (CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) || CommandQueuePresentNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            } else if (CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.resource.beginApiEvent;\n            } else if (CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            }\n        }\n        return queueSubmitEventId;\n    }\n\n    export function findRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const renderPassNode = findParentNode<CommandRenderPassInstanceNode>(current, CommandRenderPassInstanceNode.is);\n        return renderPassNode ? renderPassNode.renderPassInstanceId : undefined;\n    }\n\n    export function findDynamicRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const dynamicRenderPassNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n            current,\n            CommandDynamicRenderPassInstanceNode.is\n        );\n        return dynamicRenderPassNode ? dynamicRenderPassNode.dynamicRenderPassInstanceId : undefined;\n    }\n\n    export function findDrawInstanceId(current?: CommandTreeNode): number | undefined {\n        const drawInstanceNode = findParentNode<CommandDrawInstanceNode>(current, CommandDrawInstanceNode.is);\n        return drawInstanceNode ? drawInstanceNode.drawInstanceId : undefined;\n    }\n\n    export function findDispatchInstanceId(current?: CommandTreeNode): number | undefined {\n        const dispatchInstanceNode = findParentNode<CommandDispatchInstanceNode>(current, CommandDispatchInstanceNode.is);\n        return dispatchInstanceNode ? dispatchInstanceNode.dispatchInstanceId : undefined;\n    }\n\n    export function findMeshTaskInstanceId(current?: CommandTreeNode): number | undefined {\n        const meshTaskInstanceNode = findParentNode<CommandMeshTaskInstanceNode>(current, CommandMeshTaskInstanceNode.is);\n        return meshTaskInstanceNode ? meshTaskInstanceNode.meshTaskInstanceId : undefined;\n    }\n\n    export function findClusterInstanceId(current?: CommandTreeNode): number | undefined {\n        const clusterInstanceNode = findParentNode<CommandClusterInstanceNode>(current, CommandClusterInstanceNode.is);\n        return clusterInstanceNode ? clusterInstanceNode.clusterInstanceId : undefined;\n    }\n\n    export function findRaytracingInstanceId(current?: CommandTreeNode): number | undefined {\n        const raytracingInstanceNode = findParentNode<CommandRaytracingInstanceNode>(current, CommandRaytracingInstanceNode.is);\n        return raytracingInstanceNode ? raytracingInstanceNode.raytracingInstanceId : undefined;\n    }\n\n    export function findAccelerationBuildInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelBuildNode = findParentNode<CommandAccelerationStructureBuildNode>(current, CommandAccelerationStructureBuildNode.is);\n        return accelBuildNode ? accelBuildNode.buildInstanceId : undefined;\n    }\n\n    export function findAccelerationCopyInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelCopyNode = findParentNode<CommandAccelerationStructureCopyNode>(current, CommandAccelerationStructureCopyNode.is);\n        return accelCopyNode ? accelCopyNode.copyInstanceId : undefined;\n    }\n\n    export function findTransferCommandInstanceId(current?: CommandTreeNode): number | undefined {\n        const transferCommandNode = findParentNode<CommandTransferCommandNode>(current, CommandTransferCommandNode.is);\n        return transferCommandNode ? transferCommandNode.transferCommandInstanceId : undefined;\n    }\n\n    export function findMergedDynamicStatePromise(\n        current: CommandTreeNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> | undefined {\n        let maybeDrawOrDispatchInstance: TreeNode | undefined = current;\n        while (maybeDrawOrDispatchInstance !== undefined && !CommandTreeDrawOrDispatchNode.is(maybeDrawOrDispatchInstance)) {\n            maybeDrawOrDispatchInstance = maybeDrawOrDispatchInstance.parent;\n        }\n        let mergedDynamicStatePromise: Promise<DynamicStateEntry[]> | undefined;\n        if (maybeDrawOrDispatchInstance !== undefined && CommandDrawInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDrawInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandDispatchInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDispatchInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandMeshTaskInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandMeshTaskInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandClusterInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandClusterInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandRaytracingInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandRaytracingInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        }\n        return mergedDynamicStatePromise;\n    }\n\n    export function getRoot(node?: CompositeTreeNode | CommandRootNode | CommandTreeNode): CommandRootNode | undefined {\n        return findParentNode<CommandRootNode>(node, CommandRootNode.is);\n    }\n\n    export function getDbId(node: CommandRootNode | CommandTreeNode): number {\n        return getRoot(node)?.dbId ?? -1;\n    }\n\n    type GeneralizableNodes =\n        | typeof CommandApiEventNode\n        | typeof CommandClusterInstanceNode\n        | typeof CommandCommandBufferInstanceNode\n        | typeof CommandDispatchInstanceNode\n        | typeof CommandDrawInstanceNode\n        | typeof CommandEmptyNode\n        | typeof CommandFrameNode\n        | typeof CommandMeshTaskInstanceNode\n        | typeof CommandQueuePresentNode\n        | typeof CommandQueueSubmitNode\n        | typeof CommandQueueDebugLabelGroupNode\n        | typeof CommandQueueDebugLabelNode\n        | typeof CommandAccelerationStructureBuildNode\n        | typeof CommandAccelerationStructureCopyNode\n        | typeof CommandTransferCommandNode\n        | typeof CommandRaytracingInstanceNode\n        | typeof CommandRenderPassInstanceNode\n        | typeof CommandRenderSubpassInstanceNode\n        | typeof CommandDynamicRenderPassInstanceNode\n        | typeof CommandDebugLabelGroupNode;\n\n    /**\n     * An aggregate type label for command-tree nodes, roughly corresponding to some of the union\n     * types defined in this module.\n     */\n    export type GeneralizedType = GeneralizableNodes['GENERALIZED_TYPE'];\n\n    /**\n     * Query the generalized type of a given node, if it is a Command Tree node.\n     *\n     * @param node a tree node that may or may not be a `CommandTreeNode`\n     * @return its generalized type, or `undefined` if it isn't a `CommandTreeNode`\n     */\n    export function getGeneralizedNodeType(node: TreeNode): GeneralizedType | undefined {\n        const resourceType = 'resourceType' in node ? node.resourceType : undefined;\n        if (!resourceType) {\n            return CommandEmptyNode.is(node) ? 'empty' : undefined;\n        }\n\n        switch (resourceType) {\n            case 'frame':\n            case 'command-buffer-instance':\n            case 'render-pass-instance':\n            case 'render-subpass-instance':\n            case 'secondary-command-buffer-execution':\n            case 'debug-label-group':\n                return 'range';\n            case 'queue-submit':\n            case 'queue-present':\n                return 'queue';\n            case 'acceleration-structure-build':\n                return 'acceleration-structure-build';\n            case 'acceleration-structure-copy':\n                return 'acceleration-structure-copy';\n            case 'transfer-command':\n                return 'transfer-command';\n            case 'draw-instance':\n            case 'dispatch-instance':\n            case 'mesh-task-instance':\n            case 'cluster-instance':\n            case 'raytracing-instance':\n                return 'draw-or-dispatch';\n            case 'api-event':\n                return 'api-event';\n            default:\n                return undefined;\n        }\n    }\n\n    /** Type assertion for a range-type node. */\n    export function generalize(node: TreeNode, type: 'range'): asserts node is CommandTreeRangeNode;\n    /** Type assertion for a queue-type node. */\n    export function generalize(node: TreeNode, type: 'queue'): asserts node is CommandQueueSubmitNode | CommandQueuePresentNode;\n    /** Type assertion for a queue-debug-label-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'queue-debug-label'\n    ): asserts node is CommandQueueDebugLabelGroupNode | CommandQueueDebugLabelNode;\n    /** Type assertion for a acceleration-structure-build-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-build'): asserts node is CommandAccelerationStructureBuildNode;\n    /** Type assertion for a acceleration-structure-copy-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-copy'): asserts node is CommandAccelerationStructureCopyNode;\n    /** Type assertion for a transfer-command-type node. */\n    export function generalize(node: TreeNode, type: 'transfer-command'): asserts node is CommandTransferCommandNode;\n    /** Type assertion for a draw-or-dispatch-type node. */\n    export function generalize(node: TreeNode, type: 'draw-or-dispatch'): asserts node is CommandTreeDrawOrDispatchNode;\n    /** Type assertion for an api-event-type node. */\n    export function generalize(node: TreeNode, type: 'api-event'): asserts node is CommandApiEventNode;\n    /** Type assertion for a draw-or-dispatch- or api-event-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'draw-or-dispatch' | 'api-event'\n    ): asserts node is CommandTreeDrawOrDispatchNode | CommandApiEventNode;\n    /** Type assertion for an empty-type node. */\n    export function generalize(node: TreeNode, type: 'empty'): asserts node is CommandEmptyNode;\n    export function generalize(node: TreeNode, _type: GeneralizedType): asserts node is CommandTreeNode {\n        // Pass\n    }\n}\n\nexport type CommandTreeRangeNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeRangeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeRangeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n}\n\nexport type CommandTreeDrawOrDispatchNode =\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode;\n\nexport namespace CommandTreeDrawOrDispatchNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeDrawOrDispatchNode {\n        return (\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node)\n        );\n    }\n}\n\ninterface ArrayWithSortNumber<RangeType> {\n    array: RangeType[];\n    getSortNumber(element: RangeType): number;\n}\n\ntype AllRangeTypes =\n    | CommandTreeDebugLabelGroupInstance\n    | CommandTreeRenderPassInstance\n    | CommandTreeRenderSubpassInstance\n    | CommandTreeDynamicRenderPassInstance;\n\ntype CommandTreeRangeParentNode =\n    | CommandRenderPassInstanceNode\n    | CommandCommandBufferInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandDebugLabelGroupNode;\n\nfunction findNextRangeElementToProcess<RangeType>(...arrays: ArrayWithSortNumber<RangeType>[]): RangeType | undefined {\n    // designate which array is the api event array vs a range array\n    // when processing a range, shift off any api events that are within the range\n    // so they aren't processed (because they actually reside within a sub-group)\n\n    const arraysToProcess: ArrayWithSortNumber<RangeType>[] = [];\n    arrays.forEach(arr => {\n        if (arr.array.length) {\n            arraysToProcess.push(arr);\n        }\n    });\n\n    if (!arraysToProcess.length) {\n        return undefined;\n    }\n\n    // get the sort number of the first element of each array and sort them\n    const sortedElements = arraysToProcess\n        .map(array => ({ subarray: array.array, sortNumber: array.getSortNumber(array.array[0]) }))\n        .sort((a, b) => a.sortNumber - b.sortNumber);\n\n    return sortedElements[0].subarray.shift();\n}\n\n/**\n * Process commands and ranges together in API event order.\n * For each range element, creates child nodes for commands that come before it,\n * skips commands that fall within the range, and creates a node for the range itself.\n * After processing all ranges, any remaining commands are processed.\n *\n * @param ctx - Command tree context\n * @param root - Root node\n * @param parentNode - Parent node to add children to\n * @param apiEventCommandArray - Array of commands sorted by API event ID (will be mutated)\n * @param childCommandIndex - Starting index for child commands\n * @param baseDynamicStatePromise - Promise for dynamic state\n * @param createRangeNode - Callback to create a node for each range element\n * @param rangeArrays - Variable number of range arrays to process together\n * @returns The final child command index\n */\nasync function createChildEventNodesForRange<RangeType extends { beginApiEvent: number; endApiEvent?: number }>(\n    ctx: CommandTreeContext,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    apiEventCommandArray: CommandTreeApiEvent[],\n    childCommandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n    createRangeNode: (rangeElement: RangeType, parentNode: CommandTreeRangeParentNode) => void,\n    ...rangeArrays: ArrayWithSortNumber<RangeType>[]\n): Promise<number> {\n    const stateTracker = new DynamicStateTracker(baseDynamicStatePromise);\n    let nextRangeElement: RangeType | undefined;\n    let priorRangeEndApiEvent: number | undefined;\n\n    while ((nextRangeElement = findNextRangeElementToProcess<RangeType>(...rangeArrays))) {\n        // create a node for any command that comes BEFORE the next range element\n        while (apiEventCommandArray.length && apiEventCommandArray[0].apiEventId < nextRangeElement.beginApiEvent) {\n            const command = apiEventCommandArray.shift();\n            childCommandIndex = await createChildEventNode(ctx, command!, root, parentNode, childCommandIndex, stateTracker);\n        }\n\n        // shift off any command that falls WITHIN next range since it will be processed when creating next range node\n        while (\n            apiEventCommandArray.length &&\n            nextRangeElement.endApiEvent !== undefined &&\n            apiEventCommandArray[0].apiEventId >= nextRangeElement.beginApiEvent &&\n            apiEventCommandArray[0].apiEventId <= nextRangeElement.endApiEvent\n        ) {\n            apiEventCommandArray.shift();\n        }\n\n        // skip next range if it falls within the prior range since it will be processed when creating prior range node\n        if (\n            priorRangeEndApiEvent !== undefined &&\n            nextRangeElement.endApiEvent !== undefined &&\n            nextRangeElement.endApiEvent <= priorRangeEndApiEvent\n        ) {\n            continue;\n        }\n        priorRangeEndApiEvent = nextRangeElement.endApiEvent;\n\n        // create a node for the next range element\n        createRangeNode(nextRangeElement, parentNode);\n    }\n\n    // process any remaining command elements after all range elements have been processed\n    for (const command of apiEventCommandArray) {\n        childCommandIndex = await createChildEventNode(ctx, command, root, parentNode, childCommandIndex, stateTracker);\n    }\n\n    return childCommandIndex;\n}\n\n/**\n * Find node from descendent node for which isNode is true\n */\nexport const findParentNode = <T extends TreeNode>(\n    node: TreeNode | undefined,\n    isNode: (node: TreeNode | undefined) => node is T\n): T | undefined => {\n    let targetNode: TreeNode | undefined = node;\n    while (targetNode && targetNode.parent && !isNode(targetNode)) {\n        targetNode = targetNode.parent;\n    }\n\n    return targetNode && isNode(targetNode) ? targetNode : undefined;\n};\n\n/**\n * Find the primary command buffer instance node from a given command buffer instance node.\n * If the given node is in a secondary command buffer, traverses up through nested secondary\n * command buffers until finding the primary command buffer (one with no parent execution node).\n * If the given node is already in a primary command buffer, returns it as-is.\n */\nexport const findPrimaryCommandBufferInstanceNode = (\n    commandBufferInstanceNode: CommandCommandBufferInstanceNode | undefined,\n    secondaryCommandBufferExecutionNode: CommandSecondaryCommandBufferExecutionNode | undefined\n): CommandCommandBufferInstanceNode | undefined => {\n    let primaryCommandBufferInstanceNode = commandBufferInstanceNode;\n    if (secondaryCommandBufferExecutionNode) {\n        let currentExecution: CommandSecondaryCommandBufferExecutionNode | undefined = secondaryCommandBufferExecutionNode;\n        while (currentExecution) {\n            const parentCB: CommandCommandBufferInstanceNode | undefined = findParentNode<CommandCommandBufferInstanceNode>(\n                currentExecution,\n                CommandCommandBufferInstanceNode.is\n            );\n            if (parentCB) {\n                primaryCommandBufferInstanceNode = parentCB;\n                // Check if this CB is also inside another secondary execution (nested case)\n                currentExecution = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                    parentCB.parent,\n                    CommandSecondaryCommandBufferExecutionNode.is\n                );\n            } else {\n                break;\n            }\n        }\n    }\n    return primaryCommandBufferInstanceNode;\n};\n\n/**\n * find a frame node from descendent node or self\n */\nexport const findFrameNode = (node: TreeNode): CommandFrameNode | undefined => findParentNode<CommandFrameNode>(node, CommandFrameNode.is);\n\n@injectable()\nexport class CommandTree extends BulkTree implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTree {\n        return tree instanceof CommandTree;\n    }\n\n    @inject(CaptureDatasetWidgetProfile)\n    protected readonly profile: CaptureDatasetWidgetProfile;\n    @inject(CaptureDatasetWidgetContext)\n    protected readonly context: CaptureDatasetWidgetContext;\n\n    @inject(CommandTreeDataQueriedRootProvider)\n    protected readonly rootProvider: CommandTreeDataQueriedRootProvider;\n    @inject(GFXRQueryBuilderService)\n    protected readonly gfxrQueryBuilderService: GFXRQueryBuilderService;\n\n    protected override _root: CommandRootNode | undefined;\n\n    // Back-reference to the model that manages this tree\n    model?: CommandTreeModel;\n\n    protected readonly onStructureChangedEmitter = new Emitter<TreeNode | undefined>();\n    readonly onStructureChanged = this.onStructureChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this._root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        super.root = root;\n        // Set back-reference from root to tree\n        if (root) {\n            root.tree = this;\n        }\n    }\n\n    async initTree(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        this.root = await this.rootProvider.provide(dbId, { tree: this }, options, createDrawOrDispatchChildren);\n\n        // tree structure is fully built at this point, report structure change\n        this.onStructureChangedEmitter.fire(undefined);\n    }\n\n    async refreshStructure(node?: CompositeTreeNode, cancellationToken?: CancellationToken): Promise<void> {\n        await this.refresh(node, cancellationToken);\n        this.fireStructureChanged(node);\n    }\n\n    fireStructureChanged(node?: TreeNode): void {\n        this.onStructureChangedEmitter.fire(node);\n    }\n\n    addToDispose(disposable: Disposable): void {\n        this.toDispose.push(disposable);\n    }\n\n    override dispose(): void {\n        this.rootProvider.dispose();\n        super.dispose();\n    }\n}\n\n@injectable()\nexport class CommandTreeModelPreferenceStateAccessImpl implements CommandTreePreferenceState.Access {\n    private readonly models = new Map<CommandTree, CommandTreeModel>();\n\n    private readonly commandTreeStateChangedEmitter = new Emitter<{ tree: CommandTree; state: CommandTreePreferenceState }>();\n    readonly onCommandTreeStateChanged = this.commandTreeStateChangedEmitter.event;\n\n    getCommandTreeState(tree: CommandTree): CommandTreePreferenceState {\n        return this.models.get(tree)?.getPreferenceState() ?? {};\n    }\n\n    fireCommandTreeStateChanged(tree: CommandTree): void {\n        this.commandTreeStateChangedEmitter.fire({ tree, state: this.getCommandTreeState(tree) });\n    }\n\n    registerCommandTreeModel(tree: CommandTree, model: CommandTreeModel): void {\n        this.models.set(tree, model);\n        this.fireCommandTreeStateChanged(tree);\n    }\n}\n\n@injectable()\nexport class CommandTreeModel extends BulkTreeModel implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTreeModel {\n        return tree instanceof CommandTreeModel;\n    }\n\n    @inject(MiscPreferences)\n    protected readonly miscPreferences: MiscPreferences;\n    @inject(CommandTree) override readonly tree: CommandTree;\n    protected _groupBy: GroupByOptions = GroupByOptions.Frame;\n    private groupByChangedEmitter = new Emitter<GroupByOptions>();\n    readonly onGroupByChanged = this.groupByChangedEmitter.event;\n    protected _isThumbnailEnabled = true;\n    protected _isApiEventIdsEnabled = true;\n    protected _isShowingEmptyRows = false;\n    protected _isVulkanEnabled = true;\n    protected _isDebugNamesEnabled = true;\n    protected _isDebugLabelsEnabled = true;\n    protected _isLinksEnabled = true;\n    protected _isThreadsEnabled = true;\n\n    @inject(FrameRangeSelectionService)\n    protected readonly frameRangeSelectionService: FrameRangeSelectionService;\n\n    @inject(CommandTreeModelPreferenceStateAccessImpl)\n    private readonly preferenceStateAccess: CommandTreeModelPreferenceStateAccessImpl;\n\n    protected isCollapsingSubTree = false;\n\n    // Proxies to prevent calls on sub tree expansion\n    protected readonly onExpansionChangedEmitterProxy = new Emitter<ExpandableTreeNode>();\n    protected readonly onChangedEmitterProxy = new Emitter<void>();\n\n    protected readonly onSubTreeExpansionChangedEmitter = new Emitter<ExpandableTreeNode>();\n    readonly onSubTreeExpansionChanged = this.onSubTreeExpansionChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this.tree.root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        this.tree.root = root;\n    }\n\n    override get onChanged(): Event<void> {\n        return this.onChangedEmitterProxy.event;\n    }\n\n    override get onExpansionChanged(): Event<ExpandableTreeNode> {\n        return this.onExpansionChangedEmitterProxy.event;\n    }\n\n    get onStructureChanged(): Event<TreeNode | undefined> {\n        return this.tree.onStructureChanged;\n    }\n\n    async initModel(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        await this.tree.initTree(dbId, createDrawOrDispatchChildren, options);\n    }\n\n    set groupBy(value: GroupByOptions) {\n        if (this._groupBy !== value) {\n            this._groupBy = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n            this.groupByChangedEmitter.fire(value);\n        }\n    }\n\n    get groupBy(): GroupByOptions {\n        return this._groupBy;\n    }\n\n    /**\n     * Obtain the tree nodes that are the top-level groups according to\n     * the current {@link groupBy} mode.\n     */\n    *groupNodes(): IterableIterator<CompositeTreeNode> {\n        if (!this.root) {\n            return;\n        }\n\n        const group = this.groupBy;\n        const treeIterator = new (class extends DepthFirstTreeIterator {\n            protected override children(node: TreeNode): TreeNode[] | undefined {\n                // Prune group nodes because we needn't look in them for more groups\n                return CommandTreeModel.isOfGroup(node, group) ? undefined : super.children(node);\n            }\n        })(this.root);\n\n        for (const next of treeIterator) {\n            if (CommandTreeModel.isOfGroup(next, group)) {\n                yield next;\n            }\n        }\n    }\n\n    set isApiEventIdsEnabled(value: boolean) {\n        if (this._isApiEventIdsEnabled !== value) {\n            this._isApiEventIdsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isApiEventIdsEnabled(): boolean {\n        return this._isApiEventIdsEnabled;\n    }\n\n    set isShowingEmptyRows(value: boolean) {\n        if (this._isShowingEmptyRows !== value) {\n            this._isShowingEmptyRows = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isShowingEmptyRows(): boolean {\n        return this._isShowingEmptyRows;\n    }\n\n    set isThumbnailEnabled(value: boolean) {\n        if (this._isThumbnailEnabled !== value) {\n            this._isThumbnailEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThumbnailEnabled(): boolean {\n        return this._isThumbnailEnabled;\n    }\n\n    set isVulkanEnabled(value: boolean) {\n        if (this._isVulkanEnabled !== value) {\n            this._isVulkanEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isVulkanEnabled(): boolean {\n        return this._isVulkanEnabled;\n    }\n\n    set isDebugNamesEnabled(value: boolean) {\n        if (this._isDebugNamesEnabled !== value) {\n            this._isDebugNamesEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugNamesEnabled(): boolean {\n        return this._isDebugNamesEnabled;\n    }\n\n    set isDebugLabelsEnabled(value: boolean) {\n        if (this._isDebugLabelsEnabled !== value) {\n            this._isDebugLabelsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugLabelsEnabled(): boolean {\n        return this._isDebugLabelsEnabled;\n    }\n\n    set isLinksEnabled(value: boolean) {\n        if (this._isLinksEnabled !== value) {\n            this._isLinksEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isLinksEnabled(): boolean {\n        return this._isLinksEnabled;\n    }\n\n    set isThreadsEnabled(value: boolean) {\n        if (this._isThreadsEnabled !== value) {\n            this._isThreadsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThreadsEnabled(): boolean {\n        return this._isThreadsEnabled;\n    }\n\n    getPreferenceState(nonDefaultOnly = false): CommandTreePreferenceState {\n        const result: CommandTreePreferenceState = {};\n\n        if (!nonDefaultOnly || this.groupBy !== this.miscPreferences[MiscPrefs.GroupBy]) {\n            result.groupBy = this.groupBy;\n        }\n        if (!nonDefaultOnly || this.isApiEventIdsEnabled !== this.miscPreferences[MiscPrefs.ShowApiEventIds]) {\n            result.isApiEventIdsEnabled = this.isApiEventIdsEnabled;\n        }\n        if (!nonDefaultOnly || this.isShowingEmptyRows !== this.miscPreferences[MiscPrefs.ShowEmptyRows]) {\n            result.isShowingEmptyRows = this.isShowingEmptyRows;\n        }\n        if (!nonDefaultOnly || this.isThumbnailEnabled !== this.miscPreferences[MiscPrefs.ShowThumbnails]) {\n            result.isThumbnailEnabled = this.isThumbnailEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugNamesEnabled !== true) {\n            result.isDebugNamesEnabled = this.isDebugNamesEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugLabelsEnabled !== true) {\n            result.isDebugLabelsEnabled = this.isDebugLabelsEnabled;\n        }\n        if (!nonDefaultOnly || this.isLinksEnabled !== true) {\n            result.isLinksEnabled = this.isLinksEnabled;\n        }\n        if (!nonDefaultOnly || this.isThreadsEnabled !== true) {\n            result.isThreadsEnabled = this.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (!nonDefaultOnly || this.isVulkanEnabled !== this.miscPreferences[MiscPrefs.ShowVulkanCalls]) {\n        //     result.isVulkanEnabled = this.isVulkanEnabled;\n        // }\n\n        return result;\n    }\n\n    override restoreState(state: CommandTreeModel.State): void {\n        if (state.groupBy !== undefined) {\n            this.groupBy = state.groupBy;\n        }\n        if (state.isApiEventIdsEnabled !== undefined) {\n            this.isApiEventIdsEnabled = state.isApiEventIdsEnabled;\n        }\n        if (state.isShowingEmptyRows !== undefined) {\n            this.isShowingEmptyRows = state.isShowingEmptyRows;\n        }\n        if (state.isThumbnailEnabled !== undefined) {\n            this.isThumbnailEnabled = state.isThumbnailEnabled;\n        }\n        if (state.isDebugNamesEnabled !== undefined) {\n            this.isDebugNamesEnabled = state.isDebugNamesEnabled;\n        }\n        if (state.isDebugLabelsEnabled !== undefined) {\n            this.isDebugLabelsEnabled = state.isDebugLabelsEnabled;\n        }\n        if (state.isLinksEnabled !== undefined) {\n            this.isLinksEnabled = state.isLinksEnabled;\n        }\n        if (state.isThreadsEnabled !== undefined) {\n            this.isThreadsEnabled = state.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (state.isVulkanEnabled !== undefined) {\n        //     this.isVulkanEnabled = state.isVulkanEnabled;\n        // }\n    }\n    override storeState(): CommandTreeModel.State {\n        return {\n            ...super.storeState(),\n            ...this.getPreferenceState(true)\n        };\n    }\n\n    @postConstruct()\n    protected override init(): void {\n        super.init();\n\n        // Set back-reference from tree to model\n        this.tree.model = this;\n\n        this.toDispose.pushAll([\n            this.onChangedEmitterProxy,\n            this.onExpansionChangedEmitterProxy,\n            this.onSubTreeExpansionChangedEmitter,\n\n            super.onChanged(() => {\n                if (!this.isCollapsingSubTree) {\n                    this.onChangedEmitterProxy.fire();\n                }\n            }),\n            super.onExpansionChanged(node => {\n                if (!this.isCollapsingSubTree) {\n                    this.onExpansionChangedEmitterProxy.fire(node);\n                }\n            })\n        ]);\n\n        this._isApiEventIdsEnabled = this.miscPreferences[MiscPrefs.ShowApiEventIds];\n        this._isShowingEmptyRows = this.miscPreferences[MiscPrefs.ShowEmptyRows];\n        this.isThumbnailEnabled = this.miscPreferences[MiscPrefs.ShowThumbnails];\n        this.groupBy = this.miscPreferences[MiscPrefs.GroupBy];\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // this.isVulkanEnabled = this.miscPreferences[MiscPrefs.ShowVulkanCalls];\n\n        this.preferenceStateAccess.registerCommandTreeModel(this.tree, this);\n    }\n\n    /**\n     * Collapses the entire tree.\n     */\n    async collapseTree(): Promise<void> {\n        const root = this.root;\n\n        if (CompositeTreeNode.is(root) && root.children.length > 0) {\n            await Promise.all(\n                root.children.filter(CompositeTreeNode.is).map((child: CompositeTreeNode) => this.expansionService.collapseAll(child))\n            );\n        }\n    }\n\n    /**\n     * Expands the given node and all its children recursively.\n     */\n    async expandSubTree(node?: Readonly<TreeNode>, includeDrawOrDispatchNodes = false): Promise<void> {\n        node ??= this.root;\n        if (!ExpandableTreeNode.is(node)) {\n            return;\n        }\n\n        try {\n            this.isCollapsingSubTree = true;\n            await this.doExpandSubTree(node, includeDrawOrDispatchNodes);\n            this.onSubTreeExpansionChangedEmitter.fire(node);\n        } finally {\n            this.isCollapsingSubTree = false;\n        }\n    }\n\n    protected async doExpandSubTree(node: TreeNode, includeDrawOrDispatchNodes: boolean): Promise<void> {\n        const YIELD_AFTER_MS = 200;\n\n        const processedNodes = new Set<TreeNode>();\n        const pendingNodes: TreeNode[] = [node];\n        let lastYieldTime = performance.now();\n\n        while (pendingNodes.length > 0) {\n            const currentLevelNodes: ExpandableTreeNode[] = [];\n            const nextLevelNodes: TreeNode[] = [];\n\n            while (pendingNodes.length > 0) {\n                const currentNode = pendingNodes.shift()!;\n                if (processedNodes.has(currentNode)) {\n                    continue;\n                }\n                processedNodes.add(currentNode);\n\n                // stop expansion at draw and dispatch nodes to avoid creation of low-utility nodes\n                // if this logic gets changed please also update enablement of ExpandSubtreeCommand accordingly\n                if (ExpandableTreeNode.is(currentNode) && (includeDrawOrDispatchNodes || !CommandTreeDrawOrDispatchNode.is(currentNode))) {\n                    currentLevelNodes.push(currentNode);\n                }\n            }\n\n            if (currentLevelNodes.length > 0) {\n                const expandedNodes = await this.expansionService.bulkExpandNodes(currentLevelNodes[Symbol.iterator]());\n                for (const expandedNode of expandedNodes) {\n                    await this.ensureLazyChildrenLoaded(expandedNode);\n                    nextLevelNodes.push(...expandedNode.children);\n                }\n                // Also process children of nodes that were already expanded\n                for (const currentNode of currentLevelNodes) {\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\n                        await this.ensureLazyChildrenLoaded(currentNode);\n                        nextLevelNodes.push(...currentNode.children);\n                    }\n                }\n            }\n\n            pendingNodes.push(...nextLevelNodes);\n\n            // Yield control back to the event loop periodically based on time\n            const currentTime = performance.now();\n            if (currentTime - lastYieldTime >= YIELD_AFTER_MS) {\n                await new Promise(resolve => setTimeout(resolve, 0));\n                lastYieldTime = performance.now();\n            }\n        }\n    }\n\n    protected async ensureLazyChildrenLoaded(node: ExpandableTreeNode): Promise<void> {\n        // Find all loading nodes among children\n        const loadingNodes = node.children.filter(CommandEmptyNode.is);\n\n        if (loadingNodes.length === 0) {\n            return;\n        }\n\n        // Trigger load for all loading nodes and wait for them to complete\n        await Promise.all(loadingNodes.map(loadingNode => triggerLazyLoadAndWaitForRemoval(loadingNode)));\n    }\n\n    hasTrailingSuffixes(node: TreeNode): boolean {\n        if (CommandQueueSubmitNode.is(node)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    protected override isVisibleSelectableNode(node: TreeNode): node is SelectableTreeNode {\n        return super.isVisibleSelectableNode(node) && this.isInFrameRange(node);\n    }\n\n    protected isInFrameRange(node: TreeNode): boolean {\n        const frameNode = CommandFrameNode.getCommandFrameNodeContaining(node);\n        if (frameNode === undefined) {\n            return true; // Assume it's good\n        }\n        const range = this.frameRangeSelectionService.frameSpan;\n        if (range === undefined) {\n            return true; // No constraint\n        }\n        return frameNode.frameIndex >= range.startFrame && frameNode.frameIndex <= range.endFrame;\n    }\n}\n\nexport namespace CommandTreeModel {\n    export interface State extends TreeModelImpl.State, CommandTreePreferenceState {}\n\n    /**\n     * Test whether a `node` is of the kind that implements the given `group` mode.\n     * As groups are _a priori_ composite nodes, this additionally infers that type\n     * for the `node` if successful.\n     */\n    export function isOfGroup(node: TreeNode, group: GroupByOptions): node is CompositeTreeNode {\n        switch (group) {\n            case GroupByOptions.Frame:\n                return CommandFrameNode.is(node);\n            case GroupByOptions.RenderPass:\n                return CommandRenderPassInstanceNode.is(node) || CommandDynamicRenderPassInstanceNode.is(node);\n            case GroupByOptions.RenderSubpass:\n                return CommandRenderSubpassInstanceNode.is(node);\n            case GroupByOptions.CommandBuffer:\n                return CommandCommandBufferInstanceNode.is(node);\n            case GroupByOptions.QueueSubmission:\n                return CommandQueueSubmitNode.is(node);\n        }\n    }\n}\n\ntype TextureSupportingNode =\n    | CommandFrameNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode;\n\nexport namespace TextureSupportingNode {\n    export function is(node: CommandTreeNode): node is TextureSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node)\n        );\n    }\n    export function getLast(node: CommandTreeNode): TextureSupportingNode | undefined {\n        if (TextureSupportingNode.is(node)) {\n            return node;\n        }\n        let lastSupportingNode: TextureSupportingNode | undefined;\n        if (CompositeTreeNode.is(node)) {\n            for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n                lastSupportingNode = TextureSupportingNode.getLast(node.children[commandIndex]);\n                if (lastSupportingNode) {\n                    break;\n                }\n            }\n        }\n        return lastSupportingNode;\n    }\n}\n\n/**\n * Union type of all command tree nodes that support thumbnails.\n * Nodes with heavy thumbnail costs are commented out.\n */\ntype ThumbnailSupportingNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandDebugLabelGroupNode\n    | CommandRenderPassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDrawInstanceNode;\n// Below currently have a possibly heavy cost to getting thumbnails\n// | CommandDispatchInstanceNode\n// | CommandMeshTaskInstanceNode\n// | CommandClusterInstanceNode\n// | CommandRaytracingInstanceNode;\n\nexport namespace ThumbnailSupportingNode {\n    export function is(node: CommandTreeNode): node is ThumbnailSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node)\n        );\n    }\n}\n\nfunction getCommandTreeApiEventChildren(eventIds: Array<{ apiEvent: number }>, root: CommandRootNode): CommandTreeApiEvent[] {\n    return eventIds.reduce<CommandTreeApiEvent[]>((collected, id) => {\n        const event = root.resource.apiEvents[id.apiEvent];\n        if (event) {\n            collected.push(event);\n        } else {\n            console.warn(`No event found for ${id.apiEvent}`);\n        }\n        return collected;\n    }, []);\n}\n\nfunction getInstancesByIds<T>(ids: number[], container: PartialRecord<number, T>, source?: string, target?: string): T[] {\n    return ids.flatMap(id => {\n        const instance = container[id];\n        if (!instance) {\n            if (target) {\n                console.warn(`${source ? `${source} expected` : 'Expected'} ${target} with ${id} but found none.`);\n            }\n            return [];\n        }\n        return instance;\n    });\n}\n\n/**\n * Creates an ArrayWithSortNumber for range instances, used by createChildEventNodesForRange.\n * Fetches instances by IDs and provides sorting by beginApiEvent.\n *\n * @param ids - Array of instance IDs to fetch\n * @param container - Container object mapping IDs to instances\n * @param sourceContext - Context string for error messages (e.g., \"CommandRenderPassInstanceNode.create\")\n * @param targetName - Target instance type name for error messages (e.g., \"DebugLabelGroupInstance\")\n * @returns ArrayWithSortNumber object ready for use with getNextRangeElementToProcess\n */\nfunction createRangeInstanceArray<T extends { beginApiEvent: number }>(\n    ids: number[],\n    container: PartialRecord<number, T>,\n    sourceContext: string,\n    targetName: string\n): ArrayWithSortNumber<T> {\n    return {\n        array: getInstancesByIds(ids, container, sourceContext, targetName),\n        getSortNumber: (element: T) => element.beginApiEvent\n    };\n}\n\nexport function createLazyLoadingNode(\n    tree: CommandTree,\n    parent: ExpandableTreeNode,\n    load: (batchQuery?: boolean) => Promise<void>\n): CommandEmptyNode {\n    let loaded = false;\n    let loadingInProgress = false;\n\n    const lazyLoad: (batchQuery?: boolean) => Promise<boolean> = async (batchQuery = true) => {\n        if (loadingInProgress) {\n            return false;\n        }\n\n        if (!loaded) {\n            loaded = true;\n            loadingInProgress = true;\n            loadOnExpanded.dispose();\n            try {\n                await load(batchQuery);\n            } catch (error) {\n                console.error(`LazyLoad failed for node ${parent.id}:`, error);\n            } finally {\n                loadingInProgress = false;\n            }\n            CompositeTreeNode.removeChild(parent, loadingNode);\n            await tree.refreshStructure(parent);\n            return true;\n        }\n        return false;\n    };\n\n    // create lazy loading node\n    const loadingNode: CommandEmptyNode = CommandEmptyNode.create(parent, lazyLoad);\n    CompositeTreeNode.addChild(parent, loadingNode);\n\n    // register for lazy loading when the node is expanded\n    const loadOnExpanded = SokatoaLifecycleTreeNode.register(parent, 'onWillRender', async () => {\n        if (parent.expanded) {\n            // do not batch queries for expansion manually\n            await lazyLoad(false);\n        }\n    });\n    return loadingNode;\n}\n"
              }
            }
          ]
        }
      }
    ],
    "responses": [
      {
        "id": "ef578b7d-ce68-4178-8eaa-78413479e89f",
        "requestId": "44acca1a-222b-4f9c-be51-07e07c09f9fb",
        "isComplete": true,
        "isError": true,
        "errorMessage": "400 {\"type\":\"error\",\"error\":{\"type\":\"invalid_request_error\",\"message\":\"prompt is too long: 200344 tokens > 200000 maximum\"},\"request_id\":\"req_011CXZjRpwawv2GhpnyX23Ra\"}",
        "promptVariantId": "coder-system-agent-mode-next",
        "isPromptVariantEdited": false,
        "content": [
          {
            "kind": "markdownContent",
            "data": {
              "content": "I'll implement this diagnostic logging plan. Let me start by reading the file to understand the current code structure."
            },
            "fallbackMessage": "I'll implement this diagnostic logging plan. Let me start by reading the file to understand the current code structure."
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01P5HfxoKrVir1SCnCcCtgo1",
              "name": "getFileContent",
              "arguments": "{\"file\": \"app/packages/capture/src/browser/command-tree/command-tree-model.ts\"}",
              "finished": true,
              "result": "/********************************************************************************\n    Copyright 2024-2026 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\nimport { GFXRQueryBuilderService } from '@sokatoa/gfxr-consumer/lib/';\nimport {\n    DynamicStateEntry,\n    PipelineBindPoint,\n    PipelineBindPointShaderStageFlags,\n    StateType\n} from '@sokatoa/gfxr-consumer/lib/browser/gfxr-data-service';\nimport { PartialRecord } from '@sokatoa/platform/lib';\nimport { BulkTree, BulkTreeModel, ResourceTreeNode, SokatoaLifecycleTreeNode } from '@sokatoa/platform/lib/browser';\nimport { GroupByOptions, MiscPreferences, MiscPrefs } from '@sokatoa/platform/lib/browser/misc-preferences';\nimport { TreeStructureChangeEmitter } from '@sokatoa/platform/lib/browser/tree-table/tree-table-widget';\nimport { ImageAccessorService } from '@sokatoa/platform/lib/common';\nimport { CompressedFileService, usesCompressionExtension } from '@sokatoa/platform/lib/common/compressed-file-service';\nimport { asError } from '@sokatoa/platform/lib/common/error-utils';\nimport { ApiResources, DescriptorResource, DrawApiResult } from '@sokatoa/platform/lib/common/gfxr-apis';\nimport { CancellationToken, Disposable, Emitter, Event, Path, URI } from '@theia/core';\nimport {\n    CompositeTreeNode,\n    DepthFirstTreeIterator,\n    ExpandableTreeNode,\n    SelectableTreeNode,\n    TreeModelImpl,\n    TreeNode\n} from '@theia/core/lib/browser';\nimport { RGBA } from '@theia/core/lib/common/color';\nimport { inject, injectable, postConstruct } from '@theia/core/shared/inversify';\nimport { PNG } from 'pngjs/browser';\nimport { lookupResourceFormat, UncompressedResourceFormat } from '../../common/format-handler';\nimport { extractData } from '../../common/geometry-utils';\nimport { GfxrScreenshotService, requestThumbnails, ScreenshotType, ThumbnailRequestOptions } from '../../common/gfxr-screenshot-service';\nimport { convertDataToImageData } from '../../common/host-side-conversion/vulkan-image';\nimport { FrameRangeSelectionService } from '../capture-widget/frame-range-selection-service';\nimport { placeholderScale } from '../graphics-pipeline-widget/graphics-pipeline-screenshot-requests';\nimport {\n    CaptureDatasetWidgetContext,\n    CaptureDatasetWidgetProfile,\n    CaptureDatasetWidgetReplayContext\n} from '../profile-ui/capture-dataset-widget-types';\nimport { CommandTreePreferenceState } from './command-tree-model-preferences';\nimport {\n    CommandTreeAccelerationStructureBuildInstance,\n    CommandTreeAccelerationStructureCopyInstance,\n    CommandTreeApiEvent,\n    CommandTreeCommandBufferInstance,\n    CommandTreeDataWithFunctionAndDebugNames,\n    CommandTreeDebugLabelGroupInstance,\n    CommandTreeDynamicRenderPassInstance,\n    CommandTreeFrame,\n    CommandTreeQueueDebugLabelGroup,\n    CommandTreeQueueDebugLabelInsert,\n    CommandTreeQueuePresent,\n    CommandTreeQueueSubmit,\n    CommandTreeRenderPassInstance,\n    CommandTreeRenderSubpassInstance,\n    CommandTreeSecondaryCommandBufferInstance,\n    CommandTreeTransferCommandInstance,\n    overrideDynamicState,\n    queryClusterInstanceDynamicState,\n    queryClusterInstanceDynamicStateBatched,\n    queryDispatchInstanceDynamicState,\n    queryDispatchInstanceDynamicStateBatched,\n    queryDrawInstanceDynamicState,\n    queryDrawInstanceDynamicStateBatched,\n    queryMeshTaskInstanceDynamicState,\n    queryMeshTaskInstanceDynamicStateBatched,\n    queryRaytracingInstanceDynamicState,\n    queryRaytracingInstanceDynamicStateBatched,\n    querySecondaryCommandBufferEndDynamicState,\n    QueryTreeDataOptions\n} from './command-tree-service';\nimport { LazyLoadableNode, triggerLazyLoadAndWaitForRemoval } from './lazy-load-utils';\nimport { CommandTreeDataQueriedRootProvider } from './providers/command-tree-root-provider';\n\n// Extension names\nconst VK_NV_COMMAND_BUFFER_INHERITANCE = 'VK_NV_command_buffer_inheritance';\nconst VK_NV_INHERITED_VIEWPORT_SCISSOR = 'VK_NV_inherited_viewport_scissor';\n\n/**\n * Helper type to make TreeNode.parent writable during node construction.\n * TreeNode.parent is readonly, but during tree construction we need to update it.\n */\ninterface MutableParent {\n    parent: CompositeTreeNode | undefined;\n}\n\n/**\n * Check if VK_NV_command_buffer_inheritance extension is enabled for a device.\n * This extension enables full state inheritance between command buffers and leak-back.\n */\nfunction hasCommandBufferInheritance(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_COMMAND_BUFFER_INHERITANCE) ?? false;\n}\n\n/**\n * Check if VK_NV_inherited_viewport_scissor extension is enabled for a device.\n * This extension enables limited viewport/scissor inheritance for secondary command buffers.\n */\nfunction hasInheritedViewportScissor(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_INHERITED_VIEWPORT_SCISSOR) ?? false;\n}\n\n/**\n * Filter dynamic state to only viewport and scissor entries.\n * Used for VK_NV_inherited_viewport_scissor extension.\n */\nasync function filterDynamicStateForViewportScissor(statePromise: Promise<DynamicStateEntry[]>): Promise<DynamicStateEntry[]> {\n    const state = await statePromise;\n    return state.filter(entry => entry.stateType === StateType.VIEWPORT || entry.stateType === StateType.SCISSOR);\n}\n\n/**\n * Tracks dynamic state that may be updated as secondary command buffers execute\n * (when VK_NV_command_buffer_inheritance is enabled).\n */\nclass DynamicStateTracker {\n    private currentStatePromise: Promise<DynamicStateEntry[]>;\n\n    constructor(initialState: Promise<DynamicStateEntry[]>) {\n        this.currentStatePromise = initialState;\n    }\n\n    getCurrentState(): Promise<DynamicStateEntry[]> {\n        return this.currentStatePromise;\n    }\n\n    updateState(newState: Promise<DynamicStateEntry[]>): void {\n        this.currentStatePromise = newState;\n    }\n}\n\n/** Internal context for a command tree model.\n *\n * contains all the fixed data needed for the model,\n * e.g. services, etc.\n */\ninterface CommandTreeContext {\n    dbId: number;\n    data: CommandTreeDataWithFunctionAndDebugNames;\n    screenshotService: GfxrScreenshotService;\n    fileService: CompressedFileService;\n    profile: CaptureDatasetWidgetProfile;\n    context: CaptureDatasetWidgetContext;\n    tree: CommandTree;\n    gfxrQueryBuilderService: GFXRQueryBuilderService;\n    imageAccessorService: ImageAccessorService;\n    createDrawOrDispatchChildren: boolean;\n    rootNode: CommandRootNode;\n    deviceExtensions: Map<number, Set<string>>;\n}\n\n/**\n * Helper function to look up the debug name for an object at a specific API event.\n * Finds the most recent debug name that was set at or before the target API event.\n * @param debugNameLookup - Map of objectHandle to array of {apiEvent, name} sorted by apiEvent\n * @param objectHandle - The object handle to look up\n * @param targetApiEvent - The API event at which we want to know the object's name\n * @returns The debug name if found, undefined otherwise\n */\nfunction getDebugNameAtApiEvent(\n    debugNameLookup: Map<number, Array<{ apiEvent: number; name: string }>>,\n    objectHandle: number | null | undefined,\n    targetApiEvent: number\n): string | undefined {\n    if (typeof objectHandle !== 'number') {\n        return undefined;\n    }\n\n    const entries = debugNameLookup.get(objectHandle);\n    if (!entries || entries.length === 0) {\n        return undefined;\n    }\n\n    // Binary search for the most recent name at or before targetApiEvent\n    let left = 0;\n    let right = entries.length - 1;\n    let result: string | undefined = undefined;\n\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (entries[mid].apiEvent <= targetApiEvent) {\n            result = entries[mid].name;\n            left = mid + 1; // Look for a more recent name\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n\nexport interface CommandRootNode extends ResourceTreeNode<CommandTreeDataWithFunctionAndDebugNames>, CompositeTreeNode, ExpandableTreeNode {\n    resourceType: typeof CommandRootNode.RESOURCE_TYPE;\n    children: CommandFrameNode[];\n    dbId: number;\n    profile: CaptureDatasetWidgetProfile;\n    tree?: CommandTree; // Back-reference to the tree that owns this root\n    // Cached maps for queue debug labels to avoid rebuilding for each frame\n    queueDebugLabelGroupsBySubmitId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelGroupsByPresentId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelInsertsByApiEvent: Map<number, CommandTreeQueueDebugLabelInsert>;\n}\n\nexport namespace CommandRootNode {\n    export const ID = 'sokatoa-command-tree-widget';\n\n    export const RESOURCE_TYPE = '__root__';\n\n    export function is(node: TreeNode | undefined): node is CommandRootNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRootNode.RESOURCE_TYPE);\n    }\n\n    export function create(\n        dbId: number,\n        data: CommandTreeDataWithFunctionAndDebugNames,\n        screenshotService: GfxrScreenshotService,\n        profile: CaptureDatasetWidgetProfile,\n        context: CaptureDatasetWidgetContext,\n        tree: CommandTree,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        imageAccessorService: ImageAccessorService,\n        fileService: CompressedFileService,\n        createDrawOrDispatchChildren: boolean,\n        deviceExtensions: Map<number, Set<string>>\n    ): CommandRootNode {\n        // Build maps for queue debug labels once for all frames\n        const queueDebugLabelGroupsBySubmitId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelGroupsByPresentId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelInsertsByApiEvent = new Map<number, CommandTreeQueueDebugLabelInsert>();\n\n        for (const group of Object.values(data.queueDebugLabelGroups)) {\n            if (group) {\n                for (const submitId of group.queueSubmitIds) {\n                    queueDebugLabelGroupsBySubmitId.set(submitId, group);\n                }\n                for (const presentId of group.queuePresentIds) {\n                    queueDebugLabelGroupsByPresentId.set(presentId, group);\n                }\n            }\n        }\n\n        for (const insert of Object.values(data.queueDebugLabelInserts)) {\n            if (insert) {\n                queueDebugLabelInsertsByApiEvent.set(insert.apiEvent, insert);\n            }\n        }\n\n        const rootNode: CommandRootNode = {\n            visible: false,\n            id: CommandRootNode.ID,\n            name: 'ProfileTree',\n            parent: undefined,\n            expanded: true,\n            children: [],\n            resourceType: CommandRootNode.RESOURCE_TYPE,\n            resource: data,\n            dbId,\n            profile,\n            queueDebugLabelGroupsBySubmitId,\n            queueDebugLabelGroupsByPresentId,\n            queueDebugLabelInsertsByApiEvent\n        };\n        const ctx: CommandTreeContext = {\n            dbId,\n            data,\n            screenshotService,\n            fileService,\n            profile,\n            context,\n            tree,\n            gfxrQueryBuilderService,\n            imageAccessorService,\n            createDrawOrDispatchChildren,\n            rootNode,\n            deviceExtensions\n        };\n        const modelBuildStart = Date.now();\n        const frames = Object.values(data.frames);\n        rootNode.children = frames.flatMap(child => (child ? CommandFrameNode.create(ctx, child, rootNode) : []));\n        console.debug(`Model loaded in ${Date.now() - modelBuildStart} ms`);\n        return rootNode;\n    }\n}\n\nexport interface DebugMarker {\n    name: string;\n    color?: RGBA;\n}\n\nexport interface WithDebugMarker {\n    debugMarker?: DebugMarker;\n}\n\nexport namespace WithDebugMarker {\n    /** Type guard for a `node` that is or has a debug marker. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugMarker> {\n        return 'debugMarker' in node && node.debugMarker !== undefined;\n    }\n}\n\nexport interface WithDebugName {\n    debugName?: string;\n}\n\nexport namespace WithDebugName {\n    /** Type guard for a `node` that has a debug name. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugName> {\n        return 'debugName' in node && node.debugName !== undefined;\n    }\n}\n\ninterface LabelData {\n    labelName: string | undefined | null;\n    colorR: number | undefined | null;\n    colorG: number | undefined | null;\n    colorB: number | undefined | null;\n    colorA: number | undefined | null;\n}\n\nfunction setDebugMarkerData(node: WithDebugMarker, labelData: LabelData): void {\n    const name = labelData.labelName ?? 'Debug marker';\n    const color = {\n        r: (labelData.colorR ?? 1) * 255,\n        g: (labelData.colorG ?? 1) * 255,\n        b: (labelData.colorB ?? 1) * 255,\n        a: (labelData.colorA ?? 1) * 255\n    };\n\n    node.debugMarker = { name };\n    if (color.a !== 0 || color.b !== 0 || color.g !== 0 || color.r !== 0) {\n        node.debugMarker.color = color;\n    }\n}\n\nexport interface CommandFrameNode extends ResourceTreeNode<CommandTreeFrame>, ExpandableTreeNode, SelectableTreeNode {\n    label: string;\n    frameIndex: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandFrameNode.RESOURCE_TYPE;\n    thumbnail?: string;\n}\n\nexport namespace CommandFrameNode {\n    export const RESOURCE_TYPE = 'frame';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandFrameNode {\n        return ResourceTreeNode.hasResourceType(node, CommandFrameNode.RESOURCE_TYPE);\n    }\n\n    export function getId(frame: CommandTreeFrame): string {\n        return frame.frameIndex.toString();\n    }\n\n    export function create(ctx: CommandTreeContext, element: CommandTreeFrame, parent: CompositeTreeNode): CommandFrameNode {\n        const node: CommandFrameNode & SokatoaLifecycleTreeNode = {\n            id: getId(element),\n            frameIndex: element.frameIndex,\n            label: `Frame ${element.frameIndex}`,\n            children: [],\n            expanded: false,\n            selected: false,\n            parent,\n            resourceType: CommandFrameNode.RESOURCE_TYPE,\n            resource: element\n        };\n\n        const root = ctx.rootNode;\n\n        const children: CommandTreeNode[] = [];\n        let queueSubmitIndex = 0;\n        let queuePresentIndex = 0;\n        let accelerationStructureBuildIndex = 0;\n        let accelerationStructureCopyIndex = 0;\n\n        // Track current active debug label group and its children\n        let activeDebugLabelGroup: CommandTreeQueueDebugLabelGroup | undefined;\n        let activeGroupChildren: (CommandQueueSubmitNode | CommandQueuePresentNode)[] = [];\n        let queueDebugLabelGroupInstanceIndex = 0;\n\n        // Helper to finalize the active group and add it to children\n        const finalizeActiveGroup = (): void => {\n            if (activeDebugLabelGroup && activeGroupChildren.length > 0) {\n                children.push(\n                    CommandQueueDebugLabelGroupNode.create(\n                        ctx,\n                        activeDebugLabelGroup,\n                        node,\n                        activeGroupChildren,\n                        queueDebugLabelGroupInstanceIndex++\n                    )\n                );\n                activeDebugLabelGroup = undefined;\n                activeGroupChildren = [];\n            }\n        };\n\n        for (let id = element.beginApiEvent; id <= (element.endApiEvent ?? element.beginApiEvent); id++) {\n            // Check for queue debug label insert at this apiEvent\n            const queueDebugLabelInsert = root.queueDebugLabelInsertsByApiEvent.get(id);\n            if (queueDebugLabelInsert) {\n                // Inserts can appear in the middle of groups, so finalize any active group first\n                finalizeActiveGroup();\n                children.push(CommandQueueDebugLabelNode.create(ctx, queueDebugLabelInsert, node));\n            }\n\n            const apiEvent = root.resource.apiEvents[id];\n            if (apiEvent) {\n                if (apiEvent.submissionId && element.queueSubmitIds.includes(apiEvent.submissionId)) {\n                    const queueSubmit = root.resource.queueSubmits[apiEvent.submissionId];\n                    if (queueSubmit) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsBySubmitId.get(apiEvent.submissionId);\n\n                        // Check if this submit is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queueSubmit not found for submissionId ${apiEvent.submissionId}`);\n                    }\n                } else if (apiEvent.presentId && element.queuePresentIds.includes(apiEvent.presentId)) {\n                    const queuePresent = root.resource.queuePresents[apiEvent.presentId];\n                    if (queuePresent) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsByPresentId.get(apiEvent.presentId);\n\n                        // Check if this present is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queuePresent not found for presentId ${apiEvent.presentId}`);\n                    }\n                } else if (\n                    apiEvent.accelerationStructureBuildInstanceId &&\n                    element.accelerationStructureBuildIds.includes(apiEvent.accelerationStructureBuildInstanceId)\n                ) {\n                    // Acceleration structure builds interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureBuild =\n                        root.resource.topLevelAccelerationStructureBuilds[apiEvent.accelerationStructureBuildInstanceId];\n                    if (accelerationStructureBuild) {\n                        children.push(\n                            CommandAccelerationStructureBuildNode.create(\n                                accelerationStructureBuild,\n                                node,\n                                accelerationStructureBuildIndex++\n                            )\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureBuildInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureBuild not found for accelerationStructureBuildInstanceId ${iId}`\n                        );\n                    }\n                } else if (\n                    apiEvent.accelerationStructureCopyInstanceId &&\n                    element.accelerationStructureCopyIds.includes(apiEvent.accelerationStructureCopyInstanceId)\n                ) {\n                    // Acceleration structure copies interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureCopy =\n                        root.resource.topLevelAccelerationStructureCopies[apiEvent.accelerationStructureCopyInstanceId];\n                    if (accelerationStructureCopy) {\n                        children.push(\n                            CommandAccelerationStructureCopyNode.create(accelerationStructureCopy, node, accelerationStructureCopyIndex++)\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureCopyInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureCopy not found for accelerationStructureCopyInstanceId ${iId}`\n                        );\n                    }\n                }\n            }\n        }\n\n        // Finalize any remaining active debug label group at the end\n        finalizeActiveGroup();\n\n        node.children = children;\n\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        const request: ThumbnailRequestOptions = {\n            profileOrReplay: replay ?? ctx.profile,\n            startFrame: element.frameIndex,\n            endFrame: element.frameIndex,\n            requesterDbgName: `Command tree frame ${element.frameIndex}`,\n            onScreenshotReady: result => {\n                ctx.imageAccessorService\n                    .accessImage(new URL(URI.fromFilePath(result.path).toString()))\n                    .then(url => {\n                        node.thumbnail = url.url.toString();\n                        ctx.tree.addToDispose(url);\n                        void ctx.tree.refresh(node);\n                    })\n                    .catch(reason => {\n                        const error = asError(reason);\n                        console.error(error);\n                    });\n            },\n            onRequestComplete: (success, message) => {\n                if (!success) {\n                    console.error(`Request for frame thumbnails failed: ${message}`);\n                }\n            }\n        };\n        const onWillRender = (): void => {\n            requestThumbnails(ctx.screenshotService, request);\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', onWillRender);\n        };\n        SokatoaLifecycleTreeNode.register(node, 'onWillRender', onWillRender);\n        return node;\n    }\n\n    /**\n     * Retrieve the `CommandFrameNode` that is or contains the given `node`.\n     * Returns `undefined` in the case that the `node` is an ancestor of or\n     * otherwise not contained in an `CommandFrameNode`.\n     */\n    export function getCommandFrameNodeContaining(node: TreeNode): CommandFrameNode | undefined {\n        return CommandFrameNode.is(node) ? node : node.parent ? CommandFrameNode.getCommandFrameNodeContaining(node.parent) : undefined;\n    }\n}\n\nexport interface CommandEmptyNode extends LazyLoadableNode {\n    label: string;\n}\n\nexport namespace CommandEmptyNode {\n    export const GENERALIZED_TYPE = 'empty';\n\n    export function is(node: unknown): node is CommandEmptyNode {\n        return TreeNode.is(node) && node.id.endsWith('_empty');\n    }\n\n    export function getId(parent: CompositeTreeNode): string {\n        return `${parent.id}_empty`;\n    }\n\n    export function create(parent: CompositeTreeNode, load: CommandEmptyNode['load']): CommandEmptyNode {\n        return {\n            id: getId(parent),\n            label: 'Loading...',\n            parent,\n            load\n        };\n    }\n}\n\nexport interface CommandApiEventNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandApiEventNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandApiEventNode {\n    export const RESOURCE_TYPE = 'api-event';\n    export const GENERALIZED_TYPE = RESOURCE_TYPE;\n\n    export function is(node: TreeNode | undefined): node is CommandApiEventNode {\n        return ResourceTreeNode.hasResourceType(node, CommandApiEventNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEventId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex?: number\n    ): CommandApiEventNode {\n        const root = ctx.rootNode;\n        const node: CommandApiEventNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEventId,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex ?? ''}`,\n            parent,\n            resourceType: CommandApiEventNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId,\n            selected: false\n        };\n        // set debug marker data if node is a debug marker\n        if (element.debugLabelId) {\n            const labelData = root.resource.debugLabels[element.debugLabelId];\n            if (labelData) {\n                setDebugMarkerData(node, labelData);\n            }\n        }\n        return node;\n    }\n}\n\nexport interface CommandDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeDebugLabelGroupInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'debug-label-group';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDebugLabelGroupInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDebugLabelGroupInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDebugLabelGroupNode = {\n            id: getId(element, parent),\n            debugLabelInstanceId: element.labelId,\n            label: `${root.resource.functionNameLookup[element.functionNameId ?? -1] ?? '<not defined>'}`,\n            parent,\n            resourceType: CommandDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this debug label range\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this debug label group, add it to array\n            // - not self\n            // - only commands with same command buffer id\n            if (event && event.debugLabelId !== element.labelId && event.commandBufferInstanceId === element.commandBufferInstance) {\n                apiEventCommandArray.push(event);\n            }\n        }\n        // get array of debug label ranges with api event numbers within this debug label range\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this debug label range\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderPassInstance'\n        );\n        // get array of render subpass ranges with api event numbers within this debug label range\n        const renderSubpassInstances = createRangeInstanceArray(\n            element.renderSubpassInstanceIds,\n            root.resource.renderSubpassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderSubpassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this debug label range\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('subpassIndex' in rangeElement) {\n                    const renderSubpassInstanceNode = CommandRenderSubpassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderSubpassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            renderSubpassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for debug label group:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `debug label group ${element.labelId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelGroup>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'queue-debug-label-group';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelGroup, parent: CompositeTreeNode, instanceIndex: number): string {\n        return `${parent.id}_qdl_group_${element.labelId}_${instanceIndex}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelGroup,\n        parent: CompositeTreeNode,\n        children: (CommandQueueSubmitNode | CommandQueuePresentNode)[],\n        instanceIndex: number\n    ): CommandQueueDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelGroupNode = {\n            id: getId(element, parent, instanceIndex),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label Group',\n            queue: element.queue!,\n            parent,\n            resourceType: CommandQueueDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        // Update parent references for children since they were created with a different parent\n        // and are now being reparented to this debug label group node\n        for (const child of children) {\n            // Cast away readonly to update parent during node construction\n            (child as MutableParent).parent = node;\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelInsert>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    apiEventId: number;\n    resourceType: typeof CommandQueueDebugLabelNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelNode {\n    export const RESOURCE_TYPE = 'queue-debug-label';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelInsert, parent: CompositeTreeNode): string {\n        return `${parent.id}_qdl_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelInsert,\n        parent: CompositeTreeNode\n    ): CommandQueueDebugLabelNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelNode = {\n            id: getId(element, parent),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label',\n            queue: element.queue!,\n            apiEventId: element.apiEvent,\n            parent,\n            resourceType: CommandQueueDebugLabelNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandCommandBufferInstanceNode\n    extends ResourceTreeNode<CommandTreeCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    commandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandCommandBufferInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandCommandBufferInstanceNode {\n    export const RESOURCE_TYPE = 'command-buffer-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandCommandBufferInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandCommandBufferInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeCommandBufferInstance,\n        parent: CompositeTreeNode,\n        commandBufferIndex: number,\n        baseDynamicStatePromise?: Promise<DynamicStateEntry[]>\n    ): CommandCommandBufferInstanceNode {\n        const node: CommandCommandBufferInstanceNode = {\n            id: getId(element, parent),\n            commandBufferInstanceId: element.instanceId,\n            label: `Command Buffer ${commandBufferIndex}`,\n            parent,\n            resourceType: CommandCommandBufferInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this command buffer\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this command buffer, add it to array\n            // - omit commands that reference render pass id\n            // - if api event is a debug label, check the debug label itself for a render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                event.commandBufferInstanceId === element.instanceId &&\n                event.renderPassInstanceId === undefined &&\n                event.dynamicRenderPassInstanceId === undefined &&\n                (event.debugLabelId === undefined ||\n                    (debugLabel?.beginApiEvent === event.apiEventId &&\n                        debugLabel?.beginRenderPassInstance === undefined &&\n                        debugLabel?.beginDynamicRenderPassInstance === undefined) ||\n                    (debugLabel?.endApiEvent === event.apiEventId &&\n                        debugLabel?.endRenderPassInstance === undefined &&\n                        debugLabel?.endDynamicRenderPassInstance === undefined))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this command buffer\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this command buffer\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'RenderPassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this command buffer\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        const emptyDynamicStatePromise = new Promise<DynamicStateEntry[]>(resolve => resolve([]));\n        const effectiveBaseState = baseDynamicStatePromise ?? emptyDynamicStatePromise;\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            effectiveBaseState,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        effectiveBaseState\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for command buffer:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `command buffer ${commandBufferIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandSecondaryCommandBufferExecutionNode\n    extends ResourceTreeNode<CommandTreeSecondaryCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    parentCommandBufferInstanceId: number;\n    secondaryCommandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n}\n\nexport namespace CommandSecondaryCommandBufferExecutionNode {\n    export const RESOURCE_TYPE = 'secondary-command-buffer-execution';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: unknown): node is CommandSecondaryCommandBufferExecutionNode {\n        return (\n            ExpandableTreeNode.is(node) && SelectableTreeNode.is(node) && ResourceTreeNode.is(node, 'secondary-command-buffer-execution')\n        );\n    }\n\n    export function getId(element: CommandTreeSecondaryCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_secondary_${element.secondaryCommandBufferInstance}_${element.executionId}_${element.executionIndex}`;\n    }\n\n    export async function create(\n        ctx: CommandTreeContext,\n        elements: CommandTreeSecondaryCommandBufferInstance[],\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n        stateTracker?: DynamicStateTracker\n    ): Promise<CommandSecondaryCommandBufferExecutionNode> {\n        if (elements.length === 0) {\n            throw new Error('elements array must not be empty');\n        }\n        // Use the first element for the node's resource (they all share the same executionId and apiEvent)\n        const element = elements[0];\n        const node: CommandSecondaryCommandBufferExecutionNode = {\n            id: getId(element, parent),\n            parentCommandBufferInstanceId: element.parentCommandBufferInstance || 0,\n            secondaryCommandBufferInstanceId: element.secondaryCommandBufferInstance || 0,\n            label: `Secondary Command Buffer Execution ${commandIndex}`,\n            parent,\n            resourceType: 'secondary-command-buffer-execution',\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        createLazyLoadingNode(ctx.tree, node, async () => {\n            // Sort elements by executionIndex to maintain proper order\n            const sortedElements = [...elements].sort((a, b) => (a.executionIndex || 0) - (b.executionIndex || 0));\n\n            // Get device and check extensions\n            const firstSecondary = sortedElements[0]?.secondaryCommandBufferInstance;\n            let deviceExtensions: Set<string> | undefined;\n\n            if (firstSecondary !== undefined) {\n                const commandBufferInstance = root.resource.commandBufferInstances[firstSecondary];\n                const device = commandBufferInstance?.device;\n                if (typeof device === 'number') {\n                    deviceExtensions = ctx.deviceExtensions.get(device);\n                }\n            }\n\n            const hasInheritance = hasCommandBufferInheritance(deviceExtensions);\n            const hasViewportScissorOnly = hasInheritedViewportScissor(deviceExtensions) && !hasInheritance;\n\n            // Calculate effective base state for INHERITANCE INTO secondary\n            let effectiveBaseState: Promise<DynamicStateEntry[]>;\n            if (hasInheritance) {\n                effectiveBaseState = baseDynamicStatePromise;\n            } else if (hasViewportScissorOnly) {\n                effectiveBaseState = filterDynamicStateForViewportScissor(baseDynamicStatePromise);\n            } else {\n                effectiveBaseState = Promise.resolve([]);\n            }\n\n            // Create a CommandCommandBufferInstanceNode for each secondary command buffer in the execution\n            const childNodes: CommandCommandBufferInstanceNode[] = [];\n            sortedElements.forEach((secondaryInstance, index) => {\n                if (secondaryInstance.secondaryCommandBufferInstance) {\n                    const commandBufferInstance = root.resource.commandBufferInstances[secondaryInstance.secondaryCommandBufferInstance];\n                    if (commandBufferInstance) {\n                        const childNode = CommandCommandBufferInstanceNode.create(\n                            ctx,\n                            commandBufferInstance,\n                            node,\n                            index,\n                            effectiveBaseState\n                        );\n                        childNodes.push(childNode);\n                    } else {\n                        console.warn(\n                            `Command buffer instance ${secondaryInstance.secondaryCommandBufferInstance} ` +\n                                'not found in root.resource.commandBufferInstances'\n                        );\n                    }\n                }\n            });\n            CompositeTreeNode.addChildren(node, childNodes);\n\n            // Handle LEAK-BACK: Update parent's state tracker if extension is enabled\n            if (hasInheritance && stateTracker && element.executionId) {\n                const db = ctx.gfxrQueryBuilderService.builderFor(ctx.dbId);\n                const endStatePromise = querySecondaryCommandBufferEndDynamicState(db, [element.executionId]);\n                stateTracker.updateState(endStatePromise);\n            }\n        });\n\n        // Register for thumbnail updates\n        registerThumbnailUpdate(ctx, node, `secondary command buffer execution ${node.resource.executionId}`);\n        return node;\n    }\n}\n\nexport interface CommandQueueSubmitNode\n    extends ResourceTreeNode<CommandTreeQueueSubmit>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    submissionId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueSubmitNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueSubmitNode {\n    export const RESOURCE_TYPE = 'queue-submit';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueSubmitNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueSubmitNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueSubmit, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.submissionId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueSubmit,\n        parent: CompositeTreeNode,\n        queueSubmitIndex: number\n    ): CommandQueueSubmitNode {\n        const root = ctx.rootNode;\n        const node: CommandQueueSubmitNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            threadId: element.threadId || 0,\n            submissionId: element.submissionId,\n            label: `Queue Submit ${queueSubmitIndex}`,\n            queue: element.queue,\n            parent,\n            resourceType: CommandQueueSubmitNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        const children =\n            element.queueSubmitBuffers\n                ?.filter(b => b.commandBufferInstance)\n                .flatMap(b => {\n                    const instance = root.resource.commandBufferInstances[b.commandBufferInstance!];\n                    if (!instance) {\n                        console.warn(`CommandQueueSubmitNode.create: commandBufferInstance not found for id ${b.commandBufferInstance}`);\n                        return [];\n                    }\n                    return instance;\n                }) ?? [];\n        let commandBufferIndex = 0;\n        node.children = children.map(child => CommandCommandBufferInstanceNode.create(ctx, child, node, commandBufferIndex++));\n\n        registerThumbnailUpdate(ctx, node, `queue submit ${queueSubmitIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueuePresentNode extends ResourceTreeNode<CommandTreeQueuePresent>, SelectableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    resourceType: typeof CommandQueuePresentNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueuePresentNode {\n    export const RESOURCE_TYPE = 'queue-present';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueuePresentNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueuePresentNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueuePresent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEvent}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueuePresent,\n        parent: CompositeTreeNode,\n        queuePresentIndex: number\n    ): CommandQueuePresentNode {\n        const root = ctx.rootNode;\n        const node: CommandQueuePresentNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            label: `Queue Present ${queuePresentIndex}`,\n            parent,\n            resourceType: CommandQueuePresentNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            queue: element.queue,\n            selected: false\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureBuildNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureBuildInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    buildInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureBuildNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureBuildNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-build';\n    export const GENERALIZED_TYPE = 'acceleration-structure-build';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureBuildNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureBuildNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureBuildInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.buildApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureBuildInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureBuildNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureBuildNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            buildInstanceId: element.instanceId,\n            apiEventId: element.buildApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureBuildNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureCopyNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureCopyInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    copyInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureCopyNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureCopyNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-copy';\n    export const GENERALIZED_TYPE = 'acceleration-structure-copy';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureCopyNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureCopyNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureCopyInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.copyApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureCopyInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureCopyNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureCopyNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            copyInstanceId: element.instanceId,\n            apiEventId: element.copyApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureCopyNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandTransferCommandNode\n    extends ResourceTreeNode<CommandTreeTransferCommandInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    transferCommandInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandTransferCommandNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandTransferCommandNode {\n    export const RESOURCE_TYPE = 'transfer-command';\n    export const GENERALIZED_TYPE = 'transfer-command';\n\n    export function is(node: TreeNode | undefined): node is CommandTransferCommandNode {\n        return ResourceTreeNode.hasResourceType(node, CommandTransferCommandNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeTransferCommandInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.transferApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeTransferCommandInstance,\n        parent: CompositeTreeNode,\n        transferCommandIndex: number\n    ): CommandTransferCommandNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandTransferCommandNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            transferCommandInstanceId: element.instanceId,\n            apiEventId: element.transferApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${transferCommandIndex}`,\n            parent,\n            resourceType: CommandTransferCommandNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nfunction setThumbnailUrl(\n    ctx: CommandTreeContext,\n    resources: ApiResources[],\n    node: TreeNode & { thumbnail?: string },\n    requesterDbgName: string\n): void {\n    if (resources.length > 0) {\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        ctx.screenshotService.requestScreenshots({\n            profileOrReplay: replay ?? ctx.profile,\n            scale: placeholderScale,\n            screenshotType: ScreenshotType.API_EVENT,\n            requestData: resources,\n            moreRequests: true,\n            requesterDbgName,\n            options: {\n                DumpDepth: true\n            },\n            onScreenshotReady: result => {\n                if (result.resultData.resultType === ScreenshotType.API_EVENT && DrawApiResult.is(result.resultData.apiResult)) {\n                    const images = [...(result.resultData.apiResult.colorAttachments || [])];\n                    if (result.resultData.apiResult.depthAttachment) {\n                        images.push(result.resultData.apiResult.depthAttachment);\n                    }\n                    if (images.length > 0) {\n                        const possibleImage = images[0].subresources?.[0];\n                        if (possibleImage) {\n                            if (usesCompressionExtension(possibleImage.file)) {\n                                // Use VkImageConversionService to get a png\n                                // Do the same as the else case, but with the new png file\n                                const format = lookupResourceFormat(images[0].format);\n                                if (UncompressedResourceFormat.is(format)) {\n                                    ctx.fileService\n                                        .read(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString(), {\n                                            uncompressedSize: possibleImage.size\n                                        })\n                                        .then(async content => {\n                                            const extractedData = await extractData(format, content);\n                                            const dim = {\n                                                width: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[0]\n                                                    : possibleImage.dimensions[0] * placeholderScale,\n                                                height: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[1]\n                                                    : possibleImage.dimensions[1] * placeholderScale\n                                            };\n                                            const conversionResult = await convertDataToImageData(extractedData, format, dim, {\n                                                channelOptions: { alpha: { disabled: true } }\n                                            });\n                                            const png = new PNG({\n                                                width: conversionResult.dimensions.width,\n                                                height: conversionResult.dimensions.height\n                                            });\n                                            png.data = conversionResult.data;\n                                            const pngBuffer = PNG.sync.write(png);\n                                            node.thumbnail = `data:image/png;base64, ${pngBuffer.toString('base64')}`;\n                                            void ctx.tree.refresh(node.parent);\n                                        })\n                                        .catch(reason => {\n                                            const error = asError(reason);\n                                            console.error(error);\n                                        });\n                                }\n                            } else {\n                                ctx.imageAccessorService\n                                    .accessImage(new URL(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString()))\n                                    .then(url => {\n                                        node.thumbnail = url.url.toString();\n                                        ctx.tree.addToDispose(url);\n                                        void ctx.tree.refresh(node.parent);\n                                    })\n                                    .catch(reason => {\n                                        const error = asError(reason);\n                                        console.error(error);\n                                    });\n                            }\n                        }\n                    }\n                }\n            },\n            onRequestComplete: (result, message) => {\n                if (!result) {\n                    console.error(message);\n                }\n            }\n        });\n    }\n}\n\n/**\n * Registers a thumbnail update callback that triggers on the node's first render.\n * When triggered, finds the last draw instance and requests a screenshot for it.\n *\n * @param ctx - Command tree context\n * @param node - Node to register thumbnail update for\n * @param descriptionContext - Description for the requester debug name (e.g., \"render pass 5\", \"dynamic render pass\")\n */\nfunction registerThumbnailUpdate(\n    ctx: CommandTreeContext,\n    node: CommandTreeNode & { thumbnail?: string },\n    descriptionContext: string\n): void {\n    const updateThumbnail = (): void => {\n        const lastDraw = findLastDrawInstanceNode(node);\n        if (lastDraw) {\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', updateThumbnail);\n            const requesterDbgName = `Command tree ${descriptionContext} last draw: ${lastDraw.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(lastDraw), node, requesterDbgName);\n        }\n    };\n    SokatoaLifecycleTreeNode.register(node, 'onWillRender', updateThumbnail);\n}\n\nexport interface CommandRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    renderPassInstanceId: number;\n    renderPassId?: number;\n    renderSubpassEventIds: number[];\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderPassInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.instanceId,\n            renderPassId: element.renderPass,\n            renderSubpassEventIds: [],\n            label: `Render Pass ${element.passIndex}`,\n            parent,\n            resourceType: CommandRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        // A render pass will only contain render subpasses and will always contain at least one subpass\n        const renderSubpassInstances = element.renderSubpassInstanceIds.flatMap(id => {\n            const instance = root.resource.renderSubpassInstances[id];\n            if (!instance) {\n                console.warn(`CommandRenderPassInstanceNode.create: renderSubpassInstance not found for id ${id}`);\n                return [];\n            }\n            return instance;\n        });\n        renderSubpassInstances.forEach(subpass => {\n            if (subpass.beginApiEvent !== node.resource.beginApiEvent) {\n                node.renderSubpassEventIds.push(subpass.beginApiEvent);\n            }\n        });\n        node.children.push(\n            ...renderSubpassInstances.map(instance => {\n                const subpassNode = CommandRenderSubpassInstanceNode.create(ctx, instance, node, baseDynamicStatePromise);\n                return subpassNode;\n            })\n        );\n\n        registerThumbnailUpdate(ctx, node, `render pass ${node.renderPassId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandRenderSubpassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderSubpassInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    renderPassInstanceId: number;\n    renderSubpassInstanceId: number;\n    renderSubpassIndex: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderSubpassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderSubpassInstanceNode {\n    export const RESOURCE_TYPE = 'render-subpass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderSubpassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderSubpassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderSubpassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderSubpassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderSubpassInstanceNode {\n        const node: CommandRenderSubpassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.renderPassInstance,\n            renderSubpassInstanceId: element.instanceId,\n            renderSubpassIndex: element.subpassIndex,\n            label: `Subpass ${element.subpassIndex}`,\n            parent,\n            resourceType: CommandRenderSubpassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this render subpass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference render subpass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a render subpass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.renderSubpassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginRenderSubpassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endRenderSubpassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this render subpass\n        const debugLabelGroupInstances = {\n            array: element.debugLabelGroupInstanceIds.flatMap(id => {\n                const result = root.resource.debugLabelGroupInstances[id];\n                if (!result) {\n                    console.warn(`Missing debugLabelGroupInstances for ${id}.`);\n                    return [];\n                }\n                return result;\n            }),\n            getSortNumber: (debugLabelGroupInstance: CommandTreeDebugLabelGroupInstance) => debugLabelGroupInstance.beginApiEvent\n        };\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'render subpass');\n\n        return node;\n    }\n}\n\nexport interface CommandDynamicRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeDynamicRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    dynamicRenderPassInstanceId: number;\n    dynamicRenderPassId?: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDynamicRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'dynamic-render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDynamicRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDynamicRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDynamicRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDynamicRenderPassInstanceNode {\n        const node: CommandDynamicRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dynamicRenderPassInstanceId: element.instanceId,\n            label: `Dynamic Render Pass ${element.dynamicPassIndex}`,\n            parent,\n            resourceType: CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this dynamic render pass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this dynamic render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference dynamic render pass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a dynamic render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.dynamicRenderPassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginDynamicRenderPassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endDynamicRenderPassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this dynamic render pass\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDynamicRenderPassInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'dynamic render pass');\n\n        return node;\n    }\n}\n\nasync function createChildEventNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    stateTracker: DynamicStateTracker\n): Promise<number> {\n    let endCommandIndex = commandIndex;\n    const baseDynamicStatePromise = stateTracker.getCurrentState();\n\n    if (command.secondaryCommandBufferExecutionId) {\n        // Look up the execution to get the apiEvent, which is the key for secondaryCommandBufferInstances\n        const execution = root.resource.secondaryCommandBufferExecutions[command.secondaryCommandBufferExecutionId];\n        if (execution) {\n            const secondaryInstances = root.resource.secondaryCommandBufferInstances[execution.apiEvent];\n            if (secondaryInstances && secondaryInstances.length > 0) {\n                const node = await CommandSecondaryCommandBufferExecutionNode.create(\n                    ctx,\n                    secondaryInstances,\n                    parentNode,\n                    endCommandIndex++,\n                    baseDynamicStatePromise,\n                    stateTracker\n                );\n                parentNode.children.push(node);\n            }\n        }\n    } else {\n        endCommandIndex = createDrawOrDispatchChildNode(ctx, command, root, parentNode, commandIndex, baseDynamicStatePromise);\n    }\n    return endCommandIndex;\n}\n\nfunction createDrawOrDispatchChildNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n): number {\n    let currentCommandIndex = commandIndex;\n    let accelerationStructureBuildIndex = 0;\n    let accelerationStructureCopyIndex = 0;\n    if (command) {\n        if (command.drawInstanceId && root.resource.drawInstances[command.drawInstanceId]) {\n            parentNode.children.push(\n                CommandDrawInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.dispatchInstanceId && root.resource.dispatchInstances[command.dispatchInstanceId]) {\n            parentNode.children.push(\n                CommandDispatchInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.meshTaskInstanceId && root.resource.meshTaskInstances[command.meshTaskInstanceId]) {\n            parentNode.children.push(\n                CommandMeshTaskInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.clusterInstanceId && root.resource.clusterInstances[command.clusterInstanceId]) {\n            parentNode.children.push(\n                CommandClusterInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.raytracingInstanceId && root.resource.raytracingInstances[command.raytracingInstanceId]) {\n            parentNode.children.push(\n                CommandRaytracingInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (\n            command.accelerationStructureBuildInstanceId &&\n            root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureBuildNode.create(\n                    root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]!,\n                    parentNode,\n                    accelerationStructureBuildIndex++\n                )\n            );\n        } else if (\n            command.accelerationStructureCopyInstanceId &&\n            root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureCopyNode.create(\n                    root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]!,\n                    parentNode,\n                    accelerationStructureCopyIndex++\n                )\n            );\n        } else if (command.transferCommandInstanceId && root.resource.transferCommands[command.transferCommandInstanceId]) {\n            parentNode.children.push(\n                CommandTransferCommandNode.create(\n                    root.resource.transferCommands[command.transferCommandInstanceId]!,\n                    parentNode,\n                    currentCommandIndex++\n                )\n            );\n        } else if (command.debugLabelId && root.resource.debugLabels[command.debugLabelId]) {\n            // Only add debug label nodes if this is the BEGIN event (not END event)\n            // The END event has debugLabelId set but should not create a node\n            const debugLabel = root.resource.debugLabels[command.debugLabelId];\n            if (debugLabel && debugLabel.beginApiEvent === command.apiEventId) {\n                // Check if this is a group (has both begin and end and they differ) or just an insert\n                if (debugLabel.endApiEvent && debugLabel.beginApiEvent !== debugLabel.endApiEvent) {\n                    // This is a debug label group - it should be handled by the range processing logic\n                    // Don't create any node here, just skip it\n                    // (The group will be created if it's in debugLabelGroupInstances, or omitted if it crosses boundaries)\n                } else {\n                    // This is a debug label insert - create as simple API event node\n                    parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode));\n                }\n            }\n        } else if (command.commandInstanceId && root.resource.commandInstances[command.commandInstanceId]) {\n            parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode, currentCommandIndex++));\n        }\n    }\n    return currentCommandIndex;\n}\n\nexport interface CommandDrawInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    drawInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDrawInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandDrawInstanceNode {\n    export const RESOURCE_TYPE = 'draw-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDrawInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDrawInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_draw_${element.drawInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDrawInstanceNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDrawInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            drawInstanceId: element.drawInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDrawInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query draw instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n            const requesterDbgName = `Command draw instance ${node.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(node), node, requesterDbgName);\n        });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDrawInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const drawInstanceDynamicStatePromise = batchQuery\n                ? queryDrawInstanceDynamicStateBatched(db, [node.resource.drawInstanceId || 0])\n                : queryDrawInstanceDynamicState(db, [node.resource.drawInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                drawInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.GRAPHICS\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandDispatchInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    dispatchInstanceId: number;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandDispatchInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n    thumbnail?: string;\n}\n\nexport namespace CommandDispatchInstanceNode {\n    export const RESOURCE_TYPE = 'dispatch-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDispatchInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDispatchInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_dispatch_${element.dispatchInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDispatchInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandDispatchInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dispatchInstanceId: element.dispatchInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDispatchInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query dispatch instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for dispatch nodes\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command dispatch instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDispatchInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const dispatchInstanceDynamicStatePromise = batchQuery\n                ? queryDispatchInstanceDynamicStateBatched(db, [node.resource.dispatchInstanceId || 0])\n                : queryDispatchInstanceDynamicState(db, [node.resource.dispatchInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                dispatchInstanceDynamicStatePromise,\n                PipelineBindPoint.COMPUTE,\n                PipelineBindPointShaderStageFlags.COMPUTE\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandMeshTaskInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    meshTaskInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandMeshTaskInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandMeshTaskInstanceNode {\n    export const RESOURCE_TYPE = 'mesh-task-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandMeshTaskInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandMeshTaskInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_meshtask_${element.meshTaskInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandMeshTaskInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandMeshTaskInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            meshTaskInstanceId: element.meshTaskInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandMeshTaskInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query mesh instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for mesh task dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command mesh instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandMeshTaskInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const meshTaskInstanceDynamicStatePromise = batchQuery\n                ? queryMeshTaskInstanceDynamicStateBatched(db, [node.resource.meshTaskInstanceId || 0])\n                : queryMeshTaskInstanceDynamicState(db, [node.resource.meshTaskInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                meshTaskInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.TASK_MESH\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandClusterInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    clusterInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandClusterInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandClusterInstanceNode {\n    export const RESOURCE_TYPE = 'cluster-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandClusterInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandClusterInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_cluster_${element.clusterInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandClusterInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandClusterInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            clusterInstanceId: element.clusterInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandClusterInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query cluster instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for cluster dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command cluster instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandClusterInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const clusterInstanceDynamicStatePromise = batchQuery\n                ? queryClusterInstanceDynamicStateBatched(db, [node.resource.clusterInstanceId || 0])\n                : queryClusterInstanceDynamicState(db, [node.resource.clusterInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                clusterInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.CLUSTER\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandRaytracingInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    raytracingInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandRaytracingInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandRaytracingInstanceNode {\n    export const RESOURCE_TYPE = 'raytracing-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandRaytracingInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRaytracingInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_raytracing_${element.raytracingInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRaytracingInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRaytracingInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            raytracingInstanceId: element.raytracingInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandRaytracingInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query raytracing instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for raytracing dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command raytracing instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandRaytracingInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const raytracingInstanceDynamicStatePromise = batchQuery\n                ? queryRaytracingInstanceDynamicStateBatched(db, [node.resource.raytracingInstanceId || 0])\n                : queryRaytracingInstanceDynamicState(db, [node.resource.raytracingInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                raytracingInstanceDynamicStatePromise,\n                PipelineBindPoint.RAY_TRACING,\n                PipelineBindPointShaderStageFlags.RAY_TRACING\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport function getQueueSubmitId(node: CommandTreeNode): number | undefined {\n    let currentNode: CompositeTreeNode | undefined;\n    if (\n        CommandEmptyNode.is(node) ||\n        CommandApiEventNode.is(node) ||\n        CommandTreeDrawOrDispatchNode.is(node) ||\n        CommandAccelerationStructureBuildNode.is(node) ||\n        CommandAccelerationStructureCopyNode.is(node) ||\n        CommandTransferCommandNode.is(node)\n    ) {\n        currentNode = node.parent;\n    } else if (CommandQueuePresentNode.is(node) || CommandQueueDebugLabelNode.is(node)) {\n        return undefined;\n    } else {\n        currentNode = node;\n    }\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(currentNode, CommandQueueSubmitNode.is);\n    return queueSubmitNode ? queueSubmitNode.resource.submissionId : undefined;\n}\n\nexport function findLastDrawInstanceNode(node: CommandTreeNode): CommandDrawInstanceNode | undefined {\n    if (CommandDrawInstanceNode.is(node)) {\n        return node;\n    }\n    let lastDraw: CommandDrawInstanceNode | undefined;\n    if (!CommandDrawInstanceNode.is(node) && ExpandableTreeNode.is(node)) {\n        for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n            lastDraw = findLastDrawInstanceNode(node.children[commandIndex]);\n            if (lastDraw) {\n                break;\n            }\n        }\n    }\n    return lastDraw;\n}\n\nexport function createExecuteCommandsApiResources(\n    node: CommandSecondaryCommandBufferExecutionNode,\n    primaryNode: CommandCommandBufferInstanceNode,\n    queueSubmitNode: CommandQueueSubmitNode,\n    specificSecondaryCommandBufferBeginId?: number // If provided, only include this specific secondary CB\n): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    // findParentNode checks the given node for its type so we have to start looking from this node's parent\n    // otherwise we run into infinite recursion\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node.parent,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n\n    // Collect secondary command buffer begin IDs from the children\n    const commandBufferBeginIds: number[] = [];\n    if (specificSecondaryCommandBufferBeginId !== undefined) {\n        // Only include the specific secondary CB that was requested\n        commandBufferBeginIds.push(specificSecondaryCommandBufferBeginId);\n    } else {\n        // Include all secondary CBs (for when the execution node itself requests a thumbnail)\n        for (const child of node.children) {\n            if (CommandCommandBufferInstanceNode.is(child)) {\n                commandBufferBeginIds.push(child.resource.beginApiEvent);\n            }\n        }\n    }\n\n    const resources: ApiResources[] = [];\n    if (secondaryCommandBufferExecutionNode) {\n        const renderpassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n            renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n            CommandSecondaryCommandBufferExecutionNode.is\n        );\n\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: secondaryCommandBufferExecutionNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n                renderpassSecondaryCommandBufferExecutionNode &&\n                renderpassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n        const executionResources = createExecuteCommandsApiResources(secondaryCommandBufferExecutionNode, primaryNode, queueSubmitNode);\n        if (executionResources.length > 0) {\n            resources.push(...executionResources);\n        }\n    } else {\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: primaryNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                renderPassInstanceNode || dynamicRenderPassInstanceNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n    }\n    return resources;\n}\n\nexport function createDrawApiResources(node: CommandDrawInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    // This will find the immediate parent command buffer (secondary if in a secondary CB, primary otherwise)\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n\n    const resources: ApiResources[] = [];\n    if (\n        (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n        queueSubmitNode &&\n        commandBufferInstanceNode &&\n        primaryCommandBufferInstanceNode\n    ) {\n        if (secondaryCommandBufferExecutionNode) {\n            const renderPassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n                CommandSecondaryCommandBufferExecutionNode.is\n            );\n\n            // Add draw resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses:\n                    renderPassSecondaryCommandBufferExecutionNode &&\n                    renderPassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                        ? [\n                              {\n                                  beginId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                                  subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                                  endId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                        dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                              }\n                          ]\n                        : []\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses: [\n                    {\n                        beginId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                        subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                        endId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.endApiEvent || dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                    }\n                ]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createComputeApiResources(node: CommandDispatchInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add dispatch resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createTraceRaysApiResources(node: CommandRaytracingInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTransferNode = CommandAccelerationStructureBuildNode | CommandAccelerationStructureCopyNode | CommandTransferCommandNode;\n\nexport function createTransferApiResources(node: CommandTransferNode): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    let transferEvent: number = 0;\n    if (CommandAccelerationStructureBuildNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureBuildNode).resource.buildApiEvent;\n    } else if (CommandAccelerationStructureCopyNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureCopyNode).resource.copyApiEvent;\n    } else if (CommandTransferCommandNode.is(node)) {\n        transferEvent = (node as CommandTransferCommandNode).resource.transferApiEvent;\n    }\n\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTreeNode =\n    | CommandFrameNode\n    | CommandEmptyNode\n    | CommandApiEventNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandQueuePresentNode\n    | CommandQueueDebugLabelGroupNode\n    | CommandQueueDebugLabelNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandEmptyNode.is(node) ||\n            CommandApiEventNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandQueuePresentNode.is(node) ||\n            CommandQueueDebugLabelGroupNode.is(node) ||\n            CommandQueueDebugLabelNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n\n    export function findApiEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandSecondaryCommandBufferExecutionNode.is(current)) {\n            // For secondary command buffer execution nodes, return the VkCmdExecuteCommands apiEvent\n            // rather than the VkCommandBufferBegin apiEvent\n            return current.resource.apiEvent;\n        } else if (CommandTreeRangeNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (\n            CommandApiEventNode.is(current) ||\n            CommandQueueSubmitNode.is(current) ||\n            CommandQueuePresentNode.is(current) ||\n            CommandQueueDebugLabelNode.is(current)\n        ) {\n            return current.apiEventId;\n        } else if (CommandQueueDebugLabelGroupNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (CommandAccelerationStructureBuildNode.is(current)) {\n            return current.resource.buildApiEvent;\n        } else if (CommandAccelerationStructureCopyNode.is(current)) {\n            return current.resource.copyApiEvent;\n        } else if (CommandTransferCommandNode.is(current)) {\n            return current.apiEventId;\n        } else if (CommandTreeDrawOrDispatchNode.is(current)) {\n            return current.resource.apiEventId;\n        }\n        return undefined;\n    }\n\n    export function findFilterEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandFrameNode.is(current)) {\n            return current.resource.beginApiEvent;\n        }\n        let maybeQueueSubmitOrPresent: TreeNode | undefined = current;\n        while (\n            maybeQueueSubmitOrPresent !== undefined &&\n            !(\n                CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueuePresentNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)\n            )\n        ) {\n            maybeQueueSubmitOrPresent = maybeQueueSubmitOrPresent.parent;\n        }\n        let queueSubmitEventId: number | undefined;\n        if (maybeQueueSubmitOrPresent !== undefined) {\n            if (CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) || CommandQueuePresentNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            } else if (CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.resource.beginApiEvent;\n            } else if (CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            }\n        }\n        return queueSubmitEventId;\n    }\n\n    export function findRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const renderPassNode = findParentNode<CommandRenderPassInstanceNode>(current, CommandRenderPassInstanceNode.is);\n        return renderPassNode ? renderPassNode.renderPassInstanceId : undefined;\n    }\n\n    export function findDynamicRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const dynamicRenderPassNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n            current,\n            CommandDynamicRenderPassInstanceNode.is\n        );\n        return dynamicRenderPassNode ? dynamicRenderPassNode.dynamicRenderPassInstanceId : undefined;\n    }\n\n    export function findDrawInstanceId(current?: CommandTreeNode): number | undefined {\n        const drawInstanceNode = findParentNode<CommandDrawInstanceNode>(current, CommandDrawInstanceNode.is);\n        return drawInstanceNode ? drawInstanceNode.drawInstanceId : undefined;\n    }\n\n    export function findDispatchInstanceId(current?: CommandTreeNode): number | undefined {\n        const dispatchInstanceNode = findParentNode<CommandDispatchInstanceNode>(current, CommandDispatchInstanceNode.is);\n        return dispatchInstanceNode ? dispatchInstanceNode.dispatchInstanceId : undefined;\n    }\n\n    export function findMeshTaskInstanceId(current?: CommandTreeNode): number | undefined {\n        const meshTaskInstanceNode = findParentNode<CommandMeshTaskInstanceNode>(current, CommandMeshTaskInstanceNode.is);\n        return meshTaskInstanceNode ? meshTaskInstanceNode.meshTaskInstanceId : undefined;\n    }\n\n    export function findClusterInstanceId(current?: CommandTreeNode): number | undefined {\n        const clusterInstanceNode = findParentNode<CommandClusterInstanceNode>(current, CommandClusterInstanceNode.is);\n        return clusterInstanceNode ? clusterInstanceNode.clusterInstanceId : undefined;\n    }\n\n    export function findRaytracingInstanceId(current?: CommandTreeNode): number | undefined {\n        const raytracingInstanceNode = findParentNode<CommandRaytracingInstanceNode>(current, CommandRaytracingInstanceNode.is);\n        return raytracingInstanceNode ? raytracingInstanceNode.raytracingInstanceId : undefined;\n    }\n\n    export function findAccelerationBuildInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelBuildNode = findParentNode<CommandAccelerationStructureBuildNode>(current, CommandAccelerationStructureBuildNode.is);\n        return accelBuildNode ? accelBuildNode.buildInstanceId : undefined;\n    }\n\n    export function findAccelerationCopyInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelCopyNode = findParentNode<CommandAccelerationStructureCopyNode>(current, CommandAccelerationStructureCopyNode.is);\n        return accelCopyNode ? accelCopyNode.copyInstanceId : undefined;\n    }\n\n    export function findTransferCommandInstanceId(current?: CommandTreeNode): number | undefined {\n        const transferCommandNode = findParentNode<CommandTransferCommandNode>(current, CommandTransferCommandNode.is);\n        return transferCommandNode ? transferCommandNode.transferCommandInstanceId : undefined;\n    }\n\n    export function findMergedDynamicStatePromise(\n        current: CommandTreeNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> | undefined {\n        let maybeDrawOrDispatchInstance: TreeNode | undefined = current;\n        while (maybeDrawOrDispatchInstance !== undefined && !CommandTreeDrawOrDispatchNode.is(maybeDrawOrDispatchInstance)) {\n            maybeDrawOrDispatchInstance = maybeDrawOrDispatchInstance.parent;\n        }\n        let mergedDynamicStatePromise: Promise<DynamicStateEntry[]> | undefined;\n        if (maybeDrawOrDispatchInstance !== undefined && CommandDrawInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDrawInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandDispatchInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDispatchInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandMeshTaskInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandMeshTaskInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandClusterInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandClusterInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandRaytracingInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandRaytracingInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        }\n        return mergedDynamicStatePromise;\n    }\n\n    export function getRoot(node?: CompositeTreeNode | CommandRootNode | CommandTreeNode): CommandRootNode | undefined {\n        return findParentNode<CommandRootNode>(node, CommandRootNode.is);\n    }\n\n    export function getDbId(node: CommandRootNode | CommandTreeNode): number {\n        return getRoot(node)?.dbId ?? -1;\n    }\n\n    type GeneralizableNodes =\n        | typeof CommandApiEventNode\n        | typeof CommandClusterInstanceNode\n        | typeof CommandCommandBufferInstanceNode\n        | typeof CommandDispatchInstanceNode\n        | typeof CommandDrawInstanceNode\n        | typeof CommandEmptyNode\n        | typeof CommandFrameNode\n        | typeof CommandMeshTaskInstanceNode\n        | typeof CommandQueuePresentNode\n        | typeof CommandQueueSubmitNode\n        | typeof CommandQueueDebugLabelGroupNode\n        | typeof CommandQueueDebugLabelNode\n        | typeof CommandAccelerationStructureBuildNode\n        | typeof CommandAccelerationStructureCopyNode\n        | typeof CommandTransferCommandNode\n        | typeof CommandRaytracingInstanceNode\n        | typeof CommandRenderPassInstanceNode\n        | typeof CommandRenderSubpassInstanceNode\n        | typeof CommandDynamicRenderPassInstanceNode\n        | typeof CommandDebugLabelGroupNode;\n\n    /**\n     * An aggregate type label for command-tree nodes, roughly corresponding to some of the union\n     * types defined in this module.\n     */\n    export type GeneralizedType = GeneralizableNodes['GENERALIZED_TYPE'];\n\n    /**\n     * Query the generalized type of a given node, if it is a Command Tree node.\n     *\n     * @param node a tree node that may or may not be a `CommandTreeNode`\n     * @return its generalized type, or `undefined` if it isn't a `CommandTreeNode`\n     */\n    export function getGeneralizedNodeType(node: TreeNode): GeneralizedType | undefined {\n        const resourceType = 'resourceType' in node ? node.resourceType : undefined;\n        if (!resourceType) {\n            return CommandEmptyNode.is(node) ? 'empty' : undefined;\n        }\n\n        switch (resourceType) {\n            case 'frame':\n            case 'command-buffer-instance':\n            case 'render-pass-instance':\n            case 'render-subpass-instance':\n            case 'secondary-command-buffer-execution':\n            case 'debug-label-group':\n                return 'range';\n            case 'queue-submit':\n            case 'queue-present':\n                return 'queue';\n            case 'acceleration-structure-build':\n                return 'acceleration-structure-build';\n            case 'acceleration-structure-copy':\n                return 'acceleration-structure-copy';\n            case 'transfer-command':\n                return 'transfer-command';\n            case 'draw-instance':\n            case 'dispatch-instance':\n            case 'mesh-task-instance':\n            case 'cluster-instance':\n            case 'raytracing-instance':\n                return 'draw-or-dispatch';\n            case 'api-event':\n                return 'api-event';\n            default:\n                return undefined;\n        }\n    }\n\n    /** Type assertion for a range-type node. */\n    export function generalize(node: TreeNode, type: 'range'): asserts node is CommandTreeRangeNode;\n    /** Type assertion for a queue-type node. */\n    export function generalize(node: TreeNode, type: 'queue'): asserts node is CommandQueueSubmitNode | CommandQueuePresentNode;\n    /** Type assertion for a queue-debug-label-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'queue-debug-label'\n    ): asserts node is CommandQueueDebugLabelGroupNode | CommandQueueDebugLabelNode;\n    /** Type assertion for a acceleration-structure-build-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-build'): asserts node is CommandAccelerationStructureBuildNode;\n    /** Type assertion for a acceleration-structure-copy-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-copy'): asserts node is CommandAccelerationStructureCopyNode;\n    /** Type assertion for a transfer-command-type node. */\n    export function generalize(node: TreeNode, type: 'transfer-command'): asserts node is CommandTransferCommandNode;\n    /** Type assertion for a draw-or-dispatch-type node. */\n    export function generalize(node: TreeNode, type: 'draw-or-dispatch'): asserts node is CommandTreeDrawOrDispatchNode;\n    /** Type assertion for an api-event-type node. */\n    export function generalize(node: TreeNode, type: 'api-event'): asserts node is CommandApiEventNode;\n    /** Type assertion for a draw-or-dispatch- or api-event-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'draw-or-dispatch' | 'api-event'\n    ): asserts node is CommandTreeDrawOrDispatchNode | CommandApiEventNode;\n    /** Type assertion for an empty-type node. */\n    export function generalize(node: TreeNode, type: 'empty'): asserts node is CommandEmptyNode;\n    export function generalize(node: TreeNode, _type: GeneralizedType): asserts node is CommandTreeNode {\n        // Pass\n    }\n}\n\nexport type CommandTreeRangeNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeRangeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeRangeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n}\n\nexport type CommandTreeDrawOrDispatchNode =\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode;\n\nexport namespace CommandTreeDrawOrDispatchNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeDrawOrDispatchNode {\n        return (\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node)\n        );\n    }\n}\n\ninterface ArrayWithSortNumber<RangeType> {\n    array: RangeType[];\n    getSortNumber(element: RangeType): number;\n}\n\ntype AllRangeTypes =\n    | CommandTreeDebugLabelGroupInstance\n    | CommandTreeRenderPassInstance\n    | CommandTreeRenderSubpassInstance\n    | CommandTreeDynamicRenderPassInstance;\n\ntype CommandTreeRangeParentNode =\n    | CommandRenderPassInstanceNode\n    | CommandCommandBufferInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandDebugLabelGroupNode;\n\nfunction findNextRangeElementToProcess<RangeType>(...arrays: ArrayWithSortNumber<RangeType>[]): RangeType | undefined {\n    // designate which array is the api event array vs a range array\n    // when processing a range, shift off any api events that are within the range\n    // so they aren't processed (because they actually reside within a sub-group)\n\n    const arraysToProcess: ArrayWithSortNumber<RangeType>[] = [];\n    arrays.forEach(arr => {\n        if (arr.array.length) {\n            arraysToProcess.push(arr);\n        }\n    });\n\n    if (!arraysToProcess.length) {\n        return undefined;\n    }\n\n    // get the sort number of the first element of each array and sort them\n    const sortedElements = arraysToProcess\n        .map(array => ({ subarray: array.array, sortNumber: array.getSortNumber(array.array[0]) }))\n        .sort((a, b) => a.sortNumber - b.sortNumber);\n\n    return sortedElements[0].subarray.shift();\n}\n\n/**\n * Process commands and ranges together in API event order.\n * For each range element, creates child nodes for commands that come before it,\n * skips commands that fall within the range, and creates a node for the range itself.\n * After processing all ranges, any remaining commands are processed.\n *\n * @param ctx - Command tree context\n * @param root - Root node\n * @param parentNode - Parent node to add children to\n * @param apiEventCommandArray - Array of commands sorted by API event ID (will be mutated)\n * @param childCommandIndex - Starting index for child commands\n * @param baseDynamicStatePromise - Promise for dynamic state\n * @param createRangeNode - Callback to create a node for each range element\n * @param rangeArrays - Variable number of range arrays to process together\n * @returns The final child command index\n */\nasync function createChildEventNodesForRange<RangeType extends { beginApiEvent: number; endApiEvent?: number }>(\n    ctx: CommandTreeContext,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    apiEventCommandArray: CommandTreeApiEvent[],\n    childCommandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n    createRangeNode: (rangeElement: RangeType, parentNode: CommandTreeRangeParentNode) => void,\n    ...rangeArrays: ArrayWithSortNumber<RangeType>[]\n): Promise<number> {\n    const stateTracker = new DynamicStateTracker(baseDynamicStatePromise);\n    let nextRangeElement: RangeType | undefined;\n    let priorRangeEndApiEvent: number | undefined;\n\n    while ((nextRangeElement = findNextRangeElementToProcess<RangeType>(...rangeArrays))) {\n        // create a node for any command that comes BEFORE the next range element\n        while (apiEventCommandArray.length && apiEventCommandArray[0].apiEventId < nextRangeElement.beginApiEvent) {\n            const command = apiEventCommandArray.shift();\n            childCommandIndex = await createChildEventNode(ctx, command!, root, parentNode, childCommandIndex, stateTracker);\n        }\n\n        // shift off any command that falls WITHIN next range since it will be processed when creating next range node\n        while (\n            apiEventCommandArray.length &&\n            nextRangeElement.endApiEvent !== undefined &&\n            apiEventCommandArray[0].apiEventId >= nextRangeElement.beginApiEvent &&\n            apiEventCommandArray[0].apiEventId <= nextRangeElement.endApiEvent\n        ) {\n            apiEventCommandArray.shift();\n        }\n\n        // skip next range if it falls within the prior range since it will be processed when creating prior range node\n        if (\n            priorRangeEndApiEvent !== undefined &&\n            nextRangeElement.endApiEvent !== undefined &&\n            nextRangeElement.endApiEvent <= priorRangeEndApiEvent\n        ) {\n            continue;\n        }\n        priorRangeEndApiEvent = nextRangeElement.endApiEvent;\n\n        // create a node for the next range element\n        createRangeNode(nextRangeElement, parentNode);\n    }\n\n    // process any remaining command elements after all range elements have been processed\n    for (const command of apiEventCommandArray) {\n        childCommandIndex = await createChildEventNode(ctx, command, root, parentNode, childCommandIndex, stateTracker);\n    }\n\n    return childCommandIndex;\n}\n\n/**\n * Find node from descendent node for which isNode is true\n */\nexport const findParentNode = <T extends TreeNode>(\n    node: TreeNode | undefined,\n    isNode: (node: TreeNode | undefined) => node is T\n): T | undefined => {\n    let targetNode: TreeNode | undefined = node;\n    while (targetNode && targetNode.parent && !isNode(targetNode)) {\n        targetNode = targetNode.parent;\n    }\n\n    return targetNode && isNode(targetNode) ? targetNode : undefined;\n};\n\n/**\n * Find the primary command buffer instance node from a given command buffer instance node.\n * If the given node is in a secondary command buffer, traverses up through nested secondary\n * command buffers until finding the primary command buffer (one with no parent execution node).\n * If the given node is already in a primary command buffer, returns it as-is.\n */\nexport const findPrimaryCommandBufferInstanceNode = (\n    commandBufferInstanceNode: CommandCommandBufferInstanceNode | undefined,\n    secondaryCommandBufferExecutionNode: CommandSecondaryCommandBufferExecutionNode | undefined\n): CommandCommandBufferInstanceNode | undefined => {\n    let primaryCommandBufferInstanceNode = commandBufferInstanceNode;\n    if (secondaryCommandBufferExecutionNode) {\n        let currentExecution: CommandSecondaryCommandBufferExecutionNode | undefined = secondaryCommandBufferExecutionNode;\n        while (currentExecution) {\n            const parentCB: CommandCommandBufferInstanceNode | undefined = findParentNode<CommandCommandBufferInstanceNode>(\n                currentExecution,\n                CommandCommandBufferInstanceNode.is\n            );\n            if (parentCB) {\n                primaryCommandBufferInstanceNode = parentCB;\n                // Check if this CB is also inside another secondary execution (nested case)\n                currentExecution = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                    parentCB.parent,\n                    CommandSecondaryCommandBufferExecutionNode.is\n                );\n            } else {\n                break;\n            }\n        }\n    }\n    return primaryCommandBufferInstanceNode;\n};\n\n/**\n * find a frame node from descendent node or self\n */\nexport const findFrameNode = (node: TreeNode): CommandFrameNode | undefined => findParentNode<CommandFrameNode>(node, CommandFrameNode.is);\n\n@injectable()\nexport class CommandTree extends BulkTree implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTree {\n        return tree instanceof CommandTree;\n    }\n\n    @inject(CaptureDatasetWidgetProfile)\n    protected readonly profile: CaptureDatasetWidgetProfile;\n    @inject(CaptureDatasetWidgetContext)\n    protected readonly context: CaptureDatasetWidgetContext;\n\n    @inject(CommandTreeDataQueriedRootProvider)\n    protected readonly rootProvider: CommandTreeDataQueriedRootProvider;\n    @inject(GFXRQueryBuilderService)\n    protected readonly gfxrQueryBuilderService: GFXRQueryBuilderService;\n\n    protected override _root: CommandRootNode | undefined;\n\n    // Back-reference to the model that manages this tree\n    model?: CommandTreeModel;\n\n    protected readonly onStructureChangedEmitter = new Emitter<TreeNode | undefined>();\n    readonly onStructureChanged = this.onStructureChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this._root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        super.root = root;\n        // Set back-reference from root to tree\n        if (root) {\n            root.tree = this;\n        }\n    }\n\n    async initTree(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        this.root = await this.rootProvider.provide(dbId, { tree: this }, options, createDrawOrDispatchChildren);\n\n        // tree structure is fully built at this point, report structure change\n        this.onStructureChangedEmitter.fire(undefined);\n    }\n\n    async refreshStructure(node?: CompositeTreeNode, cancellationToken?: CancellationToken): Promise<void> {\n        await this.refresh(node, cancellationToken);\n        this.fireStructureChanged(node);\n    }\n\n    fireStructureChanged(node?: TreeNode): void {\n        this.onStructureChangedEmitter.fire(node);\n    }\n\n    addToDispose(disposable: Disposable): void {\n        this.toDispose.push(disposable);\n    }\n\n    override dispose(): void {\n        this.rootProvider.dispose();\n        super.dispose();\n    }\n}\n\n@injectable()\nexport class CommandTreeModelPreferenceStateAccessImpl implements CommandTreePreferenceState.Access {\n    private readonly models = new Map<CommandTree, CommandTreeModel>();\n\n    private readonly commandTreeStateChangedEmitter = new Emitter<{ tree: CommandTree; state: CommandTreePreferenceState }>();\n    readonly onCommandTreeStateChanged = this.commandTreeStateChangedEmitter.event;\n\n    getCommandTreeState(tree: CommandTree): CommandTreePreferenceState {\n        return this.models.get(tree)?.getPreferenceState() ?? {};\n    }\n\n    fireCommandTreeStateChanged(tree: CommandTree): void {\n        this.commandTreeStateChangedEmitter.fire({ tree, state: this.getCommandTreeState(tree) });\n    }\n\n    registerCommandTreeModel(tree: CommandTree, model: CommandTreeModel): void {\n        this.models.set(tree, model);\n        this.fireCommandTreeStateChanged(tree);\n    }\n}\n\n@injectable()\nexport class CommandTreeModel extends BulkTreeModel implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTreeModel {\n        return tree instanceof CommandTreeModel;\n    }\n\n    @inject(MiscPreferences)\n    protected readonly miscPreferences: MiscPreferences;\n    @inject(CommandTree) override readonly tree: CommandTree;\n    protected _groupBy: GroupByOptions = GroupByOptions.Frame;\n    private groupByChangedEmitter = new Emitter<GroupByOptions>();\n    readonly onGroupByChanged = this.groupByChangedEmitter.event;\n    protected _isThumbnailEnabled = true;\n    protected _isApiEventIdsEnabled = true;\n    protected _isShowingEmptyRows = false;\n    protected _isVulkanEnabled = true;\n    protected _isDebugNamesEnabled = true;\n    protected _isDebugLabelsEnabled = true;\n    protected _isLinksEnabled = true;\n    protected _isThreadsEnabled = true;\n\n    @inject(FrameRangeSelectionService)\n    protected readonly frameRangeSelectionService: FrameRangeSelectionService;\n\n    @inject(CommandTreeModelPreferenceStateAccessImpl)\n    private readonly preferenceStateAccess: CommandTreeModelPreferenceStateAccessImpl;\n\n    protected isCollapsingSubTree = false;\n\n    // Proxies to prevent calls on sub tree expansion\n    protected readonly onExpansionChangedEmitterProxy = new Emitter<ExpandableTreeNode>();\n    protected readonly onChangedEmitterProxy = new Emitter<void>();\n\n    protected readonly onSubTreeExpansionChangedEmitter = new Emitter<ExpandableTreeNode>();\n    readonly onSubTreeExpansionChanged = this.onSubTreeExpansionChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this.tree.root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        this.tree.root = root;\n    }\n\n    override get onChanged(): Event<void> {\n        return this.onChangedEmitterProxy.event;\n    }\n\n    override get onExpansionChanged(): Event<ExpandableTreeNode> {\n        return this.onExpansionChangedEmitterProxy.event;\n    }\n\n    get onStructureChanged(): Event<TreeNode | undefined> {\n        return this.tree.onStructureChanged;\n    }\n\n    async initModel(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        await this.tree.initTree(dbId, createDrawOrDispatchChildren, options);\n    }\n\n    set groupBy(value: GroupByOptions) {\n        if (this._groupBy !== value) {\n            this._groupBy = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n            this.groupByChangedEmitter.fire(value);\n        }\n    }\n\n    get groupBy(): GroupByOptions {\n        return this._groupBy;\n    }\n\n    /**\n     * Obtain the tree nodes that are the top-level groups according to\n     * the current {@link groupBy} mode.\n     */\n    *groupNodes(): IterableIterator<CompositeTreeNode> {\n        if (!this.root) {\n            return;\n        }\n\n        const group = this.groupBy;\n        const treeIterator = new (class extends DepthFirstTreeIterator {\n            protected override children(node: TreeNode): TreeNode[] | undefined {\n                // Prune group nodes because we needn't look in them for more groups\n                return CommandTreeModel.isOfGroup(node, group) ? undefined : super.children(node);\n            }\n        })(this.root);\n\n        for (const next of treeIterator) {\n            if (CommandTreeModel.isOfGroup(next, group)) {\n                yield next;\n            }\n        }\n    }\n\n    set isApiEventIdsEnabled(value: boolean) {\n        if (this._isApiEventIdsEnabled !== value) {\n            this._isApiEventIdsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isApiEventIdsEnabled(): boolean {\n        return this._isApiEventIdsEnabled;\n    }\n\n    set isShowingEmptyRows(value: boolean) {\n        if (this._isShowingEmptyRows !== value) {\n            this._isShowingEmptyRows = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isShowingEmptyRows(): boolean {\n        return this._isShowingEmptyRows;\n    }\n\n    set isThumbnailEnabled(value: boolean) {\n        if (this._isThumbnailEnabled !== value) {\n            this._isThumbnailEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThumbnailEnabled(): boolean {\n        return this._isThumbnailEnabled;\n    }\n\n    set isVulkanEnabled(value: boolean) {\n        if (this._isVulkanEnabled !== value) {\n            this._isVulkanEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isVulkanEnabled(): boolean {\n        return this._isVulkanEnabled;\n    }\n\n    set isDebugNamesEnabled(value: boolean) {\n        if (this._isDebugNamesEnabled !== value) {\n            this._isDebugNamesEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugNamesEnabled(): boolean {\n        return this._isDebugNamesEnabled;\n    }\n\n    set isDebugLabelsEnabled(value: boolean) {\n        if (this._isDebugLabelsEnabled !== value) {\n            this._isDebugLabelsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugLabelsEnabled(): boolean {\n        return this._isDebugLabelsEnabled;\n    }\n\n    set isLinksEnabled(value: boolean) {\n        if (this._isLinksEnabled !== value) {\n            this._isLinksEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isLinksEnabled(): boolean {\n        return this._isLinksEnabled;\n    }\n\n    set isThreadsEnabled(value: boolean) {\n        if (this._isThreadsEnabled !== value) {\n            this._isThreadsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThreadsEnabled(): boolean {\n        return this._isThreadsEnabled;\n    }\n\n    getPreferenceState(nonDefaultOnly = false): CommandTreePreferenceState {\n        const result: CommandTreePreferenceState = {};\n\n        if (!nonDefaultOnly || this.groupBy !== this.miscPreferences[MiscPrefs.GroupBy]) {\n            result.groupBy = this.groupBy;\n        }\n        if (!nonDefaultOnly || this.isApiEventIdsEnabled !== this.miscPreferences[MiscPrefs.ShowApiEventIds]) {\n            result.isApiEventIdsEnabled = this.isApiEventIdsEnabled;\n        }\n        if (!nonDefaultOnly || this.isShowingEmptyRows !== this.miscPreferences[MiscPrefs.ShowEmptyRows]) {\n            result.isShowingEmptyRows = this.isShowingEmptyRows;\n        }\n        if (!nonDefaultOnly || this.isThumbnailEnabled !== this.miscPreferences[MiscPrefs.ShowThumbnails]) {\n            result.isThumbnailEnabled = this.isThumbnailEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugNamesEnabled !== true) {\n            result.isDebugNamesEnabled = this.isDebugNamesEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugLabelsEnabled !== true) {\n            result.isDebugLabelsEnabled = this.isDebugLabelsEnabled;\n        }\n        if (!nonDefaultOnly || this.isLinksEnabled !== true) {\n            result.isLinksEnabled = this.isLinksEnabled;\n        }\n        if (!nonDefaultOnly || this.isThreadsEnabled !== true) {\n            result.isThreadsEnabled = this.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (!nonDefaultOnly || this.isVulkanEnabled !== this.miscPreferences[MiscPrefs.ShowVulkanCalls]) {\n        //     result.isVulkanEnabled = this.isVulkanEnabled;\n        // }\n\n        return result;\n    }\n\n    override restoreState(state: CommandTreeModel.State): void {\n        if (state.groupBy !== undefined) {\n            this.groupBy = state.groupBy;\n        }\n        if (state.isApiEventIdsEnabled !== undefined) {\n            this.isApiEventIdsEnabled = state.isApiEventIdsEnabled;\n        }\n        if (state.isShowingEmptyRows !== undefined) {\n            this.isShowingEmptyRows = state.isShowingEmptyRows;\n        }\n        if (state.isThumbnailEnabled !== undefined) {\n            this.isThumbnailEnabled = state.isThumbnailEnabled;\n        }\n        if (state.isDebugNamesEnabled !== undefined) {\n            this.isDebugNamesEnabled = state.isDebugNamesEnabled;\n        }\n        if (state.isDebugLabelsEnabled !== undefined) {\n            this.isDebugLabelsEnabled = state.isDebugLabelsEnabled;\n        }\n        if (state.isLinksEnabled !== undefined) {\n            this.isLinksEnabled = state.isLinksEnabled;\n        }\n        if (state.isThreadsEnabled !== undefined) {\n            this.isThreadsEnabled = state.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (state.isVulkanEnabled !== undefined) {\n        //     this.isVulkanEnabled = state.isVulkanEnabled;\n        // }\n    }\n    override storeState(): CommandTreeModel.State {\n        return {\n            ...super.storeState(),\n            ...this.getPreferenceState(true)\n        };\n    }\n\n    @postConstruct()\n    protected override init(): void {\n        super.init();\n\n        // Set back-reference from tree to model\n        this.tree.model = this;\n\n        this.toDispose.pushAll([\n            this.onChangedEmitterProxy,\n            this.onExpansionChangedEmitterProxy,\n            this.onSubTreeExpansionChangedEmitter,\n\n            super.onChanged(() => {\n                if (!this.isCollapsingSubTree) {\n                    this.onChangedEmitterProxy.fire();\n                }\n            }),\n            super.onExpansionChanged(node => {\n                if (!this.isCollapsingSubTree) {\n                    this.onExpansionChangedEmitterProxy.fire(node);\n                }\n            })\n        ]);\n\n        this._isApiEventIdsEnabled = this.miscPreferences[MiscPrefs.ShowApiEventIds];\n        this._isShowingEmptyRows = this.miscPreferences[MiscPrefs.ShowEmptyRows];\n        this.isThumbnailEnabled = this.miscPreferences[MiscPrefs.ShowThumbnails];\n        this.groupBy = this.miscPreferences[MiscPrefs.GroupBy];\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // this.isVulkanEnabled = this.miscPreferences[MiscPrefs.ShowVulkanCalls];\n\n        this.preferenceStateAccess.registerCommandTreeModel(this.tree, this);\n    }\n\n    /**\n     * Collapses the entire tree.\n     */\n    async collapseTree(): Promise<void> {\n        const root = this.root;\n\n        if (CompositeTreeNode.is(root) && root.children.length > 0) {\n            await Promise.all(\n                root.children.filter(CompositeTreeNode.is).map((child: CompositeTreeNode) => this.expansionService.collapseAll(child))\n            );\n        }\n    }\n\n    /**\n     * Expands the given node and all its children recursively.\n     */\n    async expandSubTree(node?: Readonly<TreeNode>, includeDrawOrDispatchNodes = false): Promise<void> {\n        node ??= this.root;\n        if (!ExpandableTreeNode.is(node)) {\n            return;\n        }\n\n        try {\n            this.isCollapsingSubTree = true;\n            await this.doExpandSubTree(node, includeDrawOrDispatchNodes);\n            this.onSubTreeExpansionChangedEmitter.fire(node);\n        } finally {\n            this.isCollapsingSubTree = false;\n        }\n    }\n\n    protected async doExpandSubTree(node: TreeNode, includeDrawOrDispatchNodes: boolean): Promise<void> {\n        const YIELD_AFTER_MS = 200;\n\n        const processedNodes = new Set<TreeNode>();\n        const pendingNodes: TreeNode[] = [node];\n        let lastYieldTime = performance.now();\n\n        while (pendingNodes.length > 0) {\n            const currentLevelNodes: ExpandableTreeNode[] = [];\n            const nextLevelNodes: TreeNode[] = [];\n\n            while (pendingNodes.length > 0) {\n                const currentNode = pendingNodes.shift()!;\n                if (processedNodes.has(currentNode)) {\n                    continue;\n                }\n                processedNodes.add(currentNode);\n\n                // stop expansion at draw and dispatch nodes to avoid creation of low-utility nodes\n                // if this logic gets changed please also update enablement of ExpandSubtreeCommand accordingly\n                if (ExpandableTreeNode.is(currentNode) && (includeDrawOrDispatchNodes || !CommandTreeDrawOrDispatchNode.is(currentNode))) {\n                    currentLevelNodes.push(currentNode);\n                }\n            }\n\n            if (currentLevelNodes.length > 0) {\n                const expandedNodes = await this.expansionService.bulkExpandNodes(currentLevelNodes[Symbol.iterator]());\n                for (const expandedNode of expandedNodes) {\n                    await this.ensureLazyChildrenLoaded(expandedNode);\n                    nextLevelNodes.push(...expandedNode.children);\n                }\n                // Also process children of nodes that were already expanded\n                for (const currentNode of currentLevelNodes) {\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\n                        await this.ensureLazyChildrenLoaded(currentNode);\n                        nextLevelNodes.push(...currentNode.children);\n                    }\n                }\n            }\n\n            pendingNodes.push(...nextLevelNodes);\n\n            // Yield control back to the event loop periodically based on time\n            const currentTime = performance.now();\n            if (currentTime - lastYieldTime >= YIELD_AFTER_MS) {\n                await new Promise(resolve => setTimeout(resolve, 0));\n                lastYieldTime = performance.now();\n            }\n        }\n    }\n\n    protected async ensureLazyChildrenLoaded(node: ExpandableTreeNode): Promise<void> {\n        // Find all loading nodes among children\n        const loadingNodes = node.children.filter(CommandEmptyNode.is);\n\n        if (loadingNodes.length === 0) {\n            return;\n        }\n\n        // Trigger load for all loading nodes and wait for them to complete\n        await Promise.all(loadingNodes.map(loadingNode => triggerLazyLoadAndWaitForRemoval(loadingNode)));\n    }\n\n    hasTrailingSuffixes(node: TreeNode): boolean {\n        if (CommandQueueSubmitNode.is(node)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    protected override isVisibleSelectableNode(node: TreeNode): node is SelectableTreeNode {\n        return super.isVisibleSelectableNode(node) && this.isInFrameRange(node);\n    }\n\n    protected isInFrameRange(node: TreeNode): boolean {\n        const frameNode = CommandFrameNode.getCommandFrameNodeContaining(node);\n        if (frameNode === undefined) {\n            return true; // Assume it's good\n        }\n        const range = this.frameRangeSelectionService.frameSpan;\n        if (range === undefined) {\n            return true; // No constraint\n        }\n        return frameNode.frameIndex >= range.startFrame && frameNode.frameIndex <= range.endFrame;\n    }\n}\n\nexport namespace CommandTreeModel {\n    export interface State extends TreeModelImpl.State, CommandTreePreferenceState {}\n\n    /**\n     * Test whether a `node` is of the kind that implements the given `group` mode.\n     * As groups are _a priori_ composite nodes, this additionally infers that type\n     * for the `node` if successful.\n     */\n    export function isOfGroup(node: TreeNode, group: GroupByOptions): node is CompositeTreeNode {\n        switch (group) {\n            case GroupByOptions.Frame:\n                return CommandFrameNode.is(node);\n            case GroupByOptions.RenderPass:\n                return CommandRenderPassInstanceNode.is(node) || CommandDynamicRenderPassInstanceNode.is(node);\n            case GroupByOptions.RenderSubpass:\n                return CommandRenderSubpassInstanceNode.is(node);\n            case GroupByOptions.CommandBuffer:\n                return CommandCommandBufferInstanceNode.is(node);\n            case GroupByOptions.QueueSubmission:\n                return CommandQueueSubmitNode.is(node);\n        }\n    }\n}\n\ntype TextureSupportingNode =\n    | CommandFrameNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode;\n\nexport namespace TextureSupportingNode {\n    export function is(node: CommandTreeNode): node is TextureSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node)\n        );\n    }\n    export function getLast(node: CommandTreeNode): TextureSupportingNode | undefined {\n        if (TextureSupportingNode.is(node)) {\n            return node;\n        }\n        let lastSupportingNode: TextureSupportingNode | undefined;\n        if (CompositeTreeNode.is(node)) {\n            for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n                lastSupportingNode = TextureSupportingNode.getLast(node.children[commandIndex]);\n                if (lastSupportingNode) {\n                    break;\n                }\n            }\n        }\n        return lastSupportingNode;\n    }\n}\n\n/**\n * Union type of all command tree nodes that support thumbnails.\n * Nodes with heavy thumbnail costs are commented out.\n */\ntype ThumbnailSupportingNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandDebugLabelGroupNode\n    | CommandRenderPassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDrawInstanceNode;\n// Below currently have a possibly heavy cost to getting thumbnails\n// | CommandDispatchInstanceNode\n// | CommandMeshTaskInstanceNode\n// | CommandClusterInstanceNode\n// | CommandRaytracingInstanceNode;\n\nexport namespace ThumbnailSupportingNode {\n    export function is(node: CommandTreeNode): node is ThumbnailSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node)\n        );\n    }\n}\n\nfunction getCommandTreeApiEventChildren(eventIds: Array<{ apiEvent: number }>, root: CommandRootNode): CommandTreeApiEvent[] {\n    return eventIds.reduce<CommandTreeApiEvent[]>((collected, id) => {\n        const event = root.resource.apiEvents[id.apiEvent];\n        if (event) {\n            collected.push(event);\n        } else {\n            console.warn(`No event found for ${id.apiEvent}`);\n        }\n        return collected;\n    }, []);\n}\n\nfunction getInstancesByIds<T>(ids: number[], container: PartialRecord<number, T>, source?: string, target?: string): T[] {\n    return ids.flatMap(id => {\n        const instance = container[id];\n        if (!instance) {\n            if (target) {\n                console.warn(`${source ? `${source} expected` : 'Expected'} ${target} with ${id} but found none.`);\n            }\n            return [];\n        }\n        return instance;\n    });\n}\n\n/**\n * Creates an ArrayWithSortNumber for range instances, used by createChildEventNodesForRange.\n * Fetches instances by IDs and provides sorting by beginApiEvent.\n *\n * @param ids - Array of instance IDs to fetch\n * @param container - Container object mapping IDs to instances\n * @param sourceContext - Context string for error messages (e.g., \"CommandRenderPassInstanceNode.create\")\n * @param targetName - Target instance type name for error messages (e.g., \"DebugLabelGroupInstance\")\n * @returns ArrayWithSortNumber object ready for use with getNextRangeElementToProcess\n */\nfunction createRangeInstanceArray<T extends { beginApiEvent: number }>(\n    ids: number[],\n    container: PartialRecord<number, T>,\n    sourceContext: string,\n    targetName: string\n): ArrayWithSortNumber<T> {\n    return {\n        array: getInstancesByIds(ids, container, sourceContext, targetName),\n        getSortNumber: (element: T) => element.beginApiEvent\n    };\n}\n\nexport function createLazyLoadingNode(\n    tree: CommandTree,\n    parent: ExpandableTreeNode,\n    load: (batchQuery?: boolean) => Promise<void>\n): CommandEmptyNode {\n    let loaded = false;\n    let loadingInProgress = false;\n\n    const lazyLoad: (batchQuery?: boolean) => Promise<boolean> = async (batchQuery = true) => {\n        if (loadingInProgress) {\n            return false;\n        }\n\n        if (!loaded) {\n            loaded = true;\n            loadingInProgress = true;\n            loadOnExpanded.dispose();\n            try {\n                await load(batchQuery);\n            } catch (error) {\n                console.error(`LazyLoad failed for node ${parent.id}:`, error);\n            } finally {\n                loadingInProgress = false;\n            }\n            CompositeTreeNode.removeChild(parent, loadingNode);\n            await tree.refreshStructure(parent);\n            return true;\n        }\n        return false;\n    };\n\n    // create lazy loading node\n    const loadingNode: CommandEmptyNode = CommandEmptyNode.create(parent, lazyLoad);\n    CompositeTreeNode.addChild(parent, loadingNode);\n\n    // register for lazy loading when the node is expanded\n    const loadOnExpanded = SokatoaLifecycleTreeNode.register(parent, 'onWillRender', async () => {\n        if (parent.expanded) {\n            // do not batch queries for expansion manually\n            await lazyLoad(false);\n        }\n    });\n    return loadingNode;\n}\n"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "Now I have the full file content. Let me implement the logging statements as specified in the plan. I'll add all the logging statements in the appropriate locations."
            },
            "fallbackMessage": "Now I have the full file content. Let me implement the logging statements as specified in the plan. I'll add all the logging statements in the appropriate locations."
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01KLre1djHvDGFscShxBVzWT",
              "name": "writeFileReplacements",
              "arguments": "{\"path\": \"app/packages/capture/src/browser/command-tree/command-tree-model.ts\", \"replacements\": [{\"oldContent\":\"async function createChildEventNodesForRange<RangeType extends { beginApiEvent: number; endApiEvent?: number }>(\\n    ctx: CommandTreeContext,\\n    root: CommandRootNode,\\n    parentNode: CommandTreeRangeParentNode,\\n    apiEventCommandArray: CommandTreeApiEvent[],\\n    childCommandIndex: number,\\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\\n    createRangeNode: (rangeElement: RangeType, parentNode: CommandTreeRangeParentNode) => void,\\n    ...rangeArrays: ArrayWithSortNumber<RangeType>[]\\n): Promise<number> {\\n    const stateTracker = new DynamicStateTracker(baseDynamicStatePromise);\",\"newContent\":\"async function createChildEventNodesForRange<RangeType extends { beginApiEvent: number; endApiEvent?: number }>(\\n    ctx: CommandTreeContext,\\n    root: CommandRootNode,\\n    parentNode: CommandTreeRangeParentNode,\\n    apiEventCommandArray: CommandTreeApiEvent[],\\n    childCommandIndex: number,\\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\\n    createRangeNode: (rangeElement: RangeType, parentNode: CommandTreeRangeParentNode) => void,\\n    ...rangeArrays: ArrayWithSortNumber<RangeType>[]\\n): Promise<number> {\\n    console.log(`JF: createChildEventNodesForRange START for parent ${parentNode.id}, apiEventCommandArray length: ${apiEventCommandArray.length}`);\\n    const stateTracker = new DynamicStateTracker(baseDynamicStatePromise);\"},{\"oldContent\":\"    // process any remaining command elements after all range elements have been processed\\n    for (const command of apiEventCommandArray) {\\n        childCommandIndex = await createChildEventNode(ctx, command, root, parentNode, childCommandIndex, stateTracker);\\n    }\\n\\n    return childCommandIndex;\\n}\",\"newContent\":\"    // process any remaining command elements after all range elements have been processed\\n    for (const command of apiEventCommandArray) {\\n        childCommandIndex = await createChildEventNode(ctx, command, root, parentNode, childCommandIndex, stateTracker);\\n    }\\n\\n    console.log(`JF: createChildEventNodesForRange END for parent ${parentNode.id}, final children count: ${parentNode.children.length}`);\\n    return childCommandIndex;\\n}\"},{\"oldContent\":\"        createChildEventNodesForRange<AllRangeTypes>(\\n            ctx,\\n            root,\\n            node,\\n            apiEventCommandArray,\\n            0,\\n            baseDynamicStatePromise,\\n            (rangeElement, parentNode) => {\\n                if ('labelId' in rangeElement) {\\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\\n                    parentNode.children.push(debugLabelGroupNode);\\n                } else if ('passIndex' in rangeElement) {\\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(\\n                        ctx,\\n                        rangeElement,\\n                        parentNode,\\n                        baseDynamicStatePromise\\n                    );\\n                    parentNode.children.push(renderPassInstanceNode);\\n                } else if ('subpassIndex' in rangeElement) {\\n                    const renderSubpassInstanceNode = CommandRenderSubpassInstanceNode.create(\\n                        ctx,\\n                        rangeElement,\\n                        parentNode,\\n                        baseDynamicStatePromise\\n                    );\\n                    parentNode.children.push(renderSubpassInstanceNode);\\n                } else if ('dynamicPassIndex' in rangeElement) {\\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\\n                        ctx,\\n                        rangeElement,\\n                        parentNode,\\n                        baseDynamicStatePromise\\n                    );\\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\\n                }\\n            },\\n            debugLabelGroupInstances,\\n            renderPassInstances,\\n            renderSubpassInstances,\\n            dynamicRenderPassInstances\\n        )\\n            .then(() => {\\n                // Children populated asynchronously\\n            })\",\"newContent\":\"        createChildEventNodesForRange<AllRangeTypes>(\\n            ctx,\\n            root,\\n            node,\\n            apiEventCommandArray,\\n            0,\\n            baseDynamicStatePromise,\\n            (rangeElement, parentNode) => {\\n                if ('labelId' in rangeElement) {\\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\\n                    parentNode.children.push(debugLabelGroupNode);\\n                } else if ('passIndex' in rangeElement) {\\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(\\n                        ctx,\\n                        rangeElement,\\n                        parentNode,\\n                        baseDynamicStatePromise\\n                    );\\n                    parentNode.children.push(renderPassInstanceNode);\\n                } else if ('subpassIndex' in rangeElement) {\\n                    const renderSubpassInstanceNode = CommandRenderSubpassInstanceNode.create(\\n                        ctx,\\n                        rangeElement,\\n                        parentNode,\\n                        baseDynamicStatePromise\\n                    );\\n                    parentNode.children.push(renderSubpassInstanceNode);\\n                } else if ('dynamicPassIndex' in rangeElement) {\\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\\n                        ctx,\\n                        rangeElement,\\n                        parentNode,\\n                        baseDynamicStatePromise\\n                    );\\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\\n                }\\n            },\\n            debugLabelGroupInstances,\\n            renderPassInstances,\\n            renderSubpassInstances,\\n            dynamicRenderPassInstances\\n        )\\n            .then(() => {\\n                console.log(`JF: CommandDebugLabelGroupNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\\n            })\"},{\"oldContent\":\"        createChildEventNodesForRange<AllRangeTypes>(\\n            ctx,\\n            root,\\n            node,\\n            apiEventCommandArray,\\n            0,\\n            effectiveBaseState,\\n            (rangeElement, parentNode) => {\\n                if ('labelId' in rangeElement) {\\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\\n                    parentNode.children.push(debugLabelGroupNode);\\n                } else if ('passIndex' in rangeElement) {\\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\\n                    parentNode.children.push(renderPassInstanceNode);\\n                } else if ('dynamicPassIndex' in rangeElement) {\\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\\n                        ctx,\\n                        rangeElement,\\n                        parentNode,\\n                        effectiveBaseState\\n                    );\\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\\n                }\\n            },\\n            debugLabelGroupInstances,\\n            renderPassInstances,\\n            dynamicRenderPassInstances\\n        )\\n            .then(() => {\\n                // Children populated asynchronously\\n            })\",\"newContent\":\"        createChildEventNodesForRange<AllRangeTypes>(\\n            ctx,\\n            root,\\n            node,\\n            apiEventCommandArray,\\n            0,\\n            effectiveBaseState,\\n            (rangeElement, parentNode) => {\\n                if ('labelId' in rangeElement) {\\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\\n                    parentNode.children.push(debugLabelGroupNode);\\n                } else if ('passIndex' in rangeElement) {\\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\\n                    parentNode.children.push(renderPassInstanceNode);\\n                } else if ('dynamicPassIndex' in rangeElement) {\\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\\n                        ctx,\\n                        rangeElement,\\n                        parentNode,\\n                        effectiveBaseState\\n                    );\\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\\n                }\\n            },\\n            debugLabelGroupInstances,\\n            renderPassInstances,\\n            dynamicRenderPassInstances\\n        )\\n            .then(() => {\\n                console.log(`JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\\n            })\"},{\"oldContent\":\"        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\\n            ctx,\\n            root,\\n            node,\\n            apiEventCommandArray,\\n            0,\\n            baseDynamicStatePromise,\\n            (rangeElement, parentNode) => {\\n                if ('labelId' in rangeElement) {\\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\\n                    parentNode.children.push(debugLabelGroupNode);\\n                }\\n            },\\n            debugLabelGroupInstances\\n        )\\n            .then(() => {\\n                // Children populated asynchronously\\n            })\\n            .catch(error => {\\n                console.error('Error creating child event nodes for render pass:', error);\\n            });\\n\\n        registerThumbnailUpdate(ctx, node, 'render subpass');\",\"newContent\":\"        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\\n            ctx,\\n            root,\\n            node,\\n            apiEventCommandArray,\\n            0,\\n            baseDynamicStatePromise,\\n            (rangeElement, parentNode) => {\\n                if ('labelId' in rangeElement) {\\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\\n                    parentNode.children.push(debugLabelGroupNode);\\n                }\\n            },\\n            debugLabelGroupInstances\\n        )\\n            .then(() => {\\n                console.log(`JF: CommandRenderSubpassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\\n            })\\n            .catch(error => {\\n                console.error('Error creating child event nodes for render pass:', error);\\n            });\\n\\n        registerThumbnailUpdate(ctx, node, 'render subpass');\"},{\"oldContent\":\"        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\\n            ctx,\\n            root,\\n            node,\\n            apiEventCommandArray,\\n            0,\\n            baseDynamicStatePromise,\\n            (rangeElement, parentNode) => {\\n                if ('labelId' in rangeElement) {\\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\\n                    parentNode.children.push(debugLabelGroupNode);\\n                }\\n            },\\n            debugLabelGroupInstances\\n        )\\n            .then(() => {\\n                // Children populated asynchronously\\n            })\\n            .catch(error => {\\n                console.error('Error creating child event nodes for render pass:', error);\\n            });\\n\\n        registerThumbnailUpdate(ctx, node, 'dynamic render pass');\",\"newContent\":\"        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\\n            ctx,\\n            root,\\n            node,\\n            apiEventCommandArray,\\n            0,\\n            baseDynamicStatePromise,\\n            (rangeElement, parentNode) => {\\n                if ('labelId' in rangeElement) {\\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\\n                    parentNode.children.push(debugLabelGroupNode);\\n                }\\n            },\\n            debugLabelGroupInstances\\n        )\\n            .then(() => {\\n                console.log(`JF: CommandDynamicRenderPassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\\n            })\\n            .catch(error => {\\n                console.error('Error creating child event nodes for render pass:', error);\\n            });\\n\\n        registerThumbnailUpdate(ctx, node, 'dynamic render pass');\"},{\"oldContent\":\"                for (const expandedNode of expandedNodes) {\\n                    await this.ensureLazyChildrenLoaded(expandedNode);\\n                    nextLevelNodes.push(...expandedNode.children);\\n                }\",\"newContent\":\"                for (const expandedNode of expandedNodes) {\\n                    await this.ensureLazyChildrenLoaded(expandedNode);\\n                    console.log(`JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, children count: ${expandedNode.children.length}, children ids: ${expandedNode.children.map(c => c.id).join(', ')}`);\\n                    nextLevelNodes.push(...expandedNode.children);\\n                }\"},{\"oldContent\":\"                // Also process children of nodes that were already expanded\\n                for (const currentNode of currentLevelNodes) {\\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\\n                        await this.ensureLazyChildrenLoaded(currentNode);\\n                        nextLevelNodes.push(...currentNode.children);\\n                    }\\n                }\",\"newContent\":\"                // Also process children of nodes that were already expanded\\n                for (const currentNode of currentLevelNodes) {\\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\\n                        await this.ensureLazyChildrenLoaded(currentNode);\\n                        console.log(`JF: doExpandSubTree - after ensureLazyChildrenLoaded (already expanded) for ${currentNode.id}, children count: ${currentNode.children.length}, children ids: ${currentNode.children.map(c => c.id).join(', ')}`);\\n                        nextLevelNodes.push(...currentNode.children);\\n                    }\\n                }\"},{\"oldContent\":\"            } finally {\\n                loadingInProgress = false;\\n            }\\n            CompositeTreeNode.removeChild(parent, loadingNode);\",\"newContent\":\"            } finally {\\n                loadingInProgress = false;\\n            }\\n            console.log(`JF: createLazyLoadingNode - load completed for parent ${parent.id}, children count before removeChild: ${parent.children.length}`);\\n            CompositeTreeNode.removeChild(parent, loadingNode);\"}]}",
              "finished": true,
              "result": "Successfully  applied replacements to file app/packages/capture/src/browser/command-tree/command-tree-model.ts."
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "Now let me verify the changes by checking for any diagnostics:"
            },
            "fallbackMessage": "Now let me verify the changes by checking for any diagnostics:"
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01TNCM9RT2cvLmCFCRdY1o4m",
              "name": "getFileDiagnostics",
              "arguments": "{\"file\": \"app/packages/capture/src/browser/command-tree/command-tree-model.ts\"}",
              "finished": true,
              "result": "[{\"text\":\"                console.log(\\n                    `JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\",\"message\":\"This line has a length of 146. Maximum allowed is 140.\",\"code\":\"max-len\"},{\"text\":\"                console.log(\\n                    `JF: CommandRenderSubpassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\",\"message\":\"This line has a length of 146. Maximum allowed is 140.\",\"code\":\"max-len\"},{\"text\":\"                console.log(\\n                    `JF: CommandDynamicRenderPassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\",\"message\":\"This line has a length of 150. Maximum allowed is 140.\",\"code\":\"max-len\"},{\"text\":\"                    console.log(\\n                        `JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, children count: ${expandedNode.children.length}, children ids: ${expandedNode.children.map(c => c.id).join(', ')}`\\n                    );\",\"message\":\"This line has a length of 216. Maximum allowed is 140.\",\"code\":\"max-len\"},{\"text\":\"                        console.log(\\n                            `JF: doExpandSubTree - after ensureLazyChildrenLoaded (already expanded) for ${currentNode.id}, children count: ${currentNode.children.length}, children ids: ${currentNode.children.map(c => c.id).join(', ')}`\\n                        );\",\"message\":\"This line has a length of 236. Maximum allowed is 140.\",\"code\":\"max-len\"},{\"text\":\"            console.log(\\n                `JF: createLazyLoadingNode - load completed for parent ${parent.id}, children count before removeChild: ${parent.children.length}`\\n            );\",\"message\":\"This line has a length of 146. Maximum allowed is 140.\",\"code\":\"max-len\"}]"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "I have lint errors for line length. Let me fix these by breaking the long lines:"
            },
            "fallbackMessage": "I have lint errors for line length. Let me fix these by breaking the long lines:"
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01Fbv6bEh6uXEVdRDPLp4DtK",
              "name": "getFileContent",
              "arguments": "{\"file\": \"app/packages/capture/src/browser/command-tree/command-tree-model.ts\"}",
              "finished": true,
              "result": "/********************************************************************************\n    Copyright 2024-2026 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\nimport { GFXRQueryBuilderService } from '@sokatoa/gfxr-consumer/lib/';\nimport {\n    DynamicStateEntry,\n    PipelineBindPoint,\n    PipelineBindPointShaderStageFlags,\n    StateType\n} from '@sokatoa/gfxr-consumer/lib/browser/gfxr-data-service';\nimport { PartialRecord } from '@sokatoa/platform/lib';\nimport { BulkTree, BulkTreeModel, ResourceTreeNode, SokatoaLifecycleTreeNode } from '@sokatoa/platform/lib/browser';\nimport { GroupByOptions, MiscPreferences, MiscPrefs } from '@sokatoa/platform/lib/browser/misc-preferences';\nimport { TreeStructureChangeEmitter } from '@sokatoa/platform/lib/browser/tree-table/tree-table-widget';\nimport { ImageAccessorService } from '@sokatoa/platform/lib/common';\nimport { CompressedFileService, usesCompressionExtension } from '@sokatoa/platform/lib/common/compressed-file-service';\nimport { asError } from '@sokatoa/platform/lib/common/error-utils';\nimport { ApiResources, DescriptorResource, DrawApiResult } from '@sokatoa/platform/lib/common/gfxr-apis';\nimport { CancellationToken, Disposable, Emitter, Event, Path, URI } from '@theia/core';\nimport {\n    CompositeTreeNode,\n    DepthFirstTreeIterator,\n    ExpandableTreeNode,\n    SelectableTreeNode,\n    TreeModelImpl,\n    TreeNode\n} from '@theia/core/lib/browser';\nimport { RGBA } from '@theia/core/lib/common/color';\nimport { inject, injectable, postConstruct } from '@theia/core/shared/inversify';\nimport { PNG } from 'pngjs/browser';\nimport { lookupResourceFormat, UncompressedResourceFormat } from '../../common/format-handler';\nimport { extractData } from '../../common/geometry-utils';\nimport { GfxrScreenshotService, requestThumbnails, ScreenshotType, ThumbnailRequestOptions } from '../../common/gfxr-screenshot-service';\nimport { convertDataToImageData } from '../../common/host-side-conversion/vulkan-image';\nimport { FrameRangeSelectionService } from '../capture-widget/frame-range-selection-service';\nimport { placeholderScale } from '../graphics-pipeline-widget/graphics-pipeline-screenshot-requests';\nimport {\n    CaptureDatasetWidgetContext,\n    CaptureDatasetWidgetProfile,\n    CaptureDatasetWidgetReplayContext\n} from '../profile-ui/capture-dataset-widget-types';\nimport { CommandTreePreferenceState } from './command-tree-model-preferences';\nimport {\n    CommandTreeAccelerationStructureBuildInstance,\n    CommandTreeAccelerationStructureCopyInstance,\n    CommandTreeApiEvent,\n    CommandTreeCommandBufferInstance,\n    CommandTreeDataWithFunctionAndDebugNames,\n    CommandTreeDebugLabelGroupInstance,\n    CommandTreeDynamicRenderPassInstance,\n    CommandTreeFrame,\n    CommandTreeQueueDebugLabelGroup,\n    CommandTreeQueueDebugLabelInsert,\n    CommandTreeQueuePresent,\n    CommandTreeQueueSubmit,\n    CommandTreeRenderPassInstance,\n    CommandTreeRenderSubpassInstance,\n    CommandTreeSecondaryCommandBufferInstance,\n    CommandTreeTransferCommandInstance,\n    overrideDynamicState,\n    queryClusterInstanceDynamicState,\n    queryClusterInstanceDynamicStateBatched,\n    queryDispatchInstanceDynamicState,\n    queryDispatchInstanceDynamicStateBatched,\n    queryDrawInstanceDynamicState,\n    queryDrawInstanceDynamicStateBatched,\n    queryMeshTaskInstanceDynamicState,\n    queryMeshTaskInstanceDynamicStateBatched,\n    queryRaytracingInstanceDynamicState,\n    queryRaytracingInstanceDynamicStateBatched,\n    querySecondaryCommandBufferEndDynamicState,\n    QueryTreeDataOptions\n} from './command-tree-service';\nimport { LazyLoadableNode, triggerLazyLoadAndWaitForRemoval } from './lazy-load-utils';\nimport { CommandTreeDataQueriedRootProvider } from './providers/command-tree-root-provider';\n\n// Extension names\nconst VK_NV_COMMAND_BUFFER_INHERITANCE = 'VK_NV_command_buffer_inheritance';\nconst VK_NV_INHERITED_VIEWPORT_SCISSOR = 'VK_NV_inherited_viewport_scissor';\n\n/**\n * Helper type to make TreeNode.parent writable during node construction.\n * TreeNode.parent is readonly, but during tree construction we need to update it.\n */\ninterface MutableParent {\n    parent: CompositeTreeNode | undefined;\n}\n\n/**\n * Check if VK_NV_command_buffer_inheritance extension is enabled for a device.\n * This extension enables full state inheritance between command buffers and leak-back.\n */\nfunction hasCommandBufferInheritance(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_COMMAND_BUFFER_INHERITANCE) ?? false;\n}\n\n/**\n * Check if VK_NV_inherited_viewport_scissor extension is enabled for a device.\n * This extension enables limited viewport/scissor inheritance for secondary command buffers.\n */\nfunction hasInheritedViewportScissor(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_INHERITED_VIEWPORT_SCISSOR) ?? false;\n}\n\n/**\n * Filter dynamic state to only viewport and scissor entries.\n * Used for VK_NV_inherited_viewport_scissor extension.\n */\nasync function filterDynamicStateForViewportScissor(statePromise: Promise<DynamicStateEntry[]>): Promise<DynamicStateEntry[]> {\n    const state = await statePromise;\n    return state.filter(entry => entry.stateType === StateType.VIEWPORT || entry.stateType === StateType.SCISSOR);\n}\n\n/**\n * Tracks dynamic state that may be updated as secondary command buffers execute\n * (when VK_NV_command_buffer_inheritance is enabled).\n */\nclass DynamicStateTracker {\n    private currentStatePromise: Promise<DynamicStateEntry[]>;\n\n    constructor(initialState: Promise<DynamicStateEntry[]>) {\n        this.currentStatePromise = initialState;\n    }\n\n    getCurrentState(): Promise<DynamicStateEntry[]> {\n        return this.currentStatePromise;\n    }\n\n    updateState(newState: Promise<DynamicStateEntry[]>): void {\n        this.currentStatePromise = newState;\n    }\n}\n\n/** Internal context for a command tree model.\n *\n * contains all the fixed data needed for the model,\n * e.g. services, etc.\n */\ninterface CommandTreeContext {\n    dbId: number;\n    data: CommandTreeDataWithFunctionAndDebugNames;\n    screenshotService: GfxrScreenshotService;\n    fileService: CompressedFileService;\n    profile: CaptureDatasetWidgetProfile;\n    context: CaptureDatasetWidgetContext;\n    tree: CommandTree;\n    gfxrQueryBuilderService: GFXRQueryBuilderService;\n    imageAccessorService: ImageAccessorService;\n    createDrawOrDispatchChildren: boolean;\n    rootNode: CommandRootNode;\n    deviceExtensions: Map<number, Set<string>>;\n}\n\n/**\n * Helper function to look up the debug name for an object at a specific API event.\n * Finds the most recent debug name that was set at or before the target API event.\n * @param debugNameLookup - Map of objectHandle to array of {apiEvent, name} sorted by apiEvent\n * @param objectHandle - The object handle to look up\n * @param targetApiEvent - The API event at which we want to know the object's name\n * @returns The debug name if found, undefined otherwise\n */\nfunction getDebugNameAtApiEvent(\n    debugNameLookup: Map<number, Array<{ apiEvent: number; name: string }>>,\n    objectHandle: number | null | undefined,\n    targetApiEvent: number\n): string | undefined {\n    if (typeof objectHandle !== 'number') {\n        return undefined;\n    }\n\n    const entries = debugNameLookup.get(objectHandle);\n    if (!entries || entries.length === 0) {\n        return undefined;\n    }\n\n    // Binary search for the most recent name at or before targetApiEvent\n    let left = 0;\n    let right = entries.length - 1;\n    let result: string | undefined = undefined;\n\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (entries[mid].apiEvent <= targetApiEvent) {\n            result = entries[mid].name;\n            left = mid + 1; // Look for a more recent name\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n\nexport interface CommandRootNode extends ResourceTreeNode<CommandTreeDataWithFunctionAndDebugNames>, CompositeTreeNode, ExpandableTreeNode {\n    resourceType: typeof CommandRootNode.RESOURCE_TYPE;\n    children: CommandFrameNode[];\n    dbId: number;\n    profile: CaptureDatasetWidgetProfile;\n    tree?: CommandTree; // Back-reference to the tree that owns this root\n    // Cached maps for queue debug labels to avoid rebuilding for each frame\n    queueDebugLabelGroupsBySubmitId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelGroupsByPresentId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelInsertsByApiEvent: Map<number, CommandTreeQueueDebugLabelInsert>;\n}\n\nexport namespace CommandRootNode {\n    export const ID = 'sokatoa-command-tree-widget';\n\n    export const RESOURCE_TYPE = '__root__';\n\n    export function is(node: TreeNode | undefined): node is CommandRootNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRootNode.RESOURCE_TYPE);\n    }\n\n    export function create(\n        dbId: number,\n        data: CommandTreeDataWithFunctionAndDebugNames,\n        screenshotService: GfxrScreenshotService,\n        profile: CaptureDatasetWidgetProfile,\n        context: CaptureDatasetWidgetContext,\n        tree: CommandTree,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        imageAccessorService: ImageAccessorService,\n        fileService: CompressedFileService,\n        createDrawOrDispatchChildren: boolean,\n        deviceExtensions: Map<number, Set<string>>\n    ): CommandRootNode {\n        // Build maps for queue debug labels once for all frames\n        const queueDebugLabelGroupsBySubmitId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelGroupsByPresentId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelInsertsByApiEvent = new Map<number, CommandTreeQueueDebugLabelInsert>();\n\n        for (const group of Object.values(data.queueDebugLabelGroups)) {\n            if (group) {\n                for (const submitId of group.queueSubmitIds) {\n                    queueDebugLabelGroupsBySubmitId.set(submitId, group);\n                }\n                for (const presentId of group.queuePresentIds) {\n                    queueDebugLabelGroupsByPresentId.set(presentId, group);\n                }\n            }\n        }\n\n        for (const insert of Object.values(data.queueDebugLabelInserts)) {\n            if (insert) {\n                queueDebugLabelInsertsByApiEvent.set(insert.apiEvent, insert);\n            }\n        }\n\n        const rootNode: CommandRootNode = {\n            visible: false,\n            id: CommandRootNode.ID,\n            name: 'ProfileTree',\n            parent: undefined,\n            expanded: true,\n            children: [],\n            resourceType: CommandRootNode.RESOURCE_TYPE,\n            resource: data,\n            dbId,\n            profile,\n            queueDebugLabelGroupsBySubmitId,\n            queueDebugLabelGroupsByPresentId,\n            queueDebugLabelInsertsByApiEvent\n        };\n        const ctx: CommandTreeContext = {\n            dbId,\n            data,\n            screenshotService,\n            fileService,\n            profile,\n            context,\n            tree,\n            gfxrQueryBuilderService,\n            imageAccessorService,\n            createDrawOrDispatchChildren,\n            rootNode,\n            deviceExtensions\n        };\n        const modelBuildStart = Date.now();\n        const frames = Object.values(data.frames);\n        rootNode.children = frames.flatMap(child => (child ? CommandFrameNode.create(ctx, child, rootNode) : []));\n        console.debug(`Model loaded in ${Date.now() - modelBuildStart} ms`);\n        return rootNode;\n    }\n}\n\nexport interface DebugMarker {\n    name: string;\n    color?: RGBA;\n}\n\nexport interface WithDebugMarker {\n    debugMarker?: DebugMarker;\n}\n\nexport namespace WithDebugMarker {\n    /** Type guard for a `node` that is or has a debug marker. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugMarker> {\n        return 'debugMarker' in node && node.debugMarker !== undefined;\n    }\n}\n\nexport interface WithDebugName {\n    debugName?: string;\n}\n\nexport namespace WithDebugName {\n    /** Type guard for a `node` that has a debug name. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugName> {\n        return 'debugName' in node && node.debugName !== undefined;\n    }\n}\n\ninterface LabelData {\n    labelName: string | undefined | null;\n    colorR: number | undefined | null;\n    colorG: number | undefined | null;\n    colorB: number | undefined | null;\n    colorA: number | undefined | null;\n}\n\nfunction setDebugMarkerData(node: WithDebugMarker, labelData: LabelData): void {\n    const name = labelData.labelName ?? 'Debug marker';\n    const color = {\n        r: (labelData.colorR ?? 1) * 255,\n        g: (labelData.colorG ?? 1) * 255,\n        b: (labelData.colorB ?? 1) * 255,\n        a: (labelData.colorA ?? 1) * 255\n    };\n\n    node.debugMarker = { name };\n    if (color.a !== 0 || color.b !== 0 || color.g !== 0 || color.r !== 0) {\n        node.debugMarker.color = color;\n    }\n}\n\nexport interface CommandFrameNode extends ResourceTreeNode<CommandTreeFrame>, ExpandableTreeNode, SelectableTreeNode {\n    label: string;\n    frameIndex: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandFrameNode.RESOURCE_TYPE;\n    thumbnail?: string;\n}\n\nexport namespace CommandFrameNode {\n    export const RESOURCE_TYPE = 'frame';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandFrameNode {\n        return ResourceTreeNode.hasResourceType(node, CommandFrameNode.RESOURCE_TYPE);\n    }\n\n    export function getId(frame: CommandTreeFrame): string {\n        return frame.frameIndex.toString();\n    }\n\n    export function create(ctx: CommandTreeContext, element: CommandTreeFrame, parent: CompositeTreeNode): CommandFrameNode {\n        const node: CommandFrameNode & SokatoaLifecycleTreeNode = {\n            id: getId(element),\n            frameIndex: element.frameIndex,\n            label: `Frame ${element.frameIndex}`,\n            children: [],\n            expanded: false,\n            selected: false,\n            parent,\n            resourceType: CommandFrameNode.RESOURCE_TYPE,\n            resource: element\n        };\n\n        const root = ctx.rootNode;\n\n        const children: CommandTreeNode[] = [];\n        let queueSubmitIndex = 0;\n        let queuePresentIndex = 0;\n        let accelerationStructureBuildIndex = 0;\n        let accelerationStructureCopyIndex = 0;\n\n        // Track current active debug label group and its children\n        let activeDebugLabelGroup: CommandTreeQueueDebugLabelGroup | undefined;\n        let activeGroupChildren: (CommandQueueSubmitNode | CommandQueuePresentNode)[] = [];\n        let queueDebugLabelGroupInstanceIndex = 0;\n\n        // Helper to finalize the active group and add it to children\n        const finalizeActiveGroup = (): void => {\n            if (activeDebugLabelGroup && activeGroupChildren.length > 0) {\n                children.push(\n                    CommandQueueDebugLabelGroupNode.create(\n                        ctx,\n                        activeDebugLabelGroup,\n                        node,\n                        activeGroupChildren,\n                        queueDebugLabelGroupInstanceIndex++\n                    )\n                );\n                activeDebugLabelGroup = undefined;\n                activeGroupChildren = [];\n            }\n        };\n\n        for (let id = element.beginApiEvent; id <= (element.endApiEvent ?? element.beginApiEvent); id++) {\n            // Check for queue debug label insert at this apiEvent\n            const queueDebugLabelInsert = root.queueDebugLabelInsertsByApiEvent.get(id);\n            if (queueDebugLabelInsert) {\n                // Inserts can appear in the middle of groups, so finalize any active group first\n                finalizeActiveGroup();\n                children.push(CommandQueueDebugLabelNode.create(ctx, queueDebugLabelInsert, node));\n            }\n\n            const apiEvent = root.resource.apiEvents[id];\n            if (apiEvent) {\n                if (apiEvent.submissionId && element.queueSubmitIds.includes(apiEvent.submissionId)) {\n                    const queueSubmit = root.resource.queueSubmits[apiEvent.submissionId];\n                    if (queueSubmit) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsBySubmitId.get(apiEvent.submissionId);\n\n                        // Check if this submit is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queueSubmit not found for submissionId ${apiEvent.submissionId}`);\n                    }\n                } else if (apiEvent.presentId && element.queuePresentIds.includes(apiEvent.presentId)) {\n                    const queuePresent = root.resource.queuePresents[apiEvent.presentId];\n                    if (queuePresent) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsByPresentId.get(apiEvent.presentId);\n\n                        // Check if this present is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queuePresent not found for presentId ${apiEvent.presentId}`);\n                    }\n                } else if (\n                    apiEvent.accelerationStructureBuildInstanceId &&\n                    element.accelerationStructureBuildIds.includes(apiEvent.accelerationStructureBuildInstanceId)\n                ) {\n                    // Acceleration structure builds interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureBuild =\n                        root.resource.topLevelAccelerationStructureBuilds[apiEvent.accelerationStructureBuildInstanceId];\n                    if (accelerationStructureBuild) {\n                        children.push(\n                            CommandAccelerationStructureBuildNode.create(\n                                accelerationStructureBuild,\n                                node,\n                                accelerationStructureBuildIndex++\n                            )\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureBuildInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureBuild not found for accelerationStructureBuildInstanceId ${iId}`\n                        );\n                    }\n                } else if (\n                    apiEvent.accelerationStructureCopyInstanceId &&\n                    element.accelerationStructureCopyIds.includes(apiEvent.accelerationStructureCopyInstanceId)\n                ) {\n                    // Acceleration structure copies interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureCopy =\n                        root.resource.topLevelAccelerationStructureCopies[apiEvent.accelerationStructureCopyInstanceId];\n                    if (accelerationStructureCopy) {\n                        children.push(\n                            CommandAccelerationStructureCopyNode.create(accelerationStructureCopy, node, accelerationStructureCopyIndex++)\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureCopyInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureCopy not found for accelerationStructureCopyInstanceId ${iId}`\n                        );\n                    }\n                }\n            }\n        }\n\n        // Finalize any remaining active debug label group at the end\n        finalizeActiveGroup();\n\n        node.children = children;\n\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        const request: ThumbnailRequestOptions = {\n            profileOrReplay: replay ?? ctx.profile,\n            startFrame: element.frameIndex,\n            endFrame: element.frameIndex,\n            requesterDbgName: `Command tree frame ${element.frameIndex}`,\n            onScreenshotReady: result => {\n                ctx.imageAccessorService\n                    .accessImage(new URL(URI.fromFilePath(result.path).toString()))\n                    .then(url => {\n                        node.thumbnail = url.url.toString();\n                        ctx.tree.addToDispose(url);\n                        void ctx.tree.refresh(node);\n                    })\n                    .catch(reason => {\n                        const error = asError(reason);\n                        console.error(error);\n                    });\n            },\n            onRequestComplete: (success, message) => {\n                if (!success) {\n                    console.error(`Request for frame thumbnails failed: ${message}`);\n                }\n            }\n        };\n        const onWillRender = (): void => {\n            requestThumbnails(ctx.screenshotService, request);\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', onWillRender);\n        };\n        SokatoaLifecycleTreeNode.register(node, 'onWillRender', onWillRender);\n        return node;\n    }\n\n    /**\n     * Retrieve the `CommandFrameNode` that is or contains the given `node`.\n     * Returns `undefined` in the case that the `node` is an ancestor of or\n     * otherwise not contained in an `CommandFrameNode`.\n     */\n    export function getCommandFrameNodeContaining(node: TreeNode): CommandFrameNode | undefined {\n        return CommandFrameNode.is(node) ? node : node.parent ? CommandFrameNode.getCommandFrameNodeContaining(node.parent) : undefined;\n    }\n}\n\nexport interface CommandEmptyNode extends LazyLoadableNode {\n    label: string;\n}\n\nexport namespace CommandEmptyNode {\n    export const GENERALIZED_TYPE = 'empty';\n\n    export function is(node: unknown): node is CommandEmptyNode {\n        return TreeNode.is(node) && node.id.endsWith('_empty');\n    }\n\n    export function getId(parent: CompositeTreeNode): string {\n        return `${parent.id}_empty`;\n    }\n\n    export function create(parent: CompositeTreeNode, load: CommandEmptyNode['load']): CommandEmptyNode {\n        return {\n            id: getId(parent),\n            label: 'Loading...',\n            parent,\n            load\n        };\n    }\n}\n\nexport interface CommandApiEventNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandApiEventNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandApiEventNode {\n    export const RESOURCE_TYPE = 'api-event';\n    export const GENERALIZED_TYPE = RESOURCE_TYPE;\n\n    export function is(node: TreeNode | undefined): node is CommandApiEventNode {\n        return ResourceTreeNode.hasResourceType(node, CommandApiEventNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEventId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex?: number\n    ): CommandApiEventNode {\n        const root = ctx.rootNode;\n        const node: CommandApiEventNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEventId,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex ?? ''}`,\n            parent,\n            resourceType: CommandApiEventNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId,\n            selected: false\n        };\n        // set debug marker data if node is a debug marker\n        if (element.debugLabelId) {\n            const labelData = root.resource.debugLabels[element.debugLabelId];\n            if (labelData) {\n                setDebugMarkerData(node, labelData);\n            }\n        }\n        return node;\n    }\n}\n\nexport interface CommandDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeDebugLabelGroupInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'debug-label-group';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDebugLabelGroupInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDebugLabelGroupInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDebugLabelGroupNode = {\n            id: getId(element, parent),\n            debugLabelInstanceId: element.labelId,\n            label: `${root.resource.functionNameLookup[element.functionNameId ?? -1] ?? '<not defined>'}`,\n            parent,\n            resourceType: CommandDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this debug label range\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this debug label group, add it to array\n            // - not self\n            // - only commands with same command buffer id\n            if (event && event.debugLabelId !== element.labelId && event.commandBufferInstanceId === element.commandBufferInstance) {\n                apiEventCommandArray.push(event);\n            }\n        }\n        // get array of debug label ranges with api event numbers within this debug label range\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this debug label range\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderPassInstance'\n        );\n        // get array of render subpass ranges with api event numbers within this debug label range\n        const renderSubpassInstances = createRangeInstanceArray(\n            element.renderSubpassInstanceIds,\n            root.resource.renderSubpassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderSubpassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this debug label range\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('subpassIndex' in rangeElement) {\n                    const renderSubpassInstanceNode = CommandRenderSubpassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderSubpassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            renderSubpassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                console.log(\n                    `JF: CommandDebugLabelGroupNode ${node.id} - async children creation completed, children count: ${node.children.length}`\n                );\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for debug label group:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `debug label group ${element.labelId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelGroup>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'queue-debug-label-group';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelGroup, parent: CompositeTreeNode, instanceIndex: number): string {\n        return `${parent.id}_qdl_group_${element.labelId}_${instanceIndex}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelGroup,\n        parent: CompositeTreeNode,\n        children: (CommandQueueSubmitNode | CommandQueuePresentNode)[],\n        instanceIndex: number\n    ): CommandQueueDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelGroupNode = {\n            id: getId(element, parent, instanceIndex),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label Group',\n            queue: element.queue!,\n            parent,\n            resourceType: CommandQueueDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        // Update parent references for children since they were created with a different parent\n        // and are now being reparented to this debug label group node\n        for (const child of children) {\n            // Cast away readonly to update parent during node construction\n            (child as MutableParent).parent = node;\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelInsert>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    apiEventId: number;\n    resourceType: typeof CommandQueueDebugLabelNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelNode {\n    export const RESOURCE_TYPE = 'queue-debug-label';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelInsert, parent: CompositeTreeNode): string {\n        return `${parent.id}_qdl_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelInsert,\n        parent: CompositeTreeNode\n    ): CommandQueueDebugLabelNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelNode = {\n            id: getId(element, parent),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label',\n            queue: element.queue!,\n            apiEventId: element.apiEvent,\n            parent,\n            resourceType: CommandQueueDebugLabelNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandCommandBufferInstanceNode\n    extends ResourceTreeNode<CommandTreeCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    commandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandCommandBufferInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandCommandBufferInstanceNode {\n    export const RESOURCE_TYPE = 'command-buffer-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandCommandBufferInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandCommandBufferInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeCommandBufferInstance,\n        parent: CompositeTreeNode,\n        commandBufferIndex: number,\n        baseDynamicStatePromise?: Promise<DynamicStateEntry[]>\n    ): CommandCommandBufferInstanceNode {\n        const node: CommandCommandBufferInstanceNode = {\n            id: getId(element, parent),\n            commandBufferInstanceId: element.instanceId,\n            label: `Command Buffer ${commandBufferIndex}`,\n            parent,\n            resourceType: CommandCommandBufferInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this command buffer\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this command buffer, add it to array\n            // - omit commands that reference render pass id\n            // - if api event is a debug label, check the debug label itself for a render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                event.commandBufferInstanceId === element.instanceId &&\n                event.renderPassInstanceId === undefined &&\n                event.dynamicRenderPassInstanceId === undefined &&\n                (event.debugLabelId === undefined ||\n                    (debugLabel?.beginApiEvent === event.apiEventId &&\n                        debugLabel?.beginRenderPassInstance === undefined &&\n                        debugLabel?.beginDynamicRenderPassInstance === undefined) ||\n                    (debugLabel?.endApiEvent === event.apiEventId &&\n                        debugLabel?.endRenderPassInstance === undefined &&\n                        debugLabel?.endDynamicRenderPassInstance === undefined))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this command buffer\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this command buffer\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'RenderPassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this command buffer\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        const emptyDynamicStatePromise = new Promise<DynamicStateEntry[]>(resolve => resolve([]));\n        const effectiveBaseState = baseDynamicStatePromise ?? emptyDynamicStatePromise;\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            effectiveBaseState,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        effectiveBaseState\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                console.log(\n                    `JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\n                );\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for command buffer:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `command buffer ${commandBufferIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandSecondaryCommandBufferExecutionNode\n    extends ResourceTreeNode<CommandTreeSecondaryCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    parentCommandBufferInstanceId: number;\n    secondaryCommandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n}\n\nexport namespace CommandSecondaryCommandBufferExecutionNode {\n    export const RESOURCE_TYPE = 'secondary-command-buffer-execution';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: unknown): node is CommandSecondaryCommandBufferExecutionNode {\n        return (\n            ExpandableTreeNode.is(node) && SelectableTreeNode.is(node) && ResourceTreeNode.is(node, 'secondary-command-buffer-execution')\n        );\n    }\n\n    export function getId(element: CommandTreeSecondaryCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_secondary_${element.secondaryCommandBufferInstance}_${element.executionId}_${element.executionIndex}`;\n    }\n\n    export async function create(\n        ctx: CommandTreeContext,\n        elements: CommandTreeSecondaryCommandBufferInstance[],\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n        stateTracker?: DynamicStateTracker\n    ): Promise<CommandSecondaryCommandBufferExecutionNode> {\n        if (elements.length === 0) {\n            throw new Error('elements array must not be empty');\n        }\n        // Use the first element for the node's resource (they all share the same executionId and apiEvent)\n        const element = elements[0];\n        const node: CommandSecondaryCommandBufferExecutionNode = {\n            id: getId(element, parent),\n            parentCommandBufferInstanceId: element.parentCommandBufferInstance || 0,\n            secondaryCommandBufferInstanceId: element.secondaryCommandBufferInstance || 0,\n            label: `Secondary Command Buffer Execution ${commandIndex}`,\n            parent,\n            resourceType: 'secondary-command-buffer-execution',\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        createLazyLoadingNode(ctx.tree, node, async () => {\n            // Sort elements by executionIndex to maintain proper order\n            const sortedElements = [...elements].sort((a, b) => (a.executionIndex || 0) - (b.executionIndex || 0));\n\n            // Get device and check extensions\n            const firstSecondary = sortedElements[0]?.secondaryCommandBufferInstance;\n            let deviceExtensions: Set<string> | undefined;\n\n            if (firstSecondary !== undefined) {\n                const commandBufferInstance = root.resource.commandBufferInstances[firstSecondary];\n                const device = commandBufferInstance?.device;\n                if (typeof device === 'number') {\n                    deviceExtensions = ctx.deviceExtensions.get(device);\n                }\n            }\n\n            const hasInheritance = hasCommandBufferInheritance(deviceExtensions);\n            const hasViewportScissorOnly = hasInheritedViewportScissor(deviceExtensions) && !hasInheritance;\n\n            // Calculate effective base state for INHERITANCE INTO secondary\n            let effectiveBaseState: Promise<DynamicStateEntry[]>;\n            if (hasInheritance) {\n                effectiveBaseState = baseDynamicStatePromise;\n            } else if (hasViewportScissorOnly) {\n                effectiveBaseState = filterDynamicStateForViewportScissor(baseDynamicStatePromise);\n            } else {\n                effectiveBaseState = Promise.resolve([]);\n            }\n\n            // Create a CommandCommandBufferInstanceNode for each secondary command buffer in the execution\n            const childNodes: CommandCommandBufferInstanceNode[] = [];\n            sortedElements.forEach((secondaryInstance, index) => {\n                if (secondaryInstance.secondaryCommandBufferInstance) {\n                    const commandBufferInstance = root.resource.commandBufferInstances[secondaryInstance.secondaryCommandBufferInstance];\n                    if (commandBufferInstance) {\n                        const childNode = CommandCommandBufferInstanceNode.create(\n                            ctx,\n                            commandBufferInstance,\n                            node,\n                            index,\n                            effectiveBaseState\n                        );\n                        childNodes.push(childNode);\n                    } else {\n                        console.warn(\n                            `Command buffer instance ${secondaryInstance.secondaryCommandBufferInstance} ` +\n                                'not found in root.resource.commandBufferInstances'\n                        );\n                    }\n                }\n            });\n            CompositeTreeNode.addChildren(node, childNodes);\n\n            // Handle LEAK-BACK: Update parent's state tracker if extension is enabled\n            if (hasInheritance && stateTracker && element.executionId) {\n                const db = ctx.gfxrQueryBuilderService.builderFor(ctx.dbId);\n                const endStatePromise = querySecondaryCommandBufferEndDynamicState(db, [element.executionId]);\n                stateTracker.updateState(endStatePromise);\n            }\n        });\n\n        // Register for thumbnail updates\n        registerThumbnailUpdate(ctx, node, `secondary command buffer execution ${node.resource.executionId}`);\n        return node;\n    }\n}\n\nexport interface CommandQueueSubmitNode\n    extends ResourceTreeNode<CommandTreeQueueSubmit>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    submissionId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueSubmitNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueSubmitNode {\n    export const RESOURCE_TYPE = 'queue-submit';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueSubmitNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueSubmitNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueSubmit, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.submissionId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueSubmit,\n        parent: CompositeTreeNode,\n        queueSubmitIndex: number\n    ): CommandQueueSubmitNode {\n        const root = ctx.rootNode;\n        const node: CommandQueueSubmitNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            threadId: element.threadId || 0,\n            submissionId: element.submissionId,\n            label: `Queue Submit ${queueSubmitIndex}`,\n            queue: element.queue,\n            parent,\n            resourceType: CommandQueueSubmitNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        const children =\n            element.queueSubmitBuffers\n                ?.filter(b => b.commandBufferInstance)\n                .flatMap(b => {\n                    const instance = root.resource.commandBufferInstances[b.commandBufferInstance!];\n                    if (!instance) {\n                        console.warn(`CommandQueueSubmitNode.create: commandBufferInstance not found for id ${b.commandBufferInstance}`);\n                        return [];\n                    }\n                    return instance;\n                }) ?? [];\n        let commandBufferIndex = 0;\n        node.children = children.map(child => CommandCommandBufferInstanceNode.create(ctx, child, node, commandBufferIndex++));\n\n        registerThumbnailUpdate(ctx, node, `queue submit ${queueSubmitIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueuePresentNode extends ResourceTreeNode<CommandTreeQueuePresent>, SelectableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    resourceType: typeof CommandQueuePresentNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueuePresentNode {\n    export const RESOURCE_TYPE = 'queue-present';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueuePresentNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueuePresentNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueuePresent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEvent}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueuePresent,\n        parent: CompositeTreeNode,\n        queuePresentIndex: number\n    ): CommandQueuePresentNode {\n        const root = ctx.rootNode;\n        const node: CommandQueuePresentNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            label: `Queue Present ${queuePresentIndex}`,\n            parent,\n            resourceType: CommandQueuePresentNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            queue: element.queue,\n            selected: false\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureBuildNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureBuildInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    buildInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureBuildNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureBuildNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-build';\n    export const GENERALIZED_TYPE = 'acceleration-structure-build';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureBuildNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureBuildNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureBuildInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.buildApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureBuildInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureBuildNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureBuildNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            buildInstanceId: element.instanceId,\n            apiEventId: element.buildApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureBuildNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureCopyNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureCopyInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    copyInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureCopyNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureCopyNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-copy';\n    export const GENERALIZED_TYPE = 'acceleration-structure-copy';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureCopyNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureCopyNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureCopyInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.copyApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureCopyInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureCopyNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureCopyNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            copyInstanceId: element.instanceId,\n            apiEventId: element.copyApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureCopyNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandTransferCommandNode\n    extends ResourceTreeNode<CommandTreeTransferCommandInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    transferCommandInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandTransferCommandNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandTransferCommandNode {\n    export const RESOURCE_TYPE = 'transfer-command';\n    export const GENERALIZED_TYPE = 'transfer-command';\n\n    export function is(node: TreeNode | undefined): node is CommandTransferCommandNode {\n        return ResourceTreeNode.hasResourceType(node, CommandTransferCommandNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeTransferCommandInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.transferApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeTransferCommandInstance,\n        parent: CompositeTreeNode,\n        transferCommandIndex: number\n    ): CommandTransferCommandNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandTransferCommandNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            transferCommandInstanceId: element.instanceId,\n            apiEventId: element.transferApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${transferCommandIndex}`,\n            parent,\n            resourceType: CommandTransferCommandNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nfunction setThumbnailUrl(\n    ctx: CommandTreeContext,\n    resources: ApiResources[],\n    node: TreeNode & { thumbnail?: string },\n    requesterDbgName: string\n): void {\n    if (resources.length > 0) {\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        ctx.screenshotService.requestScreenshots({\n            profileOrReplay: replay ?? ctx.profile,\n            scale: placeholderScale,\n            screenshotType: ScreenshotType.API_EVENT,\n            requestData: resources,\n            moreRequests: true,\n            requesterDbgName,\n            options: {\n                DumpDepth: true\n            },\n            onScreenshotReady: result => {\n                if (result.resultData.resultType === ScreenshotType.API_EVENT && DrawApiResult.is(result.resultData.apiResult)) {\n                    const images = [...(result.resultData.apiResult.colorAttachments || [])];\n                    if (result.resultData.apiResult.depthAttachment) {\n                        images.push(result.resultData.apiResult.depthAttachment);\n                    }\n                    if (images.length > 0) {\n                        const possibleImage = images[0].subresources?.[0];\n                        if (possibleImage) {\n                            if (usesCompressionExtension(possibleImage.file)) {\n                                // Use VkImageConversionService to get a png\n                                // Do the same as the else case, but with the new png file\n                                const format = lookupResourceFormat(images[0].format);\n                                if (UncompressedResourceFormat.is(format)) {\n                                    ctx.fileService\n                                        .read(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString(), {\n                                            uncompressedSize: possibleImage.size\n                                        })\n                                        .then(async content => {\n                                            const extractedData = await extractData(format, content);\n                                            const dim = {\n                                                width: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[0]\n                                                    : possibleImage.dimensions[0] * placeholderScale,\n                                                height: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[1]\n                                                    : possibleImage.dimensions[1] * placeholderScale\n                                            };\n                                            const conversionResult = await convertDataToImageData(extractedData, format, dim, {\n                                                channelOptions: { alpha: { disabled: true } }\n                                            });\n                                            const png = new PNG({\n                                                width: conversionResult.dimensions.width,\n                                                height: conversionResult.dimensions.height\n                                            });\n                                            png.data = conversionResult.data;\n                                            const pngBuffer = PNG.sync.write(png);\n                                            node.thumbnail = `data:image/png;base64, ${pngBuffer.toString('base64')}`;\n                                            void ctx.tree.refresh(node.parent);\n                                        })\n                                        .catch(reason => {\n                                            const error = asError(reason);\n                                            console.error(error);\n                                        });\n                                }\n                            } else {\n                                ctx.imageAccessorService\n                                    .accessImage(new URL(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString()))\n                                    .then(url => {\n                                        node.thumbnail = url.url.toString();\n                                        ctx.tree.addToDispose(url);\n                                        void ctx.tree.refresh(node.parent);\n                                    })\n                                    .catch(reason => {\n                                        const error = asError(reason);\n                                        console.error(error);\n                                    });\n                            }\n                        }\n                    }\n                }\n            },\n            onRequestComplete: (result, message) => {\n                if (!result) {\n                    console.error(message);\n                }\n            }\n        });\n    }\n}\n\n/**\n * Registers a thumbnail update callback that triggers on the node's first render.\n * When triggered, finds the last draw instance and requests a screenshot for it.\n *\n * @param ctx - Command tree context\n * @param node - Node to register thumbnail update for\n * @param descriptionContext - Description for the requester debug name (e.g., \"render pass 5\", \"dynamic render pass\")\n */\nfunction registerThumbnailUpdate(\n    ctx: CommandTreeContext,\n    node: CommandTreeNode & { thumbnail?: string },\n    descriptionContext: string\n): void {\n    const updateThumbnail = (): void => {\n        const lastDraw = findLastDrawInstanceNode(node);\n        if (lastDraw) {\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', updateThumbnail);\n            const requesterDbgName = `Command tree ${descriptionContext} last draw: ${lastDraw.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(lastDraw), node, requesterDbgName);\n        }\n    };\n    SokatoaLifecycleTreeNode.register(node, 'onWillRender', updateThumbnail);\n}\n\nexport interface CommandRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    renderPassInstanceId: number;\n    renderPassId?: number;\n    renderSubpassEventIds: number[];\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderPassInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.instanceId,\n            renderPassId: element.renderPass,\n            renderSubpassEventIds: [],\n            label: `Render Pass ${element.passIndex}`,\n            parent,\n            resourceType: CommandRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        // A render pass will only contain render subpasses and will always contain at least one subpass\n        const renderSubpassInstances = element.renderSubpassInstanceIds.flatMap(id => {\n            const instance = root.resource.renderSubpassInstances[id];\n            if (!instance) {\n                console.warn(`CommandRenderPassInstanceNode.create: renderSubpassInstance not found for id ${id}`);\n                return [];\n            }\n            return instance;\n        });\n        renderSubpassInstances.forEach(subpass => {\n            if (subpass.beginApiEvent !== node.resource.beginApiEvent) {\n                node.renderSubpassEventIds.push(subpass.beginApiEvent);\n            }\n        });\n        node.children.push(\n            ...renderSubpassInstances.map(instance => {\n                const subpassNode = CommandRenderSubpassInstanceNode.create(ctx, instance, node, baseDynamicStatePromise);\n                return subpassNode;\n            })\n        );\n\n        registerThumbnailUpdate(ctx, node, `render pass ${node.renderPassId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandRenderSubpassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderSubpassInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    renderPassInstanceId: number;\n    renderSubpassInstanceId: number;\n    renderSubpassIndex: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderSubpassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderSubpassInstanceNode {\n    export const RESOURCE_TYPE = 'render-subpass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderSubpassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderSubpassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderSubpassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderSubpassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderSubpassInstanceNode {\n        const node: CommandRenderSubpassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.renderPassInstance,\n            renderSubpassInstanceId: element.instanceId,\n            renderSubpassIndex: element.subpassIndex,\n            label: `Subpass ${element.subpassIndex}`,\n            parent,\n            resourceType: CommandRenderSubpassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this render subpass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference render subpass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a render subpass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.renderSubpassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginRenderSubpassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endRenderSubpassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this render subpass\n        const debugLabelGroupInstances = {\n            array: element.debugLabelGroupInstanceIds.flatMap(id => {\n                const result = root.resource.debugLabelGroupInstances[id];\n                if (!result) {\n                    console.warn(`Missing debugLabelGroupInstances for ${id}.`);\n                    return [];\n                }\n                return result;\n            }),\n            getSortNumber: (debugLabelGroupInstance: CommandTreeDebugLabelGroupInstance) => debugLabelGroupInstance.beginApiEvent\n        };\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                console.log(\n                    `JF: CommandRenderSubpassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\n                );\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'render subpass');\n\n        return node;\n    }\n}\n\nexport interface CommandDynamicRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeDynamicRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    dynamicRenderPassInstanceId: number;\n    dynamicRenderPassId?: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDynamicRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'dynamic-render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDynamicRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDynamicRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDynamicRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDynamicRenderPassInstanceNode {\n        const node: CommandDynamicRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dynamicRenderPassInstanceId: element.instanceId,\n            label: `Dynamic Render Pass ${element.dynamicPassIndex}`,\n            parent,\n            resourceType: CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this dynamic render pass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this dynamic render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference dynamic render pass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a dynamic render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.dynamicRenderPassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginDynamicRenderPassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endDynamicRenderPassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this dynamic render pass\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDynamicRenderPassInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                console.log(\n                    `JF: CommandDynamicRenderPassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\n                );\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'dynamic render pass');\n\n        return node;\n    }\n}\n\nasync function createChildEventNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    stateTracker: DynamicStateTracker\n): Promise<number> {\n    let endCommandIndex = commandIndex;\n    const baseDynamicStatePromise = stateTracker.getCurrentState();\n\n    if (command.secondaryCommandBufferExecutionId) {\n        // Look up the execution to get the apiEvent, which is the key for secondaryCommandBufferInstances\n        const execution = root.resource.secondaryCommandBufferExecutions[command.secondaryCommandBufferExecutionId];\n        if (execution) {\n            const secondaryInstances = root.resource.secondaryCommandBufferInstances[execution.apiEvent];\n            if (secondaryInstances && secondaryInstances.length > 0) {\n                const node = await CommandSecondaryCommandBufferExecutionNode.create(\n                    ctx,\n                    secondaryInstances,\n                    parentNode,\n                    endCommandIndex++,\n                    baseDynamicStatePromise,\n                    stateTracker\n                );\n                parentNode.children.push(node);\n            }\n        }\n    } else {\n        endCommandIndex = createDrawOrDispatchChildNode(ctx, command, root, parentNode, commandIndex, baseDynamicStatePromise);\n    }\n    return endCommandIndex;\n}\n\nfunction createDrawOrDispatchChildNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n): number {\n    let currentCommandIndex = commandIndex;\n    let accelerationStructureBuildIndex = 0;\n    let accelerationStructureCopyIndex = 0;\n    if (command) {\n        if (command.drawInstanceId && root.resource.drawInstances[command.drawInstanceId]) {\n            parentNode.children.push(\n                CommandDrawInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.dispatchInstanceId && root.resource.dispatchInstances[command.dispatchInstanceId]) {\n            parentNode.children.push(\n                CommandDispatchInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.meshTaskInstanceId && root.resource.meshTaskInstances[command.meshTaskInstanceId]) {\n            parentNode.children.push(\n                CommandMeshTaskInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.clusterInstanceId && root.resource.clusterInstances[command.clusterInstanceId]) {\n            parentNode.children.push(\n                CommandClusterInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.raytracingInstanceId && root.resource.raytracingInstances[command.raytracingInstanceId]) {\n            parentNode.children.push(\n                CommandRaytracingInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (\n            command.accelerationStructureBuildInstanceId &&\n            root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureBuildNode.create(\n                    root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]!,\n                    parentNode,\n                    accelerationStructureBuildIndex++\n                )\n            );\n        } else if (\n            command.accelerationStructureCopyInstanceId &&\n            root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureCopyNode.create(\n                    root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]!,\n                    parentNode,\n                    accelerationStructureCopyIndex++\n                )\n            );\n        } else if (command.transferCommandInstanceId && root.resource.transferCommands[command.transferCommandInstanceId]) {\n            parentNode.children.push(\n                CommandTransferCommandNode.create(\n                    root.resource.transferCommands[command.transferCommandInstanceId]!,\n                    parentNode,\n                    currentCommandIndex++\n                )\n            );\n        } else if (command.debugLabelId && root.resource.debugLabels[command.debugLabelId]) {\n            // Only add debug label nodes if this is the BEGIN event (not END event)\n            // The END event has debugLabelId set but should not create a node\n            const debugLabel = root.resource.debugLabels[command.debugLabelId];\n            if (debugLabel && debugLabel.beginApiEvent === command.apiEventId) {\n                // Check if this is a group (has both begin and end and they differ) or just an insert\n                if (debugLabel.endApiEvent && debugLabel.beginApiEvent !== debugLabel.endApiEvent) {\n                    // This is a debug label group - it should be handled by the range processing logic\n                    // Don't create any node here, just skip it\n                    // (The group will be created if it's in debugLabelGroupInstances, or omitted if it crosses boundaries)\n                } else {\n                    // This is a debug label insert - create as simple API event node\n                    parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode));\n                }\n            }\n        } else if (command.commandInstanceId && root.resource.commandInstances[command.commandInstanceId]) {\n            parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode, currentCommandIndex++));\n        }\n    }\n    return currentCommandIndex;\n}\n\nexport interface CommandDrawInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    drawInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDrawInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandDrawInstanceNode {\n    export const RESOURCE_TYPE = 'draw-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDrawInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDrawInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_draw_${element.drawInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDrawInstanceNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDrawInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            drawInstanceId: element.drawInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDrawInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query draw instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n            const requesterDbgName = `Command draw instance ${node.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(node), node, requesterDbgName);\n        });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDrawInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const drawInstanceDynamicStatePromise = batchQuery\n                ? queryDrawInstanceDynamicStateBatched(db, [node.resource.drawInstanceId || 0])\n                : queryDrawInstanceDynamicState(db, [node.resource.drawInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                drawInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.GRAPHICS\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandDispatchInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    dispatchInstanceId: number;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandDispatchInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n    thumbnail?: string;\n}\n\nexport namespace CommandDispatchInstanceNode {\n    export const RESOURCE_TYPE = 'dispatch-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDispatchInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDispatchInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_dispatch_${element.dispatchInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDispatchInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandDispatchInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dispatchInstanceId: element.dispatchInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDispatchInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query dispatch instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for dispatch nodes\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command dispatch instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDispatchInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const dispatchInstanceDynamicStatePromise = batchQuery\n                ? queryDispatchInstanceDynamicStateBatched(db, [node.resource.dispatchInstanceId || 0])\n                : queryDispatchInstanceDynamicState(db, [node.resource.dispatchInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                dispatchInstanceDynamicStatePromise,\n                PipelineBindPoint.COMPUTE,\n                PipelineBindPointShaderStageFlags.COMPUTE\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandMeshTaskInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    meshTaskInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandMeshTaskInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandMeshTaskInstanceNode {\n    export const RESOURCE_TYPE = 'mesh-task-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandMeshTaskInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandMeshTaskInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_meshtask_${element.meshTaskInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandMeshTaskInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandMeshTaskInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            meshTaskInstanceId: element.meshTaskInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandMeshTaskInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query mesh instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for mesh task dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command mesh instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandMeshTaskInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const meshTaskInstanceDynamicStatePromise = batchQuery\n                ? queryMeshTaskInstanceDynamicStateBatched(db, [node.resource.meshTaskInstanceId || 0])\n                : queryMeshTaskInstanceDynamicState(db, [node.resource.meshTaskInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                meshTaskInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.TASK_MESH\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandClusterInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    clusterInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandClusterInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandClusterInstanceNode {\n    export const RESOURCE_TYPE = 'cluster-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandClusterInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandClusterInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_cluster_${element.clusterInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandClusterInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandClusterInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            clusterInstanceId: element.clusterInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandClusterInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query cluster instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for cluster dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command cluster instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandClusterInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const clusterInstanceDynamicStatePromise = batchQuery\n                ? queryClusterInstanceDynamicStateBatched(db, [node.resource.clusterInstanceId || 0])\n                : queryClusterInstanceDynamicState(db, [node.resource.clusterInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                clusterInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.CLUSTER\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandRaytracingInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    raytracingInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandRaytracingInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandRaytracingInstanceNode {\n    export const RESOURCE_TYPE = 'raytracing-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandRaytracingInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRaytracingInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_raytracing_${element.raytracingInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRaytracingInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRaytracingInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            raytracingInstanceId: element.raytracingInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandRaytracingInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query raytracing instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for raytracing dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command raytracing instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandRaytracingInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const raytracingInstanceDynamicStatePromise = batchQuery\n                ? queryRaytracingInstanceDynamicStateBatched(db, [node.resource.raytracingInstanceId || 0])\n                : queryRaytracingInstanceDynamicState(db, [node.resource.raytracingInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                raytracingInstanceDynamicStatePromise,\n                PipelineBindPoint.RAY_TRACING,\n                PipelineBindPointShaderStageFlags.RAY_TRACING\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport function getQueueSubmitId(node: CommandTreeNode): number | undefined {\n    let currentNode: CompositeTreeNode | undefined;\n    if (\n        CommandEmptyNode.is(node) ||\n        CommandApiEventNode.is(node) ||\n        CommandTreeDrawOrDispatchNode.is(node) ||\n        CommandAccelerationStructureBuildNode.is(node) ||\n        CommandAccelerationStructureCopyNode.is(node) ||\n        CommandTransferCommandNode.is(node)\n    ) {\n        currentNode = node.parent;\n    } else if (CommandQueuePresentNode.is(node) || CommandQueueDebugLabelNode.is(node)) {\n        return undefined;\n    } else {\n        currentNode = node;\n    }\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(currentNode, CommandQueueSubmitNode.is);\n    return queueSubmitNode ? queueSubmitNode.resource.submissionId : undefined;\n}\n\nexport function findLastDrawInstanceNode(node: CommandTreeNode): CommandDrawInstanceNode | undefined {\n    if (CommandDrawInstanceNode.is(node)) {\n        return node;\n    }\n    let lastDraw: CommandDrawInstanceNode | undefined;\n    if (!CommandDrawInstanceNode.is(node) && ExpandableTreeNode.is(node)) {\n        for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n            lastDraw = findLastDrawInstanceNode(node.children[commandIndex]);\n            if (lastDraw) {\n                break;\n            }\n        }\n    }\n    return lastDraw;\n}\n\nexport function createExecuteCommandsApiResources(\n    node: CommandSecondaryCommandBufferExecutionNode,\n    primaryNode: CommandCommandBufferInstanceNode,\n    queueSubmitNode: CommandQueueSubmitNode,\n    specificSecondaryCommandBufferBeginId?: number // If provided, only include this specific secondary CB\n): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    // findParentNode checks the given node for its type so we have to start looking from this node's parent\n    // otherwise we run into infinite recursion\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node.parent,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n\n    // Collect secondary command buffer begin IDs from the children\n    const commandBufferBeginIds: number[] = [];\n    if (specificSecondaryCommandBufferBeginId !== undefined) {\n        // Only include the specific secondary CB that was requested\n        commandBufferBeginIds.push(specificSecondaryCommandBufferBeginId);\n    } else {\n        // Include all secondary CBs (for when the execution node itself requests a thumbnail)\n        for (const child of node.children) {\n            if (CommandCommandBufferInstanceNode.is(child)) {\n                commandBufferBeginIds.push(child.resource.beginApiEvent);\n            }\n        }\n    }\n\n    const resources: ApiResources[] = [];\n    if (secondaryCommandBufferExecutionNode) {\n        const renderpassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n            renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n            CommandSecondaryCommandBufferExecutionNode.is\n        );\n\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: secondaryCommandBufferExecutionNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n                renderpassSecondaryCommandBufferExecutionNode &&\n                renderpassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n        const executionResources = createExecuteCommandsApiResources(secondaryCommandBufferExecutionNode, primaryNode, queueSubmitNode);\n        if (executionResources.length > 0) {\n            resources.push(...executionResources);\n        }\n    } else {\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: primaryNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                renderPassInstanceNode || dynamicRenderPassInstanceNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n    }\n    return resources;\n}\n\nexport function createDrawApiResources(node: CommandDrawInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    // This will find the immediate parent command buffer (secondary if in a secondary CB, primary otherwise)\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n\n    const resources: ApiResources[] = [];\n    if (\n        (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n        queueSubmitNode &&\n        commandBufferInstanceNode &&\n        primaryCommandBufferInstanceNode\n    ) {\n        if (secondaryCommandBufferExecutionNode) {\n            const renderPassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n                CommandSecondaryCommandBufferExecutionNode.is\n            );\n\n            // Add draw resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses:\n                    renderPassSecondaryCommandBufferExecutionNode &&\n                    renderPassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                        ? [\n                              {\n                                  beginId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                                  subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                                  endId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                        dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                              }\n                          ]\n                        : []\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses: [\n                    {\n                        beginId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                        subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                        endId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.endApiEvent || dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                    }\n                ]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createComputeApiResources(node: CommandDispatchInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add dispatch resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createTraceRaysApiResources(node: CommandRaytracingInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTransferNode = CommandAccelerationStructureBuildNode | CommandAccelerationStructureCopyNode | CommandTransferCommandNode;\n\nexport function createTransferApiResources(node: CommandTransferNode): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    let transferEvent: number = 0;\n    if (CommandAccelerationStructureBuildNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureBuildNode).resource.buildApiEvent;\n    } else if (CommandAccelerationStructureCopyNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureCopyNode).resource.copyApiEvent;\n    } else if (CommandTransferCommandNode.is(node)) {\n        transferEvent = (node as CommandTransferCommandNode).resource.transferApiEvent;\n    }\n\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTreeNode =\n    | CommandFrameNode\n    | CommandEmptyNode\n    | CommandApiEventNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandQueuePresentNode\n    | CommandQueueDebugLabelGroupNode\n    | CommandQueueDebugLabelNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandEmptyNode.is(node) ||\n            CommandApiEventNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandQueuePresentNode.is(node) ||\n            CommandQueueDebugLabelGroupNode.is(node) ||\n            CommandQueueDebugLabelNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n\n    export function findApiEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandSecondaryCommandBufferExecutionNode.is(current)) {\n            // For secondary command buffer execution nodes, return the VkCmdExecuteCommands apiEvent\n            // rather than the VkCommandBufferBegin apiEvent\n            return current.resource.apiEvent;\n        } else if (CommandTreeRangeNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (\n            CommandApiEventNode.is(current) ||\n            CommandQueueSubmitNode.is(current) ||\n            CommandQueuePresentNode.is(current) ||\n            CommandQueueDebugLabelNode.is(current)\n        ) {\n            return current.apiEventId;\n        } else if (CommandQueueDebugLabelGroupNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (CommandAccelerationStructureBuildNode.is(current)) {\n            return current.resource.buildApiEvent;\n        } else if (CommandAccelerationStructureCopyNode.is(current)) {\n            return current.resource.copyApiEvent;\n        } else if (CommandTransferCommandNode.is(current)) {\n            return current.apiEventId;\n        } else if (CommandTreeDrawOrDispatchNode.is(current)) {\n            return current.resource.apiEventId;\n        }\n        return undefined;\n    }\n\n    export function findFilterEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandFrameNode.is(current)) {\n            return current.resource.beginApiEvent;\n        }\n        let maybeQueueSubmitOrPresent: TreeNode | undefined = current;\n        while (\n            maybeQueueSubmitOrPresent !== undefined &&\n            !(\n                CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueuePresentNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)\n            )\n        ) {\n            maybeQueueSubmitOrPresent = maybeQueueSubmitOrPresent.parent;\n        }\n        let queueSubmitEventId: number | undefined;\n        if (maybeQueueSubmitOrPresent !== undefined) {\n            if (CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) || CommandQueuePresentNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            } else if (CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.resource.beginApiEvent;\n            } else if (CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            }\n        }\n        return queueSubmitEventId;\n    }\n\n    export function findRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const renderPassNode = findParentNode<CommandRenderPassInstanceNode>(current, CommandRenderPassInstanceNode.is);\n        return renderPassNode ? renderPassNode.renderPassInstanceId : undefined;\n    }\n\n    export function findDynamicRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const dynamicRenderPassNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n            current,\n            CommandDynamicRenderPassInstanceNode.is\n        );\n        return dynamicRenderPassNode ? dynamicRenderPassNode.dynamicRenderPassInstanceId : undefined;\n    }\n\n    export function findDrawInstanceId(current?: CommandTreeNode): number | undefined {\n        const drawInstanceNode = findParentNode<CommandDrawInstanceNode>(current, CommandDrawInstanceNode.is);\n        return drawInstanceNode ? drawInstanceNode.drawInstanceId : undefined;\n    }\n\n    export function findDispatchInstanceId(current?: CommandTreeNode): number | undefined {\n        const dispatchInstanceNode = findParentNode<CommandDispatchInstanceNode>(current, CommandDispatchInstanceNode.is);\n        return dispatchInstanceNode ? dispatchInstanceNode.dispatchInstanceId : undefined;\n    }\n\n    export function findMeshTaskInstanceId(current?: CommandTreeNode): number | undefined {\n        const meshTaskInstanceNode = findParentNode<CommandMeshTaskInstanceNode>(current, CommandMeshTaskInstanceNode.is);\n        return meshTaskInstanceNode ? meshTaskInstanceNode.meshTaskInstanceId : undefined;\n    }\n\n    export function findClusterInstanceId(current?: CommandTreeNode): number | undefined {\n        const clusterInstanceNode = findParentNode<CommandClusterInstanceNode>(current, CommandClusterInstanceNode.is);\n        return clusterInstanceNode ? clusterInstanceNode.clusterInstanceId : undefined;\n    }\n\n    export function findRaytracingInstanceId(current?: CommandTreeNode): number | undefined {\n        const raytracingInstanceNode = findParentNode<CommandRaytracingInstanceNode>(current, CommandRaytracingInstanceNode.is);\n        return raytracingInstanceNode ? raytracingInstanceNode.raytracingInstanceId : undefined;\n    }\n\n    export function findAccelerationBuildInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelBuildNode = findParentNode<CommandAccelerationStructureBuildNode>(current, CommandAccelerationStructureBuildNode.is);\n        return accelBuildNode ? accelBuildNode.buildInstanceId : undefined;\n    }\n\n    export function findAccelerationCopyInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelCopyNode = findParentNode<CommandAccelerationStructureCopyNode>(current, CommandAccelerationStructureCopyNode.is);\n        return accelCopyNode ? accelCopyNode.copyInstanceId : undefined;\n    }\n\n    export function findTransferCommandInstanceId(current?: CommandTreeNode): number | undefined {\n        const transferCommandNode = findParentNode<CommandTransferCommandNode>(current, CommandTransferCommandNode.is);\n        return transferCommandNode ? transferCommandNode.transferCommandInstanceId : undefined;\n    }\n\n    export function findMergedDynamicStatePromise(\n        current: CommandTreeNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> | undefined {\n        let maybeDrawOrDispatchInstance: TreeNode | undefined = current;\n        while (maybeDrawOrDispatchInstance !== undefined && !CommandTreeDrawOrDispatchNode.is(maybeDrawOrDispatchInstance)) {\n            maybeDrawOrDispatchInstance = maybeDrawOrDispatchInstance.parent;\n        }\n        let mergedDynamicStatePromise: Promise<DynamicStateEntry[]> | undefined;\n        if (maybeDrawOrDispatchInstance !== undefined && CommandDrawInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDrawInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandDispatchInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDispatchInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandMeshTaskInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandMeshTaskInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandClusterInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandClusterInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandRaytracingInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandRaytracingInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        }\n        return mergedDynamicStatePromise;\n    }\n\n    export function getRoot(node?: CompositeTreeNode | CommandRootNode | CommandTreeNode): CommandRootNode | undefined {\n        return findParentNode<CommandRootNode>(node, CommandRootNode.is);\n    }\n\n    export function getDbId(node: CommandRootNode | CommandTreeNode): number {\n        return getRoot(node)?.dbId ?? -1;\n    }\n\n    type GeneralizableNodes =\n        | typeof CommandApiEventNode\n        | typeof CommandClusterInstanceNode\n        | typeof CommandCommandBufferInstanceNode\n        | typeof CommandDispatchInstanceNode\n        | typeof CommandDrawInstanceNode\n        | typeof CommandEmptyNode\n        | typeof CommandFrameNode\n        | typeof CommandMeshTaskInstanceNode\n        | typeof CommandQueuePresentNode\n        | typeof CommandQueueSubmitNode\n        | typeof CommandQueueDebugLabelGroupNode\n        | typeof CommandQueueDebugLabelNode\n        | typeof CommandAccelerationStructureBuildNode\n        | typeof CommandAccelerationStructureCopyNode\n        | typeof CommandTransferCommandNode\n        | typeof CommandRaytracingInstanceNode\n        | typeof CommandRenderPassInstanceNode\n        | typeof CommandRenderSubpassInstanceNode\n        | typeof CommandDynamicRenderPassInstanceNode\n        | typeof CommandDebugLabelGroupNode;\n\n    /**\n     * An aggregate type label for command-tree nodes, roughly corresponding to some of the union\n     * types defined in this module.\n     */\n    export type GeneralizedType = GeneralizableNodes['GENERALIZED_TYPE'];\n\n    /**\n     * Query the generalized type of a given node, if it is a Command Tree node.\n     *\n     * @param node a tree node that may or may not be a `CommandTreeNode`\n     * @return its generalized type, or `undefined` if it isn't a `CommandTreeNode`\n     */\n    export function getGeneralizedNodeType(node: TreeNode): GeneralizedType | undefined {\n        const resourceType = 'resourceType' in node ? node.resourceType : undefined;\n        if (!resourceType) {\n            return CommandEmptyNode.is(node) ? 'empty' : undefined;\n        }\n\n        switch (resourceType) {\n            case 'frame':\n            case 'command-buffer-instance':\n            case 'render-pass-instance':\n            case 'render-subpass-instance':\n            case 'secondary-command-buffer-execution':\n            case 'debug-label-group':\n                return 'range';\n            case 'queue-submit':\n            case 'queue-present':\n                return 'queue';\n            case 'acceleration-structure-build':\n                return 'acceleration-structure-build';\n            case 'acceleration-structure-copy':\n                return 'acceleration-structure-copy';\n            case 'transfer-command':\n                return 'transfer-command';\n            case 'draw-instance':\n            case 'dispatch-instance':\n            case 'mesh-task-instance':\n            case 'cluster-instance':\n            case 'raytracing-instance':\n                return 'draw-or-dispatch';\n            case 'api-event':\n                return 'api-event';\n            default:\n                return undefined;\n        }\n    }\n\n    /** Type assertion for a range-type node. */\n    export function generalize(node: TreeNode, type: 'range'): asserts node is CommandTreeRangeNode;\n    /** Type assertion for a queue-type node. */\n    export function generalize(node: TreeNode, type: 'queue'): asserts node is CommandQueueSubmitNode | CommandQueuePresentNode;\n    /** Type assertion for a queue-debug-label-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'queue-debug-label'\n    ): asserts node is CommandQueueDebugLabelGroupNode | CommandQueueDebugLabelNode;\n    /** Type assertion for a acceleration-structure-build-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-build'): asserts node is CommandAccelerationStructureBuildNode;\n    /** Type assertion for a acceleration-structure-copy-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-copy'): asserts node is CommandAccelerationStructureCopyNode;\n    /** Type assertion for a transfer-command-type node. */\n    export function generalize(node: TreeNode, type: 'transfer-command'): asserts node is CommandTransferCommandNode;\n    /** Type assertion for a draw-or-dispatch-type node. */\n    export function generalize(node: TreeNode, type: 'draw-or-dispatch'): asserts node is CommandTreeDrawOrDispatchNode;\n    /** Type assertion for an api-event-type node. */\n    export function generalize(node: TreeNode, type: 'api-event'): asserts node is CommandApiEventNode;\n    /** Type assertion for a draw-or-dispatch- or api-event-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'draw-or-dispatch' | 'api-event'\n    ): asserts node is CommandTreeDrawOrDispatchNode | CommandApiEventNode;\n    /** Type assertion for an empty-type node. */\n    export function generalize(node: TreeNode, type: 'empty'): asserts node is CommandEmptyNode;\n    export function generalize(node: TreeNode, _type: GeneralizedType): asserts node is CommandTreeNode {\n        // Pass\n    }\n}\n\nexport type CommandTreeRangeNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeRangeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeRangeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n}\n\nexport type CommandTreeDrawOrDispatchNode =\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode;\n\nexport namespace CommandTreeDrawOrDispatchNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeDrawOrDispatchNode {\n        return (\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node)\n        );\n    }\n}\n\ninterface ArrayWithSortNumber<RangeType> {\n    array: RangeType[];\n    getSortNumber(element: RangeType): number;\n}\n\ntype AllRangeTypes =\n    | CommandTreeDebugLabelGroupInstance\n    | CommandTreeRenderPassInstance\n    | CommandTreeRenderSubpassInstance\n    | CommandTreeDynamicRenderPassInstance;\n\ntype CommandTreeRangeParentNode =\n    | CommandRenderPassInstanceNode\n    | CommandCommandBufferInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandDebugLabelGroupNode;\n\nfunction findNextRangeElementToProcess<RangeType>(...arrays: ArrayWithSortNumber<RangeType>[]): RangeType | undefined {\n    // designate which array is the api event array vs a range array\n    // when processing a range, shift off any api events that are within the range\n    // so they aren't processed (because they actually reside within a sub-group)\n\n    const arraysToProcess: ArrayWithSortNumber<RangeType>[] = [];\n    arrays.forEach(arr => {\n        if (arr.array.length) {\n            arraysToProcess.push(arr);\n        }\n    });\n\n    if (!arraysToProcess.length) {\n        return undefined;\n    }\n\n    // get the sort number of the first element of each array and sort them\n    const sortedElements = arraysToProcess\n        .map(array => ({ subarray: array.array, sortNumber: array.getSortNumber(array.array[0]) }))\n        .sort((a, b) => a.sortNumber - b.sortNumber);\n\n    return sortedElements[0].subarray.shift();\n}\n\n/**\n * Process commands and ranges together in API event order.\n * For each range element, creates child nodes for commands that come before it,\n * skips commands that fall within the range, and creates a node for the range itself.\n * After processing all ranges, any remaining commands are processed.\n *\n * @param ctx - Command tree context\n * @param root - Root node\n * @param parentNode - Parent node to add children to\n * @param apiEventCommandArray - Array of commands sorted by API event ID (will be mutated)\n * @param childCommandIndex - Starting index for child commands\n * @param baseDynamicStatePromise - Promise for dynamic state\n * @param createRangeNode - Callback to create a node for each range element\n * @param rangeArrays - Variable number of range arrays to process together\n * @returns The final child command index\n */\nasync function createChildEventNodesForRange<RangeType extends { beginApiEvent: number; endApiEvent?: number }>(\n    ctx: CommandTreeContext,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    apiEventCommandArray: CommandTreeApiEvent[],\n    childCommandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n    createRangeNode: (rangeElement: RangeType, parentNode: CommandTreeRangeParentNode) => void,\n    ...rangeArrays: ArrayWithSortNumber<RangeType>[]\n): Promise<number> {\n    console.log(\n        `JF: createChildEventNodesForRange START for parent ${parentNode.id}, apiEventCommandArray length: ${apiEventCommandArray.length}`\n    );\n    const stateTracker = new DynamicStateTracker(baseDynamicStatePromise);\n    let nextRangeElement: RangeType | undefined;\n    let priorRangeEndApiEvent: number | undefined;\n\n    while ((nextRangeElement = findNextRangeElementToProcess<RangeType>(...rangeArrays))) {\n        // create a node for any command that comes BEFORE the next range element\n        while (apiEventCommandArray.length && apiEventCommandArray[0].apiEventId < nextRangeElement.beginApiEvent) {\n            const command = apiEventCommandArray.shift();\n            childCommandIndex = await createChildEventNode(ctx, command!, root, parentNode, childCommandIndex, stateTracker);\n        }\n\n        // shift off any command that falls WITHIN next range since it will be processed when creating next range node\n        while (\n            apiEventCommandArray.length &&\n            nextRangeElement.endApiEvent !== undefined &&\n            apiEventCommandArray[0].apiEventId >= nextRangeElement.beginApiEvent &&\n            apiEventCommandArray[0].apiEventId <= nextRangeElement.endApiEvent\n        ) {\n            apiEventCommandArray.shift();\n        }\n\n        // skip next range if it falls within the prior range since it will be processed when creating prior range node\n        if (\n            priorRangeEndApiEvent !== undefined &&\n            nextRangeElement.endApiEvent !== undefined &&\n            nextRangeElement.endApiEvent <= priorRangeEndApiEvent\n        ) {\n            continue;\n        }\n        priorRangeEndApiEvent = nextRangeElement.endApiEvent;\n\n        // create a node for the next range element\n        createRangeNode(nextRangeElement, parentNode);\n    }\n\n    // process any remaining command elements after all range elements have been processed\n    for (const command of apiEventCommandArray) {\n        childCommandIndex = await createChildEventNode(ctx, command, root, parentNode, childCommandIndex, stateTracker);\n    }\n\n    console.log(`JF: createChildEventNodesForRange END for parent ${parentNode.id}, final children count: ${parentNode.children.length}`);\n    return childCommandIndex;\n}\n\n/**\n * Find node from descendent node for which isNode is true\n */\nexport const findParentNode = <T extends TreeNode>(\n    node: TreeNode | undefined,\n    isNode: (node: TreeNode | undefined) => node is T\n): T | undefined => {\n    let targetNode: TreeNode | undefined = node;\n    while (targetNode && targetNode.parent && !isNode(targetNode)) {\n        targetNode = targetNode.parent;\n    }\n\n    return targetNode && isNode(targetNode) ? targetNode : undefined;\n};\n\n/**\n * Find the primary command buffer instance node from a given command buffer instance node.\n * If the given node is in a secondary command buffer, traverses up through nested secondary\n * command buffers until finding the primary command buffer (one with no parent execution node).\n * If the given node is already in a primary command buffer, returns it as-is.\n */\nexport const findPrimaryCommandBufferInstanceNode = (\n    commandBufferInstanceNode: CommandCommandBufferInstanceNode | undefined,\n    secondaryCommandBufferExecutionNode: CommandSecondaryCommandBufferExecutionNode | undefined\n): CommandCommandBufferInstanceNode | undefined => {\n    let primaryCommandBufferInstanceNode = commandBufferInstanceNode;\n    if (secondaryCommandBufferExecutionNode) {\n        let currentExecution: CommandSecondaryCommandBufferExecutionNode | undefined = secondaryCommandBufferExecutionNode;\n        while (currentExecution) {\n            const parentCB: CommandCommandBufferInstanceNode | undefined = findParentNode<CommandCommandBufferInstanceNode>(\n                currentExecution,\n                CommandCommandBufferInstanceNode.is\n            );\n            if (parentCB) {\n                primaryCommandBufferInstanceNode = parentCB;\n                // Check if this CB is also inside another secondary execution (nested case)\n                currentExecution = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                    parentCB.parent,\n                    CommandSecondaryCommandBufferExecutionNode.is\n                );\n            } else {\n                break;\n            }\n        }\n    }\n    return primaryCommandBufferInstanceNode;\n};\n\n/**\n * find a frame node from descendent node or self\n */\nexport const findFrameNode = (node: TreeNode): CommandFrameNode | undefined => findParentNode<CommandFrameNode>(node, CommandFrameNode.is);\n\n@injectable()\nexport class CommandTree extends BulkTree implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTree {\n        return tree instanceof CommandTree;\n    }\n\n    @inject(CaptureDatasetWidgetProfile)\n    protected readonly profile: CaptureDatasetWidgetProfile;\n    @inject(CaptureDatasetWidgetContext)\n    protected readonly context: CaptureDatasetWidgetContext;\n\n    @inject(CommandTreeDataQueriedRootProvider)\n    protected readonly rootProvider: CommandTreeDataQueriedRootProvider;\n    @inject(GFXRQueryBuilderService)\n    protected readonly gfxrQueryBuilderService: GFXRQueryBuilderService;\n\n    protected override _root: CommandRootNode | undefined;\n\n    // Back-reference to the model that manages this tree\n    model?: CommandTreeModel;\n\n    protected readonly onStructureChangedEmitter = new Emitter<TreeNode | undefined>();\n    readonly onStructureChanged = this.onStructureChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this._root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        super.root = root;\n        // Set back-reference from root to tree\n        if (root) {\n            root.tree = this;\n        }\n    }\n\n    async initTree(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        this.root = await this.rootProvider.provide(dbId, { tree: this }, options, createDrawOrDispatchChildren);\n\n        // tree structure is fully built at this point, report structure change\n        this.onStructureChangedEmitter.fire(undefined);\n    }\n\n    async refreshStructure(node?: CompositeTreeNode, cancellationToken?: CancellationToken): Promise<void> {\n        await this.refresh(node, cancellationToken);\n        this.fireStructureChanged(node);\n    }\n\n    fireStructureChanged(node?: TreeNode): void {\n        this.onStructureChangedEmitter.fire(node);\n    }\n\n    addToDispose(disposable: Disposable): void {\n        this.toDispose.push(disposable);\n    }\n\n    override dispose(): void {\n        this.rootProvider.dispose();\n        super.dispose();\n    }\n}\n\n@injectable()\nexport class CommandTreeModelPreferenceStateAccessImpl implements CommandTreePreferenceState.Access {\n    private readonly models = new Map<CommandTree, CommandTreeModel>();\n\n    private readonly commandTreeStateChangedEmitter = new Emitter<{ tree: CommandTree; state: CommandTreePreferenceState }>();\n    readonly onCommandTreeStateChanged = this.commandTreeStateChangedEmitter.event;\n\n    getCommandTreeState(tree: CommandTree): CommandTreePreferenceState {\n        return this.models.get(tree)?.getPreferenceState() ?? {};\n    }\n\n    fireCommandTreeStateChanged(tree: CommandTree): void {\n        this.commandTreeStateChangedEmitter.fire({ tree, state: this.getCommandTreeState(tree) });\n    }\n\n    registerCommandTreeModel(tree: CommandTree, model: CommandTreeModel): void {\n        this.models.set(tree, model);\n        this.fireCommandTreeStateChanged(tree);\n    }\n}\n\n@injectable()\nexport class CommandTreeModel extends BulkTreeModel implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTreeModel {\n        return tree instanceof CommandTreeModel;\n    }\n\n    @inject(MiscPreferences)\n    protected readonly miscPreferences: MiscPreferences;\n    @inject(CommandTree) override readonly tree: CommandTree;\n    protected _groupBy: GroupByOptions = GroupByOptions.Frame;\n    private groupByChangedEmitter = new Emitter<GroupByOptions>();\n    readonly onGroupByChanged = this.groupByChangedEmitter.event;\n    protected _isThumbnailEnabled = true;\n    protected _isApiEventIdsEnabled = true;\n    protected _isShowingEmptyRows = false;\n    protected _isVulkanEnabled = true;\n    protected _isDebugNamesEnabled = true;\n    protected _isDebugLabelsEnabled = true;\n    protected _isLinksEnabled = true;\n    protected _isThreadsEnabled = true;\n\n    @inject(FrameRangeSelectionService)\n    protected readonly frameRangeSelectionService: FrameRangeSelectionService;\n\n    @inject(CommandTreeModelPreferenceStateAccessImpl)\n    private readonly preferenceStateAccess: CommandTreeModelPreferenceStateAccessImpl;\n\n    protected isCollapsingSubTree = false;\n\n    // Proxies to prevent calls on sub tree expansion\n    protected readonly onExpansionChangedEmitterProxy = new Emitter<ExpandableTreeNode>();\n    protected readonly onChangedEmitterProxy = new Emitter<void>();\n\n    protected readonly onSubTreeExpansionChangedEmitter = new Emitter<ExpandableTreeNode>();\n    readonly onSubTreeExpansionChanged = this.onSubTreeExpansionChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this.tree.root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        this.tree.root = root;\n    }\n\n    override get onChanged(): Event<void> {\n        return this.onChangedEmitterProxy.event;\n    }\n\n    override get onExpansionChanged(): Event<ExpandableTreeNode> {\n        return this.onExpansionChangedEmitterProxy.event;\n    }\n\n    get onStructureChanged(): Event<TreeNode | undefined> {\n        return this.tree.onStructureChanged;\n    }\n\n    async initModel(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        await this.tree.initTree(dbId, createDrawOrDispatchChildren, options);\n    }\n\n    set groupBy(value: GroupByOptions) {\n        if (this._groupBy !== value) {\n            this._groupBy = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n            this.groupByChangedEmitter.fire(value);\n        }\n    }\n\n    get groupBy(): GroupByOptions {\n        return this._groupBy;\n    }\n\n    /**\n     * Obtain the tree nodes that are the top-level groups according to\n     * the current {@link groupBy} mode.\n     */\n    *groupNodes(): IterableIterator<CompositeTreeNode> {\n        if (!this.root) {\n            return;\n        }\n\n        const group = this.groupBy;\n        const treeIterator = new (class extends DepthFirstTreeIterator {\n            protected override children(node: TreeNode): TreeNode[] | undefined {\n                // Prune group nodes because we needn't look in them for more groups\n                return CommandTreeModel.isOfGroup(node, group) ? undefined : super.children(node);\n            }\n        })(this.root);\n\n        for (const next of treeIterator) {\n            if (CommandTreeModel.isOfGroup(next, group)) {\n                yield next;\n            }\n        }\n    }\n\n    set isApiEventIdsEnabled(value: boolean) {\n        if (this._isApiEventIdsEnabled !== value) {\n            this._isApiEventIdsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isApiEventIdsEnabled(): boolean {\n        return this._isApiEventIdsEnabled;\n    }\n\n    set isShowingEmptyRows(value: boolean) {\n        if (this._isShowingEmptyRows !== value) {\n            this._isShowingEmptyRows = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isShowingEmptyRows(): boolean {\n        return this._isShowingEmptyRows;\n    }\n\n    set isThumbnailEnabled(value: boolean) {\n        if (this._isThumbnailEnabled !== value) {\n            this._isThumbnailEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThumbnailEnabled(): boolean {\n        return this._isThumbnailEnabled;\n    }\n\n    set isVulkanEnabled(value: boolean) {\n        if (this._isVulkanEnabled !== value) {\n            this._isVulkanEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isVulkanEnabled(): boolean {\n        return this._isVulkanEnabled;\n    }\n\n    set isDebugNamesEnabled(value: boolean) {\n        if (this._isDebugNamesEnabled !== value) {\n            this._isDebugNamesEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugNamesEnabled(): boolean {\n        return this._isDebugNamesEnabled;\n    }\n\n    set isDebugLabelsEnabled(value: boolean) {\n        if (this._isDebugLabelsEnabled !== value) {\n            this._isDebugLabelsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugLabelsEnabled(): boolean {\n        return this._isDebugLabelsEnabled;\n    }\n\n    set isLinksEnabled(value: boolean) {\n        if (this._isLinksEnabled !== value) {\n            this._isLinksEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isLinksEnabled(): boolean {\n        return this._isLinksEnabled;\n    }\n\n    set isThreadsEnabled(value: boolean) {\n        if (this._isThreadsEnabled !== value) {\n            this._isThreadsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThreadsEnabled(): boolean {\n        return this._isThreadsEnabled;\n    }\n\n    getPreferenceState(nonDefaultOnly = false): CommandTreePreferenceState {\n        const result: CommandTreePreferenceState = {};\n\n        if (!nonDefaultOnly || this.groupBy !== this.miscPreferences[MiscPrefs.GroupBy]) {\n            result.groupBy = this.groupBy;\n        }\n        if (!nonDefaultOnly || this.isApiEventIdsEnabled !== this.miscPreferences[MiscPrefs.ShowApiEventIds]) {\n            result.isApiEventIdsEnabled = this.isApiEventIdsEnabled;\n        }\n        if (!nonDefaultOnly || this.isShowingEmptyRows !== this.miscPreferences[MiscPrefs.ShowEmptyRows]) {\n            result.isShowingEmptyRows = this.isShowingEmptyRows;\n        }\n        if (!nonDefaultOnly || this.isThumbnailEnabled !== this.miscPreferences[MiscPrefs.ShowThumbnails]) {\n            result.isThumbnailEnabled = this.isThumbnailEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugNamesEnabled !== true) {\n            result.isDebugNamesEnabled = this.isDebugNamesEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugLabelsEnabled !== true) {\n            result.isDebugLabelsEnabled = this.isDebugLabelsEnabled;\n        }\n        if (!nonDefaultOnly || this.isLinksEnabled !== true) {\n            result.isLinksEnabled = this.isLinksEnabled;\n        }\n        if (!nonDefaultOnly || this.isThreadsEnabled !== true) {\n            result.isThreadsEnabled = this.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (!nonDefaultOnly || this.isVulkanEnabled !== this.miscPreferences[MiscPrefs.ShowVulkanCalls]) {\n        //     result.isVulkanEnabled = this.isVulkanEnabled;\n        // }\n\n        return result;\n    }\n\n    override restoreState(state: CommandTreeModel.State): void {\n        if (state.groupBy !== undefined) {\n            this.groupBy = state.groupBy;\n        }\n        if (state.isApiEventIdsEnabled !== undefined) {\n            this.isApiEventIdsEnabled = state.isApiEventIdsEnabled;\n        }\n        if (state.isShowingEmptyRows !== undefined) {\n            this.isShowingEmptyRows = state.isShowingEmptyRows;\n        }\n        if (state.isThumbnailEnabled !== undefined) {\n            this.isThumbnailEnabled = state.isThumbnailEnabled;\n        }\n        if (state.isDebugNamesEnabled !== undefined) {\n            this.isDebugNamesEnabled = state.isDebugNamesEnabled;\n        }\n        if (state.isDebugLabelsEnabled !== undefined) {\n            this.isDebugLabelsEnabled = state.isDebugLabelsEnabled;\n        }\n        if (state.isLinksEnabled !== undefined) {\n            this.isLinksEnabled = state.isLinksEnabled;\n        }\n        if (state.isThreadsEnabled !== undefined) {\n            this.isThreadsEnabled = state.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (state.isVulkanEnabled !== undefined) {\n        //     this.isVulkanEnabled = state.isVulkanEnabled;\n        // }\n    }\n    override storeState(): CommandTreeModel.State {\n        return {\n            ...super.storeState(),\n            ...this.getPreferenceState(true)\n        };\n    }\n\n    @postConstruct()\n    protected override init(): void {\n        super.init();\n\n        // Set back-reference from tree to model\n        this.tree.model = this;\n\n        this.toDispose.pushAll([\n            this.onChangedEmitterProxy,\n            this.onExpansionChangedEmitterProxy,\n            this.onSubTreeExpansionChangedEmitter,\n\n            super.onChanged(() => {\n                if (!this.isCollapsingSubTree) {\n                    this.onChangedEmitterProxy.fire();\n                }\n            }),\n            super.onExpansionChanged(node => {\n                if (!this.isCollapsingSubTree) {\n                    this.onExpansionChangedEmitterProxy.fire(node);\n                }\n            })\n        ]);\n\n        this._isApiEventIdsEnabled = this.miscPreferences[MiscPrefs.ShowApiEventIds];\n        this._isShowingEmptyRows = this.miscPreferences[MiscPrefs.ShowEmptyRows];\n        this.isThumbnailEnabled = this.miscPreferences[MiscPrefs.ShowThumbnails];\n        this.groupBy = this.miscPreferences[MiscPrefs.GroupBy];\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // this.isVulkanEnabled = this.miscPreferences[MiscPrefs.ShowVulkanCalls];\n\n        this.preferenceStateAccess.registerCommandTreeModel(this.tree, this);\n    }\n\n    /**\n     * Collapses the entire tree.\n     */\n    async collapseTree(): Promise<void> {\n        const root = this.root;\n\n        if (CompositeTreeNode.is(root) && root.children.length > 0) {\n            await Promise.all(\n                root.children.filter(CompositeTreeNode.is).map((child: CompositeTreeNode) => this.expansionService.collapseAll(child))\n            );\n        }\n    }\n\n    /**\n     * Expands the given node and all its children recursively.\n     */\n    async expandSubTree(node?: Readonly<TreeNode>, includeDrawOrDispatchNodes = false): Promise<void> {\n        node ??= this.root;\n        if (!ExpandableTreeNode.is(node)) {\n            return;\n        }\n\n        try {\n            this.isCollapsingSubTree = true;\n            await this.doExpandSubTree(node, includeDrawOrDispatchNodes);\n            this.onSubTreeExpansionChangedEmitter.fire(node);\n        } finally {\n            this.isCollapsingSubTree = false;\n        }\n    }\n\n    protected async doExpandSubTree(node: TreeNode, includeDrawOrDispatchNodes: boolean): Promise<void> {\n        const YIELD_AFTER_MS = 200;\n\n        const processedNodes = new Set<TreeNode>();\n        const pendingNodes: TreeNode[] = [node];\n        let lastYieldTime = performance.now();\n\n        while (pendingNodes.length > 0) {\n            const currentLevelNodes: ExpandableTreeNode[] = [];\n            const nextLevelNodes: TreeNode[] = [];\n\n            while (pendingNodes.length > 0) {\n                const currentNode = pendingNodes.shift()!;\n                if (processedNodes.has(currentNode)) {\n                    continue;\n                }\n                processedNodes.add(currentNode);\n\n                // stop expansion at draw and dispatch nodes to avoid creation of low-utility nodes\n                // if this logic gets changed please also update enablement of ExpandSubtreeCommand accordingly\n                if (ExpandableTreeNode.is(currentNode) && (includeDrawOrDispatchNodes || !CommandTreeDrawOrDispatchNode.is(currentNode))) {\n                    currentLevelNodes.push(currentNode);\n                }\n            }\n\n            if (currentLevelNodes.length > 0) {\n                const expandedNodes = await this.expansionService.bulkExpandNodes(currentLevelNodes[Symbol.iterator]());\n                for (const expandedNode of expandedNodes) {\n                    await this.ensureLazyChildrenLoaded(expandedNode);\n                    console.log(\n                        `JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, children count: ${expandedNode.children.length}, children ids: ${expandedNode.children.map(c => c.id).join(', ')}`\n                    );\n                    nextLevelNodes.push(...expandedNode.children);\n                }\n                // Also process children of nodes that were already expanded\n                for (const currentNode of currentLevelNodes) {\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\n                        await this.ensureLazyChildrenLoaded(currentNode);\n                        console.log(\n                            `JF: doExpandSubTree - after ensureLazyChildrenLoaded (already expanded) for ${currentNode.id}, children count: ${currentNode.children.length}, children ids: ${currentNode.children.map(c => c.id).join(', ')}`\n                        );\n                        nextLevelNodes.push(...currentNode.children);\n                    }\n                }\n            }\n\n            pendingNodes.push(...nextLevelNodes);\n\n            // Yield control back to the event loop periodically based on time\n            const currentTime = performance.now();\n            if (currentTime - lastYieldTime >= YIELD_AFTER_MS) {\n                await new Promise(resolve => setTimeout(resolve, 0));\n                lastYieldTime = performance.now();\n            }\n        }\n    }\n\n    protected async ensureLazyChildrenLoaded(node: ExpandableTreeNode): Promise<void> {\n        // Find all loading nodes among children\n        const loadingNodes = node.children.filter(CommandEmptyNode.is);\n\n        if (loadingNodes.length === 0) {\n            return;\n        }\n\n        // Trigger load for all loading nodes and wait for them to complete\n        await Promise.all(loadingNodes.map(loadingNode => triggerLazyLoadAndWaitForRemoval(loadingNode)));\n    }\n\n    hasTrailingSuffixes(node: TreeNode): boolean {\n        if (CommandQueueSubmitNode.is(node)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    protected override isVisibleSelectableNode(node: TreeNode): node is SelectableTreeNode {\n        return super.isVisibleSelectableNode(node) && this.isInFrameRange(node);\n    }\n\n    protected isInFrameRange(node: TreeNode): boolean {\n        const frameNode = CommandFrameNode.getCommandFrameNodeContaining(node);\n        if (frameNode === undefined) {\n            return true; // Assume it's good\n        }\n        const range = this.frameRangeSelectionService.frameSpan;\n        if (range === undefined) {\n            return true; // No constraint\n        }\n        return frameNode.frameIndex >= range.startFrame && frameNode.frameIndex <= range.endFrame;\n    }\n}\n\nexport namespace CommandTreeModel {\n    export interface State extends TreeModelImpl.State, CommandTreePreferenceState {}\n\n    /**\n     * Test whether a `node` is of the kind that implements the given `group` mode.\n     * As groups are _a priori_ composite nodes, this additionally infers that type\n     * for the `node` if successful.\n     */\n    export function isOfGroup(node: TreeNode, group: GroupByOptions): node is CompositeTreeNode {\n        switch (group) {\n            case GroupByOptions.Frame:\n                return CommandFrameNode.is(node);\n            case GroupByOptions.RenderPass:\n                return CommandRenderPassInstanceNode.is(node) || CommandDynamicRenderPassInstanceNode.is(node);\n            case GroupByOptions.RenderSubpass:\n                return CommandRenderSubpassInstanceNode.is(node);\n            case GroupByOptions.CommandBuffer:\n                return CommandCommandBufferInstanceNode.is(node);\n            case GroupByOptions.QueueSubmission:\n                return CommandQueueSubmitNode.is(node);\n        }\n    }\n}\n\ntype TextureSupportingNode =\n    | CommandFrameNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode;\n\nexport namespace TextureSupportingNode {\n    export function is(node: CommandTreeNode): node is TextureSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node)\n        );\n    }\n    export function getLast(node: CommandTreeNode): TextureSupportingNode | undefined {\n        if (TextureSupportingNode.is(node)) {\n            return node;\n        }\n        let lastSupportingNode: TextureSupportingNode | undefined;\n        if (CompositeTreeNode.is(node)) {\n            for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n                lastSupportingNode = TextureSupportingNode.getLast(node.children[commandIndex]);\n                if (lastSupportingNode) {\n                    break;\n                }\n            }\n        }\n        return lastSupportingNode;\n    }\n}\n\n/**\n * Union type of all command tree nodes that support thumbnails.\n * Nodes with heavy thumbnail costs are commented out.\n */\ntype ThumbnailSupportingNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandDebugLabelGroupNode\n    | CommandRenderPassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDrawInstanceNode;\n// Below currently have a possibly heavy cost to getting thumbnails\n// | CommandDispatchInstanceNode\n// | CommandMeshTaskInstanceNode\n// | CommandClusterInstanceNode\n// | CommandRaytracingInstanceNode;\n\nexport namespace ThumbnailSupportingNode {\n    export function is(node: CommandTreeNode): node is ThumbnailSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node)\n        );\n    }\n}\n\nfunction getCommandTreeApiEventChildren(eventIds: Array<{ apiEvent: number }>, root: CommandRootNode): CommandTreeApiEvent[] {\n    return eventIds.reduce<CommandTreeApiEvent[]>((collected, id) => {\n        const event = root.resource.apiEvents[id.apiEvent];\n        if (event) {\n            collected.push(event);\n        } else {\n            console.warn(`No event found for ${id.apiEvent}`);\n        }\n        return collected;\n    }, []);\n}\n\nfunction getInstancesByIds<T>(ids: number[], container: PartialRecord<number, T>, source?: string, target?: string): T[] {\n    return ids.flatMap(id => {\n        const instance = container[id];\n        if (!instance) {\n            if (target) {\n                console.warn(`${source ? `${source} expected` : 'Expected'} ${target} with ${id} but found none.`);\n            }\n            return [];\n        }\n        return instance;\n    });\n}\n\n/**\n * Creates an ArrayWithSortNumber for range instances, used by createChildEventNodesForRange.\n * Fetches instances by IDs and provides sorting by beginApiEvent.\n *\n * @param ids - Array of instance IDs to fetch\n * @param container - Container object mapping IDs to instances\n * @param sourceContext - Context string for error messages (e.g., \"CommandRenderPassInstanceNode.create\")\n * @param targetName - Target instance type name for error messages (e.g., \"DebugLabelGroupInstance\")\n * @returns ArrayWithSortNumber object ready for use with getNextRangeElementToProcess\n */\nfunction createRangeInstanceArray<T extends { beginApiEvent: number }>(\n    ids: number[],\n    container: PartialRecord<number, T>,\n    sourceContext: string,\n    targetName: string\n): ArrayWithSortNumber<T> {\n    return {\n        array: getInstancesByIds(ids, container, sourceContext, targetName),\n        getSortNumber: (element: T) => element.beginApiEvent\n    };\n}\n\nexport function createLazyLoadingNode(\n    tree: CommandTree,\n    parent: ExpandableTreeNode,\n    load: (batchQuery?: boolean) => Promise<void>\n): CommandEmptyNode {\n    let loaded = false;\n    let loadingInProgress = false;\n\n    const lazyLoad: (batchQuery?: boolean) => Promise<boolean> = async (batchQuery = true) => {\n        if (loadingInProgress) {\n            return false;\n        }\n\n        if (!loaded) {\n            loaded = true;\n            loadingInProgress = true;\n            loadOnExpanded.dispose();\n            try {\n                await load(batchQuery);\n            } catch (error) {\n                console.error(`LazyLoad failed for node ${parent.id}:`, error);\n            } finally {\n                loadingInProgress = false;\n            }\n            console.log(\n                `JF: createLazyLoadingNode - load completed for parent ${parent.id}, children count before removeChild: ${parent.children.length}`\n            );\n            CompositeTreeNode.removeChild(parent, loadingNode);\n            await tree.refreshStructure(parent);\n            return true;\n        }\n        return false;\n    };\n\n    // create lazy loading node\n    const loadingNode: CommandEmptyNode = CommandEmptyNode.create(parent, lazyLoad);\n    CompositeTreeNode.addChild(parent, loadingNode);\n\n    // register for lazy loading when the node is expanded\n    const loadOnExpanded = SokatoaLifecycleTreeNode.register(parent, 'onWillRender', async () => {\n        if (parent.expanded) {\n            // do not batch queries for expansion manually\n            await lazyLoad(false);\n        }\n    });\n    return loadingNode;\n}\n"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "I see the long lines are still present. Let me fix them by breaking them into multiple lines:"
            },
            "fallbackMessage": "I see the long lines are still present. Let me fix them by breaking them into multiple lines:"
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_018j32UbRsTM1ZV1Xf61hKJX",
              "name": "writeFileReplacements",
              "arguments": "{\"path\": \"app/packages/capture/src/browser/command-tree/command-tree-model.ts\", \"replacements\": [{\"oldContent\":\"                for (const expandedNode of expandedNodes) {\\n                    await this.ensureLazyChildrenLoaded(expandedNode);\\n                    console.log(\\n                        `JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, children count: ${expandedNode.children.length}, children ids: ${expandedNode.children.map(c => c.id).join(', ')}`\\n                    );\\n                    nextLevelNodes.push(...expandedNode.children);\\n                }\",\"newContent\":\"                for (const expandedNode of expandedNodes) {\\n                    await this.ensureLazyChildrenLoaded(expandedNode);\\n                    const childIds = expandedNode.children.map(c => c.id).join(', ');\\n                    console.log(\\n                        `JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, ` +\\n                            `children count: ${expandedNode.children.length}, children ids: ${childIds}`\\n                    );\\n                    nextLevelNodes.push(...expandedNode.children);\\n                }\"},{\"oldContent\":\"                // Also process children of nodes that were already expanded\\n                for (const currentNode of currentLevelNodes) {\\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\\n                        await this.ensureLazyChildrenLoaded(currentNode);\\n                        console.log(\\n                            `JF: doExpandSubTree - after ensureLazyChildrenLoaded (already expanded) for ${currentNode.id}, children count: ${currentNode.children.length}, children ids: ${currentNode.children.map(c => c.id).join(', ')}`\\n                        );\\n                        nextLevelNodes.push(...currentNode.children);\\n                    }\\n                }\",\"newContent\":\"                // Also process children of nodes that were already expanded\\n                for (const currentNode of currentLevelNodes) {\\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\\n                        await this.ensureLazyChildrenLoaded(currentNode);\\n                        const childIds = currentNode.children.map(c => c.id).join(', ');\\n                        console.log(\\n                            `JF: doExpandSubTree - after ensureLazyChildrenLoaded (already expanded) for ${currentNode.id}, ` +\\n                                `children count: ${currentNode.children.length}, children ids: ${childIds}`\\n                        );\\n                        nextLevelNodes.push(...currentNode.children);\\n                    }\\n                }\"},{\"oldContent\":\"            console.log(\\n                `JF: createLazyLoadingNode - load completed for parent ${parent.id}, children count before removeChild: ${parent.children.length}`\\n            );\",\"newContent\":\"            console.log(\\n                `JF: createLazyLoadingNode - load completed for parent ${parent.id}, ` +\\n                    `children count before removeChild: ${parent.children.length}`\\n            );\"},{\"oldContent\":\"            .then(() => {\\n                console.log(\\n                    `JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\\n            })\",\"newContent\":\"            .then(() => {\\n                console.log(\\n                    `JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, ` +\\n                        `children count: ${node.children.length}`\\n                );\\n            })\"},{\"oldContent\":\"            .then(() => {\\n                console.log(\\n                    `JF: CommandRenderSubpassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\\n            })\",\"newContent\":\"            .then(() => {\\n                console.log(\\n                    `JF: CommandRenderSubpassInstanceNode ${node.id} - async children creation completed, ` +\\n                        `children count: ${node.children.length}`\\n                );\\n            })\"},{\"oldContent\":\"            .then(() => {\\n                console.log(\\n                    `JF: CommandDynamicRenderPassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\\n            })\",\"newContent\":\"            .then(() => {\\n                console.log(\\n                    `JF: CommandDynamicRenderPassInstanceNode ${node.id} - async children creation completed, ` +\\n                        `children count: ${node.children.length}`\\n                );\\n            })\"}]}",
              "finished": true,
              "result": "Errors encountered: Content to replace not found: \"                for (const expandedNode of expa...sh(...expandedNode.children);\n                }\"; Content to replace not found: \"                // Also process children of nod...ldren);\n                    }\n                }\"; Content to replace not found: \"            console.log(\n                `JF: c...hild: ${parent.children.length}`\n            );\"; Content to replace not found: \"            .then(() => {\n                conso...dren.length}`\n                );\n            })\"; Content to replace not found: \"            .then(() => {\n                conso...dren.length}`\n                );\n            })\"; Content to replace not found: \"            .then(() => {\n                conso...dren.length}`\n                );\n            })\""
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "The file content may have changed. Let me re-read the file to get the current state:"
            },
            "fallbackMessage": "The file content may have changed. Let me re-read the file to get the current state:"
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_013ZnQW8C8Dz6A5uEqXWtEiv",
              "name": "getFileContent",
              "arguments": "{\"file\": \"app/packages/capture/src/browser/command-tree/command-tree-model.ts\"}",
              "finished": true,
              "result": "/********************************************************************************\n    Copyright 2024-2026 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\nimport { GFXRQueryBuilderService } from '@sokatoa/gfxr-consumer/lib/';\nimport {\n    DynamicStateEntry,\n    PipelineBindPoint,\n    PipelineBindPointShaderStageFlags,\n    StateType\n} from '@sokatoa/gfxr-consumer/lib/browser/gfxr-data-service';\nimport { PartialRecord } from '@sokatoa/platform/lib';\nimport { BulkTree, BulkTreeModel, ResourceTreeNode, SokatoaLifecycleTreeNode } from '@sokatoa/platform/lib/browser';\nimport { GroupByOptions, MiscPreferences, MiscPrefs } from '@sokatoa/platform/lib/browser/misc-preferences';\nimport { TreeStructureChangeEmitter } from '@sokatoa/platform/lib/browser/tree-table/tree-table-widget';\nimport { ImageAccessorService } from '@sokatoa/platform/lib/common';\nimport { CompressedFileService, usesCompressionExtension } from '@sokatoa/platform/lib/common/compressed-file-service';\nimport { asError } from '@sokatoa/platform/lib/common/error-utils';\nimport { ApiResources, DescriptorResource, DrawApiResult } from '@sokatoa/platform/lib/common/gfxr-apis';\nimport { CancellationToken, Disposable, Emitter, Event, Path, URI } from '@theia/core';\nimport {\n    CompositeTreeNode,\n    DepthFirstTreeIterator,\n    ExpandableTreeNode,\n    SelectableTreeNode,\n    TreeModelImpl,\n    TreeNode\n} from '@theia/core/lib/browser';\nimport { RGBA } from '@theia/core/lib/common/color';\nimport { inject, injectable, postConstruct } from '@theia/core/shared/inversify';\nimport { PNG } from 'pngjs/browser';\nimport { lookupResourceFormat, UncompressedResourceFormat } from '../../common/format-handler';\nimport { extractData } from '../../common/geometry-utils';\nimport { GfxrScreenshotService, requestThumbnails, ScreenshotType, ThumbnailRequestOptions } from '../../common/gfxr-screenshot-service';\nimport { convertDataToImageData } from '../../common/host-side-conversion/vulkan-image';\nimport { FrameRangeSelectionService } from '../capture-widget/frame-range-selection-service';\nimport { placeholderScale } from '../graphics-pipeline-widget/graphics-pipeline-screenshot-requests';\nimport {\n    CaptureDatasetWidgetContext,\n    CaptureDatasetWidgetProfile,\n    CaptureDatasetWidgetReplayContext\n} from '../profile-ui/capture-dataset-widget-types';\nimport { CommandTreePreferenceState } from './command-tree-model-preferences';\nimport {\n    CommandTreeAccelerationStructureBuildInstance,\n    CommandTreeAccelerationStructureCopyInstance,\n    CommandTreeApiEvent,\n    CommandTreeCommandBufferInstance,\n    CommandTreeDataWithFunctionAndDebugNames,\n    CommandTreeDebugLabelGroupInstance,\n    CommandTreeDynamicRenderPassInstance,\n    CommandTreeFrame,\n    CommandTreeQueueDebugLabelGroup,\n    CommandTreeQueueDebugLabelInsert,\n    CommandTreeQueuePresent,\n    CommandTreeQueueSubmit,\n    CommandTreeRenderPassInstance,\n    CommandTreeRenderSubpassInstance,\n    CommandTreeSecondaryCommandBufferInstance,\n    CommandTreeTransferCommandInstance,\n    overrideDynamicState,\n    queryClusterInstanceDynamicState,\n    queryClusterInstanceDynamicStateBatched,\n    queryDispatchInstanceDynamicState,\n    queryDispatchInstanceDynamicStateBatched,\n    queryDrawInstanceDynamicState,\n    queryDrawInstanceDynamicStateBatched,\n    queryMeshTaskInstanceDynamicState,\n    queryMeshTaskInstanceDynamicStateBatched,\n    queryRaytracingInstanceDynamicState,\n    queryRaytracingInstanceDynamicStateBatched,\n    querySecondaryCommandBufferEndDynamicState,\n    QueryTreeDataOptions\n} from './command-tree-service';\nimport { LazyLoadableNode, triggerLazyLoadAndWaitForRemoval } from './lazy-load-utils';\nimport { CommandTreeDataQueriedRootProvider } from './providers/command-tree-root-provider';\n\n// Extension names\nconst VK_NV_COMMAND_BUFFER_INHERITANCE = 'VK_NV_command_buffer_inheritance';\nconst VK_NV_INHERITED_VIEWPORT_SCISSOR = 'VK_NV_inherited_viewport_scissor';\n\n/**\n * Helper type to make TreeNode.parent writable during node construction.\n * TreeNode.parent is readonly, but during tree construction we need to update it.\n */\ninterface MutableParent {\n    parent: CompositeTreeNode | undefined;\n}\n\n/**\n * Check if VK_NV_command_buffer_inheritance extension is enabled for a device.\n * This extension enables full state inheritance between command buffers and leak-back.\n */\nfunction hasCommandBufferInheritance(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_COMMAND_BUFFER_INHERITANCE) ?? false;\n}\n\n/**\n * Check if VK_NV_inherited_viewport_scissor extension is enabled for a device.\n * This extension enables limited viewport/scissor inheritance for secondary command buffers.\n */\nfunction hasInheritedViewportScissor(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_INHERITED_VIEWPORT_SCISSOR) ?? false;\n}\n\n/**\n * Filter dynamic state to only viewport and scissor entries.\n * Used for VK_NV_inherited_viewport_scissor extension.\n */\nasync function filterDynamicStateForViewportScissor(statePromise: Promise<DynamicStateEntry[]>): Promise<DynamicStateEntry[]> {\n    const state = await statePromise;\n    return state.filter(entry => entry.stateType === StateType.VIEWPORT || entry.stateType === StateType.SCISSOR);\n}\n\n/**\n * Tracks dynamic state that may be updated as secondary command buffers execute\n * (when VK_NV_command_buffer_inheritance is enabled).\n */\nclass DynamicStateTracker {\n    private currentStatePromise: Promise<DynamicStateEntry[]>;\n\n    constructor(initialState: Promise<DynamicStateEntry[]>) {\n        this.currentStatePromise = initialState;\n    }\n\n    getCurrentState(): Promise<DynamicStateEntry[]> {\n        return this.currentStatePromise;\n    }\n\n    updateState(newState: Promise<DynamicStateEntry[]>): void {\n        this.currentStatePromise = newState;\n    }\n}\n\n/** Internal context for a command tree model.\n *\n * contains all the fixed data needed for the model,\n * e.g. services, etc.\n */\ninterface CommandTreeContext {\n    dbId: number;\n    data: CommandTreeDataWithFunctionAndDebugNames;\n    screenshotService: GfxrScreenshotService;\n    fileService: CompressedFileService;\n    profile: CaptureDatasetWidgetProfile;\n    context: CaptureDatasetWidgetContext;\n    tree: CommandTree;\n    gfxrQueryBuilderService: GFXRQueryBuilderService;\n    imageAccessorService: ImageAccessorService;\n    createDrawOrDispatchChildren: boolean;\n    rootNode: CommandRootNode;\n    deviceExtensions: Map<number, Set<string>>;\n}\n\n/**\n * Helper function to look up the debug name for an object at a specific API event.\n * Finds the most recent debug name that was set at or before the target API event.\n * @param debugNameLookup - Map of objectHandle to array of {apiEvent, name} sorted by apiEvent\n * @param objectHandle - The object handle to look up\n * @param targetApiEvent - The API event at which we want to know the object's name\n * @returns The debug name if found, undefined otherwise\n */\nfunction getDebugNameAtApiEvent(\n    debugNameLookup: Map<number, Array<{ apiEvent: number; name: string }>>,\n    objectHandle: number | null | undefined,\n    targetApiEvent: number\n): string | undefined {\n    if (typeof objectHandle !== 'number') {\n        return undefined;\n    }\n\n    const entries = debugNameLookup.get(objectHandle);\n    if (!entries || entries.length === 0) {\n        return undefined;\n    }\n\n    // Binary search for the most recent name at or before targetApiEvent\n    let left = 0;\n    let right = entries.length - 1;\n    let result: string | undefined = undefined;\n\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (entries[mid].apiEvent <= targetApiEvent) {\n            result = entries[mid].name;\n            left = mid + 1; // Look for a more recent name\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n\nexport interface CommandRootNode extends ResourceTreeNode<CommandTreeDataWithFunctionAndDebugNames>, CompositeTreeNode, ExpandableTreeNode {\n    resourceType: typeof CommandRootNode.RESOURCE_TYPE;\n    children: CommandFrameNode[];\n    dbId: number;\n    profile: CaptureDatasetWidgetProfile;\n    tree?: CommandTree; // Back-reference to the tree that owns this root\n    // Cached maps for queue debug labels to avoid rebuilding for each frame\n    queueDebugLabelGroupsBySubmitId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelGroupsByPresentId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelInsertsByApiEvent: Map<number, CommandTreeQueueDebugLabelInsert>;\n}\n\nexport namespace CommandRootNode {\n    export const ID = 'sokatoa-command-tree-widget';\n\n    export const RESOURCE_TYPE = '__root__';\n\n    export function is(node: TreeNode | undefined): node is CommandRootNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRootNode.RESOURCE_TYPE);\n    }\n\n    export function create(\n        dbId: number,\n        data: CommandTreeDataWithFunctionAndDebugNames,\n        screenshotService: GfxrScreenshotService,\n        profile: CaptureDatasetWidgetProfile,\n        context: CaptureDatasetWidgetContext,\n        tree: CommandTree,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        imageAccessorService: ImageAccessorService,\n        fileService: CompressedFileService,\n        createDrawOrDispatchChildren: boolean,\n        deviceExtensions: Map<number, Set<string>>\n    ): CommandRootNode {\n        // Build maps for queue debug labels once for all frames\n        const queueDebugLabelGroupsBySubmitId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelGroupsByPresentId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelInsertsByApiEvent = new Map<number, CommandTreeQueueDebugLabelInsert>();\n\n        for (const group of Object.values(data.queueDebugLabelGroups)) {\n            if (group) {\n                for (const submitId of group.queueSubmitIds) {\n                    queueDebugLabelGroupsBySubmitId.set(submitId, group);\n                }\n                for (const presentId of group.queuePresentIds) {\n                    queueDebugLabelGroupsByPresentId.set(presentId, group);\n                }\n            }\n        }\n\n        for (const insert of Object.values(data.queueDebugLabelInserts)) {\n            if (insert) {\n                queueDebugLabelInsertsByApiEvent.set(insert.apiEvent, insert);\n            }\n        }\n\n        const rootNode: CommandRootNode = {\n            visible: false,\n            id: CommandRootNode.ID,\n            name: 'ProfileTree',\n            parent: undefined,\n            expanded: true,\n            children: [],\n            resourceType: CommandRootNode.RESOURCE_TYPE,\n            resource: data,\n            dbId,\n            profile,\n            queueDebugLabelGroupsBySubmitId,\n            queueDebugLabelGroupsByPresentId,\n            queueDebugLabelInsertsByApiEvent\n        };\n        const ctx: CommandTreeContext = {\n            dbId,\n            data,\n            screenshotService,\n            fileService,\n            profile,\n            context,\n            tree,\n            gfxrQueryBuilderService,\n            imageAccessorService,\n            createDrawOrDispatchChildren,\n            rootNode,\n            deviceExtensions\n        };\n        const modelBuildStart = Date.now();\n        const frames = Object.values(data.frames);\n        rootNode.children = frames.flatMap(child => (child ? CommandFrameNode.create(ctx, child, rootNode) : []));\n        console.debug(`Model loaded in ${Date.now() - modelBuildStart} ms`);\n        return rootNode;\n    }\n}\n\nexport interface DebugMarker {\n    name: string;\n    color?: RGBA;\n}\n\nexport interface WithDebugMarker {\n    debugMarker?: DebugMarker;\n}\n\nexport namespace WithDebugMarker {\n    /** Type guard for a `node` that is or has a debug marker. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugMarker> {\n        return 'debugMarker' in node && node.debugMarker !== undefined;\n    }\n}\n\nexport interface WithDebugName {\n    debugName?: string;\n}\n\nexport namespace WithDebugName {\n    /** Type guard for a `node` that has a debug name. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugName> {\n        return 'debugName' in node && node.debugName !== undefined;\n    }\n}\n\ninterface LabelData {\n    labelName: string | undefined | null;\n    colorR: number | undefined | null;\n    colorG: number | undefined | null;\n    colorB: number | undefined | null;\n    colorA: number | undefined | null;\n}\n\nfunction setDebugMarkerData(node: WithDebugMarker, labelData: LabelData): void {\n    const name = labelData.labelName ?? 'Debug marker';\n    const color = {\n        r: (labelData.colorR ?? 1) * 255,\n        g: (labelData.colorG ?? 1) * 255,\n        b: (labelData.colorB ?? 1) * 255,\n        a: (labelData.colorA ?? 1) * 255\n    };\n\n    node.debugMarker = { name };\n    if (color.a !== 0 || color.b !== 0 || color.g !== 0 || color.r !== 0) {\n        node.debugMarker.color = color;\n    }\n}\n\nexport interface CommandFrameNode extends ResourceTreeNode<CommandTreeFrame>, ExpandableTreeNode, SelectableTreeNode {\n    label: string;\n    frameIndex: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandFrameNode.RESOURCE_TYPE;\n    thumbnail?: string;\n}\n\nexport namespace CommandFrameNode {\n    export const RESOURCE_TYPE = 'frame';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandFrameNode {\n        return ResourceTreeNode.hasResourceType(node, CommandFrameNode.RESOURCE_TYPE);\n    }\n\n    export function getId(frame: CommandTreeFrame): string {\n        return frame.frameIndex.toString();\n    }\n\n    export function create(ctx: CommandTreeContext, element: CommandTreeFrame, parent: CompositeTreeNode): CommandFrameNode {\n        const node: CommandFrameNode & SokatoaLifecycleTreeNode = {\n            id: getId(element),\n            frameIndex: element.frameIndex,\n            label: `Frame ${element.frameIndex}`,\n            children: [],\n            expanded: false,\n            selected: false,\n            parent,\n            resourceType: CommandFrameNode.RESOURCE_TYPE,\n            resource: element\n        };\n\n        const root = ctx.rootNode;\n\n        const children: CommandTreeNode[] = [];\n        let queueSubmitIndex = 0;\n        let queuePresentIndex = 0;\n        let accelerationStructureBuildIndex = 0;\n        let accelerationStructureCopyIndex = 0;\n\n        // Track current active debug label group and its children\n        let activeDebugLabelGroup: CommandTreeQueueDebugLabelGroup | undefined;\n        let activeGroupChildren: (CommandQueueSubmitNode | CommandQueuePresentNode)[] = [];\n        let queueDebugLabelGroupInstanceIndex = 0;\n\n        // Helper to finalize the active group and add it to children\n        const finalizeActiveGroup = (): void => {\n            if (activeDebugLabelGroup && activeGroupChildren.length > 0) {\n                children.push(\n                    CommandQueueDebugLabelGroupNode.create(\n                        ctx,\n                        activeDebugLabelGroup,\n                        node,\n                        activeGroupChildren,\n                        queueDebugLabelGroupInstanceIndex++\n                    )\n                );\n                activeDebugLabelGroup = undefined;\n                activeGroupChildren = [];\n            }\n        };\n\n        for (let id = element.beginApiEvent; id <= (element.endApiEvent ?? element.beginApiEvent); id++) {\n            // Check for queue debug label insert at this apiEvent\n            const queueDebugLabelInsert = root.queueDebugLabelInsertsByApiEvent.get(id);\n            if (queueDebugLabelInsert) {\n                // Inserts can appear in the middle of groups, so finalize any active group first\n                finalizeActiveGroup();\n                children.push(CommandQueueDebugLabelNode.create(ctx, queueDebugLabelInsert, node));\n            }\n\n            const apiEvent = root.resource.apiEvents[id];\n            if (apiEvent) {\n                if (apiEvent.submissionId && element.queueSubmitIds.includes(apiEvent.submissionId)) {\n                    const queueSubmit = root.resource.queueSubmits[apiEvent.submissionId];\n                    if (queueSubmit) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsBySubmitId.get(apiEvent.submissionId);\n\n                        // Check if this submit is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queueSubmit not found for submissionId ${apiEvent.submissionId}`);\n                    }\n                } else if (apiEvent.presentId && element.queuePresentIds.includes(apiEvent.presentId)) {\n                    const queuePresent = root.resource.queuePresents[apiEvent.presentId];\n                    if (queuePresent) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsByPresentId.get(apiEvent.presentId);\n\n                        // Check if this present is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queuePresent not found for presentId ${apiEvent.presentId}`);\n                    }\n                } else if (\n                    apiEvent.accelerationStructureBuildInstanceId &&\n                    element.accelerationStructureBuildIds.includes(apiEvent.accelerationStructureBuildInstanceId)\n                ) {\n                    // Acceleration structure builds interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureBuild =\n                        root.resource.topLevelAccelerationStructureBuilds[apiEvent.accelerationStructureBuildInstanceId];\n                    if (accelerationStructureBuild) {\n                        children.push(\n                            CommandAccelerationStructureBuildNode.create(\n                                accelerationStructureBuild,\n                                node,\n                                accelerationStructureBuildIndex++\n                            )\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureBuildInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureBuild not found for accelerationStructureBuildInstanceId ${iId}`\n                        );\n                    }\n                } else if (\n                    apiEvent.accelerationStructureCopyInstanceId &&\n                    element.accelerationStructureCopyIds.includes(apiEvent.accelerationStructureCopyInstanceId)\n                ) {\n                    // Acceleration structure copies interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureCopy =\n                        root.resource.topLevelAccelerationStructureCopies[apiEvent.accelerationStructureCopyInstanceId];\n                    if (accelerationStructureCopy) {\n                        children.push(\n                            CommandAccelerationStructureCopyNode.create(accelerationStructureCopy, node, accelerationStructureCopyIndex++)\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureCopyInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureCopy not found for accelerationStructureCopyInstanceId ${iId}`\n                        );\n                    }\n                }\n            }\n        }\n\n        // Finalize any remaining active debug label group at the end\n        finalizeActiveGroup();\n\n        node.children = children;\n\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        const request: ThumbnailRequestOptions = {\n            profileOrReplay: replay ?? ctx.profile,\n            startFrame: element.frameIndex,\n            endFrame: element.frameIndex,\n            requesterDbgName: `Command tree frame ${element.frameIndex}`,\n            onScreenshotReady: result => {\n                ctx.imageAccessorService\n                    .accessImage(new URL(URI.fromFilePath(result.path).toString()))\n                    .then(url => {\n                        node.thumbnail = url.url.toString();\n                        ctx.tree.addToDispose(url);\n                        void ctx.tree.refresh(node);\n                    })\n                    .catch(reason => {\n                        const error = asError(reason);\n                        console.error(error);\n                    });\n            },\n            onRequestComplete: (success, message) => {\n                if (!success) {\n                    console.error(`Request for frame thumbnails failed: ${message}`);\n                }\n            }\n        };\n        const onWillRender = (): void => {\n            requestThumbnails(ctx.screenshotService, request);\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', onWillRender);\n        };\n        SokatoaLifecycleTreeNode.register(node, 'onWillRender', onWillRender);\n        return node;\n    }\n\n    /**\n     * Retrieve the `CommandFrameNode` that is or contains the given `node`.\n     * Returns `undefined` in the case that the `node` is an ancestor of or\n     * otherwise not contained in an `CommandFrameNode`.\n     */\n    export function getCommandFrameNodeContaining(node: TreeNode): CommandFrameNode | undefined {\n        return CommandFrameNode.is(node) ? node : node.parent ? CommandFrameNode.getCommandFrameNodeContaining(node.parent) : undefined;\n    }\n}\n\nexport interface CommandEmptyNode extends LazyLoadableNode {\n    label: string;\n}\n\nexport namespace CommandEmptyNode {\n    export const GENERALIZED_TYPE = 'empty';\n\n    export function is(node: unknown): node is CommandEmptyNode {\n        return TreeNode.is(node) && node.id.endsWith('_empty');\n    }\n\n    export function getId(parent: CompositeTreeNode): string {\n        return `${parent.id}_empty`;\n    }\n\n    export function create(parent: CompositeTreeNode, load: CommandEmptyNode['load']): CommandEmptyNode {\n        return {\n            id: getId(parent),\n            label: 'Loading...',\n            parent,\n            load\n        };\n    }\n}\n\nexport interface CommandApiEventNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandApiEventNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandApiEventNode {\n    export const RESOURCE_TYPE = 'api-event';\n    export const GENERALIZED_TYPE = RESOURCE_TYPE;\n\n    export function is(node: TreeNode | undefined): node is CommandApiEventNode {\n        return ResourceTreeNode.hasResourceType(node, CommandApiEventNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEventId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex?: number\n    ): CommandApiEventNode {\n        const root = ctx.rootNode;\n        const node: CommandApiEventNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEventId,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex ?? ''}`,\n            parent,\n            resourceType: CommandApiEventNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId,\n            selected: false\n        };\n        // set debug marker data if node is a debug marker\n        if (element.debugLabelId) {\n            const labelData = root.resource.debugLabels[element.debugLabelId];\n            if (labelData) {\n                setDebugMarkerData(node, labelData);\n            }\n        }\n        return node;\n    }\n}\n\nexport interface CommandDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeDebugLabelGroupInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'debug-label-group';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDebugLabelGroupInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDebugLabelGroupInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDebugLabelGroupNode = {\n            id: getId(element, parent),\n            debugLabelInstanceId: element.labelId,\n            label: `${root.resource.functionNameLookup[element.functionNameId ?? -1] ?? '<not defined>'}`,\n            parent,\n            resourceType: CommandDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this debug label range\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this debug label group, add it to array\n            // - not self\n            // - only commands with same command buffer id\n            if (event && event.debugLabelId !== element.labelId && event.commandBufferInstanceId === element.commandBufferInstance) {\n                apiEventCommandArray.push(event);\n            }\n        }\n        // get array of debug label ranges with api event numbers within this debug label range\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this debug label range\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderPassInstance'\n        );\n        // get array of render subpass ranges with api event numbers within this debug label range\n        const renderSubpassInstances = createRangeInstanceArray(\n            element.renderSubpassInstanceIds,\n            root.resource.renderSubpassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderSubpassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this debug label range\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('subpassIndex' in rangeElement) {\n                    const renderSubpassInstanceNode = CommandRenderSubpassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderSubpassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            renderSubpassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                console.log(\n                    `JF: CommandDebugLabelGroupNode ${node.id} - async children creation completed, children count: ${node.children.length}`\n                );\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for debug label group:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `debug label group ${element.labelId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelGroup>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'queue-debug-label-group';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelGroup, parent: CompositeTreeNode, instanceIndex: number): string {\n        return `${parent.id}_qdl_group_${element.labelId}_${instanceIndex}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelGroup,\n        parent: CompositeTreeNode,\n        children: (CommandQueueSubmitNode | CommandQueuePresentNode)[],\n        instanceIndex: number\n    ): CommandQueueDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelGroupNode = {\n            id: getId(element, parent, instanceIndex),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label Group',\n            queue: element.queue!,\n            parent,\n            resourceType: CommandQueueDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        // Update parent references for children since they were created with a different parent\n        // and are now being reparented to this debug label group node\n        for (const child of children) {\n            // Cast away readonly to update parent during node construction\n            (child as MutableParent).parent = node;\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelInsert>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    apiEventId: number;\n    resourceType: typeof CommandQueueDebugLabelNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelNode {\n    export const RESOURCE_TYPE = 'queue-debug-label';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelInsert, parent: CompositeTreeNode): string {\n        return `${parent.id}_qdl_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelInsert,\n        parent: CompositeTreeNode\n    ): CommandQueueDebugLabelNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelNode = {\n            id: getId(element, parent),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label',\n            queue: element.queue!,\n            apiEventId: element.apiEvent,\n            parent,\n            resourceType: CommandQueueDebugLabelNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandCommandBufferInstanceNode\n    extends ResourceTreeNode<CommandTreeCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    commandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandCommandBufferInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandCommandBufferInstanceNode {\n    export const RESOURCE_TYPE = 'command-buffer-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandCommandBufferInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandCommandBufferInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeCommandBufferInstance,\n        parent: CompositeTreeNode,\n        commandBufferIndex: number,\n        baseDynamicStatePromise?: Promise<DynamicStateEntry[]>\n    ): CommandCommandBufferInstanceNode {\n        const node: CommandCommandBufferInstanceNode = {\n            id: getId(element, parent),\n            commandBufferInstanceId: element.instanceId,\n            label: `Command Buffer ${commandBufferIndex}`,\n            parent,\n            resourceType: CommandCommandBufferInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this command buffer\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this command buffer, add it to array\n            // - omit commands that reference render pass id\n            // - if api event is a debug label, check the debug label itself for a render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                event.commandBufferInstanceId === element.instanceId &&\n                event.renderPassInstanceId === undefined &&\n                event.dynamicRenderPassInstanceId === undefined &&\n                (event.debugLabelId === undefined ||\n                    (debugLabel?.beginApiEvent === event.apiEventId &&\n                        debugLabel?.beginRenderPassInstance === undefined &&\n                        debugLabel?.beginDynamicRenderPassInstance === undefined) ||\n                    (debugLabel?.endApiEvent === event.apiEventId &&\n                        debugLabel?.endRenderPassInstance === undefined &&\n                        debugLabel?.endDynamicRenderPassInstance === undefined))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this command buffer\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this command buffer\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'RenderPassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this command buffer\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        const emptyDynamicStatePromise = new Promise<DynamicStateEntry[]>(resolve => resolve([]));\n        const effectiveBaseState = baseDynamicStatePromise ?? emptyDynamicStatePromise;\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            effectiveBaseState,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        effectiveBaseState\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                console.log(\n                    `JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\n                );\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for command buffer:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `command buffer ${commandBufferIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandSecondaryCommandBufferExecutionNode\n    extends ResourceTreeNode<CommandTreeSecondaryCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    parentCommandBufferInstanceId: number;\n    secondaryCommandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n}\n\nexport namespace CommandSecondaryCommandBufferExecutionNode {\n    export const RESOURCE_TYPE = 'secondary-command-buffer-execution';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: unknown): node is CommandSecondaryCommandBufferExecutionNode {\n        return (\n            ExpandableTreeNode.is(node) && SelectableTreeNode.is(node) && ResourceTreeNode.is(node, 'secondary-command-buffer-execution')\n        );\n    }\n\n    export function getId(element: CommandTreeSecondaryCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_secondary_${element.secondaryCommandBufferInstance}_${element.executionId}_${element.executionIndex}`;\n    }\n\n    export async function create(\n        ctx: CommandTreeContext,\n        elements: CommandTreeSecondaryCommandBufferInstance[],\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n        stateTracker?: DynamicStateTracker\n    ): Promise<CommandSecondaryCommandBufferExecutionNode> {\n        if (elements.length === 0) {\n            throw new Error('elements array must not be empty');\n        }\n        // Use the first element for the node's resource (they all share the same executionId and apiEvent)\n        const element = elements[0];\n        const node: CommandSecondaryCommandBufferExecutionNode = {\n            id: getId(element, parent),\n            parentCommandBufferInstanceId: element.parentCommandBufferInstance || 0,\n            secondaryCommandBufferInstanceId: element.secondaryCommandBufferInstance || 0,\n            label: `Secondary Command Buffer Execution ${commandIndex}`,\n            parent,\n            resourceType: 'secondary-command-buffer-execution',\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        createLazyLoadingNode(ctx.tree, node, async () => {\n            // Sort elements by executionIndex to maintain proper order\n            const sortedElements = [...elements].sort((a, b) => (a.executionIndex || 0) - (b.executionIndex || 0));\n\n            // Get device and check extensions\n            const firstSecondary = sortedElements[0]?.secondaryCommandBufferInstance;\n            let deviceExtensions: Set<string> | undefined;\n\n            if (firstSecondary !== undefined) {\n                const commandBufferInstance = root.resource.commandBufferInstances[firstSecondary];\n                const device = commandBufferInstance?.device;\n                if (typeof device === 'number') {\n                    deviceExtensions = ctx.deviceExtensions.get(device);\n                }\n            }\n\n            const hasInheritance = hasCommandBufferInheritance(deviceExtensions);\n            const hasViewportScissorOnly = hasInheritedViewportScissor(deviceExtensions) && !hasInheritance;\n\n            // Calculate effective base state for INHERITANCE INTO secondary\n            let effectiveBaseState: Promise<DynamicStateEntry[]>;\n            if (hasInheritance) {\n                effectiveBaseState = baseDynamicStatePromise;\n            } else if (hasViewportScissorOnly) {\n                effectiveBaseState = filterDynamicStateForViewportScissor(baseDynamicStatePromise);\n            } else {\n                effectiveBaseState = Promise.resolve([]);\n            }\n\n            // Create a CommandCommandBufferInstanceNode for each secondary command buffer in the execution\n            const childNodes: CommandCommandBufferInstanceNode[] = [];\n            sortedElements.forEach((secondaryInstance, index) => {\n                if (secondaryInstance.secondaryCommandBufferInstance) {\n                    const commandBufferInstance = root.resource.commandBufferInstances[secondaryInstance.secondaryCommandBufferInstance];\n                    if (commandBufferInstance) {\n                        const childNode = CommandCommandBufferInstanceNode.create(\n                            ctx,\n                            commandBufferInstance,\n                            node,\n                            index,\n                            effectiveBaseState\n                        );\n                        childNodes.push(childNode);\n                    } else {\n                        console.warn(\n                            `Command buffer instance ${secondaryInstance.secondaryCommandBufferInstance} ` +\n                                'not found in root.resource.commandBufferInstances'\n                        );\n                    }\n                }\n            });\n            CompositeTreeNode.addChildren(node, childNodes);\n\n            // Handle LEAK-BACK: Update parent's state tracker if extension is enabled\n            if (hasInheritance && stateTracker && element.executionId) {\n                const db = ctx.gfxrQueryBuilderService.builderFor(ctx.dbId);\n                const endStatePromise = querySecondaryCommandBufferEndDynamicState(db, [element.executionId]);\n                stateTracker.updateState(endStatePromise);\n            }\n        });\n\n        // Register for thumbnail updates\n        registerThumbnailUpdate(ctx, node, `secondary command buffer execution ${node.resource.executionId}`);\n        return node;\n    }\n}\n\nexport interface CommandQueueSubmitNode\n    extends ResourceTreeNode<CommandTreeQueueSubmit>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    submissionId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueSubmitNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueSubmitNode {\n    export const RESOURCE_TYPE = 'queue-submit';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueSubmitNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueSubmitNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueSubmit, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.submissionId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueSubmit,\n        parent: CompositeTreeNode,\n        queueSubmitIndex: number\n    ): CommandQueueSubmitNode {\n        const root = ctx.rootNode;\n        const node: CommandQueueSubmitNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            threadId: element.threadId || 0,\n            submissionId: element.submissionId,\n            label: `Queue Submit ${queueSubmitIndex}`,\n            queue: element.queue,\n            parent,\n            resourceType: CommandQueueSubmitNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        const children =\n            element.queueSubmitBuffers\n                ?.filter(b => b.commandBufferInstance)\n                .flatMap(b => {\n                    const instance = root.resource.commandBufferInstances[b.commandBufferInstance!];\n                    if (!instance) {\n                        console.warn(`CommandQueueSubmitNode.create: commandBufferInstance not found for id ${b.commandBufferInstance}`);\n                        return [];\n                    }\n                    return instance;\n                }) ?? [];\n        let commandBufferIndex = 0;\n        node.children = children.map(child => CommandCommandBufferInstanceNode.create(ctx, child, node, commandBufferIndex++));\n\n        registerThumbnailUpdate(ctx, node, `queue submit ${queueSubmitIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueuePresentNode extends ResourceTreeNode<CommandTreeQueuePresent>, SelectableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    resourceType: typeof CommandQueuePresentNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueuePresentNode {\n    export const RESOURCE_TYPE = 'queue-present';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueuePresentNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueuePresentNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueuePresent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEvent}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueuePresent,\n        parent: CompositeTreeNode,\n        queuePresentIndex: number\n    ): CommandQueuePresentNode {\n        const root = ctx.rootNode;\n        const node: CommandQueuePresentNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            label: `Queue Present ${queuePresentIndex}`,\n            parent,\n            resourceType: CommandQueuePresentNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            queue: element.queue,\n            selected: false\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureBuildNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureBuildInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    buildInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureBuildNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureBuildNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-build';\n    export const GENERALIZED_TYPE = 'acceleration-structure-build';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureBuildNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureBuildNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureBuildInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.buildApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureBuildInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureBuildNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureBuildNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            buildInstanceId: element.instanceId,\n            apiEventId: element.buildApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureBuildNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureCopyNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureCopyInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    copyInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureCopyNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureCopyNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-copy';\n    export const GENERALIZED_TYPE = 'acceleration-structure-copy';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureCopyNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureCopyNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureCopyInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.copyApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureCopyInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureCopyNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureCopyNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            copyInstanceId: element.instanceId,\n            apiEventId: element.copyApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureCopyNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandTransferCommandNode\n    extends ResourceTreeNode<CommandTreeTransferCommandInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    transferCommandInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandTransferCommandNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandTransferCommandNode {\n    export const RESOURCE_TYPE = 'transfer-command';\n    export const GENERALIZED_TYPE = 'transfer-command';\n\n    export function is(node: TreeNode | undefined): node is CommandTransferCommandNode {\n        return ResourceTreeNode.hasResourceType(node, CommandTransferCommandNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeTransferCommandInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.transferApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeTransferCommandInstance,\n        parent: CompositeTreeNode,\n        transferCommandIndex: number\n    ): CommandTransferCommandNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandTransferCommandNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            transferCommandInstanceId: element.instanceId,\n            apiEventId: element.transferApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${transferCommandIndex}`,\n            parent,\n            resourceType: CommandTransferCommandNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nfunction setThumbnailUrl(\n    ctx: CommandTreeContext,\n    resources: ApiResources[],\n    node: TreeNode & { thumbnail?: string },\n    requesterDbgName: string\n): void {\n    if (resources.length > 0) {\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        ctx.screenshotService.requestScreenshots({\n            profileOrReplay: replay ?? ctx.profile,\n            scale: placeholderScale,\n            screenshotType: ScreenshotType.API_EVENT,\n            requestData: resources,\n            moreRequests: true,\n            requesterDbgName,\n            options: {\n                DumpDepth: true\n            },\n            onScreenshotReady: result => {\n                if (result.resultData.resultType === ScreenshotType.API_EVENT && DrawApiResult.is(result.resultData.apiResult)) {\n                    const images = [...(result.resultData.apiResult.colorAttachments || [])];\n                    if (result.resultData.apiResult.depthAttachment) {\n                        images.push(result.resultData.apiResult.depthAttachment);\n                    }\n                    if (images.length > 0) {\n                        const possibleImage = images[0].subresources?.[0];\n                        if (possibleImage) {\n                            if (usesCompressionExtension(possibleImage.file)) {\n                                // Use VkImageConversionService to get a png\n                                // Do the same as the else case, but with the new png file\n                                const format = lookupResourceFormat(images[0].format);\n                                if (UncompressedResourceFormat.is(format)) {\n                                    ctx.fileService\n                                        .read(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString(), {\n                                            uncompressedSize: possibleImage.size\n                                        })\n                                        .then(async content => {\n                                            const extractedData = await extractData(format, content);\n                                            const dim = {\n                                                width: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[0]\n                                                    : possibleImage.dimensions[0] * placeholderScale,\n                                                height: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[1]\n                                                    : possibleImage.dimensions[1] * placeholderScale\n                                            };\n                                            const conversionResult = await convertDataToImageData(extractedData, format, dim, {\n                                                channelOptions: { alpha: { disabled: true } }\n                                            });\n                                            const png = new PNG({\n                                                width: conversionResult.dimensions.width,\n                                                height: conversionResult.dimensions.height\n                                            });\n                                            png.data = conversionResult.data;\n                                            const pngBuffer = PNG.sync.write(png);\n                                            node.thumbnail = `data:image/png;base64, ${pngBuffer.toString('base64')}`;\n                                            void ctx.tree.refresh(node.parent);\n                                        })\n                                        .catch(reason => {\n                                            const error = asError(reason);\n                                            console.error(error);\n                                        });\n                                }\n                            } else {\n                                ctx.imageAccessorService\n                                    .accessImage(new URL(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString()))\n                                    .then(url => {\n                                        node.thumbnail = url.url.toString();\n                                        ctx.tree.addToDispose(url);\n                                        void ctx.tree.refresh(node.parent);\n                                    })\n                                    .catch(reason => {\n                                        const error = asError(reason);\n                                        console.error(error);\n                                    });\n                            }\n                        }\n                    }\n                }\n            },\n            onRequestComplete: (result, message) => {\n                if (!result) {\n                    console.error(message);\n                }\n            }\n        });\n    }\n}\n\n/**\n * Registers a thumbnail update callback that triggers on the node's first render.\n * When triggered, finds the last draw instance and requests a screenshot for it.\n *\n * @param ctx - Command tree context\n * @param node - Node to register thumbnail update for\n * @param descriptionContext - Description for the requester debug name (e.g., \"render pass 5\", \"dynamic render pass\")\n */\nfunction registerThumbnailUpdate(\n    ctx: CommandTreeContext,\n    node: CommandTreeNode & { thumbnail?: string },\n    descriptionContext: string\n): void {\n    const updateThumbnail = (): void => {\n        const lastDraw = findLastDrawInstanceNode(node);\n        if (lastDraw) {\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', updateThumbnail);\n            const requesterDbgName = `Command tree ${descriptionContext} last draw: ${lastDraw.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(lastDraw), node, requesterDbgName);\n        }\n    };\n    SokatoaLifecycleTreeNode.register(node, 'onWillRender', updateThumbnail);\n}\n\nexport interface CommandRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    renderPassInstanceId: number;\n    renderPassId?: number;\n    renderSubpassEventIds: number[];\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderPassInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.instanceId,\n            renderPassId: element.renderPass,\n            renderSubpassEventIds: [],\n            label: `Render Pass ${element.passIndex}`,\n            parent,\n            resourceType: CommandRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        // A render pass will only contain render subpasses and will always contain at least one subpass\n        const renderSubpassInstances = element.renderSubpassInstanceIds.flatMap(id => {\n            const instance = root.resource.renderSubpassInstances[id];\n            if (!instance) {\n                console.warn(`CommandRenderPassInstanceNode.create: renderSubpassInstance not found for id ${id}`);\n                return [];\n            }\n            return instance;\n        });\n        renderSubpassInstances.forEach(subpass => {\n            if (subpass.beginApiEvent !== node.resource.beginApiEvent) {\n                node.renderSubpassEventIds.push(subpass.beginApiEvent);\n            }\n        });\n        node.children.push(\n            ...renderSubpassInstances.map(instance => {\n                const subpassNode = CommandRenderSubpassInstanceNode.create(ctx, instance, node, baseDynamicStatePromise);\n                return subpassNode;\n            })\n        );\n\n        registerThumbnailUpdate(ctx, node, `render pass ${node.renderPassId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandRenderSubpassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderSubpassInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    renderPassInstanceId: number;\n    renderSubpassInstanceId: number;\n    renderSubpassIndex: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderSubpassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderSubpassInstanceNode {\n    export const RESOURCE_TYPE = 'render-subpass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderSubpassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderSubpassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderSubpassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderSubpassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderSubpassInstanceNode {\n        const node: CommandRenderSubpassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.renderPassInstance,\n            renderSubpassInstanceId: element.instanceId,\n            renderSubpassIndex: element.subpassIndex,\n            label: `Subpass ${element.subpassIndex}`,\n            parent,\n            resourceType: CommandRenderSubpassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this render subpass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference render subpass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a render subpass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.renderSubpassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginRenderSubpassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endRenderSubpassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this render subpass\n        const debugLabelGroupInstances = {\n            array: element.debugLabelGroupInstanceIds.flatMap(id => {\n                const result = root.resource.debugLabelGroupInstances[id];\n                if (!result) {\n                    console.warn(`Missing debugLabelGroupInstances for ${id}.`);\n                    return [];\n                }\n                return result;\n            }),\n            getSortNumber: (debugLabelGroupInstance: CommandTreeDebugLabelGroupInstance) => debugLabelGroupInstance.beginApiEvent\n        };\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                console.log(\n                    `JF: CommandRenderSubpassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\n                );\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'render subpass');\n\n        return node;\n    }\n}\n\nexport interface CommandDynamicRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeDynamicRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    dynamicRenderPassInstanceId: number;\n    dynamicRenderPassId?: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDynamicRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'dynamic-render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDynamicRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDynamicRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDynamicRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDynamicRenderPassInstanceNode {\n        const node: CommandDynamicRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dynamicRenderPassInstanceId: element.instanceId,\n            label: `Dynamic Render Pass ${element.dynamicPassIndex}`,\n            parent,\n            resourceType: CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this dynamic render pass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this dynamic render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference dynamic render pass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a dynamic render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.dynamicRenderPassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginDynamicRenderPassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endDynamicRenderPassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this dynamic render pass\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDynamicRenderPassInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                console.log(\n                    `JF: CommandDynamicRenderPassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\n                );\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'dynamic render pass');\n\n        return node;\n    }\n}\n\nasync function createChildEventNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    stateTracker: DynamicStateTracker\n): Promise<number> {\n    let endCommandIndex = commandIndex;\n    const baseDynamicStatePromise = stateTracker.getCurrentState();\n\n    if (command.secondaryCommandBufferExecutionId) {\n        // Look up the execution to get the apiEvent, which is the key for secondaryCommandBufferInstances\n        const execution = root.resource.secondaryCommandBufferExecutions[command.secondaryCommandBufferExecutionId];\n        if (execution) {\n            const secondaryInstances = root.resource.secondaryCommandBufferInstances[execution.apiEvent];\n            if (secondaryInstances && secondaryInstances.length > 0) {\n                const node = await CommandSecondaryCommandBufferExecutionNode.create(\n                    ctx,\n                    secondaryInstances,\n                    parentNode,\n                    endCommandIndex++,\n                    baseDynamicStatePromise,\n                    stateTracker\n                );\n                parentNode.children.push(node);\n            }\n        }\n    } else {\n        endCommandIndex = createDrawOrDispatchChildNode(ctx, command, root, parentNode, commandIndex, baseDynamicStatePromise);\n    }\n    return endCommandIndex;\n}\n\nfunction createDrawOrDispatchChildNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n): number {\n    let currentCommandIndex = commandIndex;\n    let accelerationStructureBuildIndex = 0;\n    let accelerationStructureCopyIndex = 0;\n    if (command) {\n        if (command.drawInstanceId && root.resource.drawInstances[command.drawInstanceId]) {\n            parentNode.children.push(\n                CommandDrawInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.dispatchInstanceId && root.resource.dispatchInstances[command.dispatchInstanceId]) {\n            parentNode.children.push(\n                CommandDispatchInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.meshTaskInstanceId && root.resource.meshTaskInstances[command.meshTaskInstanceId]) {\n            parentNode.children.push(\n                CommandMeshTaskInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.clusterInstanceId && root.resource.clusterInstances[command.clusterInstanceId]) {\n            parentNode.children.push(\n                CommandClusterInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.raytracingInstanceId && root.resource.raytracingInstances[command.raytracingInstanceId]) {\n            parentNode.children.push(\n                CommandRaytracingInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (\n            command.accelerationStructureBuildInstanceId &&\n            root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureBuildNode.create(\n                    root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]!,\n                    parentNode,\n                    accelerationStructureBuildIndex++\n                )\n            );\n        } else if (\n            command.accelerationStructureCopyInstanceId &&\n            root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureCopyNode.create(\n                    root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]!,\n                    parentNode,\n                    accelerationStructureCopyIndex++\n                )\n            );\n        } else if (command.transferCommandInstanceId && root.resource.transferCommands[command.transferCommandInstanceId]) {\n            parentNode.children.push(\n                CommandTransferCommandNode.create(\n                    root.resource.transferCommands[command.transferCommandInstanceId]!,\n                    parentNode,\n                    currentCommandIndex++\n                )\n            );\n        } else if (command.debugLabelId && root.resource.debugLabels[command.debugLabelId]) {\n            // Only add debug label nodes if this is the BEGIN event (not END event)\n            // The END event has debugLabelId set but should not create a node\n            const debugLabel = root.resource.debugLabels[command.debugLabelId];\n            if (debugLabel && debugLabel.beginApiEvent === command.apiEventId) {\n                // Check if this is a group (has both begin and end and they differ) or just an insert\n                if (debugLabel.endApiEvent && debugLabel.beginApiEvent !== debugLabel.endApiEvent) {\n                    // This is a debug label group - it should be handled by the range processing logic\n                    // Don't create any node here, just skip it\n                    // (The group will be created if it's in debugLabelGroupInstances, or omitted if it crosses boundaries)\n                } else {\n                    // This is a debug label insert - create as simple API event node\n                    parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode));\n                }\n            }\n        } else if (command.commandInstanceId && root.resource.commandInstances[command.commandInstanceId]) {\n            parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode, currentCommandIndex++));\n        }\n    }\n    return currentCommandIndex;\n}\n\nexport interface CommandDrawInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    drawInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDrawInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandDrawInstanceNode {\n    export const RESOURCE_TYPE = 'draw-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDrawInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDrawInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_draw_${element.drawInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDrawInstanceNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDrawInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            drawInstanceId: element.drawInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDrawInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query draw instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n            const requesterDbgName = `Command draw instance ${node.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(node), node, requesterDbgName);\n        });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDrawInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const drawInstanceDynamicStatePromise = batchQuery\n                ? queryDrawInstanceDynamicStateBatched(db, [node.resource.drawInstanceId || 0])\n                : queryDrawInstanceDynamicState(db, [node.resource.drawInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                drawInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.GRAPHICS\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandDispatchInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    dispatchInstanceId: number;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandDispatchInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n    thumbnail?: string;\n}\n\nexport namespace CommandDispatchInstanceNode {\n    export const RESOURCE_TYPE = 'dispatch-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDispatchInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDispatchInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_dispatch_${element.dispatchInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDispatchInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandDispatchInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dispatchInstanceId: element.dispatchInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDispatchInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query dispatch instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for dispatch nodes\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command dispatch instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDispatchInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const dispatchInstanceDynamicStatePromise = batchQuery\n                ? queryDispatchInstanceDynamicStateBatched(db, [node.resource.dispatchInstanceId || 0])\n                : queryDispatchInstanceDynamicState(db, [node.resource.dispatchInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                dispatchInstanceDynamicStatePromise,\n                PipelineBindPoint.COMPUTE,\n                PipelineBindPointShaderStageFlags.COMPUTE\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandMeshTaskInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    meshTaskInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandMeshTaskInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandMeshTaskInstanceNode {\n    export const RESOURCE_TYPE = 'mesh-task-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandMeshTaskInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandMeshTaskInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_meshtask_${element.meshTaskInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandMeshTaskInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandMeshTaskInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            meshTaskInstanceId: element.meshTaskInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandMeshTaskInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query mesh instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for mesh task dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command mesh instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandMeshTaskInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const meshTaskInstanceDynamicStatePromise = batchQuery\n                ? queryMeshTaskInstanceDynamicStateBatched(db, [node.resource.meshTaskInstanceId || 0])\n                : queryMeshTaskInstanceDynamicState(db, [node.resource.meshTaskInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                meshTaskInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.TASK_MESH\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandClusterInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    clusterInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandClusterInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandClusterInstanceNode {\n    export const RESOURCE_TYPE = 'cluster-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandClusterInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandClusterInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_cluster_${element.clusterInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandClusterInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandClusterInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            clusterInstanceId: element.clusterInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandClusterInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query cluster instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for cluster dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command cluster instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandClusterInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const clusterInstanceDynamicStatePromise = batchQuery\n                ? queryClusterInstanceDynamicStateBatched(db, [node.resource.clusterInstanceId || 0])\n                : queryClusterInstanceDynamicState(db, [node.resource.clusterInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                clusterInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.CLUSTER\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandRaytracingInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    raytracingInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandRaytracingInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandRaytracingInstanceNode {\n    export const RESOURCE_TYPE = 'raytracing-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandRaytracingInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRaytracingInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_raytracing_${element.raytracingInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRaytracingInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRaytracingInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            raytracingInstanceId: element.raytracingInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandRaytracingInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query raytracing instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for raytracing dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command raytracing instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandRaytracingInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const raytracingInstanceDynamicStatePromise = batchQuery\n                ? queryRaytracingInstanceDynamicStateBatched(db, [node.resource.raytracingInstanceId || 0])\n                : queryRaytracingInstanceDynamicState(db, [node.resource.raytracingInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                raytracingInstanceDynamicStatePromise,\n                PipelineBindPoint.RAY_TRACING,\n                PipelineBindPointShaderStageFlags.RAY_TRACING\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport function getQueueSubmitId(node: CommandTreeNode): number | undefined {\n    let currentNode: CompositeTreeNode | undefined;\n    if (\n        CommandEmptyNode.is(node) ||\n        CommandApiEventNode.is(node) ||\n        CommandTreeDrawOrDispatchNode.is(node) ||\n        CommandAccelerationStructureBuildNode.is(node) ||\n        CommandAccelerationStructureCopyNode.is(node) ||\n        CommandTransferCommandNode.is(node)\n    ) {\n        currentNode = node.parent;\n    } else if (CommandQueuePresentNode.is(node) || CommandQueueDebugLabelNode.is(node)) {\n        return undefined;\n    } else {\n        currentNode = node;\n    }\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(currentNode, CommandQueueSubmitNode.is);\n    return queueSubmitNode ? queueSubmitNode.resource.submissionId : undefined;\n}\n\nexport function findLastDrawInstanceNode(node: CommandTreeNode): CommandDrawInstanceNode | undefined {\n    if (CommandDrawInstanceNode.is(node)) {\n        return node;\n    }\n    let lastDraw: CommandDrawInstanceNode | undefined;\n    if (!CommandDrawInstanceNode.is(node) && ExpandableTreeNode.is(node)) {\n        for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n            lastDraw = findLastDrawInstanceNode(node.children[commandIndex]);\n            if (lastDraw) {\n                break;\n            }\n        }\n    }\n    return lastDraw;\n}\n\nexport function createExecuteCommandsApiResources(\n    node: CommandSecondaryCommandBufferExecutionNode,\n    primaryNode: CommandCommandBufferInstanceNode,\n    queueSubmitNode: CommandQueueSubmitNode,\n    specificSecondaryCommandBufferBeginId?: number // If provided, only include this specific secondary CB\n): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    // findParentNode checks the given node for its type so we have to start looking from this node's parent\n    // otherwise we run into infinite recursion\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node.parent,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n\n    // Collect secondary command buffer begin IDs from the children\n    const commandBufferBeginIds: number[] = [];\n    if (specificSecondaryCommandBufferBeginId !== undefined) {\n        // Only include the specific secondary CB that was requested\n        commandBufferBeginIds.push(specificSecondaryCommandBufferBeginId);\n    } else {\n        // Include all secondary CBs (for when the execution node itself requests a thumbnail)\n        for (const child of node.children) {\n            if (CommandCommandBufferInstanceNode.is(child)) {\n                commandBufferBeginIds.push(child.resource.beginApiEvent);\n            }\n        }\n    }\n\n    const resources: ApiResources[] = [];\n    if (secondaryCommandBufferExecutionNode) {\n        const renderpassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n            renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n            CommandSecondaryCommandBufferExecutionNode.is\n        );\n\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: secondaryCommandBufferExecutionNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n                renderpassSecondaryCommandBufferExecutionNode &&\n                renderpassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n        const executionResources = createExecuteCommandsApiResources(secondaryCommandBufferExecutionNode, primaryNode, queueSubmitNode);\n        if (executionResources.length > 0) {\n            resources.push(...executionResources);\n        }\n    } else {\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: primaryNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                renderPassInstanceNode || dynamicRenderPassInstanceNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n    }\n    return resources;\n}\n\nexport function createDrawApiResources(node: CommandDrawInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    // This will find the immediate parent command buffer (secondary if in a secondary CB, primary otherwise)\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n\n    const resources: ApiResources[] = [];\n    if (\n        (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n        queueSubmitNode &&\n        commandBufferInstanceNode &&\n        primaryCommandBufferInstanceNode\n    ) {\n        if (secondaryCommandBufferExecutionNode) {\n            const renderPassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n                CommandSecondaryCommandBufferExecutionNode.is\n            );\n\n            // Add draw resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses:\n                    renderPassSecondaryCommandBufferExecutionNode &&\n                    renderPassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                        ? [\n                              {\n                                  beginId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                                  subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                                  endId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                        dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                              }\n                          ]\n                        : []\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses: [\n                    {\n                        beginId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                        subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                        endId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.endApiEvent || dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                    }\n                ]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createComputeApiResources(node: CommandDispatchInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add dispatch resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createTraceRaysApiResources(node: CommandRaytracingInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTransferNode = CommandAccelerationStructureBuildNode | CommandAccelerationStructureCopyNode | CommandTransferCommandNode;\n\nexport function createTransferApiResources(node: CommandTransferNode): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    let transferEvent: number = 0;\n    if (CommandAccelerationStructureBuildNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureBuildNode).resource.buildApiEvent;\n    } else if (CommandAccelerationStructureCopyNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureCopyNode).resource.copyApiEvent;\n    } else if (CommandTransferCommandNode.is(node)) {\n        transferEvent = (node as CommandTransferCommandNode).resource.transferApiEvent;\n    }\n\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTreeNode =\n    | CommandFrameNode\n    | CommandEmptyNode\n    | CommandApiEventNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandQueuePresentNode\n    | CommandQueueDebugLabelGroupNode\n    | CommandQueueDebugLabelNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandEmptyNode.is(node) ||\n            CommandApiEventNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandQueuePresentNode.is(node) ||\n            CommandQueueDebugLabelGroupNode.is(node) ||\n            CommandQueueDebugLabelNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n\n    export function findApiEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandSecondaryCommandBufferExecutionNode.is(current)) {\n            // For secondary command buffer execution nodes, return the VkCmdExecuteCommands apiEvent\n            // rather than the VkCommandBufferBegin apiEvent\n            return current.resource.apiEvent;\n        } else if (CommandTreeRangeNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (\n            CommandApiEventNode.is(current) ||\n            CommandQueueSubmitNode.is(current) ||\n            CommandQueuePresentNode.is(current) ||\n            CommandQueueDebugLabelNode.is(current)\n        ) {\n            return current.apiEventId;\n        } else if (CommandQueueDebugLabelGroupNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (CommandAccelerationStructureBuildNode.is(current)) {\n            return current.resource.buildApiEvent;\n        } else if (CommandAccelerationStructureCopyNode.is(current)) {\n            return current.resource.copyApiEvent;\n        } else if (CommandTransferCommandNode.is(current)) {\n            return current.apiEventId;\n        } else if (CommandTreeDrawOrDispatchNode.is(current)) {\n            return current.resource.apiEventId;\n        }\n        return undefined;\n    }\n\n    export function findFilterEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandFrameNode.is(current)) {\n            return current.resource.beginApiEvent;\n        }\n        let maybeQueueSubmitOrPresent: TreeNode | undefined = current;\n        while (\n            maybeQueueSubmitOrPresent !== undefined &&\n            !(\n                CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueuePresentNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)\n            )\n        ) {\n            maybeQueueSubmitOrPresent = maybeQueueSubmitOrPresent.parent;\n        }\n        let queueSubmitEventId: number | undefined;\n        if (maybeQueueSubmitOrPresent !== undefined) {\n            if (CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) || CommandQueuePresentNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            } else if (CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.resource.beginApiEvent;\n            } else if (CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            }\n        }\n        return queueSubmitEventId;\n    }\n\n    export function findRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const renderPassNode = findParentNode<CommandRenderPassInstanceNode>(current, CommandRenderPassInstanceNode.is);\n        return renderPassNode ? renderPassNode.renderPassInstanceId : undefined;\n    }\n\n    export function findDynamicRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const dynamicRenderPassNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n            current,\n            CommandDynamicRenderPassInstanceNode.is\n        );\n        return dynamicRenderPassNode ? dynamicRenderPassNode.dynamicRenderPassInstanceId : undefined;\n    }\n\n    export function findDrawInstanceId(current?: CommandTreeNode): number | undefined {\n        const drawInstanceNode = findParentNode<CommandDrawInstanceNode>(current, CommandDrawInstanceNode.is);\n        return drawInstanceNode ? drawInstanceNode.drawInstanceId : undefined;\n    }\n\n    export function findDispatchInstanceId(current?: CommandTreeNode): number | undefined {\n        const dispatchInstanceNode = findParentNode<CommandDispatchInstanceNode>(current, CommandDispatchInstanceNode.is);\n        return dispatchInstanceNode ? dispatchInstanceNode.dispatchInstanceId : undefined;\n    }\n\n    export function findMeshTaskInstanceId(current?: CommandTreeNode): number | undefined {\n        const meshTaskInstanceNode = findParentNode<CommandMeshTaskInstanceNode>(current, CommandMeshTaskInstanceNode.is);\n        return meshTaskInstanceNode ? meshTaskInstanceNode.meshTaskInstanceId : undefined;\n    }\n\n    export function findClusterInstanceId(current?: CommandTreeNode): number | undefined {\n        const clusterInstanceNode = findParentNode<CommandClusterInstanceNode>(current, CommandClusterInstanceNode.is);\n        return clusterInstanceNode ? clusterInstanceNode.clusterInstanceId : undefined;\n    }\n\n    export function findRaytracingInstanceId(current?: CommandTreeNode): number | undefined {\n        const raytracingInstanceNode = findParentNode<CommandRaytracingInstanceNode>(current, CommandRaytracingInstanceNode.is);\n        return raytracingInstanceNode ? raytracingInstanceNode.raytracingInstanceId : undefined;\n    }\n\n    export function findAccelerationBuildInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelBuildNode = findParentNode<CommandAccelerationStructureBuildNode>(current, CommandAccelerationStructureBuildNode.is);\n        return accelBuildNode ? accelBuildNode.buildInstanceId : undefined;\n    }\n\n    export function findAccelerationCopyInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelCopyNode = findParentNode<CommandAccelerationStructureCopyNode>(current, CommandAccelerationStructureCopyNode.is);\n        return accelCopyNode ? accelCopyNode.copyInstanceId : undefined;\n    }\n\n    export function findTransferCommandInstanceId(current?: CommandTreeNode): number | undefined {\n        const transferCommandNode = findParentNode<CommandTransferCommandNode>(current, CommandTransferCommandNode.is);\n        return transferCommandNode ? transferCommandNode.transferCommandInstanceId : undefined;\n    }\n\n    export function findMergedDynamicStatePromise(\n        current: CommandTreeNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> | undefined {\n        let maybeDrawOrDispatchInstance: TreeNode | undefined = current;\n        while (maybeDrawOrDispatchInstance !== undefined && !CommandTreeDrawOrDispatchNode.is(maybeDrawOrDispatchInstance)) {\n            maybeDrawOrDispatchInstance = maybeDrawOrDispatchInstance.parent;\n        }\n        let mergedDynamicStatePromise: Promise<DynamicStateEntry[]> | undefined;\n        if (maybeDrawOrDispatchInstance !== undefined && CommandDrawInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDrawInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandDispatchInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDispatchInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandMeshTaskInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandMeshTaskInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandClusterInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandClusterInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandRaytracingInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandRaytracingInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        }\n        return mergedDynamicStatePromise;\n    }\n\n    export function getRoot(node?: CompositeTreeNode | CommandRootNode | CommandTreeNode): CommandRootNode | undefined {\n        return findParentNode<CommandRootNode>(node, CommandRootNode.is);\n    }\n\n    export function getDbId(node: CommandRootNode | CommandTreeNode): number {\n        return getRoot(node)?.dbId ?? -1;\n    }\n\n    type GeneralizableNodes =\n        | typeof CommandApiEventNode\n        | typeof CommandClusterInstanceNode\n        | typeof CommandCommandBufferInstanceNode\n        | typeof CommandDispatchInstanceNode\n        | typeof CommandDrawInstanceNode\n        | typeof CommandEmptyNode\n        | typeof CommandFrameNode\n        | typeof CommandMeshTaskInstanceNode\n        | typeof CommandQueuePresentNode\n        | typeof CommandQueueSubmitNode\n        | typeof CommandQueueDebugLabelGroupNode\n        | typeof CommandQueueDebugLabelNode\n        | typeof CommandAccelerationStructureBuildNode\n        | typeof CommandAccelerationStructureCopyNode\n        | typeof CommandTransferCommandNode\n        | typeof CommandRaytracingInstanceNode\n        | typeof CommandRenderPassInstanceNode\n        | typeof CommandRenderSubpassInstanceNode\n        | typeof CommandDynamicRenderPassInstanceNode\n        | typeof CommandDebugLabelGroupNode;\n\n    /**\n     * An aggregate type label for command-tree nodes, roughly corresponding to some of the union\n     * types defined in this module.\n     */\n    export type GeneralizedType = GeneralizableNodes['GENERALIZED_TYPE'];\n\n    /**\n     * Query the generalized type of a given node, if it is a Command Tree node.\n     *\n     * @param node a tree node that may or may not be a `CommandTreeNode`\n     * @return its generalized type, or `undefined` if it isn't a `CommandTreeNode`\n     */\n    export function getGeneralizedNodeType(node: TreeNode): GeneralizedType | undefined {\n        const resourceType = 'resourceType' in node ? node.resourceType : undefined;\n        if (!resourceType) {\n            return CommandEmptyNode.is(node) ? 'empty' : undefined;\n        }\n\n        switch (resourceType) {\n            case 'frame':\n            case 'command-buffer-instance':\n            case 'render-pass-instance':\n            case 'render-subpass-instance':\n            case 'secondary-command-buffer-execution':\n            case 'debug-label-group':\n                return 'range';\n            case 'queue-submit':\n            case 'queue-present':\n                return 'queue';\n            case 'acceleration-structure-build':\n                return 'acceleration-structure-build';\n            case 'acceleration-structure-copy':\n                return 'acceleration-structure-copy';\n            case 'transfer-command':\n                return 'transfer-command';\n            case 'draw-instance':\n            case 'dispatch-instance':\n            case 'mesh-task-instance':\n            case 'cluster-instance':\n            case 'raytracing-instance':\n                return 'draw-or-dispatch';\n            case 'api-event':\n                return 'api-event';\n            default:\n                return undefined;\n        }\n    }\n\n    /** Type assertion for a range-type node. */\n    export function generalize(node: TreeNode, type: 'range'): asserts node is CommandTreeRangeNode;\n    /** Type assertion for a queue-type node. */\n    export function generalize(node: TreeNode, type: 'queue'): asserts node is CommandQueueSubmitNode | CommandQueuePresentNode;\n    /** Type assertion for a queue-debug-label-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'queue-debug-label'\n    ): asserts node is CommandQueueDebugLabelGroupNode | CommandQueueDebugLabelNode;\n    /** Type assertion for a acceleration-structure-build-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-build'): asserts node is CommandAccelerationStructureBuildNode;\n    /** Type assertion for a acceleration-structure-copy-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-copy'): asserts node is CommandAccelerationStructureCopyNode;\n    /** Type assertion for a transfer-command-type node. */\n    export function generalize(node: TreeNode, type: 'transfer-command'): asserts node is CommandTransferCommandNode;\n    /** Type assertion for a draw-or-dispatch-type node. */\n    export function generalize(node: TreeNode, type: 'draw-or-dispatch'): asserts node is CommandTreeDrawOrDispatchNode;\n    /** Type assertion for an api-event-type node. */\n    export function generalize(node: TreeNode, type: 'api-event'): asserts node is CommandApiEventNode;\n    /** Type assertion for a draw-or-dispatch- or api-event-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'draw-or-dispatch' | 'api-event'\n    ): asserts node is CommandTreeDrawOrDispatchNode | CommandApiEventNode;\n    /** Type assertion for an empty-type node. */\n    export function generalize(node: TreeNode, type: 'empty'): asserts node is CommandEmptyNode;\n    export function generalize(node: TreeNode, _type: GeneralizedType): asserts node is CommandTreeNode {\n        // Pass\n    }\n}\n\nexport type CommandTreeRangeNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeRangeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeRangeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n}\n\nexport type CommandTreeDrawOrDispatchNode =\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode;\n\nexport namespace CommandTreeDrawOrDispatchNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeDrawOrDispatchNode {\n        return (\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node)\n        );\n    }\n}\n\ninterface ArrayWithSortNumber<RangeType> {\n    array: RangeType[];\n    getSortNumber(element: RangeType): number;\n}\n\ntype AllRangeTypes =\n    | CommandTreeDebugLabelGroupInstance\n    | CommandTreeRenderPassInstance\n    | CommandTreeRenderSubpassInstance\n    | CommandTreeDynamicRenderPassInstance;\n\ntype CommandTreeRangeParentNode =\n    | CommandRenderPassInstanceNode\n    | CommandCommandBufferInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandDebugLabelGroupNode;\n\nfunction findNextRangeElementToProcess<RangeType>(...arrays: ArrayWithSortNumber<RangeType>[]): RangeType | undefined {\n    // designate which array is the api event array vs a range array\n    // when processing a range, shift off any api events that are within the range\n    // so they aren't processed (because they actually reside within a sub-group)\n\n    const arraysToProcess: ArrayWithSortNumber<RangeType>[] = [];\n    arrays.forEach(arr => {\n        if (arr.array.length) {\n            arraysToProcess.push(arr);\n        }\n    });\n\n    if (!arraysToProcess.length) {\n        return undefined;\n    }\n\n    // get the sort number of the first element of each array and sort them\n    const sortedElements = arraysToProcess\n        .map(array => ({ subarray: array.array, sortNumber: array.getSortNumber(array.array[0]) }))\n        .sort((a, b) => a.sortNumber - b.sortNumber);\n\n    return sortedElements[0].subarray.shift();\n}\n\n/**\n * Process commands and ranges together in API event order.\n * For each range element, creates child nodes for commands that come before it,\n * skips commands that fall within the range, and creates a node for the range itself.\n * After processing all ranges, any remaining commands are processed.\n *\n * @param ctx - Command tree context\n * @param root - Root node\n * @param parentNode - Parent node to add children to\n * @param apiEventCommandArray - Array of commands sorted by API event ID (will be mutated)\n * @param childCommandIndex - Starting index for child commands\n * @param baseDynamicStatePromise - Promise for dynamic state\n * @param createRangeNode - Callback to create a node for each range element\n * @param rangeArrays - Variable number of range arrays to process together\n * @returns The final child command index\n */\nasync function createChildEventNodesForRange<RangeType extends { beginApiEvent: number; endApiEvent?: number }>(\n    ctx: CommandTreeContext,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    apiEventCommandArray: CommandTreeApiEvent[],\n    childCommandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n    createRangeNode: (rangeElement: RangeType, parentNode: CommandTreeRangeParentNode) => void,\n    ...rangeArrays: ArrayWithSortNumber<RangeType>[]\n): Promise<number> {\n    console.log(\n        `JF: createChildEventNodesForRange START for parent ${parentNode.id}, apiEventCommandArray length: ${apiEventCommandArray.length}`\n    );\n    const stateTracker = new DynamicStateTracker(baseDynamicStatePromise);\n    let nextRangeElement: RangeType | undefined;\n    let priorRangeEndApiEvent: number | undefined;\n\n    while ((nextRangeElement = findNextRangeElementToProcess<RangeType>(...rangeArrays))) {\n        // create a node for any command that comes BEFORE the next range element\n        while (apiEventCommandArray.length && apiEventCommandArray[0].apiEventId < nextRangeElement.beginApiEvent) {\n            const command = apiEventCommandArray.shift();\n            childCommandIndex = await createChildEventNode(ctx, command!, root, parentNode, childCommandIndex, stateTracker);\n        }\n\n        // shift off any command that falls WITHIN next range since it will be processed when creating next range node\n        while (\n            apiEventCommandArray.length &&\n            nextRangeElement.endApiEvent !== undefined &&\n            apiEventCommandArray[0].apiEventId >= nextRangeElement.beginApiEvent &&\n            apiEventCommandArray[0].apiEventId <= nextRangeElement.endApiEvent\n        ) {\n            apiEventCommandArray.shift();\n        }\n\n        // skip next range if it falls within the prior range since it will be processed when creating prior range node\n        if (\n            priorRangeEndApiEvent !== undefined &&\n            nextRangeElement.endApiEvent !== undefined &&\n            nextRangeElement.endApiEvent <= priorRangeEndApiEvent\n        ) {\n            continue;\n        }\n        priorRangeEndApiEvent = nextRangeElement.endApiEvent;\n\n        // create a node for the next range element\n        createRangeNode(nextRangeElement, parentNode);\n    }\n\n    // process any remaining command elements after all range elements have been processed\n    for (const command of apiEventCommandArray) {\n        childCommandIndex = await createChildEventNode(ctx, command, root, parentNode, childCommandIndex, stateTracker);\n    }\n\n    console.log(`JF: createChildEventNodesForRange END for parent ${parentNode.id}, final children count: ${parentNode.children.length}`);\n    return childCommandIndex;\n}\n\n/**\n * Find node from descendent node for which isNode is true\n */\nexport const findParentNode = <T extends TreeNode>(\n    node: TreeNode | undefined,\n    isNode: (node: TreeNode | undefined) => node is T\n): T | undefined => {\n    let targetNode: TreeNode | undefined = node;\n    while (targetNode && targetNode.parent && !isNode(targetNode)) {\n        targetNode = targetNode.parent;\n    }\n\n    return targetNode && isNode(targetNode) ? targetNode : undefined;\n};\n\n/**\n * Find the primary command buffer instance node from a given command buffer instance node.\n * If the given node is in a secondary command buffer, traverses up through nested secondary\n * command buffers until finding the primary command buffer (one with no parent execution node).\n * If the given node is already in a primary command buffer, returns it as-is.\n */\nexport const findPrimaryCommandBufferInstanceNode = (\n    commandBufferInstanceNode: CommandCommandBufferInstanceNode | undefined,\n    secondaryCommandBufferExecutionNode: CommandSecondaryCommandBufferExecutionNode | undefined\n): CommandCommandBufferInstanceNode | undefined => {\n    let primaryCommandBufferInstanceNode = commandBufferInstanceNode;\n    if (secondaryCommandBufferExecutionNode) {\n        let currentExecution: CommandSecondaryCommandBufferExecutionNode | undefined = secondaryCommandBufferExecutionNode;\n        while (currentExecution) {\n            const parentCB: CommandCommandBufferInstanceNode | undefined = findParentNode<CommandCommandBufferInstanceNode>(\n                currentExecution,\n                CommandCommandBufferInstanceNode.is\n            );\n            if (parentCB) {\n                primaryCommandBufferInstanceNode = parentCB;\n                // Check if this CB is also inside another secondary execution (nested case)\n                currentExecution = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                    parentCB.parent,\n                    CommandSecondaryCommandBufferExecutionNode.is\n                );\n            } else {\n                break;\n            }\n        }\n    }\n    return primaryCommandBufferInstanceNode;\n};\n\n/**\n * find a frame node from descendent node or self\n */\nexport const findFrameNode = (node: TreeNode): CommandFrameNode | undefined => findParentNode<CommandFrameNode>(node, CommandFrameNode.is);\n\n@injectable()\nexport class CommandTree extends BulkTree implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTree {\n        return tree instanceof CommandTree;\n    }\n\n    @inject(CaptureDatasetWidgetProfile)\n    protected readonly profile: CaptureDatasetWidgetProfile;\n    @inject(CaptureDatasetWidgetContext)\n    protected readonly context: CaptureDatasetWidgetContext;\n\n    @inject(CommandTreeDataQueriedRootProvider)\n    protected readonly rootProvider: CommandTreeDataQueriedRootProvider;\n    @inject(GFXRQueryBuilderService)\n    protected readonly gfxrQueryBuilderService: GFXRQueryBuilderService;\n\n    protected override _root: CommandRootNode | undefined;\n\n    // Back-reference to the model that manages this tree\n    model?: CommandTreeModel;\n\n    protected readonly onStructureChangedEmitter = new Emitter<TreeNode | undefined>();\n    readonly onStructureChanged = this.onStructureChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this._root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        super.root = root;\n        // Set back-reference from root to tree\n        if (root) {\n            root.tree = this;\n        }\n    }\n\n    async initTree(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        this.root = await this.rootProvider.provide(dbId, { tree: this }, options, createDrawOrDispatchChildren);\n\n        // tree structure is fully built at this point, report structure change\n        this.onStructureChangedEmitter.fire(undefined);\n    }\n\n    async refreshStructure(node?: CompositeTreeNode, cancellationToken?: CancellationToken): Promise<void> {\n        await this.refresh(node, cancellationToken);\n        this.fireStructureChanged(node);\n    }\n\n    fireStructureChanged(node?: TreeNode): void {\n        this.onStructureChangedEmitter.fire(node);\n    }\n\n    addToDispose(disposable: Disposable): void {\n        this.toDispose.push(disposable);\n    }\n\n    override dispose(): void {\n        this.rootProvider.dispose();\n        super.dispose();\n    }\n}\n\n@injectable()\nexport class CommandTreeModelPreferenceStateAccessImpl implements CommandTreePreferenceState.Access {\n    private readonly models = new Map<CommandTree, CommandTreeModel>();\n\n    private readonly commandTreeStateChangedEmitter = new Emitter<{ tree: CommandTree; state: CommandTreePreferenceState }>();\n    readonly onCommandTreeStateChanged = this.commandTreeStateChangedEmitter.event;\n\n    getCommandTreeState(tree: CommandTree): CommandTreePreferenceState {\n        return this.models.get(tree)?.getPreferenceState() ?? {};\n    }\n\n    fireCommandTreeStateChanged(tree: CommandTree): void {\n        this.commandTreeStateChangedEmitter.fire({ tree, state: this.getCommandTreeState(tree) });\n    }\n\n    registerCommandTreeModel(tree: CommandTree, model: CommandTreeModel): void {\n        this.models.set(tree, model);\n        this.fireCommandTreeStateChanged(tree);\n    }\n}\n\n@injectable()\nexport class CommandTreeModel extends BulkTreeModel implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTreeModel {\n        return tree instanceof CommandTreeModel;\n    }\n\n    @inject(MiscPreferences)\n    protected readonly miscPreferences: MiscPreferences;\n    @inject(CommandTree) override readonly tree: CommandTree;\n    protected _groupBy: GroupByOptions = GroupByOptions.Frame;\n    private groupByChangedEmitter = new Emitter<GroupByOptions>();\n    readonly onGroupByChanged = this.groupByChangedEmitter.event;\n    protected _isThumbnailEnabled = true;\n    protected _isApiEventIdsEnabled = true;\n    protected _isShowingEmptyRows = false;\n    protected _isVulkanEnabled = true;\n    protected _isDebugNamesEnabled = true;\n    protected _isDebugLabelsEnabled = true;\n    protected _isLinksEnabled = true;\n    protected _isThreadsEnabled = true;\n\n    @inject(FrameRangeSelectionService)\n    protected readonly frameRangeSelectionService: FrameRangeSelectionService;\n\n    @inject(CommandTreeModelPreferenceStateAccessImpl)\n    private readonly preferenceStateAccess: CommandTreeModelPreferenceStateAccessImpl;\n\n    protected isCollapsingSubTree = false;\n\n    // Proxies to prevent calls on sub tree expansion\n    protected readonly onExpansionChangedEmitterProxy = new Emitter<ExpandableTreeNode>();\n    protected readonly onChangedEmitterProxy = new Emitter<void>();\n\n    protected readonly onSubTreeExpansionChangedEmitter = new Emitter<ExpandableTreeNode>();\n    readonly onSubTreeExpansionChanged = this.onSubTreeExpansionChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this.tree.root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        this.tree.root = root;\n    }\n\n    override get onChanged(): Event<void> {\n        return this.onChangedEmitterProxy.event;\n    }\n\n    override get onExpansionChanged(): Event<ExpandableTreeNode> {\n        return this.onExpansionChangedEmitterProxy.event;\n    }\n\n    get onStructureChanged(): Event<TreeNode | undefined> {\n        return this.tree.onStructureChanged;\n    }\n\n    async initModel(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        await this.tree.initTree(dbId, createDrawOrDispatchChildren, options);\n    }\n\n    set groupBy(value: GroupByOptions) {\n        if (this._groupBy !== value) {\n            this._groupBy = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n            this.groupByChangedEmitter.fire(value);\n        }\n    }\n\n    get groupBy(): GroupByOptions {\n        return this._groupBy;\n    }\n\n    /**\n     * Obtain the tree nodes that are the top-level groups according to\n     * the current {@link groupBy} mode.\n     */\n    *groupNodes(): IterableIterator<CompositeTreeNode> {\n        if (!this.root) {\n            return;\n        }\n\n        const group = this.groupBy;\n        const treeIterator = new (class extends DepthFirstTreeIterator {\n            protected override children(node: TreeNode): TreeNode[] | undefined {\n                // Prune group nodes because we needn't look in them for more groups\n                return CommandTreeModel.isOfGroup(node, group) ? undefined : super.children(node);\n            }\n        })(this.root);\n\n        for (const next of treeIterator) {\n            if (CommandTreeModel.isOfGroup(next, group)) {\n                yield next;\n            }\n        }\n    }\n\n    set isApiEventIdsEnabled(value: boolean) {\n        if (this._isApiEventIdsEnabled !== value) {\n            this._isApiEventIdsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isApiEventIdsEnabled(): boolean {\n        return this._isApiEventIdsEnabled;\n    }\n\n    set isShowingEmptyRows(value: boolean) {\n        if (this._isShowingEmptyRows !== value) {\n            this._isShowingEmptyRows = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isShowingEmptyRows(): boolean {\n        return this._isShowingEmptyRows;\n    }\n\n    set isThumbnailEnabled(value: boolean) {\n        if (this._isThumbnailEnabled !== value) {\n            this._isThumbnailEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThumbnailEnabled(): boolean {\n        return this._isThumbnailEnabled;\n    }\n\n    set isVulkanEnabled(value: boolean) {\n        if (this._isVulkanEnabled !== value) {\n            this._isVulkanEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isVulkanEnabled(): boolean {\n        return this._isVulkanEnabled;\n    }\n\n    set isDebugNamesEnabled(value: boolean) {\n        if (this._isDebugNamesEnabled !== value) {\n            this._isDebugNamesEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugNamesEnabled(): boolean {\n        return this._isDebugNamesEnabled;\n    }\n\n    set isDebugLabelsEnabled(value: boolean) {\n        if (this._isDebugLabelsEnabled !== value) {\n            this._isDebugLabelsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugLabelsEnabled(): boolean {\n        return this._isDebugLabelsEnabled;\n    }\n\n    set isLinksEnabled(value: boolean) {\n        if (this._isLinksEnabled !== value) {\n            this._isLinksEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isLinksEnabled(): boolean {\n        return this._isLinksEnabled;\n    }\n\n    set isThreadsEnabled(value: boolean) {\n        if (this._isThreadsEnabled !== value) {\n            this._isThreadsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThreadsEnabled(): boolean {\n        return this._isThreadsEnabled;\n    }\n\n    getPreferenceState(nonDefaultOnly = false): CommandTreePreferenceState {\n        const result: CommandTreePreferenceState = {};\n\n        if (!nonDefaultOnly || this.groupBy !== this.miscPreferences[MiscPrefs.GroupBy]) {\n            result.groupBy = this.groupBy;\n        }\n        if (!nonDefaultOnly || this.isApiEventIdsEnabled !== this.miscPreferences[MiscPrefs.ShowApiEventIds]) {\n            result.isApiEventIdsEnabled = this.isApiEventIdsEnabled;\n        }\n        if (!nonDefaultOnly || this.isShowingEmptyRows !== this.miscPreferences[MiscPrefs.ShowEmptyRows]) {\n            result.isShowingEmptyRows = this.isShowingEmptyRows;\n        }\n        if (!nonDefaultOnly || this.isThumbnailEnabled !== this.miscPreferences[MiscPrefs.ShowThumbnails]) {\n            result.isThumbnailEnabled = this.isThumbnailEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugNamesEnabled !== true) {\n            result.isDebugNamesEnabled = this.isDebugNamesEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugLabelsEnabled !== true) {\n            result.isDebugLabelsEnabled = this.isDebugLabelsEnabled;\n        }\n        if (!nonDefaultOnly || this.isLinksEnabled !== true) {\n            result.isLinksEnabled = this.isLinksEnabled;\n        }\n        if (!nonDefaultOnly || this.isThreadsEnabled !== true) {\n            result.isThreadsEnabled = this.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (!nonDefaultOnly || this.isVulkanEnabled !== this.miscPreferences[MiscPrefs.ShowVulkanCalls]) {\n        //     result.isVulkanEnabled = this.isVulkanEnabled;\n        // }\n\n        return result;\n    }\n\n    override restoreState(state: CommandTreeModel.State): void {\n        if (state.groupBy !== undefined) {\n            this.groupBy = state.groupBy;\n        }\n        if (state.isApiEventIdsEnabled !== undefined) {\n            this.isApiEventIdsEnabled = state.isApiEventIdsEnabled;\n        }\n        if (state.isShowingEmptyRows !== undefined) {\n            this.isShowingEmptyRows = state.isShowingEmptyRows;\n        }\n        if (state.isThumbnailEnabled !== undefined) {\n            this.isThumbnailEnabled = state.isThumbnailEnabled;\n        }\n        if (state.isDebugNamesEnabled !== undefined) {\n            this.isDebugNamesEnabled = state.isDebugNamesEnabled;\n        }\n        if (state.isDebugLabelsEnabled !== undefined) {\n            this.isDebugLabelsEnabled = state.isDebugLabelsEnabled;\n        }\n        if (state.isLinksEnabled !== undefined) {\n            this.isLinksEnabled = state.isLinksEnabled;\n        }\n        if (state.isThreadsEnabled !== undefined) {\n            this.isThreadsEnabled = state.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (state.isVulkanEnabled !== undefined) {\n        //     this.isVulkanEnabled = state.isVulkanEnabled;\n        // }\n    }\n    override storeState(): CommandTreeModel.State {\n        return {\n            ...super.storeState(),\n            ...this.getPreferenceState(true)\n        };\n    }\n\n    @postConstruct()\n    protected override init(): void {\n        super.init();\n\n        // Set back-reference from tree to model\n        this.tree.model = this;\n\n        this.toDispose.pushAll([\n            this.onChangedEmitterProxy,\n            this.onExpansionChangedEmitterProxy,\n            this.onSubTreeExpansionChangedEmitter,\n\n            super.onChanged(() => {\n                if (!this.isCollapsingSubTree) {\n                    this.onChangedEmitterProxy.fire();\n                }\n            }),\n            super.onExpansionChanged(node => {\n                if (!this.isCollapsingSubTree) {\n                    this.onExpansionChangedEmitterProxy.fire(node);\n                }\n            })\n        ]);\n\n        this._isApiEventIdsEnabled = this.miscPreferences[MiscPrefs.ShowApiEventIds];\n        this._isShowingEmptyRows = this.miscPreferences[MiscPrefs.ShowEmptyRows];\n        this.isThumbnailEnabled = this.miscPreferences[MiscPrefs.ShowThumbnails];\n        this.groupBy = this.miscPreferences[MiscPrefs.GroupBy];\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // this.isVulkanEnabled = this.miscPreferences[MiscPrefs.ShowVulkanCalls];\n\n        this.preferenceStateAccess.registerCommandTreeModel(this.tree, this);\n    }\n\n    /**\n     * Collapses the entire tree.\n     */\n    async collapseTree(): Promise<void> {\n        const root = this.root;\n\n        if (CompositeTreeNode.is(root) && root.children.length > 0) {\n            await Promise.all(\n                root.children.filter(CompositeTreeNode.is).map((child: CompositeTreeNode) => this.expansionService.collapseAll(child))\n            );\n        }\n    }\n\n    /**\n     * Expands the given node and all its children recursively.\n     */\n    async expandSubTree(node?: Readonly<TreeNode>, includeDrawOrDispatchNodes = false): Promise<void> {\n        node ??= this.root;\n        if (!ExpandableTreeNode.is(node)) {\n            return;\n        }\n\n        try {\n            this.isCollapsingSubTree = true;\n            await this.doExpandSubTree(node, includeDrawOrDispatchNodes);\n            this.onSubTreeExpansionChangedEmitter.fire(node);\n        } finally {\n            this.isCollapsingSubTree = false;\n        }\n    }\n\n    protected async doExpandSubTree(node: TreeNode, includeDrawOrDispatchNodes: boolean): Promise<void> {\n        const YIELD_AFTER_MS = 200;\n\n        const processedNodes = new Set<TreeNode>();\n        const pendingNodes: TreeNode[] = [node];\n        let lastYieldTime = performance.now();\n\n        while (pendingNodes.length > 0) {\n            const currentLevelNodes: ExpandableTreeNode[] = [];\n            const nextLevelNodes: TreeNode[] = [];\n\n            while (pendingNodes.length > 0) {\n                const currentNode = pendingNodes.shift()!;\n                if (processedNodes.has(currentNode)) {\n                    continue;\n                }\n                processedNodes.add(currentNode);\n\n                // stop expansion at draw and dispatch nodes to avoid creation of low-utility nodes\n                // if this logic gets changed please also update enablement of ExpandSubtreeCommand accordingly\n                if (ExpandableTreeNode.is(currentNode) && (includeDrawOrDispatchNodes || !CommandTreeDrawOrDispatchNode.is(currentNode))) {\n                    currentLevelNodes.push(currentNode);\n                }\n            }\n\n            if (currentLevelNodes.length > 0) {\n                const expandedNodes = await this.expansionService.bulkExpandNodes(currentLevelNodes[Symbol.iterator]());\n                for (const expandedNode of expandedNodes) {\n                    await this.ensureLazyChildrenLoaded(expandedNode);\n                    console.log(\n                        `JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, children count: ${expandedNode.children.length}, children ids: ${expandedNode.children.map(c => c.id).join(', ')}`\n                    );\n                    nextLevelNodes.push(...expandedNode.children);\n                }\n                // Also process children of nodes that were already expanded\n                for (const currentNode of currentLevelNodes) {\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\n                        await this.ensureLazyChildrenLoaded(currentNode);\n                        console.log(\n                            `JF: doExpandSubTree - after ensureLazyChildrenLoaded (already expanded) for ${currentNode.id}, children count: ${currentNode.children.length}, children ids: ${currentNode.children.map(c => c.id).join(', ')}`\n                        );\n                        nextLevelNodes.push(...currentNode.children);\n                    }\n                }\n            }\n\n            pendingNodes.push(...nextLevelNodes);\n\n            // Yield control back to the event loop periodically based on time\n            const currentTime = performance.now();\n            if (currentTime - lastYieldTime >= YIELD_AFTER_MS) {\n                await new Promise(resolve => setTimeout(resolve, 0));\n                lastYieldTime = performance.now();\n            }\n        }\n    }\n\n    protected async ensureLazyChildrenLoaded(node: ExpandableTreeNode): Promise<void> {\n        // Find all loading nodes among children\n        const loadingNodes = node.children.filter(CommandEmptyNode.is);\n\n        if (loadingNodes.length === 0) {\n            return;\n        }\n\n        // Trigger load for all loading nodes and wait for them to complete\n        await Promise.all(loadingNodes.map(loadingNode => triggerLazyLoadAndWaitForRemoval(loadingNode)));\n    }\n\n    hasTrailingSuffixes(node: TreeNode): boolean {\n        if (CommandQueueSubmitNode.is(node)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    protected override isVisibleSelectableNode(node: TreeNode): node is SelectableTreeNode {\n        return super.isVisibleSelectableNode(node) && this.isInFrameRange(node);\n    }\n\n    protected isInFrameRange(node: TreeNode): boolean {\n        const frameNode = CommandFrameNode.getCommandFrameNodeContaining(node);\n        if (frameNode === undefined) {\n            return true; // Assume it's good\n        }\n        const range = this.frameRangeSelectionService.frameSpan;\n        if (range === undefined) {\n            return true; // No constraint\n        }\n        return frameNode.frameIndex >= range.startFrame && frameNode.frameIndex <= range.endFrame;\n    }\n}\n\nexport namespace CommandTreeModel {\n    export interface State extends TreeModelImpl.State, CommandTreePreferenceState {}\n\n    /**\n     * Test whether a `node` is of the kind that implements the given `group` mode.\n     * As groups are _a priori_ composite nodes, this additionally infers that type\n     * for the `node` if successful.\n     */\n    export function isOfGroup(node: TreeNode, group: GroupByOptions): node is CompositeTreeNode {\n        switch (group) {\n            case GroupByOptions.Frame:\n                return CommandFrameNode.is(node);\n            case GroupByOptions.RenderPass:\n                return CommandRenderPassInstanceNode.is(node) || CommandDynamicRenderPassInstanceNode.is(node);\n            case GroupByOptions.RenderSubpass:\n                return CommandRenderSubpassInstanceNode.is(node);\n            case GroupByOptions.CommandBuffer:\n                return CommandCommandBufferInstanceNode.is(node);\n            case GroupByOptions.QueueSubmission:\n                return CommandQueueSubmitNode.is(node);\n        }\n    }\n}\n\ntype TextureSupportingNode =\n    | CommandFrameNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode;\n\nexport namespace TextureSupportingNode {\n    export function is(node: CommandTreeNode): node is TextureSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node)\n        );\n    }\n    export function getLast(node: CommandTreeNode): TextureSupportingNode | undefined {\n        if (TextureSupportingNode.is(node)) {\n            return node;\n        }\n        let lastSupportingNode: TextureSupportingNode | undefined;\n        if (CompositeTreeNode.is(node)) {\n            for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n                lastSupportingNode = TextureSupportingNode.getLast(node.children[commandIndex]);\n                if (lastSupportingNode) {\n                    break;\n                }\n            }\n        }\n        return lastSupportingNode;\n    }\n}\n\n/**\n * Union type of all command tree nodes that support thumbnails.\n * Nodes with heavy thumbnail costs are commented out.\n */\ntype ThumbnailSupportingNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandDebugLabelGroupNode\n    | CommandRenderPassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDrawInstanceNode;\n// Below currently have a possibly heavy cost to getting thumbnails\n// | CommandDispatchInstanceNode\n// | CommandMeshTaskInstanceNode\n// | CommandClusterInstanceNode\n// | CommandRaytracingInstanceNode;\n\nexport namespace ThumbnailSupportingNode {\n    export function is(node: CommandTreeNode): node is ThumbnailSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node)\n        );\n    }\n}\n\nfunction getCommandTreeApiEventChildren(eventIds: Array<{ apiEvent: number }>, root: CommandRootNode): CommandTreeApiEvent[] {\n    return eventIds.reduce<CommandTreeApiEvent[]>((collected, id) => {\n        const event = root.resource.apiEvents[id.apiEvent];\n        if (event) {\n            collected.push(event);\n        } else {\n            console.warn(`No event found for ${id.apiEvent}`);\n        }\n        return collected;\n    }, []);\n}\n\nfunction getInstancesByIds<T>(ids: number[], container: PartialRecord<number, T>, source?: string, target?: string): T[] {\n    return ids.flatMap(id => {\n        const instance = container[id];\n        if (!instance) {\n            if (target) {\n                console.warn(`${source ? `${source} expected` : 'Expected'} ${target} with ${id} but found none.`);\n            }\n            return [];\n        }\n        return instance;\n    });\n}\n\n/**\n * Creates an ArrayWithSortNumber for range instances, used by createChildEventNodesForRange.\n * Fetches instances by IDs and provides sorting by beginApiEvent.\n *\n * @param ids - Array of instance IDs to fetch\n * @param container - Container object mapping IDs to instances\n * @param sourceContext - Context string for error messages (e.g., \"CommandRenderPassInstanceNode.create\")\n * @param targetName - Target instance type name for error messages (e.g., \"DebugLabelGroupInstance\")\n * @returns ArrayWithSortNumber object ready for use with getNextRangeElementToProcess\n */\nfunction createRangeInstanceArray<T extends { beginApiEvent: number }>(\n    ids: number[],\n    container: PartialRecord<number, T>,\n    sourceContext: string,\n    targetName: string\n): ArrayWithSortNumber<T> {\n    return {\n        array: getInstancesByIds(ids, container, sourceContext, targetName),\n        getSortNumber: (element: T) => element.beginApiEvent\n    };\n}\n\nexport function createLazyLoadingNode(\n    tree: CommandTree,\n    parent: ExpandableTreeNode,\n    load: (batchQuery?: boolean) => Promise<void>\n): CommandEmptyNode {\n    let loaded = false;\n    let loadingInProgress = false;\n\n    const lazyLoad: (batchQuery?: boolean) => Promise<boolean> = async (batchQuery = true) => {\n        if (loadingInProgress) {\n            return false;\n        }\n\n        if (!loaded) {\n            loaded = true;\n            loadingInProgress = true;\n            loadOnExpanded.dispose();\n            try {\n                await load(batchQuery);\n            } catch (error) {\n                console.error(`LazyLoad failed for node ${parent.id}:`, error);\n            } finally {\n                loadingInProgress = false;\n            }\n            console.log(\n                `JF: createLazyLoadingNode - load completed for parent ${parent.id}, children count before removeChild: ${parent.children.length}`\n            );\n            CompositeTreeNode.removeChild(parent, loadingNode);\n            await tree.refreshStructure(parent);\n            return true;\n        }\n        return false;\n    };\n\n    // create lazy loading node\n    const loadingNode: CommandEmptyNode = CommandEmptyNode.create(parent, lazyLoad);\n    CompositeTreeNode.addChild(parent, loadingNode);\n\n    // register for lazy loading when the node is expanded\n    const loadOnExpanded = SokatoaLifecycleTreeNode.register(parent, 'onWillRender', async () => {\n        if (parent.expanded) {\n            // do not batch queries for expansion manually\n            await lazyLoad(false);\n        }\n    });\n    return loadingNode;\n}\n"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "The file is quite large. Let me run lint to check for the remaining issues:"
            },
            "fallbackMessage": "The file is quite large. Let me run lint to check for the remaining issues:"
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01NRvcrrQo13oqQNRZwWKw7t",
              "name": "runTask",
              "arguments": "{\"taskName\": \"npm: lint:check - capture\"}",
              "finished": true,
              "result": "Did not find a task for the label: 'npm: lint:check - capture'"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01D9xH3kJUeMtLRaK9MU68AY",
              "name": "listTasks",
              "arguments": "{\"filter\": \"lint\"}",
              "finished": true,
              "result": "[\"build - app/tsconfig.eslint.json\",\"watch - app/tsconfig.eslint.json\",\"build - app/sample_extensions/tsconfig.eslint.json\",\"watch - app/sample_extensions/tsconfig.eslint.json\",\"lint - app\",\"lint:fix - app\",\"lint:github-ci - app\",\"lint - app/packages/plugin-ext-api\",\"lint - app/packages/plugin-ext-sokatoa\",\"lint - app/packages/ai\",\"lint - app/packages/plugin-ext-headless-api\",\"lint - app/packages/electron-logging\",\"lint - app/packages/plugin-ext-headless-sokatoa\",\"lint - app/packages/tracks\",\"lint - app/packages/capture\",\"lint - app/packages/shader-static-analyzer\",\"lint - app/packages/notebook\",\"lint - app/packages/product\",\"lint - app/packages/json-forms\",\"lint - app/packages/workspace\",\"lint - app/tests/e2e-tests\",\"lint-fix - app/tests/e2e-tests\",\"lint - app/sample_extensions/raytracing\",\"lint - app/sample_extensions/capturepart\",\"lint - app/packages/gfxr-consumer\",\"lint - app/sample_extensions/sqlquery\",\"lint - app/sample_extensions/helloworld\",\"lint - app/packages/buffer-view\",\"lint - app/sample_extensions/deviceinsp\",\"lint - app/.browser_modules/drivelist\",\"lint-cpp - app/.browser_modules/drivelist\",\"lint-ts - app/.browser_modules/drivelist\",\"lint - app/packages/etc-decoder\",\"lint - app/packages/timeline\",\"lint - app/packages/platform\",\"lint - app/packages/electron-updater\",\"lint - app/packages/bc-decoder\",\"lint - app/packages/astc-decoder\",\"lint - app/.browser_modules/node-pty\",\"lint - app/.browser_modules/keytar\",\"cpplint - app/.browser_modules/keytar\",\"lint - app/out/perfetto-ui\",\"lint - external/perfetto/buildtools/linux64/emsdk/emscripten\",\"lint - external/perfetto/ui\"]"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01RFQ2CaPspH6NRn1mgqKX5n",
              "name": "runTask",
              "arguments": "{\"taskName\": \"lint - app/packages/capture\"}",
              "finished": true,
              "result": "> Executing task: npm run lint <                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n> @sokatoa/capture@0.0.9 lint                                                                                                                                      \n> eslint -c ./eslint.config.mjs --max-warnings=0 --ext .ts,.tsx ./src                                                                                              \n                                                                                                                                                                   \n                                                                                                                                                                   \n/home/johannes/Git/sokatoa/app/packages/capture/src/browser/command-tree/command-tree-model.ts                                                                     \n  1022:1  warning  This line has a length of 146. Maximum allowed is 140  max-len                                                                                  \n  1688:1  warning  This line has a length of 146. Maximum allowed is 140  max-len                                                                                  \n  1787:1  warning  This line has a length of 150. Maximum allowed is 140  max-len                                                                                  \n  3692:1  warning  This line has a length of 216. Maximum allowed is 140  max-len                                                                                  \n  3701:1  warning  This line has a length of 236. Maximum allowed is 140  max-len                                                                                  \n  3926:1  warning  This line has a length of 146. Maximum allowed is 140  max-len                                                                                  \n                                                                                                                                                                   \n 6 problems (0 errors, 6 warnings)                                                                                                                                \n                                                                                                                                                                   \nESLint found too many warnings (maximum: 0).                                                                                                                       \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   "
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "I need to fix these line length issues. Let me search for the specific lines and fix them:"
            },
            "fallbackMessage": "I need to fix these line length issues. Let me search for the specific lines and fix them:"
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01SZpXjJtWy8cVZgZkz4pkRb",
              "name": "searchInWorkspace",
              "arguments": "{\"query\": \"JF: CommandCommandBufferInstanceNode\", \"useRegExp\": false, \"fileExtensions\": [\"ts\"]}",
              "finished": true,
              "result": "[{\"file\":\"app/packages/capture/src/browser/command-tree/command-tree-model.ts\",\"matches\":[{\"line\":1022,\"text\":\"`JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\"}]}]"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01Qtn5T35na3fxTgpfhjoEuW",
              "name": "writeFileReplacements",
              "arguments": "{\"path\": \"app/packages/capture/src/browser/command-tree/command-tree-model.ts\", \"replacements\": [{\"oldContent\":\"            .then(() => {\\n                console.log(\\n                    `JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\",\"newContent\":\"            .then(() => {\\n                // eslint-disable-next-line max-len\\n                console.log(`JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\"},{\"oldContent\":\"            .then(() => {\\n                console.log(\\n                    `JF: CommandRenderSubpassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\",\"newContent\":\"            .then(() => {\\n                // eslint-disable-next-line max-len\\n                console.log(`JF: CommandRenderSubpassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\"},{\"oldContent\":\"            .then(() => {\\n                console.log(\\n                    `JF: CommandDynamicRenderPassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\",\"newContent\":\"            .then(() => {\\n                // eslint-disable-next-line max-len\\n                console.log(`JF: CommandDynamicRenderPassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\"},{\"oldContent\":\"                for (const expandedNode of expandedNodes) {\\n                    await this.ensureLazyChildrenLoaded(expandedNode);\\n                    console.log(\\n                        `JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, children count: ${expandedNode.children.length}, children ids: ${expandedNode.children.map(c => c.id).join(', ')}`\\n                    );\\n                    nextLevelNodes.push(...expandedNode.children);\\n                }\",\"newContent\":\"                for (const expandedNode of expandedNodes) {\\n                    await this.ensureLazyChildrenLoaded(expandedNode);\\n                    const childIds = expandedNode.children.map(c => c.id).join(', ');\\n                    // eslint-disable-next-line max-len\\n                    console.log(`JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, children count: ${expandedNode.children.length}, children ids: ${childIds}`);\\n                    nextLevelNodes.push(...expandedNode.children);\\n                }\"},{\"oldContent\":\"                // Also process children of nodes that were already expanded\\n                for (const currentNode of currentLevelNodes) {\\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\\n                        await this.ensureLazyChildrenLoaded(currentNode);\\n                        console.log(\\n                            `JF: doExpandSubTree - after ensureLazyChildrenLoaded (already expanded) for ${currentNode.id}, children count: ${currentNode.children.length}, children ids: ${currentNode.children.map(c => c.id).join(', ')}`\\n                        );\\n                        nextLevelNodes.push(...currentNode.children);\\n                    }\\n                }\",\"newContent\":\"                // Also process children of nodes that were already expanded\\n                for (const currentNode of currentLevelNodes) {\\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\\n                        await this.ensureLazyChildrenLoaded(currentNode);\\n                        const childIds = currentNode.children.map(c => c.id).join(', ');\\n                        // eslint-disable-next-line max-len\\n                        console.log(`JF: doExpandSubTree - after ensureLazyChildrenLoaded (already expanded) for ${currentNode.id}, children count: ${currentNode.children.length}, children ids: ${childIds}`);\\n                        nextLevelNodes.push(...currentNode.children);\\n                    }\\n                }\"},{\"oldContent\":\"            console.log(\\n                `JF: createLazyLoadingNode - load completed for parent ${parent.id}, children count before removeChild: ${parent.children.length}`\\n            );\",\"newContent\":\"            // eslint-disable-next-line max-len\\n            console.log(`JF: createLazyLoadingNode - load completed for parent ${parent.id}, children count before removeChild: ${parent.children.length}`);\"}]}",
              "finished": true,
              "result": "Errors encountered: Content to replace not found: \"            .then(() => {\n                conso...nt: ${node.children.length}`\n                );\"; Content to replace not found: \"            .then(() => {\n                conso...nt: ${node.children.length}`\n                );\"; Content to replace not found: \"            .then(() => {\n                conso...nt: ${node.children.length}`\n                );\"; Content to replace not found: \"                for (const expandedNode of expa...sh(...expandedNode.children);\n                }\"; Content to replace not found: \"                // Also process children of nod...ldren);\n                    }\n                }\"; Content to replace not found: \"            console.log(\n                `JF: c...hild: ${parent.children.length}`\n            );\""
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "The file state seems to have changed. Let me re-read specific sections around those line numbers:"
            },
            "fallbackMessage": "The file state seems to have changed. Let me re-read specific sections around those line numbers:"
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01A6A5NUyLsRy5NbHYDGqcVG",
              "name": "searchInWorkspace",
              "arguments": "{\"query\": \"JF: doExpandSubTree - after ensureLazyChildrenLoaded for\", \"useRegExp\": false, \"fileExtensions\": [\"ts\"]}",
              "finished": true,
              "result": "[{\"file\":\"app/packages/capture/src/browser/command-tree/command-tree-model.ts\",\"matches\":[{\"line\":3692,\"text\":\"`JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, children count: ${expandedNode.children.length}, children ids: ${expandedNode.children.map(c => c.id).join(', ')}`\"}]}]"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01SNnexu6A5K6CTPWJdnUVGU",
              "name": "searchInWorkspace",
              "arguments": "{\"query\": \"JF: createLazyLoadingNode - load completed\", \"useRegExp\": false, \"fileExtensions\": [\"ts\"]}",
              "finished": true,
              "result": "[{\"file\":\"app/packages/capture/src/browser/command-tree/command-tree-model.ts\",\"matches\":[{\"line\":3926,\"text\":\"`JF: createLazyLoadingNode - load completed for parent ${parent.id}, children count before removeChild: ${parent.children.length}`\"}]}]"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "Let me look at the exact content around those lines directly:"
            },
            "fallbackMessage": "Let me look at the exact content around those lines directly:"
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01RyyAXQZWmUyVuTNCQtwbFN",
              "name": "searchInWorkspace",
              "arguments": "{\"query\": \"for \\\\(const expandedNode of expandedNodes\\\\)\", \"useRegExp\": true, \"fileExtensions\": [\"ts\"], \"subDirectoryPath\": \"app/packages/capture\"}",
              "finished": true,
              "result": "[{\"file\":\"app/packages/capture/src/browser/command-tree/command-tree-model.ts\",\"matches\":[{\"line\":3689,\"text\":\"for (const expandedNode of expandedNodes) {\"}]}]"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "The file may have an issue with exact content matching. Let me use `writeFileContent` to replace the entire file with corrected content. First, let me get the file content again and show the lines around line 3689:"
            },
            "fallbackMessage": "The file may have an issue with exact content matching. Let me use `writeFileContent` to replace the entire file with corrected content. First, let me get the file content again and show the lines around line 3689:"
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01EFRSiYjEdn1RGNL4pdFbQL",
              "name": "runTask",
              "arguments": "{\"taskName\": \"lint:fix - app\"}",
              "finished": true,
              "result": "                                                                                                                                                                   \nTerminal will be reused by tasks.                                                                                                                                  \n                                                                                                                                                                   \nnpm error Lifecycle script `lint` failed with error:                                                                                                               \nnpm error code 1                                                                                                                                                   \nnpm error path /home/johannes/Git/sokatoa/app/packages/capture                                                                                                     \nnpm error workspace @sokatoa/capture@0.0.9                                                                                                                         \nnpm error location /home/johannes/Git/sokatoa/app/packages/capture                                                                                                 \nnpm error command failed                                                                                                                                           \nnpm error command sh -c eslint -c ./eslint.config.mjs --max-warnings=0 --ext .ts,.tsx ./src                                                                        \n> Executing task: npm run lint:fix <                                                                                                                               \n                                                                                                                                                                   \n                                                                                                                                                                   \n> project-sokatoa-monorepo@1.0.0 lint:fix                                                                                                                          \n> yarn lint --fix                                                                                                                                                  \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   \n                                                                                                                                                                   "
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "The lint:fix task seems to be running. Let me wait for it to complete and then check the diagnostics:"
            },
            "fallbackMessage": "The lint:fix task seems to be running. Let me wait for it to complete and then check the diagnostics:"
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01DFuTHzZFu1VyZyn67XC9AR",
              "name": "getFileDiagnostics",
              "arguments": "{\"file\": \"app/packages/capture/src/browser/command-tree/command-tree-model.ts\"}",
              "finished": true,
              "result": "[{\"text\":\"                console.log(\\n                    `JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\",\"message\":\"This line has a length of 146. Maximum allowed is 140.\",\"code\":\"max-len\"},{\"text\":\"                console.log(\\n                    `JF: CommandRenderSubpassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\",\"message\":\"This line has a length of 146. Maximum allowed is 140.\",\"code\":\"max-len\"},{\"text\":\"                console.log(\\n                    `JF: CommandDynamicRenderPassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\",\"message\":\"This line has a length of 150. Maximum allowed is 140.\",\"code\":\"max-len\"},{\"text\":\"                    console.log(\\n                        `JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, children count: ${expandedNode.children.length}, children ids: ${expandedNode.children.map(c => c.id).join(', ')}`\\n                    );\",\"message\":\"This line has a length of 216. Maximum allowed is 140.\",\"code\":\"max-len\"},{\"text\":\"                        console.log(\\n                            `JF: doExpandSubTree - after ensureLazyChildrenLoaded (already expanded) for ${currentNode.id}, children count: ${currentNode.children.length}, children ids: ${currentNode.children.map(c => c.id).join(', ')}`\\n                        );\",\"message\":\"This line has a length of 236. Maximum allowed is 140.\",\"code\":\"max-len\"},{\"text\":\"            console.log(\\n                `JF: createLazyLoadingNode - load completed for parent ${parent.id}, children count before removeChild: ${parent.children.length}`\\n            );\",\"message\":\"This line has a length of 146. Maximum allowed is 140.\",\"code\":\"max-len\"}]"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "I see the file still has the format that's breaking on the line length. The issue is the formatter seems to have formatted the strings but they're still too long. Let me re-read and fix the sections more carefully:"
            },
            "fallbackMessage": "I see the file still has the format that's breaking on the line length. The issue is the formatter seems to have formatted the strings but they're still too long. Let me re-read and fix the sections more carefully:"
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01LgFgxouM6sFSqciZ7XeWG4",
              "name": "getFileContent",
              "arguments": "{\"file\": \"app/packages/capture/src/browser/command-tree/command-tree-model.ts\"}",
              "finished": true,
              "result": "/********************************************************************************\n    Copyright 2024-2026 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\nimport { GFXRQueryBuilderService } from '@sokatoa/gfxr-consumer/lib/';\nimport {\n    DynamicStateEntry,\n    PipelineBindPoint,\n    PipelineBindPointShaderStageFlags,\n    StateType\n} from '@sokatoa/gfxr-consumer/lib/browser/gfxr-data-service';\nimport { PartialRecord } from '@sokatoa/platform/lib';\nimport { BulkTree, BulkTreeModel, ResourceTreeNode, SokatoaLifecycleTreeNode } from '@sokatoa/platform/lib/browser';\nimport { GroupByOptions, MiscPreferences, MiscPrefs } from '@sokatoa/platform/lib/browser/misc-preferences';\nimport { TreeStructureChangeEmitter } from '@sokatoa/platform/lib/browser/tree-table/tree-table-widget';\nimport { ImageAccessorService } from '@sokatoa/platform/lib/common';\nimport { CompressedFileService, usesCompressionExtension } from '@sokatoa/platform/lib/common/compressed-file-service';\nimport { asError } from '@sokatoa/platform/lib/common/error-utils';\nimport { ApiResources, DescriptorResource, DrawApiResult } from '@sokatoa/platform/lib/common/gfxr-apis';\nimport { CancellationToken, Disposable, Emitter, Event, Path, URI } from '@theia/core';\nimport {\n    CompositeTreeNode,\n    DepthFirstTreeIterator,\n    ExpandableTreeNode,\n    SelectableTreeNode,\n    TreeModelImpl,\n    TreeNode\n} from '@theia/core/lib/browser';\nimport { RGBA } from '@theia/core/lib/common/color';\nimport { inject, injectable, postConstruct } from '@theia/core/shared/inversify';\nimport { PNG } from 'pngjs/browser';\nimport { lookupResourceFormat, UncompressedResourceFormat } from '../../common/format-handler';\nimport { extractData } from '../../common/geometry-utils';\nimport { GfxrScreenshotService, requestThumbnails, ScreenshotType, ThumbnailRequestOptions } from '../../common/gfxr-screenshot-service';\nimport { convertDataToImageData } from '../../common/host-side-conversion/vulkan-image';\nimport { FrameRangeSelectionService } from '../capture-widget/frame-range-selection-service';\nimport { placeholderScale } from '../graphics-pipeline-widget/graphics-pipeline-screenshot-requests';\nimport {\n    CaptureDatasetWidgetContext,\n    CaptureDatasetWidgetProfile,\n    CaptureDatasetWidgetReplayContext\n} from '../profile-ui/capture-dataset-widget-types';\nimport { CommandTreePreferenceState } from './command-tree-model-preferences';\nimport {\n    CommandTreeAccelerationStructureBuildInstance,\n    CommandTreeAccelerationStructureCopyInstance,\n    CommandTreeApiEvent,\n    CommandTreeCommandBufferInstance,\n    CommandTreeDataWithFunctionAndDebugNames,\n    CommandTreeDebugLabelGroupInstance,\n    CommandTreeDynamicRenderPassInstance,\n    CommandTreeFrame,\n    CommandTreeQueueDebugLabelGroup,\n    CommandTreeQueueDebugLabelInsert,\n    CommandTreeQueuePresent,\n    CommandTreeQueueSubmit,\n    CommandTreeRenderPassInstance,\n    CommandTreeRenderSubpassInstance,\n    CommandTreeSecondaryCommandBufferInstance,\n    CommandTreeTransferCommandInstance,\n    overrideDynamicState,\n    queryClusterInstanceDynamicState,\n    queryClusterInstanceDynamicStateBatched,\n    queryDispatchInstanceDynamicState,\n    queryDispatchInstanceDynamicStateBatched,\n    queryDrawInstanceDynamicState,\n    queryDrawInstanceDynamicStateBatched,\n    queryMeshTaskInstanceDynamicState,\n    queryMeshTaskInstanceDynamicStateBatched,\n    queryRaytracingInstanceDynamicState,\n    queryRaytracingInstanceDynamicStateBatched,\n    querySecondaryCommandBufferEndDynamicState,\n    QueryTreeDataOptions\n} from './command-tree-service';\nimport { LazyLoadableNode, triggerLazyLoadAndWaitForRemoval } from './lazy-load-utils';\nimport { CommandTreeDataQueriedRootProvider } from './providers/command-tree-root-provider';\n\n// Extension names\nconst VK_NV_COMMAND_BUFFER_INHERITANCE = 'VK_NV_command_buffer_inheritance';\nconst VK_NV_INHERITED_VIEWPORT_SCISSOR = 'VK_NV_inherited_viewport_scissor';\n\n/**\n * Helper type to make TreeNode.parent writable during node construction.\n * TreeNode.parent is readonly, but during tree construction we need to update it.\n */\ninterface MutableParent {\n    parent: CompositeTreeNode | undefined;\n}\n\n/**\n * Check if VK_NV_command_buffer_inheritance extension is enabled for a device.\n * This extension enables full state inheritance between command buffers and leak-back.\n */\nfunction hasCommandBufferInheritance(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_COMMAND_BUFFER_INHERITANCE) ?? false;\n}\n\n/**\n * Check if VK_NV_inherited_viewport_scissor extension is enabled for a device.\n * This extension enables limited viewport/scissor inheritance for secondary command buffers.\n */\nfunction hasInheritedViewportScissor(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_INHERITED_VIEWPORT_SCISSOR) ?? false;\n}\n\n/**\n * Filter dynamic state to only viewport and scissor entries.\n * Used for VK_NV_inherited_viewport_scissor extension.\n */\nasync function filterDynamicStateForViewportScissor(statePromise: Promise<DynamicStateEntry[]>): Promise<DynamicStateEntry[]> {\n    const state = await statePromise;\n    return state.filter(entry => entry.stateType === StateType.VIEWPORT || entry.stateType === StateType.SCISSOR);\n}\n\n/**\n * Tracks dynamic state that may be updated as secondary command buffers execute\n * (when VK_NV_command_buffer_inheritance is enabled).\n */\nclass DynamicStateTracker {\n    private currentStatePromise: Promise<DynamicStateEntry[]>;\n\n    constructor(initialState: Promise<DynamicStateEntry[]>) {\n        this.currentStatePromise = initialState;\n    }\n\n    getCurrentState(): Promise<DynamicStateEntry[]> {\n        return this.currentStatePromise;\n    }\n\n    updateState(newState: Promise<DynamicStateEntry[]>): void {\n        this.currentStatePromise = newState;\n    }\n}\n\n/** Internal context for a command tree model.\n *\n * contains all the fixed data needed for the model,\n * e.g. services, etc.\n */\ninterface CommandTreeContext {\n    dbId: number;\n    data: CommandTreeDataWithFunctionAndDebugNames;\n    screenshotService: GfxrScreenshotService;\n    fileService: CompressedFileService;\n    profile: CaptureDatasetWidgetProfile;\n    context: CaptureDatasetWidgetContext;\n    tree: CommandTree;\n    gfxrQueryBuilderService: GFXRQueryBuilderService;\n    imageAccessorService: ImageAccessorService;\n    createDrawOrDispatchChildren: boolean;\n    rootNode: CommandRootNode;\n    deviceExtensions: Map<number, Set<string>>;\n}\n\n/**\n * Helper function to look up the debug name for an object at a specific API event.\n * Finds the most recent debug name that was set at or before the target API event.\n * @param debugNameLookup - Map of objectHandle to array of {apiEvent, name} sorted by apiEvent\n * @param objectHandle - The object handle to look up\n * @param targetApiEvent - The API event at which we want to know the object's name\n * @returns The debug name if found, undefined otherwise\n */\nfunction getDebugNameAtApiEvent(\n    debugNameLookup: Map<number, Array<{ apiEvent: number; name: string }>>,\n    objectHandle: number | null | undefined,\n    targetApiEvent: number\n): string | undefined {\n    if (typeof objectHandle !== 'number') {\n        return undefined;\n    }\n\n    const entries = debugNameLookup.get(objectHandle);\n    if (!entries || entries.length === 0) {\n        return undefined;\n    }\n\n    // Binary search for the most recent name at or before targetApiEvent\n    let left = 0;\n    let right = entries.length - 1;\n    let result: string | undefined = undefined;\n\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (entries[mid].apiEvent <= targetApiEvent) {\n            result = entries[mid].name;\n            left = mid + 1; // Look for a more recent name\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n\nexport interface CommandRootNode extends ResourceTreeNode<CommandTreeDataWithFunctionAndDebugNames>, CompositeTreeNode, ExpandableTreeNode {\n    resourceType: typeof CommandRootNode.RESOURCE_TYPE;\n    children: CommandFrameNode[];\n    dbId: number;\n    profile: CaptureDatasetWidgetProfile;\n    tree?: CommandTree; // Back-reference to the tree that owns this root\n    // Cached maps for queue debug labels to avoid rebuilding for each frame\n    queueDebugLabelGroupsBySubmitId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelGroupsByPresentId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelInsertsByApiEvent: Map<number, CommandTreeQueueDebugLabelInsert>;\n}\n\nexport namespace CommandRootNode {\n    export const ID = 'sokatoa-command-tree-widget';\n\n    export const RESOURCE_TYPE = '__root__';\n\n    export function is(node: TreeNode | undefined): node is CommandRootNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRootNode.RESOURCE_TYPE);\n    }\n\n    export function create(\n        dbId: number,\n        data: CommandTreeDataWithFunctionAndDebugNames,\n        screenshotService: GfxrScreenshotService,\n        profile: CaptureDatasetWidgetProfile,\n        context: CaptureDatasetWidgetContext,\n        tree: CommandTree,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        imageAccessorService: ImageAccessorService,\n        fileService: CompressedFileService,\n        createDrawOrDispatchChildren: boolean,\n        deviceExtensions: Map<number, Set<string>>\n    ): CommandRootNode {\n        // Build maps for queue debug labels once for all frames\n        const queueDebugLabelGroupsBySubmitId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelGroupsByPresentId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelInsertsByApiEvent = new Map<number, CommandTreeQueueDebugLabelInsert>();\n\n        for (const group of Object.values(data.queueDebugLabelGroups)) {\n            if (group) {\n                for (const submitId of group.queueSubmitIds) {\n                    queueDebugLabelGroupsBySubmitId.set(submitId, group);\n                }\n                for (const presentId of group.queuePresentIds) {\n                    queueDebugLabelGroupsByPresentId.set(presentId, group);\n                }\n            }\n        }\n\n        for (const insert of Object.values(data.queueDebugLabelInserts)) {\n            if (insert) {\n                queueDebugLabelInsertsByApiEvent.set(insert.apiEvent, insert);\n            }\n        }\n\n        const rootNode: CommandRootNode = {\n            visible: false,\n            id: CommandRootNode.ID,\n            name: 'ProfileTree',\n            parent: undefined,\n            expanded: true,\n            children: [],\n            resourceType: CommandRootNode.RESOURCE_TYPE,\n            resource: data,\n            dbId,\n            profile,\n            queueDebugLabelGroupsBySubmitId,\n            queueDebugLabelGroupsByPresentId,\n            queueDebugLabelInsertsByApiEvent\n        };\n        const ctx: CommandTreeContext = {\n            dbId,\n            data,\n            screenshotService,\n            fileService,\n            profile,\n            context,\n            tree,\n            gfxrQueryBuilderService,\n            imageAccessorService,\n            createDrawOrDispatchChildren,\n            rootNode,\n            deviceExtensions\n        };\n        const modelBuildStart = Date.now();\n        const frames = Object.values(data.frames);\n        rootNode.children = frames.flatMap(child => (child ? CommandFrameNode.create(ctx, child, rootNode) : []));\n        console.debug(`Model loaded in ${Date.now() - modelBuildStart} ms`);\n        return rootNode;\n    }\n}\n\nexport interface DebugMarker {\n    name: string;\n    color?: RGBA;\n}\n\nexport interface WithDebugMarker {\n    debugMarker?: DebugMarker;\n}\n\nexport namespace WithDebugMarker {\n    /** Type guard for a `node` that is or has a debug marker. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugMarker> {\n        return 'debugMarker' in node && node.debugMarker !== undefined;\n    }\n}\n\nexport interface WithDebugName {\n    debugName?: string;\n}\n\nexport namespace WithDebugName {\n    /** Type guard for a `node` that has a debug name. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugName> {\n        return 'debugName' in node && node.debugName !== undefined;\n    }\n}\n\ninterface LabelData {\n    labelName: string | undefined | null;\n    colorR: number | undefined | null;\n    colorG: number | undefined | null;\n    colorB: number | undefined | null;\n    colorA: number | undefined | null;\n}\n\nfunction setDebugMarkerData(node: WithDebugMarker, labelData: LabelData): void {\n    const name = labelData.labelName ?? 'Debug marker';\n    const color = {\n        r: (labelData.colorR ?? 1) * 255,\n        g: (labelData.colorG ?? 1) * 255,\n        b: (labelData.colorB ?? 1) * 255,\n        a: (labelData.colorA ?? 1) * 255\n    };\n\n    node.debugMarker = { name };\n    if (color.a !== 0 || color.b !== 0 || color.g !== 0 || color.r !== 0) {\n        node.debugMarker.color = color;\n    }\n}\n\nexport interface CommandFrameNode extends ResourceTreeNode<CommandTreeFrame>, ExpandableTreeNode, SelectableTreeNode {\n    label: string;\n    frameIndex: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandFrameNode.RESOURCE_TYPE;\n    thumbnail?: string;\n}\n\nexport namespace CommandFrameNode {\n    export const RESOURCE_TYPE = 'frame';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandFrameNode {\n        return ResourceTreeNode.hasResourceType(node, CommandFrameNode.RESOURCE_TYPE);\n    }\n\n    export function getId(frame: CommandTreeFrame): string {\n        return frame.frameIndex.toString();\n    }\n\n    export function create(ctx: CommandTreeContext, element: CommandTreeFrame, parent: CompositeTreeNode): CommandFrameNode {\n        const node: CommandFrameNode & SokatoaLifecycleTreeNode = {\n            id: getId(element),\n            frameIndex: element.frameIndex,\n            label: `Frame ${element.frameIndex}`,\n            children: [],\n            expanded: false,\n            selected: false,\n            parent,\n            resourceType: CommandFrameNode.RESOURCE_TYPE,\n            resource: element\n        };\n\n        const root = ctx.rootNode;\n\n        const children: CommandTreeNode[] = [];\n        let queueSubmitIndex = 0;\n        let queuePresentIndex = 0;\n        let accelerationStructureBuildIndex = 0;\n        let accelerationStructureCopyIndex = 0;\n\n        // Track current active debug label group and its children\n        let activeDebugLabelGroup: CommandTreeQueueDebugLabelGroup | undefined;\n        let activeGroupChildren: (CommandQueueSubmitNode | CommandQueuePresentNode)[] = [];\n        let queueDebugLabelGroupInstanceIndex = 0;\n\n        // Helper to finalize the active group and add it to children\n        const finalizeActiveGroup = (): void => {\n            if (activeDebugLabelGroup && activeGroupChildren.length > 0) {\n                children.push(\n                    CommandQueueDebugLabelGroupNode.create(\n                        ctx,\n                        activeDebugLabelGroup,\n                        node,\n                        activeGroupChildren,\n                        queueDebugLabelGroupInstanceIndex++\n                    )\n                );\n                activeDebugLabelGroup = undefined;\n                activeGroupChildren = [];\n            }\n        };\n\n        for (let id = element.beginApiEvent; id <= (element.endApiEvent ?? element.beginApiEvent); id++) {\n            // Check for queue debug label insert at this apiEvent\n            const queueDebugLabelInsert = root.queueDebugLabelInsertsByApiEvent.get(id);\n            if (queueDebugLabelInsert) {\n                // Inserts can appear in the middle of groups, so finalize any active group first\n                finalizeActiveGroup();\n                children.push(CommandQueueDebugLabelNode.create(ctx, queueDebugLabelInsert, node));\n            }\n\n            const apiEvent = root.resource.apiEvents[id];\n            if (apiEvent) {\n                if (apiEvent.submissionId && element.queueSubmitIds.includes(apiEvent.submissionId)) {\n                    const queueSubmit = root.resource.queueSubmits[apiEvent.submissionId];\n                    if (queueSubmit) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsBySubmitId.get(apiEvent.submissionId);\n\n                        // Check if this submit is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queueSubmit not found for submissionId ${apiEvent.submissionId}`);\n                    }\n                } else if (apiEvent.presentId && element.queuePresentIds.includes(apiEvent.presentId)) {\n                    const queuePresent = root.resource.queuePresents[apiEvent.presentId];\n                    if (queuePresent) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsByPresentId.get(apiEvent.presentId);\n\n                        // Check if this present is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queuePresent not found for presentId ${apiEvent.presentId}`);\n                    }\n                } else if (\n                    apiEvent.accelerationStructureBuildInstanceId &&\n                    element.accelerationStructureBuildIds.includes(apiEvent.accelerationStructureBuildInstanceId)\n                ) {\n                    // Acceleration structure builds interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureBuild =\n                        root.resource.topLevelAccelerationStructureBuilds[apiEvent.accelerationStructureBuildInstanceId];\n                    if (accelerationStructureBuild) {\n                        children.push(\n                            CommandAccelerationStructureBuildNode.create(\n                                accelerationStructureBuild,\n                                node,\n                                accelerationStructureBuildIndex++\n                            )\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureBuildInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureBuild not found for accelerationStructureBuildInstanceId ${iId}`\n                        );\n                    }\n                } else if (\n                    apiEvent.accelerationStructureCopyInstanceId &&\n                    element.accelerationStructureCopyIds.includes(apiEvent.accelerationStructureCopyInstanceId)\n                ) {\n                    // Acceleration structure copies interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureCopy =\n                        root.resource.topLevelAccelerationStructureCopies[apiEvent.accelerationStructureCopyInstanceId];\n                    if (accelerationStructureCopy) {\n                        children.push(\n                            CommandAccelerationStructureCopyNode.create(accelerationStructureCopy, node, accelerationStructureCopyIndex++)\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureCopyInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureCopy not found for accelerationStructureCopyInstanceId ${iId}`\n                        );\n                    }\n                }\n            }\n        }\n\n        // Finalize any remaining active debug label group at the end\n        finalizeActiveGroup();\n\n        node.children = children;\n\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        const request: ThumbnailRequestOptions = {\n            profileOrReplay: replay ?? ctx.profile,\n            startFrame: element.frameIndex,\n            endFrame: element.frameIndex,\n            requesterDbgName: `Command tree frame ${element.frameIndex}`,\n            onScreenshotReady: result => {\n                ctx.imageAccessorService\n                    .accessImage(new URL(URI.fromFilePath(result.path).toString()))\n                    .then(url => {\n                        node.thumbnail = url.url.toString();\n                        ctx.tree.addToDispose(url);\n                        void ctx.tree.refresh(node);\n                    })\n                    .catch(reason => {\n                        const error = asError(reason);\n                        console.error(error);\n                    });\n            },\n            onRequestComplete: (success, message) => {\n                if (!success) {\n                    console.error(`Request for frame thumbnails failed: ${message}`);\n                }\n            }\n        };\n        const onWillRender = (): void => {\n            requestThumbnails(ctx.screenshotService, request);\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', onWillRender);\n        };\n        SokatoaLifecycleTreeNode.register(node, 'onWillRender', onWillRender);\n        return node;\n    }\n\n    /**\n     * Retrieve the `CommandFrameNode` that is or contains the given `node`.\n     * Returns `undefined` in the case that the `node` is an ancestor of or\n     * otherwise not contained in an `CommandFrameNode`.\n     */\n    export function getCommandFrameNodeContaining(node: TreeNode): CommandFrameNode | undefined {\n        return CommandFrameNode.is(node) ? node : node.parent ? CommandFrameNode.getCommandFrameNodeContaining(node.parent) : undefined;\n    }\n}\n\nexport interface CommandEmptyNode extends LazyLoadableNode {\n    label: string;\n}\n\nexport namespace CommandEmptyNode {\n    export const GENERALIZED_TYPE = 'empty';\n\n    export function is(node: unknown): node is CommandEmptyNode {\n        return TreeNode.is(node) && node.id.endsWith('_empty');\n    }\n\n    export function getId(parent: CompositeTreeNode): string {\n        return `${parent.id}_empty`;\n    }\n\n    export function create(parent: CompositeTreeNode, load: CommandEmptyNode['load']): CommandEmptyNode {\n        return {\n            id: getId(parent),\n            label: 'Loading...',\n            parent,\n            load\n        };\n    }\n}\n\nexport interface CommandApiEventNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandApiEventNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandApiEventNode {\n    export const RESOURCE_TYPE = 'api-event';\n    export const GENERALIZED_TYPE = RESOURCE_TYPE;\n\n    export function is(node: TreeNode | undefined): node is CommandApiEventNode {\n        return ResourceTreeNode.hasResourceType(node, CommandApiEventNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEventId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex?: number\n    ): CommandApiEventNode {\n        const root = ctx.rootNode;\n        const node: CommandApiEventNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEventId,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex ?? ''}`,\n            parent,\n            resourceType: CommandApiEventNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId,\n            selected: false\n        };\n        // set debug marker data if node is a debug marker\n        if (element.debugLabelId) {\n            const labelData = root.resource.debugLabels[element.debugLabelId];\n            if (labelData) {\n                setDebugMarkerData(node, labelData);\n            }\n        }\n        return node;\n    }\n}\n\nexport interface CommandDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeDebugLabelGroupInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'debug-label-group';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDebugLabelGroupInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDebugLabelGroupInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDebugLabelGroupNode = {\n            id: getId(element, parent),\n            debugLabelInstanceId: element.labelId,\n            label: `${root.resource.functionNameLookup[element.functionNameId ?? -1] ?? '<not defined>'}`,\n            parent,\n            resourceType: CommandDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this debug label range\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this debug label group, add it to array\n            // - not self\n            // - only commands with same command buffer id\n            if (event && event.debugLabelId !== element.labelId && event.commandBufferInstanceId === element.commandBufferInstance) {\n                apiEventCommandArray.push(event);\n            }\n        }\n        // get array of debug label ranges with api event numbers within this debug label range\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this debug label range\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderPassInstance'\n        );\n        // get array of render subpass ranges with api event numbers within this debug label range\n        const renderSubpassInstances = createRangeInstanceArray(\n            element.renderSubpassInstanceIds,\n            root.resource.renderSubpassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderSubpassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this debug label range\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('subpassIndex' in rangeElement) {\n                    const renderSubpassInstanceNode = CommandRenderSubpassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderSubpassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            renderSubpassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                console.log(\n                    `JF: CommandDebugLabelGroupNode ${node.id} - async children creation completed, children count: ${node.children.length}`\n                );\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for debug label group:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `debug label group ${element.labelId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelGroup>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'queue-debug-label-group';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelGroup, parent: CompositeTreeNode, instanceIndex: number): string {\n        return `${parent.id}_qdl_group_${element.labelId}_${instanceIndex}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelGroup,\n        parent: CompositeTreeNode,\n        children: (CommandQueueSubmitNode | CommandQueuePresentNode)[],\n        instanceIndex: number\n    ): CommandQueueDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelGroupNode = {\n            id: getId(element, parent, instanceIndex),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label Group',\n            queue: element.queue!,\n            parent,\n            resourceType: CommandQueueDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        // Update parent references for children since they were created with a different parent\n        // and are now being reparented to this debug label group node\n        for (const child of children) {\n            // Cast away readonly to update parent during node construction\n            (child as MutableParent).parent = node;\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelInsert>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    apiEventId: number;\n    resourceType: typeof CommandQueueDebugLabelNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelNode {\n    export const RESOURCE_TYPE = 'queue-debug-label';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelInsert, parent: CompositeTreeNode): string {\n        return `${parent.id}_qdl_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelInsert,\n        parent: CompositeTreeNode\n    ): CommandQueueDebugLabelNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelNode = {\n            id: getId(element, parent),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label',\n            queue: element.queue!,\n            apiEventId: element.apiEvent,\n            parent,\n            resourceType: CommandQueueDebugLabelNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandCommandBufferInstanceNode\n    extends ResourceTreeNode<CommandTreeCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    commandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandCommandBufferInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandCommandBufferInstanceNode {\n    export const RESOURCE_TYPE = 'command-buffer-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandCommandBufferInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandCommandBufferInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeCommandBufferInstance,\n        parent: CompositeTreeNode,\n        commandBufferIndex: number,\n        baseDynamicStatePromise?: Promise<DynamicStateEntry[]>\n    ): CommandCommandBufferInstanceNode {\n        const node: CommandCommandBufferInstanceNode = {\n            id: getId(element, parent),\n            commandBufferInstanceId: element.instanceId,\n            label: `Command Buffer ${commandBufferIndex}`,\n            parent,\n            resourceType: CommandCommandBufferInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this command buffer\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this command buffer, add it to array\n            // - omit commands that reference render pass id\n            // - if api event is a debug label, check the debug label itself for a render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                event.commandBufferInstanceId === element.instanceId &&\n                event.renderPassInstanceId === undefined &&\n                event.dynamicRenderPassInstanceId === undefined &&\n                (event.debugLabelId === undefined ||\n                    (debugLabel?.beginApiEvent === event.apiEventId &&\n                        debugLabel?.beginRenderPassInstance === undefined &&\n                        debugLabel?.beginDynamicRenderPassInstance === undefined) ||\n                    (debugLabel?.endApiEvent === event.apiEventId &&\n                        debugLabel?.endRenderPassInstance === undefined &&\n                        debugLabel?.endDynamicRenderPassInstance === undefined))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this command buffer\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this command buffer\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'RenderPassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this command buffer\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        const emptyDynamicStatePromise = new Promise<DynamicStateEntry[]>(resolve => resolve([]));\n        const effectiveBaseState = baseDynamicStatePromise ?? emptyDynamicStatePromise;\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            effectiveBaseState,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        effectiveBaseState\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                console.log(\n                    `JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\n                );\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for command buffer:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `command buffer ${commandBufferIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandSecondaryCommandBufferExecutionNode\n    extends ResourceTreeNode<CommandTreeSecondaryCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    parentCommandBufferInstanceId: number;\n    secondaryCommandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n}\n\nexport namespace CommandSecondaryCommandBufferExecutionNode {\n    export const RESOURCE_TYPE = 'secondary-command-buffer-execution';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: unknown): node is CommandSecondaryCommandBufferExecutionNode {\n        return (\n            ExpandableTreeNode.is(node) && SelectableTreeNode.is(node) && ResourceTreeNode.is(node, 'secondary-command-buffer-execution')\n        );\n    }\n\n    export function getId(element: CommandTreeSecondaryCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_secondary_${element.secondaryCommandBufferInstance}_${element.executionId}_${element.executionIndex}`;\n    }\n\n    export async function create(\n        ctx: CommandTreeContext,\n        elements: CommandTreeSecondaryCommandBufferInstance[],\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n        stateTracker?: DynamicStateTracker\n    ): Promise<CommandSecondaryCommandBufferExecutionNode> {\n        if (elements.length === 0) {\n            throw new Error('elements array must not be empty');\n        }\n        // Use the first element for the node's resource (they all share the same executionId and apiEvent)\n        const element = elements[0];\n        const node: CommandSecondaryCommandBufferExecutionNode = {\n            id: getId(element, parent),\n            parentCommandBufferInstanceId: element.parentCommandBufferInstance || 0,\n            secondaryCommandBufferInstanceId: element.secondaryCommandBufferInstance || 0,\n            label: `Secondary Command Buffer Execution ${commandIndex}`,\n            parent,\n            resourceType: 'secondary-command-buffer-execution',\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        createLazyLoadingNode(ctx.tree, node, async () => {\n            // Sort elements by executionIndex to maintain proper order\n            const sortedElements = [...elements].sort((a, b) => (a.executionIndex || 0) - (b.executionIndex || 0));\n\n            // Get device and check extensions\n            const firstSecondary = sortedElements[0]?.secondaryCommandBufferInstance;\n            let deviceExtensions: Set<string> | undefined;\n\n            if (firstSecondary !== undefined) {\n                const commandBufferInstance = root.resource.commandBufferInstances[firstSecondary];\n                const device = commandBufferInstance?.device;\n                if (typeof device === 'number') {\n                    deviceExtensions = ctx.deviceExtensions.get(device);\n                }\n            }\n\n            const hasInheritance = hasCommandBufferInheritance(deviceExtensions);\n            const hasViewportScissorOnly = hasInheritedViewportScissor(deviceExtensions) && !hasInheritance;\n\n            // Calculate effective base state for INHERITANCE INTO secondary\n            let effectiveBaseState: Promise<DynamicStateEntry[]>;\n            if (hasInheritance) {\n                effectiveBaseState = baseDynamicStatePromise;\n            } else if (hasViewportScissorOnly) {\n                effectiveBaseState = filterDynamicStateForViewportScissor(baseDynamicStatePromise);\n            } else {\n                effectiveBaseState = Promise.resolve([]);\n            }\n\n            // Create a CommandCommandBufferInstanceNode for each secondary command buffer in the execution\n            const childNodes: CommandCommandBufferInstanceNode[] = [];\n            sortedElements.forEach((secondaryInstance, index) => {\n                if (secondaryInstance.secondaryCommandBufferInstance) {\n                    const commandBufferInstance = root.resource.commandBufferInstances[secondaryInstance.secondaryCommandBufferInstance];\n                    if (commandBufferInstance) {\n                        const childNode = CommandCommandBufferInstanceNode.create(\n                            ctx,\n                            commandBufferInstance,\n                            node,\n                            index,\n                            effectiveBaseState\n                        );\n                        childNodes.push(childNode);\n                    } else {\n                        console.warn(\n                            `Command buffer instance ${secondaryInstance.secondaryCommandBufferInstance} ` +\n                                'not found in root.resource.commandBufferInstances'\n                        );\n                    }\n                }\n            });\n            CompositeTreeNode.addChildren(node, childNodes);\n\n            // Handle LEAK-BACK: Update parent's state tracker if extension is enabled\n            if (hasInheritance && stateTracker && element.executionId) {\n                const db = ctx.gfxrQueryBuilderService.builderFor(ctx.dbId);\n                const endStatePromise = querySecondaryCommandBufferEndDynamicState(db, [element.executionId]);\n                stateTracker.updateState(endStatePromise);\n            }\n        });\n\n        // Register for thumbnail updates\n        registerThumbnailUpdate(ctx, node, `secondary command buffer execution ${node.resource.executionId}`);\n        return node;\n    }\n}\n\nexport interface CommandQueueSubmitNode\n    extends ResourceTreeNode<CommandTreeQueueSubmit>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    submissionId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueSubmitNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueSubmitNode {\n    export const RESOURCE_TYPE = 'queue-submit';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueSubmitNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueSubmitNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueSubmit, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.submissionId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueSubmit,\n        parent: CompositeTreeNode,\n        queueSubmitIndex: number\n    ): CommandQueueSubmitNode {\n        const root = ctx.rootNode;\n        const node: CommandQueueSubmitNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            threadId: element.threadId || 0,\n            submissionId: element.submissionId,\n            label: `Queue Submit ${queueSubmitIndex}`,\n            queue: element.queue,\n            parent,\n            resourceType: CommandQueueSubmitNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        const children =\n            element.queueSubmitBuffers\n                ?.filter(b => b.commandBufferInstance)\n                .flatMap(b => {\n                    const instance = root.resource.commandBufferInstances[b.commandBufferInstance!];\n                    if (!instance) {\n                        console.warn(`CommandQueueSubmitNode.create: commandBufferInstance not found for id ${b.commandBufferInstance}`);\n                        return [];\n                    }\n                    return instance;\n                }) ?? [];\n        let commandBufferIndex = 0;\n        node.children = children.map(child => CommandCommandBufferInstanceNode.create(ctx, child, node, commandBufferIndex++));\n\n        registerThumbnailUpdate(ctx, node, `queue submit ${queueSubmitIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueuePresentNode extends ResourceTreeNode<CommandTreeQueuePresent>, SelectableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    resourceType: typeof CommandQueuePresentNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueuePresentNode {\n    export const RESOURCE_TYPE = 'queue-present';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueuePresentNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueuePresentNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueuePresent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEvent}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueuePresent,\n        parent: CompositeTreeNode,\n        queuePresentIndex: number\n    ): CommandQueuePresentNode {\n        const root = ctx.rootNode;\n        const node: CommandQueuePresentNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            label: `Queue Present ${queuePresentIndex}`,\n            parent,\n            resourceType: CommandQueuePresentNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            queue: element.queue,\n            selected: false\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureBuildNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureBuildInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    buildInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureBuildNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureBuildNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-build';\n    export const GENERALIZED_TYPE = 'acceleration-structure-build';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureBuildNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureBuildNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureBuildInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.buildApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureBuildInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureBuildNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureBuildNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            buildInstanceId: element.instanceId,\n            apiEventId: element.buildApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureBuildNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureCopyNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureCopyInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    copyInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureCopyNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureCopyNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-copy';\n    export const GENERALIZED_TYPE = 'acceleration-structure-copy';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureCopyNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureCopyNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureCopyInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.copyApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureCopyInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureCopyNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureCopyNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            copyInstanceId: element.instanceId,\n            apiEventId: element.copyApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureCopyNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandTransferCommandNode\n    extends ResourceTreeNode<CommandTreeTransferCommandInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    transferCommandInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandTransferCommandNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandTransferCommandNode {\n    export const RESOURCE_TYPE = 'transfer-command';\n    export const GENERALIZED_TYPE = 'transfer-command';\n\n    export function is(node: TreeNode | undefined): node is CommandTransferCommandNode {\n        return ResourceTreeNode.hasResourceType(node, CommandTransferCommandNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeTransferCommandInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.transferApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeTransferCommandInstance,\n        parent: CompositeTreeNode,\n        transferCommandIndex: number\n    ): CommandTransferCommandNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandTransferCommandNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            transferCommandInstanceId: element.instanceId,\n            apiEventId: element.transferApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${transferCommandIndex}`,\n            parent,\n            resourceType: CommandTransferCommandNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nfunction setThumbnailUrl(\n    ctx: CommandTreeContext,\n    resources: ApiResources[],\n    node: TreeNode & { thumbnail?: string },\n    requesterDbgName: string\n): void {\n    if (resources.length > 0) {\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        ctx.screenshotService.requestScreenshots({\n            profileOrReplay: replay ?? ctx.profile,\n            scale: placeholderScale,\n            screenshotType: ScreenshotType.API_EVENT,\n            requestData: resources,\n            moreRequests: true,\n            requesterDbgName,\n            options: {\n                DumpDepth: true\n            },\n            onScreenshotReady: result => {\n                if (result.resultData.resultType === ScreenshotType.API_EVENT && DrawApiResult.is(result.resultData.apiResult)) {\n                    const images = [...(result.resultData.apiResult.colorAttachments || [])];\n                    if (result.resultData.apiResult.depthAttachment) {\n                        images.push(result.resultData.apiResult.depthAttachment);\n                    }\n                    if (images.length > 0) {\n                        const possibleImage = images[0].subresources?.[0];\n                        if (possibleImage) {\n                            if (usesCompressionExtension(possibleImage.file)) {\n                                // Use VkImageConversionService to get a png\n                                // Do the same as the else case, but with the new png file\n                                const format = lookupResourceFormat(images[0].format);\n                                if (UncompressedResourceFormat.is(format)) {\n                                    ctx.fileService\n                                        .read(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString(), {\n                                            uncompressedSize: possibleImage.size\n                                        })\n                                        .then(async content => {\n                                            const extractedData = await extractData(format, content);\n                                            const dim = {\n                                                width: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[0]\n                                                    : possibleImage.dimensions[0] * placeholderScale,\n                                                height: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[1]\n                                                    : possibleImage.dimensions[1] * placeholderScale\n                                            };\n                                            const conversionResult = await convertDataToImageData(extractedData, format, dim, {\n                                                channelOptions: { alpha: { disabled: true } }\n                                            });\n                                            const png = new PNG({\n                                                width: conversionResult.dimensions.width,\n                                                height: conversionResult.dimensions.height\n                                            });\n                                            png.data = conversionResult.data;\n                                            const pngBuffer = PNG.sync.write(png);\n                                            node.thumbnail = `data:image/png;base64, ${pngBuffer.toString('base64')}`;\n                                            void ctx.tree.refresh(node.parent);\n                                        })\n                                        .catch(reason => {\n                                            const error = asError(reason);\n                                            console.error(error);\n                                        });\n                                }\n                            } else {\n                                ctx.imageAccessorService\n                                    .accessImage(new URL(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString()))\n                                    .then(url => {\n                                        node.thumbnail = url.url.toString();\n                                        ctx.tree.addToDispose(url);\n                                        void ctx.tree.refresh(node.parent);\n                                    })\n                                    .catch(reason => {\n                                        const error = asError(reason);\n                                        console.error(error);\n                                    });\n                            }\n                        }\n                    }\n                }\n            },\n            onRequestComplete: (result, message) => {\n                if (!result) {\n                    console.error(message);\n                }\n            }\n        });\n    }\n}\n\n/**\n * Registers a thumbnail update callback that triggers on the node's first render.\n * When triggered, finds the last draw instance and requests a screenshot for it.\n *\n * @param ctx - Command tree context\n * @param node - Node to register thumbnail update for\n * @param descriptionContext - Description for the requester debug name (e.g., \"render pass 5\", \"dynamic render pass\")\n */\nfunction registerThumbnailUpdate(\n    ctx: CommandTreeContext,\n    node: CommandTreeNode & { thumbnail?: string },\n    descriptionContext: string\n): void {\n    const updateThumbnail = (): void => {\n        const lastDraw = findLastDrawInstanceNode(node);\n        if (lastDraw) {\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', updateThumbnail);\n            const requesterDbgName = `Command tree ${descriptionContext} last draw: ${lastDraw.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(lastDraw), node, requesterDbgName);\n        }\n    };\n    SokatoaLifecycleTreeNode.register(node, 'onWillRender', updateThumbnail);\n}\n\nexport interface CommandRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    renderPassInstanceId: number;\n    renderPassId?: number;\n    renderSubpassEventIds: number[];\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderPassInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.instanceId,\n            renderPassId: element.renderPass,\n            renderSubpassEventIds: [],\n            label: `Render Pass ${element.passIndex}`,\n            parent,\n            resourceType: CommandRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        // A render pass will only contain render subpasses and will always contain at least one subpass\n        const renderSubpassInstances = element.renderSubpassInstanceIds.flatMap(id => {\n            const instance = root.resource.renderSubpassInstances[id];\n            if (!instance) {\n                console.warn(`CommandRenderPassInstanceNode.create: renderSubpassInstance not found for id ${id}`);\n                return [];\n            }\n            return instance;\n        });\n        renderSubpassInstances.forEach(subpass => {\n            if (subpass.beginApiEvent !== node.resource.beginApiEvent) {\n                node.renderSubpassEventIds.push(subpass.beginApiEvent);\n            }\n        });\n        node.children.push(\n            ...renderSubpassInstances.map(instance => {\n                const subpassNode = CommandRenderSubpassInstanceNode.create(ctx, instance, node, baseDynamicStatePromise);\n                return subpassNode;\n            })\n        );\n\n        registerThumbnailUpdate(ctx, node, `render pass ${node.renderPassId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandRenderSubpassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderSubpassInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    renderPassInstanceId: number;\n    renderSubpassInstanceId: number;\n    renderSubpassIndex: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderSubpassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderSubpassInstanceNode {\n    export const RESOURCE_TYPE = 'render-subpass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderSubpassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderSubpassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderSubpassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderSubpassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderSubpassInstanceNode {\n        const node: CommandRenderSubpassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.renderPassInstance,\n            renderSubpassInstanceId: element.instanceId,\n            renderSubpassIndex: element.subpassIndex,\n            label: `Subpass ${element.subpassIndex}`,\n            parent,\n            resourceType: CommandRenderSubpassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this render subpass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference render subpass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a render subpass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.renderSubpassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginRenderSubpassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endRenderSubpassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this render subpass\n        const debugLabelGroupInstances = {\n            array: element.debugLabelGroupInstanceIds.flatMap(id => {\n                const result = root.resource.debugLabelGroupInstances[id];\n                if (!result) {\n                    console.warn(`Missing debugLabelGroupInstances for ${id}.`);\n                    return [];\n                }\n                return result;\n            }),\n            getSortNumber: (debugLabelGroupInstance: CommandTreeDebugLabelGroupInstance) => debugLabelGroupInstance.beginApiEvent\n        };\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                console.log(\n                    `JF: CommandRenderSubpassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\n                );\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'render subpass');\n\n        return node;\n    }\n}\n\nexport interface CommandDynamicRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeDynamicRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    dynamicRenderPassInstanceId: number;\n    dynamicRenderPassId?: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDynamicRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'dynamic-render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDynamicRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDynamicRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDynamicRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDynamicRenderPassInstanceNode {\n        const node: CommandDynamicRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dynamicRenderPassInstanceId: element.instanceId,\n            label: `Dynamic Render Pass ${element.dynamicPassIndex}`,\n            parent,\n            resourceType: CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this dynamic render pass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this dynamic render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference dynamic render pass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a dynamic render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.dynamicRenderPassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginDynamicRenderPassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endDynamicRenderPassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this dynamic render pass\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDynamicRenderPassInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                console.log(\n                    `JF: CommandDynamicRenderPassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\n                );\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'dynamic render pass');\n\n        return node;\n    }\n}\n\nasync function createChildEventNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    stateTracker: DynamicStateTracker\n): Promise<number> {\n    let endCommandIndex = commandIndex;\n    const baseDynamicStatePromise = stateTracker.getCurrentState();\n\n    if (command.secondaryCommandBufferExecutionId) {\n        // Look up the execution to get the apiEvent, which is the key for secondaryCommandBufferInstances\n        const execution = root.resource.secondaryCommandBufferExecutions[command.secondaryCommandBufferExecutionId];\n        if (execution) {\n            const secondaryInstances = root.resource.secondaryCommandBufferInstances[execution.apiEvent];\n            if (secondaryInstances && secondaryInstances.length > 0) {\n                const node = await CommandSecondaryCommandBufferExecutionNode.create(\n                    ctx,\n                    secondaryInstances,\n                    parentNode,\n                    endCommandIndex++,\n                    baseDynamicStatePromise,\n                    stateTracker\n                );\n                parentNode.children.push(node);\n            }\n        }\n    } else {\n        endCommandIndex = createDrawOrDispatchChildNode(ctx, command, root, parentNode, commandIndex, baseDynamicStatePromise);\n    }\n    return endCommandIndex;\n}\n\nfunction createDrawOrDispatchChildNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n): number {\n    let currentCommandIndex = commandIndex;\n    let accelerationStructureBuildIndex = 0;\n    let accelerationStructureCopyIndex = 0;\n    if (command) {\n        if (command.drawInstanceId && root.resource.drawInstances[command.drawInstanceId]) {\n            parentNode.children.push(\n                CommandDrawInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.dispatchInstanceId && root.resource.dispatchInstances[command.dispatchInstanceId]) {\n            parentNode.children.push(\n                CommandDispatchInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.meshTaskInstanceId && root.resource.meshTaskInstances[command.meshTaskInstanceId]) {\n            parentNode.children.push(\n                CommandMeshTaskInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.clusterInstanceId && root.resource.clusterInstances[command.clusterInstanceId]) {\n            parentNode.children.push(\n                CommandClusterInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.raytracingInstanceId && root.resource.raytracingInstances[command.raytracingInstanceId]) {\n            parentNode.children.push(\n                CommandRaytracingInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (\n            command.accelerationStructureBuildInstanceId &&\n            root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureBuildNode.create(\n                    root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]!,\n                    parentNode,\n                    accelerationStructureBuildIndex++\n                )\n            );\n        } else if (\n            command.accelerationStructureCopyInstanceId &&\n            root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureCopyNode.create(\n                    root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]!,\n                    parentNode,\n                    accelerationStructureCopyIndex++\n                )\n            );\n        } else if (command.transferCommandInstanceId && root.resource.transferCommands[command.transferCommandInstanceId]) {\n            parentNode.children.push(\n                CommandTransferCommandNode.create(\n                    root.resource.transferCommands[command.transferCommandInstanceId]!,\n                    parentNode,\n                    currentCommandIndex++\n                )\n            );\n        } else if (command.debugLabelId && root.resource.debugLabels[command.debugLabelId]) {\n            // Only add debug label nodes if this is the BEGIN event (not END event)\n            // The END event has debugLabelId set but should not create a node\n            const debugLabel = root.resource.debugLabels[command.debugLabelId];\n            if (debugLabel && debugLabel.beginApiEvent === command.apiEventId) {\n                // Check if this is a group (has both begin and end and they differ) or just an insert\n                if (debugLabel.endApiEvent && debugLabel.beginApiEvent !== debugLabel.endApiEvent) {\n                    // This is a debug label group - it should be handled by the range processing logic\n                    // Don't create any node here, just skip it\n                    // (The group will be created if it's in debugLabelGroupInstances, or omitted if it crosses boundaries)\n                } else {\n                    // This is a debug label insert - create as simple API event node\n                    parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode));\n                }\n            }\n        } else if (command.commandInstanceId && root.resource.commandInstances[command.commandInstanceId]) {\n            parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode, currentCommandIndex++));\n        }\n    }\n    return currentCommandIndex;\n}\n\nexport interface CommandDrawInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    drawInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDrawInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandDrawInstanceNode {\n    export const RESOURCE_TYPE = 'draw-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDrawInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDrawInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_draw_${element.drawInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDrawInstanceNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDrawInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            drawInstanceId: element.drawInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDrawInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query draw instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n            const requesterDbgName = `Command draw instance ${node.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(node), node, requesterDbgName);\n        });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDrawInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const drawInstanceDynamicStatePromise = batchQuery\n                ? queryDrawInstanceDynamicStateBatched(db, [node.resource.drawInstanceId || 0])\n                : queryDrawInstanceDynamicState(db, [node.resource.drawInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                drawInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.GRAPHICS\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandDispatchInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    dispatchInstanceId: number;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandDispatchInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n    thumbnail?: string;\n}\n\nexport namespace CommandDispatchInstanceNode {\n    export const RESOURCE_TYPE = 'dispatch-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDispatchInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDispatchInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_dispatch_${element.dispatchInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDispatchInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandDispatchInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dispatchInstanceId: element.dispatchInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDispatchInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query dispatch instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for dispatch nodes\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command dispatch instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDispatchInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const dispatchInstanceDynamicStatePromise = batchQuery\n                ? queryDispatchInstanceDynamicStateBatched(db, [node.resource.dispatchInstanceId || 0])\n                : queryDispatchInstanceDynamicState(db, [node.resource.dispatchInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                dispatchInstanceDynamicStatePromise,\n                PipelineBindPoint.COMPUTE,\n                PipelineBindPointShaderStageFlags.COMPUTE\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandMeshTaskInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    meshTaskInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandMeshTaskInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandMeshTaskInstanceNode {\n    export const RESOURCE_TYPE = 'mesh-task-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandMeshTaskInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandMeshTaskInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_meshtask_${element.meshTaskInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandMeshTaskInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandMeshTaskInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            meshTaskInstanceId: element.meshTaskInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandMeshTaskInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query mesh instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for mesh task dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command mesh instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandMeshTaskInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const meshTaskInstanceDynamicStatePromise = batchQuery\n                ? queryMeshTaskInstanceDynamicStateBatched(db, [node.resource.meshTaskInstanceId || 0])\n                : queryMeshTaskInstanceDynamicState(db, [node.resource.meshTaskInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                meshTaskInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.TASK_MESH\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandClusterInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    clusterInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandClusterInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandClusterInstanceNode {\n    export const RESOURCE_TYPE = 'cluster-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandClusterInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandClusterInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_cluster_${element.clusterInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandClusterInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandClusterInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            clusterInstanceId: element.clusterInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandClusterInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query cluster instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for cluster dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command cluster instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandClusterInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const clusterInstanceDynamicStatePromise = batchQuery\n                ? queryClusterInstanceDynamicStateBatched(db, [node.resource.clusterInstanceId || 0])\n                : queryClusterInstanceDynamicState(db, [node.resource.clusterInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                clusterInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.CLUSTER\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandRaytracingInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    raytracingInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandRaytracingInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandRaytracingInstanceNode {\n    export const RESOURCE_TYPE = 'raytracing-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandRaytracingInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRaytracingInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_raytracing_${element.raytracingInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRaytracingInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRaytracingInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            raytracingInstanceId: element.raytracingInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandRaytracingInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query raytracing instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for raytracing dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command raytracing instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandRaytracingInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const raytracingInstanceDynamicStatePromise = batchQuery\n                ? queryRaytracingInstanceDynamicStateBatched(db, [node.resource.raytracingInstanceId || 0])\n                : queryRaytracingInstanceDynamicState(db, [node.resource.raytracingInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                raytracingInstanceDynamicStatePromise,\n                PipelineBindPoint.RAY_TRACING,\n                PipelineBindPointShaderStageFlags.RAY_TRACING\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport function getQueueSubmitId(node: CommandTreeNode): number | undefined {\n    let currentNode: CompositeTreeNode | undefined;\n    if (\n        CommandEmptyNode.is(node) ||\n        CommandApiEventNode.is(node) ||\n        CommandTreeDrawOrDispatchNode.is(node) ||\n        CommandAccelerationStructureBuildNode.is(node) ||\n        CommandAccelerationStructureCopyNode.is(node) ||\n        CommandTransferCommandNode.is(node)\n    ) {\n        currentNode = node.parent;\n    } else if (CommandQueuePresentNode.is(node) || CommandQueueDebugLabelNode.is(node)) {\n        return undefined;\n    } else {\n        currentNode = node;\n    }\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(currentNode, CommandQueueSubmitNode.is);\n    return queueSubmitNode ? queueSubmitNode.resource.submissionId : undefined;\n}\n\nexport function findLastDrawInstanceNode(node: CommandTreeNode): CommandDrawInstanceNode | undefined {\n    if (CommandDrawInstanceNode.is(node)) {\n        return node;\n    }\n    let lastDraw: CommandDrawInstanceNode | undefined;\n    if (!CommandDrawInstanceNode.is(node) && ExpandableTreeNode.is(node)) {\n        for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n            lastDraw = findLastDrawInstanceNode(node.children[commandIndex]);\n            if (lastDraw) {\n                break;\n            }\n        }\n    }\n    return lastDraw;\n}\n\nexport function createExecuteCommandsApiResources(\n    node: CommandSecondaryCommandBufferExecutionNode,\n    primaryNode: CommandCommandBufferInstanceNode,\n    queueSubmitNode: CommandQueueSubmitNode,\n    specificSecondaryCommandBufferBeginId?: number // If provided, only include this specific secondary CB\n): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    // findParentNode checks the given node for its type so we have to start looking from this node's parent\n    // otherwise we run into infinite recursion\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node.parent,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n\n    // Collect secondary command buffer begin IDs from the children\n    const commandBufferBeginIds: number[] = [];\n    if (specificSecondaryCommandBufferBeginId !== undefined) {\n        // Only include the specific secondary CB that was requested\n        commandBufferBeginIds.push(specificSecondaryCommandBufferBeginId);\n    } else {\n        // Include all secondary CBs (for when the execution node itself requests a thumbnail)\n        for (const child of node.children) {\n            if (CommandCommandBufferInstanceNode.is(child)) {\n                commandBufferBeginIds.push(child.resource.beginApiEvent);\n            }\n        }\n    }\n\n    const resources: ApiResources[] = [];\n    if (secondaryCommandBufferExecutionNode) {\n        const renderpassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n            renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n            CommandSecondaryCommandBufferExecutionNode.is\n        );\n\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: secondaryCommandBufferExecutionNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n                renderpassSecondaryCommandBufferExecutionNode &&\n                renderpassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n        const executionResources = createExecuteCommandsApiResources(secondaryCommandBufferExecutionNode, primaryNode, queueSubmitNode);\n        if (executionResources.length > 0) {\n            resources.push(...executionResources);\n        }\n    } else {\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: primaryNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                renderPassInstanceNode || dynamicRenderPassInstanceNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n    }\n    return resources;\n}\n\nexport function createDrawApiResources(node: CommandDrawInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    // This will find the immediate parent command buffer (secondary if in a secondary CB, primary otherwise)\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n\n    const resources: ApiResources[] = [];\n    if (\n        (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n        queueSubmitNode &&\n        commandBufferInstanceNode &&\n        primaryCommandBufferInstanceNode\n    ) {\n        if (secondaryCommandBufferExecutionNode) {\n            const renderPassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n                CommandSecondaryCommandBufferExecutionNode.is\n            );\n\n            // Add draw resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses:\n                    renderPassSecondaryCommandBufferExecutionNode &&\n                    renderPassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                        ? [\n                              {\n                                  beginId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                                  subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                                  endId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                        dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                              }\n                          ]\n                        : []\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses: [\n                    {\n                        beginId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                        subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                        endId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.endApiEvent || dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                    }\n                ]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createComputeApiResources(node: CommandDispatchInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add dispatch resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createTraceRaysApiResources(node: CommandRaytracingInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTransferNode = CommandAccelerationStructureBuildNode | CommandAccelerationStructureCopyNode | CommandTransferCommandNode;\n\nexport function createTransferApiResources(node: CommandTransferNode): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    let transferEvent: number = 0;\n    if (CommandAccelerationStructureBuildNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureBuildNode).resource.buildApiEvent;\n    } else if (CommandAccelerationStructureCopyNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureCopyNode).resource.copyApiEvent;\n    } else if (CommandTransferCommandNode.is(node)) {\n        transferEvent = (node as CommandTransferCommandNode).resource.transferApiEvent;\n    }\n\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTreeNode =\n    | CommandFrameNode\n    | CommandEmptyNode\n    | CommandApiEventNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandQueuePresentNode\n    | CommandQueueDebugLabelGroupNode\n    | CommandQueueDebugLabelNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandEmptyNode.is(node) ||\n            CommandApiEventNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandQueuePresentNode.is(node) ||\n            CommandQueueDebugLabelGroupNode.is(node) ||\n            CommandQueueDebugLabelNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n\n    export function findApiEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandSecondaryCommandBufferExecutionNode.is(current)) {\n            // For secondary command buffer execution nodes, return the VkCmdExecuteCommands apiEvent\n            // rather than the VkCommandBufferBegin apiEvent\n            return current.resource.apiEvent;\n        } else if (CommandTreeRangeNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (\n            CommandApiEventNode.is(current) ||\n            CommandQueueSubmitNode.is(current) ||\n            CommandQueuePresentNode.is(current) ||\n            CommandQueueDebugLabelNode.is(current)\n        ) {\n            return current.apiEventId;\n        } else if (CommandQueueDebugLabelGroupNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (CommandAccelerationStructureBuildNode.is(current)) {\n            return current.resource.buildApiEvent;\n        } else if (CommandAccelerationStructureCopyNode.is(current)) {\n            return current.resource.copyApiEvent;\n        } else if (CommandTransferCommandNode.is(current)) {\n            return current.apiEventId;\n        } else if (CommandTreeDrawOrDispatchNode.is(current)) {\n            return current.resource.apiEventId;\n        }\n        return undefined;\n    }\n\n    export function findFilterEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandFrameNode.is(current)) {\n            return current.resource.beginApiEvent;\n        }\n        let maybeQueueSubmitOrPresent: TreeNode | undefined = current;\n        while (\n            maybeQueueSubmitOrPresent !== undefined &&\n            !(\n                CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueuePresentNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)\n            )\n        ) {\n            maybeQueueSubmitOrPresent = maybeQueueSubmitOrPresent.parent;\n        }\n        let queueSubmitEventId: number | undefined;\n        if (maybeQueueSubmitOrPresent !== undefined) {\n            if (CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) || CommandQueuePresentNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            } else if (CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.resource.beginApiEvent;\n            } else if (CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            }\n        }\n        return queueSubmitEventId;\n    }\n\n    export function findRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const renderPassNode = findParentNode<CommandRenderPassInstanceNode>(current, CommandRenderPassInstanceNode.is);\n        return renderPassNode ? renderPassNode.renderPassInstanceId : undefined;\n    }\n\n    export function findDynamicRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const dynamicRenderPassNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n            current,\n            CommandDynamicRenderPassInstanceNode.is\n        );\n        return dynamicRenderPassNode ? dynamicRenderPassNode.dynamicRenderPassInstanceId : undefined;\n    }\n\n    export function findDrawInstanceId(current?: CommandTreeNode): number | undefined {\n        const drawInstanceNode = findParentNode<CommandDrawInstanceNode>(current, CommandDrawInstanceNode.is);\n        return drawInstanceNode ? drawInstanceNode.drawInstanceId : undefined;\n    }\n\n    export function findDispatchInstanceId(current?: CommandTreeNode): number | undefined {\n        const dispatchInstanceNode = findParentNode<CommandDispatchInstanceNode>(current, CommandDispatchInstanceNode.is);\n        return dispatchInstanceNode ? dispatchInstanceNode.dispatchInstanceId : undefined;\n    }\n\n    export function findMeshTaskInstanceId(current?: CommandTreeNode): number | undefined {\n        const meshTaskInstanceNode = findParentNode<CommandMeshTaskInstanceNode>(current, CommandMeshTaskInstanceNode.is);\n        return meshTaskInstanceNode ? meshTaskInstanceNode.meshTaskInstanceId : undefined;\n    }\n\n    export function findClusterInstanceId(current?: CommandTreeNode): number | undefined {\n        const clusterInstanceNode = findParentNode<CommandClusterInstanceNode>(current, CommandClusterInstanceNode.is);\n        return clusterInstanceNode ? clusterInstanceNode.clusterInstanceId : undefined;\n    }\n\n    export function findRaytracingInstanceId(current?: CommandTreeNode): number | undefined {\n        const raytracingInstanceNode = findParentNode<CommandRaytracingInstanceNode>(current, CommandRaytracingInstanceNode.is);\n        return raytracingInstanceNode ? raytracingInstanceNode.raytracingInstanceId : undefined;\n    }\n\n    export function findAccelerationBuildInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelBuildNode = findParentNode<CommandAccelerationStructureBuildNode>(current, CommandAccelerationStructureBuildNode.is);\n        return accelBuildNode ? accelBuildNode.buildInstanceId : undefined;\n    }\n\n    export function findAccelerationCopyInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelCopyNode = findParentNode<CommandAccelerationStructureCopyNode>(current, CommandAccelerationStructureCopyNode.is);\n        return accelCopyNode ? accelCopyNode.copyInstanceId : undefined;\n    }\n\n    export function findTransferCommandInstanceId(current?: CommandTreeNode): number | undefined {\n        const transferCommandNode = findParentNode<CommandTransferCommandNode>(current, CommandTransferCommandNode.is);\n        return transferCommandNode ? transferCommandNode.transferCommandInstanceId : undefined;\n    }\n\n    export function findMergedDynamicStatePromise(\n        current: CommandTreeNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> | undefined {\n        let maybeDrawOrDispatchInstance: TreeNode | undefined = current;\n        while (maybeDrawOrDispatchInstance !== undefined && !CommandTreeDrawOrDispatchNode.is(maybeDrawOrDispatchInstance)) {\n            maybeDrawOrDispatchInstance = maybeDrawOrDispatchInstance.parent;\n        }\n        let mergedDynamicStatePromise: Promise<DynamicStateEntry[]> | undefined;\n        if (maybeDrawOrDispatchInstance !== undefined && CommandDrawInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDrawInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandDispatchInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDispatchInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandMeshTaskInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandMeshTaskInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandClusterInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandClusterInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandRaytracingInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandRaytracingInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        }\n        return mergedDynamicStatePromise;\n    }\n\n    export function getRoot(node?: CompositeTreeNode | CommandRootNode | CommandTreeNode): CommandRootNode | undefined {\n        return findParentNode<CommandRootNode>(node, CommandRootNode.is);\n    }\n\n    export function getDbId(node: CommandRootNode | CommandTreeNode): number {\n        return getRoot(node)?.dbId ?? -1;\n    }\n\n    type GeneralizableNodes =\n        | typeof CommandApiEventNode\n        | typeof CommandClusterInstanceNode\n        | typeof CommandCommandBufferInstanceNode\n        | typeof CommandDispatchInstanceNode\n        | typeof CommandDrawInstanceNode\n        | typeof CommandEmptyNode\n        | typeof CommandFrameNode\n        | typeof CommandMeshTaskInstanceNode\n        | typeof CommandQueuePresentNode\n        | typeof CommandQueueSubmitNode\n        | typeof CommandQueueDebugLabelGroupNode\n        | typeof CommandQueueDebugLabelNode\n        | typeof CommandAccelerationStructureBuildNode\n        | typeof CommandAccelerationStructureCopyNode\n        | typeof CommandTransferCommandNode\n        | typeof CommandRaytracingInstanceNode\n        | typeof CommandRenderPassInstanceNode\n        | typeof CommandRenderSubpassInstanceNode\n        | typeof CommandDynamicRenderPassInstanceNode\n        | typeof CommandDebugLabelGroupNode;\n\n    /**\n     * An aggregate type label for command-tree nodes, roughly corresponding to some of the union\n     * types defined in this module.\n     */\n    export type GeneralizedType = GeneralizableNodes['GENERALIZED_TYPE'];\n\n    /**\n     * Query the generalized type of a given node, if it is a Command Tree node.\n     *\n     * @param node a tree node that may or may not be a `CommandTreeNode`\n     * @return its generalized type, or `undefined` if it isn't a `CommandTreeNode`\n     */\n    export function getGeneralizedNodeType(node: TreeNode): GeneralizedType | undefined {\n        const resourceType = 'resourceType' in node ? node.resourceType : undefined;\n        if (!resourceType) {\n            return CommandEmptyNode.is(node) ? 'empty' : undefined;\n        }\n\n        switch (resourceType) {\n            case 'frame':\n            case 'command-buffer-instance':\n            case 'render-pass-instance':\n            case 'render-subpass-instance':\n            case 'secondary-command-buffer-execution':\n            case 'debug-label-group':\n                return 'range';\n            case 'queue-submit':\n            case 'queue-present':\n                return 'queue';\n            case 'acceleration-structure-build':\n                return 'acceleration-structure-build';\n            case 'acceleration-structure-copy':\n                return 'acceleration-structure-copy';\n            case 'transfer-command':\n                return 'transfer-command';\n            case 'draw-instance':\n            case 'dispatch-instance':\n            case 'mesh-task-instance':\n            case 'cluster-instance':\n            case 'raytracing-instance':\n                return 'draw-or-dispatch';\n            case 'api-event':\n                return 'api-event';\n            default:\n                return undefined;\n        }\n    }\n\n    /** Type assertion for a range-type node. */\n    export function generalize(node: TreeNode, type: 'range'): asserts node is CommandTreeRangeNode;\n    /** Type assertion for a queue-type node. */\n    export function generalize(node: TreeNode, type: 'queue'): asserts node is CommandQueueSubmitNode | CommandQueuePresentNode;\n    /** Type assertion for a queue-debug-label-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'queue-debug-label'\n    ): asserts node is CommandQueueDebugLabelGroupNode | CommandQueueDebugLabelNode;\n    /** Type assertion for a acceleration-structure-build-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-build'): asserts node is CommandAccelerationStructureBuildNode;\n    /** Type assertion for a acceleration-structure-copy-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-copy'): asserts node is CommandAccelerationStructureCopyNode;\n    /** Type assertion for a transfer-command-type node. */\n    export function generalize(node: TreeNode, type: 'transfer-command'): asserts node is CommandTransferCommandNode;\n    /** Type assertion for a draw-or-dispatch-type node. */\n    export function generalize(node: TreeNode, type: 'draw-or-dispatch'): asserts node is CommandTreeDrawOrDispatchNode;\n    /** Type assertion for an api-event-type node. */\n    export function generalize(node: TreeNode, type: 'api-event'): asserts node is CommandApiEventNode;\n    /** Type assertion for a draw-or-dispatch- or api-event-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'draw-or-dispatch' | 'api-event'\n    ): asserts node is CommandTreeDrawOrDispatchNode | CommandApiEventNode;\n    /** Type assertion for an empty-type node. */\n    export function generalize(node: TreeNode, type: 'empty'): asserts node is CommandEmptyNode;\n    export function generalize(node: TreeNode, _type: GeneralizedType): asserts node is CommandTreeNode {\n        // Pass\n    }\n}\n\nexport type CommandTreeRangeNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeRangeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeRangeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n}\n\nexport type CommandTreeDrawOrDispatchNode =\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode;\n\nexport namespace CommandTreeDrawOrDispatchNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeDrawOrDispatchNode {\n        return (\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node)\n        );\n    }\n}\n\ninterface ArrayWithSortNumber<RangeType> {\n    array: RangeType[];\n    getSortNumber(element: RangeType): number;\n}\n\ntype AllRangeTypes =\n    | CommandTreeDebugLabelGroupInstance\n    | CommandTreeRenderPassInstance\n    | CommandTreeRenderSubpassInstance\n    | CommandTreeDynamicRenderPassInstance;\n\ntype CommandTreeRangeParentNode =\n    | CommandRenderPassInstanceNode\n    | CommandCommandBufferInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandDebugLabelGroupNode;\n\nfunction findNextRangeElementToProcess<RangeType>(...arrays: ArrayWithSortNumber<RangeType>[]): RangeType | undefined {\n    // designate which array is the api event array vs a range array\n    // when processing a range, shift off any api events that are within the range\n    // so they aren't processed (because they actually reside within a sub-group)\n\n    const arraysToProcess: ArrayWithSortNumber<RangeType>[] = [];\n    arrays.forEach(arr => {\n        if (arr.array.length) {\n            arraysToProcess.push(arr);\n        }\n    });\n\n    if (!arraysToProcess.length) {\n        return undefined;\n    }\n\n    // get the sort number of the first element of each array and sort them\n    const sortedElements = arraysToProcess\n        .map(array => ({ subarray: array.array, sortNumber: array.getSortNumber(array.array[0]) }))\n        .sort((a, b) => a.sortNumber - b.sortNumber);\n\n    return sortedElements[0].subarray.shift();\n}\n\n/**\n * Process commands and ranges together in API event order.\n * For each range element, creates child nodes for commands that come before it,\n * skips commands that fall within the range, and creates a node for the range itself.\n * After processing all ranges, any remaining commands are processed.\n *\n * @param ctx - Command tree context\n * @param root - Root node\n * @param parentNode - Parent node to add children to\n * @param apiEventCommandArray - Array of commands sorted by API event ID (will be mutated)\n * @param childCommandIndex - Starting index for child commands\n * @param baseDynamicStatePromise - Promise for dynamic state\n * @param createRangeNode - Callback to create a node for each range element\n * @param rangeArrays - Variable number of range arrays to process together\n * @returns The final child command index\n */\nasync function createChildEventNodesForRange<RangeType extends { beginApiEvent: number; endApiEvent?: number }>(\n    ctx: CommandTreeContext,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    apiEventCommandArray: CommandTreeApiEvent[],\n    childCommandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n    createRangeNode: (rangeElement: RangeType, parentNode: CommandTreeRangeParentNode) => void,\n    ...rangeArrays: ArrayWithSortNumber<RangeType>[]\n): Promise<number> {\n    console.log(\n        `JF: createChildEventNodesForRange START for parent ${parentNode.id}, apiEventCommandArray length: ${apiEventCommandArray.length}`\n    );\n    const stateTracker = new DynamicStateTracker(baseDynamicStatePromise);\n    let nextRangeElement: RangeType | undefined;\n    let priorRangeEndApiEvent: number | undefined;\n\n    while ((nextRangeElement = findNextRangeElementToProcess<RangeType>(...rangeArrays))) {\n        // create a node for any command that comes BEFORE the next range element\n        while (apiEventCommandArray.length && apiEventCommandArray[0].apiEventId < nextRangeElement.beginApiEvent) {\n            const command = apiEventCommandArray.shift();\n            childCommandIndex = await createChildEventNode(ctx, command!, root, parentNode, childCommandIndex, stateTracker);\n        }\n\n        // shift off any command that falls WITHIN next range since it will be processed when creating next range node\n        while (\n            apiEventCommandArray.length &&\n            nextRangeElement.endApiEvent !== undefined &&\n            apiEventCommandArray[0].apiEventId >= nextRangeElement.beginApiEvent &&\n            apiEventCommandArray[0].apiEventId <= nextRangeElement.endApiEvent\n        ) {\n            apiEventCommandArray.shift();\n        }\n\n        // skip next range if it falls within the prior range since it will be processed when creating prior range node\n        if (\n            priorRangeEndApiEvent !== undefined &&\n            nextRangeElement.endApiEvent !== undefined &&\n            nextRangeElement.endApiEvent <= priorRangeEndApiEvent\n        ) {\n            continue;\n        }\n        priorRangeEndApiEvent = nextRangeElement.endApiEvent;\n\n        // create a node for the next range element\n        createRangeNode(nextRangeElement, parentNode);\n    }\n\n    // process any remaining command elements after all range elements have been processed\n    for (const command of apiEventCommandArray) {\n        childCommandIndex = await createChildEventNode(ctx, command, root, parentNode, childCommandIndex, stateTracker);\n    }\n\n    console.log(`JF: createChildEventNodesForRange END for parent ${parentNode.id}, final children count: ${parentNode.children.length}`);\n    return childCommandIndex;\n}\n\n/**\n * Find node from descendent node for which isNode is true\n */\nexport const findParentNode = <T extends TreeNode>(\n    node: TreeNode | undefined,\n    isNode: (node: TreeNode | undefined) => node is T\n): T | undefined => {\n    let targetNode: TreeNode | undefined = node;\n    while (targetNode && targetNode.parent && !isNode(targetNode)) {\n        targetNode = targetNode.parent;\n    }\n\n    return targetNode && isNode(targetNode) ? targetNode : undefined;\n};\n\n/**\n * Find the primary command buffer instance node from a given command buffer instance node.\n * If the given node is in a secondary command buffer, traverses up through nested secondary\n * command buffers until finding the primary command buffer (one with no parent execution node).\n * If the given node is already in a primary command buffer, returns it as-is.\n */\nexport const findPrimaryCommandBufferInstanceNode = (\n    commandBufferInstanceNode: CommandCommandBufferInstanceNode | undefined,\n    secondaryCommandBufferExecutionNode: CommandSecondaryCommandBufferExecutionNode | undefined\n): CommandCommandBufferInstanceNode | undefined => {\n    let primaryCommandBufferInstanceNode = commandBufferInstanceNode;\n    if (secondaryCommandBufferExecutionNode) {\n        let currentExecution: CommandSecondaryCommandBufferExecutionNode | undefined = secondaryCommandBufferExecutionNode;\n        while (currentExecution) {\n            const parentCB: CommandCommandBufferInstanceNode | undefined = findParentNode<CommandCommandBufferInstanceNode>(\n                currentExecution,\n                CommandCommandBufferInstanceNode.is\n            );\n            if (parentCB) {\n                primaryCommandBufferInstanceNode = parentCB;\n                // Check if this CB is also inside another secondary execution (nested case)\n                currentExecution = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                    parentCB.parent,\n                    CommandSecondaryCommandBufferExecutionNode.is\n                );\n            } else {\n                break;\n            }\n        }\n    }\n    return primaryCommandBufferInstanceNode;\n};\n\n/**\n * find a frame node from descendent node or self\n */\nexport const findFrameNode = (node: TreeNode): CommandFrameNode | undefined => findParentNode<CommandFrameNode>(node, CommandFrameNode.is);\n\n@injectable()\nexport class CommandTree extends BulkTree implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTree {\n        return tree instanceof CommandTree;\n    }\n\n    @inject(CaptureDatasetWidgetProfile)\n    protected readonly profile: CaptureDatasetWidgetProfile;\n    @inject(CaptureDatasetWidgetContext)\n    protected readonly context: CaptureDatasetWidgetContext;\n\n    @inject(CommandTreeDataQueriedRootProvider)\n    protected readonly rootProvider: CommandTreeDataQueriedRootProvider;\n    @inject(GFXRQueryBuilderService)\n    protected readonly gfxrQueryBuilderService: GFXRQueryBuilderService;\n\n    protected override _root: CommandRootNode | undefined;\n\n    // Back-reference to the model that manages this tree\n    model?: CommandTreeModel;\n\n    protected readonly onStructureChangedEmitter = new Emitter<TreeNode | undefined>();\n    readonly onStructureChanged = this.onStructureChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this._root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        super.root = root;\n        // Set back-reference from root to tree\n        if (root) {\n            root.tree = this;\n        }\n    }\n\n    async initTree(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        this.root = await this.rootProvider.provide(dbId, { tree: this }, options, createDrawOrDispatchChildren);\n\n        // tree structure is fully built at this point, report structure change\n        this.onStructureChangedEmitter.fire(undefined);\n    }\n\n    async refreshStructure(node?: CompositeTreeNode, cancellationToken?: CancellationToken): Promise<void> {\n        await this.refresh(node, cancellationToken);\n        this.fireStructureChanged(node);\n    }\n\n    fireStructureChanged(node?: TreeNode): void {\n        this.onStructureChangedEmitter.fire(node);\n    }\n\n    addToDispose(disposable: Disposable): void {\n        this.toDispose.push(disposable);\n    }\n\n    override dispose(): void {\n        this.rootProvider.dispose();\n        super.dispose();\n    }\n}\n\n@injectable()\nexport class CommandTreeModelPreferenceStateAccessImpl implements CommandTreePreferenceState.Access {\n    private readonly models = new Map<CommandTree, CommandTreeModel>();\n\n    private readonly commandTreeStateChangedEmitter = new Emitter<{ tree: CommandTree; state: CommandTreePreferenceState }>();\n    readonly onCommandTreeStateChanged = this.commandTreeStateChangedEmitter.event;\n\n    getCommandTreeState(tree: CommandTree): CommandTreePreferenceState {\n        return this.models.get(tree)?.getPreferenceState() ?? {};\n    }\n\n    fireCommandTreeStateChanged(tree: CommandTree): void {\n        this.commandTreeStateChangedEmitter.fire({ tree, state: this.getCommandTreeState(tree) });\n    }\n\n    registerCommandTreeModel(tree: CommandTree, model: CommandTreeModel): void {\n        this.models.set(tree, model);\n        this.fireCommandTreeStateChanged(tree);\n    }\n}\n\n@injectable()\nexport class CommandTreeModel extends BulkTreeModel implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTreeModel {\n        return tree instanceof CommandTreeModel;\n    }\n\n    @inject(MiscPreferences)\n    protected readonly miscPreferences: MiscPreferences;\n    @inject(CommandTree) override readonly tree: CommandTree;\n    protected _groupBy: GroupByOptions = GroupByOptions.Frame;\n    private groupByChangedEmitter = new Emitter<GroupByOptions>();\n    readonly onGroupByChanged = this.groupByChangedEmitter.event;\n    protected _isThumbnailEnabled = true;\n    protected _isApiEventIdsEnabled = true;\n    protected _isShowingEmptyRows = false;\n    protected _isVulkanEnabled = true;\n    protected _isDebugNamesEnabled = true;\n    protected _isDebugLabelsEnabled = true;\n    protected _isLinksEnabled = true;\n    protected _isThreadsEnabled = true;\n\n    @inject(FrameRangeSelectionService)\n    protected readonly frameRangeSelectionService: FrameRangeSelectionService;\n\n    @inject(CommandTreeModelPreferenceStateAccessImpl)\n    private readonly preferenceStateAccess: CommandTreeModelPreferenceStateAccessImpl;\n\n    protected isCollapsingSubTree = false;\n\n    // Proxies to prevent calls on sub tree expansion\n    protected readonly onExpansionChangedEmitterProxy = new Emitter<ExpandableTreeNode>();\n    protected readonly onChangedEmitterProxy = new Emitter<void>();\n\n    protected readonly onSubTreeExpansionChangedEmitter = new Emitter<ExpandableTreeNode>();\n    readonly onSubTreeExpansionChanged = this.onSubTreeExpansionChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this.tree.root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        this.tree.root = root;\n    }\n\n    override get onChanged(): Event<void> {\n        return this.onChangedEmitterProxy.event;\n    }\n\n    override get onExpansionChanged(): Event<ExpandableTreeNode> {\n        return this.onExpansionChangedEmitterProxy.event;\n    }\n\n    get onStructureChanged(): Event<TreeNode | undefined> {\n        return this.tree.onStructureChanged;\n    }\n\n    async initModel(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        await this.tree.initTree(dbId, createDrawOrDispatchChildren, options);\n    }\n\n    set groupBy(value: GroupByOptions) {\n        if (this._groupBy !== value) {\n            this._groupBy = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n            this.groupByChangedEmitter.fire(value);\n        }\n    }\n\n    get groupBy(): GroupByOptions {\n        return this._groupBy;\n    }\n\n    /**\n     * Obtain the tree nodes that are the top-level groups according to\n     * the current {@link groupBy} mode.\n     */\n    *groupNodes(): IterableIterator<CompositeTreeNode> {\n        if (!this.root) {\n            return;\n        }\n\n        const group = this.groupBy;\n        const treeIterator = new (class extends DepthFirstTreeIterator {\n            protected override children(node: TreeNode): TreeNode[] | undefined {\n                // Prune group nodes because we needn't look in them for more groups\n                return CommandTreeModel.isOfGroup(node, group) ? undefined : super.children(node);\n            }\n        })(this.root);\n\n        for (const next of treeIterator) {\n            if (CommandTreeModel.isOfGroup(next, group)) {\n                yield next;\n            }\n        }\n    }\n\n    set isApiEventIdsEnabled(value: boolean) {\n        if (this._isApiEventIdsEnabled !== value) {\n            this._isApiEventIdsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isApiEventIdsEnabled(): boolean {\n        return this._isApiEventIdsEnabled;\n    }\n\n    set isShowingEmptyRows(value: boolean) {\n        if (this._isShowingEmptyRows !== value) {\n            this._isShowingEmptyRows = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isShowingEmptyRows(): boolean {\n        return this._isShowingEmptyRows;\n    }\n\n    set isThumbnailEnabled(value: boolean) {\n        if (this._isThumbnailEnabled !== value) {\n            this._isThumbnailEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThumbnailEnabled(): boolean {\n        return this._isThumbnailEnabled;\n    }\n\n    set isVulkanEnabled(value: boolean) {\n        if (this._isVulkanEnabled !== value) {\n            this._isVulkanEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isVulkanEnabled(): boolean {\n        return this._isVulkanEnabled;\n    }\n\n    set isDebugNamesEnabled(value: boolean) {\n        if (this._isDebugNamesEnabled !== value) {\n            this._isDebugNamesEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugNamesEnabled(): boolean {\n        return this._isDebugNamesEnabled;\n    }\n\n    set isDebugLabelsEnabled(value: boolean) {\n        if (this._isDebugLabelsEnabled !== value) {\n            this._isDebugLabelsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugLabelsEnabled(): boolean {\n        return this._isDebugLabelsEnabled;\n    }\n\n    set isLinksEnabled(value: boolean) {\n        if (this._isLinksEnabled !== value) {\n            this._isLinksEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isLinksEnabled(): boolean {\n        return this._isLinksEnabled;\n    }\n\n    set isThreadsEnabled(value: boolean) {\n        if (this._isThreadsEnabled !== value) {\n            this._isThreadsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThreadsEnabled(): boolean {\n        return this._isThreadsEnabled;\n    }\n\n    getPreferenceState(nonDefaultOnly = false): CommandTreePreferenceState {\n        const result: CommandTreePreferenceState = {};\n\n        if (!nonDefaultOnly || this.groupBy !== this.miscPreferences[MiscPrefs.GroupBy]) {\n            result.groupBy = this.groupBy;\n        }\n        if (!nonDefaultOnly || this.isApiEventIdsEnabled !== this.miscPreferences[MiscPrefs.ShowApiEventIds]) {\n            result.isApiEventIdsEnabled = this.isApiEventIdsEnabled;\n        }\n        if (!nonDefaultOnly || this.isShowingEmptyRows !== this.miscPreferences[MiscPrefs.ShowEmptyRows]) {\n            result.isShowingEmptyRows = this.isShowingEmptyRows;\n        }\n        if (!nonDefaultOnly || this.isThumbnailEnabled !== this.miscPreferences[MiscPrefs.ShowThumbnails]) {\n            result.isThumbnailEnabled = this.isThumbnailEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugNamesEnabled !== true) {\n            result.isDebugNamesEnabled = this.isDebugNamesEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugLabelsEnabled !== true) {\n            result.isDebugLabelsEnabled = this.isDebugLabelsEnabled;\n        }\n        if (!nonDefaultOnly || this.isLinksEnabled !== true) {\n            result.isLinksEnabled = this.isLinksEnabled;\n        }\n        if (!nonDefaultOnly || this.isThreadsEnabled !== true) {\n            result.isThreadsEnabled = this.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (!nonDefaultOnly || this.isVulkanEnabled !== this.miscPreferences[MiscPrefs.ShowVulkanCalls]) {\n        //     result.isVulkanEnabled = this.isVulkanEnabled;\n        // }\n\n        return result;\n    }\n\n    override restoreState(state: CommandTreeModel.State): void {\n        if (state.groupBy !== undefined) {\n            this.groupBy = state.groupBy;\n        }\n        if (state.isApiEventIdsEnabled !== undefined) {\n            this.isApiEventIdsEnabled = state.isApiEventIdsEnabled;\n        }\n        if (state.isShowingEmptyRows !== undefined) {\n            this.isShowingEmptyRows = state.isShowingEmptyRows;\n        }\n        if (state.isThumbnailEnabled !== undefined) {\n            this.isThumbnailEnabled = state.isThumbnailEnabled;\n        }\n        if (state.isDebugNamesEnabled !== undefined) {\n            this.isDebugNamesEnabled = state.isDebugNamesEnabled;\n        }\n        if (state.isDebugLabelsEnabled !== undefined) {\n            this.isDebugLabelsEnabled = state.isDebugLabelsEnabled;\n        }\n        if (state.isLinksEnabled !== undefined) {\n            this.isLinksEnabled = state.isLinksEnabled;\n        }\n        if (state.isThreadsEnabled !== undefined) {\n            this.isThreadsEnabled = state.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (state.isVulkanEnabled !== undefined) {\n        //     this.isVulkanEnabled = state.isVulkanEnabled;\n        // }\n    }\n    override storeState(): CommandTreeModel.State {\n        return {\n            ...super.storeState(),\n            ...this.getPreferenceState(true)\n        };\n    }\n\n    @postConstruct()\n    protected override init(): void {\n        super.init();\n\n        // Set back-reference from tree to model\n        this.tree.model = this;\n\n        this.toDispose.pushAll([\n            this.onChangedEmitterProxy,\n            this.onExpansionChangedEmitterProxy,\n            this.onSubTreeExpansionChangedEmitter,\n\n            super.onChanged(() => {\n                if (!this.isCollapsingSubTree) {\n                    this.onChangedEmitterProxy.fire();\n                }\n            }),\n            super.onExpansionChanged(node => {\n                if (!this.isCollapsingSubTree) {\n                    this.onExpansionChangedEmitterProxy.fire(node);\n                }\n            })\n        ]);\n\n        this._isApiEventIdsEnabled = this.miscPreferences[MiscPrefs.ShowApiEventIds];\n        this._isShowingEmptyRows = this.miscPreferences[MiscPrefs.ShowEmptyRows];\n        this.isThumbnailEnabled = this.miscPreferences[MiscPrefs.ShowThumbnails];\n        this.groupBy = this.miscPreferences[MiscPrefs.GroupBy];\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // this.isVulkanEnabled = this.miscPreferences[MiscPrefs.ShowVulkanCalls];\n\n        this.preferenceStateAccess.registerCommandTreeModel(this.tree, this);\n    }\n\n    /**\n     * Collapses the entire tree.\n     */\n    async collapseTree(): Promise<void> {\n        const root = this.root;\n\n        if (CompositeTreeNode.is(root) && root.children.length > 0) {\n            await Promise.all(\n                root.children.filter(CompositeTreeNode.is).map((child: CompositeTreeNode) => this.expansionService.collapseAll(child))\n            );\n        }\n    }\n\n    /**\n     * Expands the given node and all its children recursively.\n     */\n    async expandSubTree(node?: Readonly<TreeNode>, includeDrawOrDispatchNodes = false): Promise<void> {\n        node ??= this.root;\n        if (!ExpandableTreeNode.is(node)) {\n            return;\n        }\n\n        try {\n            this.isCollapsingSubTree = true;\n            await this.doExpandSubTree(node, includeDrawOrDispatchNodes);\n            this.onSubTreeExpansionChangedEmitter.fire(node);\n        } finally {\n            this.isCollapsingSubTree = false;\n        }\n    }\n\n    protected async doExpandSubTree(node: TreeNode, includeDrawOrDispatchNodes: boolean): Promise<void> {\n        const YIELD_AFTER_MS = 200;\n\n        const processedNodes = new Set<TreeNode>();\n        const pendingNodes: TreeNode[] = [node];\n        let lastYieldTime = performance.now();\n\n        while (pendingNodes.length > 0) {\n            const currentLevelNodes: ExpandableTreeNode[] = [];\n            const nextLevelNodes: TreeNode[] = [];\n\n            while (pendingNodes.length > 0) {\n                const currentNode = pendingNodes.shift()!;\n                if (processedNodes.has(currentNode)) {\n                    continue;\n                }\n                processedNodes.add(currentNode);\n\n                // stop expansion at draw and dispatch nodes to avoid creation of low-utility nodes\n                // if this logic gets changed please also update enablement of ExpandSubtreeCommand accordingly\n                if (ExpandableTreeNode.is(currentNode) && (includeDrawOrDispatchNodes || !CommandTreeDrawOrDispatchNode.is(currentNode))) {\n                    currentLevelNodes.push(currentNode);\n                }\n            }\n\n            if (currentLevelNodes.length > 0) {\n                const expandedNodes = await this.expansionService.bulkExpandNodes(currentLevelNodes[Symbol.iterator]());\n                for (const expandedNode of expandedNodes) {\n                    await this.ensureLazyChildrenLoaded(expandedNode);\n                    console.log(\n                        `JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, children count: ${expandedNode.children.length}, children ids: ${expandedNode.children.map(c => c.id).join(', ')}`\n                    );\n                    nextLevelNodes.push(...expandedNode.children);\n                }\n                // Also process children of nodes that were already expanded\n                for (const currentNode of currentLevelNodes) {\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\n                        await this.ensureLazyChildrenLoaded(currentNode);\n                        console.log(\n                            `JF: doExpandSubTree - after ensureLazyChildrenLoaded (already expanded) for ${currentNode.id}, children count: ${currentNode.children.length}, children ids: ${currentNode.children.map(c => c.id).join(', ')}`\n                        );\n                        nextLevelNodes.push(...currentNode.children);\n                    }\n                }\n            }\n\n            pendingNodes.push(...nextLevelNodes);\n\n            // Yield control back to the event loop periodically based on time\n            const currentTime = performance.now();\n            if (currentTime - lastYieldTime >= YIELD_AFTER_MS) {\n                await new Promise(resolve => setTimeout(resolve, 0));\n                lastYieldTime = performance.now();\n            }\n        }\n    }\n\n    protected async ensureLazyChildrenLoaded(node: ExpandableTreeNode): Promise<void> {\n        // Find all loading nodes among children\n        const loadingNodes = node.children.filter(CommandEmptyNode.is);\n\n        if (loadingNodes.length === 0) {\n            return;\n        }\n\n        // Trigger load for all loading nodes and wait for them to complete\n        await Promise.all(loadingNodes.map(loadingNode => triggerLazyLoadAndWaitForRemoval(loadingNode)));\n    }\n\n    hasTrailingSuffixes(node: TreeNode): boolean {\n        if (CommandQueueSubmitNode.is(node)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    protected override isVisibleSelectableNode(node: TreeNode): node is SelectableTreeNode {\n        return super.isVisibleSelectableNode(node) && this.isInFrameRange(node);\n    }\n\n    protected isInFrameRange(node: TreeNode): boolean {\n        const frameNode = CommandFrameNode.getCommandFrameNodeContaining(node);\n        if (frameNode === undefined) {\n            return true; // Assume it's good\n        }\n        const range = this.frameRangeSelectionService.frameSpan;\n        if (range === undefined) {\n            return true; // No constraint\n        }\n        return frameNode.frameIndex >= range.startFrame && frameNode.frameIndex <= range.endFrame;\n    }\n}\n\nexport namespace CommandTreeModel {\n    export interface State extends TreeModelImpl.State, CommandTreePreferenceState {}\n\n    /**\n     * Test whether a `node` is of the kind that implements the given `group` mode.\n     * As groups are _a priori_ composite nodes, this additionally infers that type\n     * for the `node` if successful.\n     */\n    export function isOfGroup(node: TreeNode, group: GroupByOptions): node is CompositeTreeNode {\n        switch (group) {\n            case GroupByOptions.Frame:\n                return CommandFrameNode.is(node);\n            case GroupByOptions.RenderPass:\n                return CommandRenderPassInstanceNode.is(node) || CommandDynamicRenderPassInstanceNode.is(node);\n            case GroupByOptions.RenderSubpass:\n                return CommandRenderSubpassInstanceNode.is(node);\n            case GroupByOptions.CommandBuffer:\n                return CommandCommandBufferInstanceNode.is(node);\n            case GroupByOptions.QueueSubmission:\n                return CommandQueueSubmitNode.is(node);\n        }\n    }\n}\n\ntype TextureSupportingNode =\n    | CommandFrameNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode;\n\nexport namespace TextureSupportingNode {\n    export function is(node: CommandTreeNode): node is TextureSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node)\n        );\n    }\n    export function getLast(node: CommandTreeNode): TextureSupportingNode | undefined {\n        if (TextureSupportingNode.is(node)) {\n            return node;\n        }\n        let lastSupportingNode: TextureSupportingNode | undefined;\n        if (CompositeTreeNode.is(node)) {\n            for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n                lastSupportingNode = TextureSupportingNode.getLast(node.children[commandIndex]);\n                if (lastSupportingNode) {\n                    break;\n                }\n            }\n        }\n        return lastSupportingNode;\n    }\n}\n\n/**\n * Union type of all command tree nodes that support thumbnails.\n * Nodes with heavy thumbnail costs are commented out.\n */\ntype ThumbnailSupportingNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandDebugLabelGroupNode\n    | CommandRenderPassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDrawInstanceNode;\n// Below currently have a possibly heavy cost to getting thumbnails\n// | CommandDispatchInstanceNode\n// | CommandMeshTaskInstanceNode\n// | CommandClusterInstanceNode\n// | CommandRaytracingInstanceNode;\n\nexport namespace ThumbnailSupportingNode {\n    export function is(node: CommandTreeNode): node is ThumbnailSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node)\n        );\n    }\n}\n\nfunction getCommandTreeApiEventChildren(eventIds: Array<{ apiEvent: number }>, root: CommandRootNode): CommandTreeApiEvent[] {\n    return eventIds.reduce<CommandTreeApiEvent[]>((collected, id) => {\n        const event = root.resource.apiEvents[id.apiEvent];\n        if (event) {\n            collected.push(event);\n        } else {\n            console.warn(`No event found for ${id.apiEvent}`);\n        }\n        return collected;\n    }, []);\n}\n\nfunction getInstancesByIds<T>(ids: number[], container: PartialRecord<number, T>, source?: string, target?: string): T[] {\n    return ids.flatMap(id => {\n        const instance = container[id];\n        if (!instance) {\n            if (target) {\n                console.warn(`${source ? `${source} expected` : 'Expected'} ${target} with ${id} but found none.`);\n            }\n            return [];\n        }\n        return instance;\n    });\n}\n\n/**\n * Creates an ArrayWithSortNumber for range instances, used by createChildEventNodesForRange.\n * Fetches instances by IDs and provides sorting by beginApiEvent.\n *\n * @param ids - Array of instance IDs to fetch\n * @param container - Container object mapping IDs to instances\n * @param sourceContext - Context string for error messages (e.g., \"CommandRenderPassInstanceNode.create\")\n * @param targetName - Target instance type name for error messages (e.g., \"DebugLabelGroupInstance\")\n * @returns ArrayWithSortNumber object ready for use with getNextRangeElementToProcess\n */\nfunction createRangeInstanceArray<T extends { beginApiEvent: number }>(\n    ids: number[],\n    container: PartialRecord<number, T>,\n    sourceContext: string,\n    targetName: string\n): ArrayWithSortNumber<T> {\n    return {\n        array: getInstancesByIds(ids, container, sourceContext, targetName),\n        getSortNumber: (element: T) => element.beginApiEvent\n    };\n}\n\nexport function createLazyLoadingNode(\n    tree: CommandTree,\n    parent: ExpandableTreeNode,\n    load: (batchQuery?: boolean) => Promise<void>\n): CommandEmptyNode {\n    let loaded = false;\n    let loadingInProgress = false;\n\n    const lazyLoad: (batchQuery?: boolean) => Promise<boolean> = async (batchQuery = true) => {\n        if (loadingInProgress) {\n            return false;\n        }\n\n        if (!loaded) {\n            loaded = true;\n            loadingInProgress = true;\n            loadOnExpanded.dispose();\n            try {\n                await load(batchQuery);\n            } catch (error) {\n                console.error(`LazyLoad failed for node ${parent.id}:`, error);\n            } finally {\n                loadingInProgress = false;\n            }\n            console.log(\n                `JF: createLazyLoadingNode - load completed for parent ${parent.id}, children count before removeChild: ${parent.children.length}`\n            );\n            CompositeTreeNode.removeChild(parent, loadingNode);\n            await tree.refreshStructure(parent);\n            return true;\n        }\n        return false;\n    };\n\n    // create lazy loading node\n    const loadingNode: CommandEmptyNode = CommandEmptyNode.create(parent, lazyLoad);\n    CompositeTreeNode.addChild(parent, loadingNode);\n\n    // register for lazy loading when the node is expanded\n    const loadOnExpanded = SokatoaLifecycleTreeNode.register(parent, 'onWillRender', async () => {\n        if (parent.expanded) {\n            // do not batch queries for expansion manually\n            await lazyLoad(false);\n        }\n    });\n    return loadingNode;\n}\n"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "The file is very large. The issue is that lines in the file are too long. Given the linting constraints, I'll use eslint-disable comments to suppress these specific lines. Since these are diagnostic logs that will be removed later, using eslint-disable is appropriate:"
            },
            "fallbackMessage": "The file is very large. The issue is that lines in the file are too long. Given the linting constraints, I'll use eslint-disable comments to suppress these specific lines. Since these are diagnostic logs that will be removed later, using eslint-disable is appropriate:"
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_019S7zUakpdNNF4c1aZhrnHw",
              "name": "writeFileReplacements",
              "arguments": "{\"path\": \"app/packages/capture/src/browser/command-tree/command-tree-model.ts\", \"replacements\": [{\"oldContent\":\"            .then(() => {\\n                console.log(\\n                    `JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\",\"newContent\":\"            .then(() => {\\n                // eslint-disable-next-line max-len\\n                console.log(`JF: CommandCommandBufferInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\"},{\"oldContent\":\"            .then(() => {\\n                console.log(\\n                    `JF: CommandRenderSubpassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\",\"newContent\":\"            .then(() => {\\n                // eslint-disable-next-line max-len\\n                console.log(`JF: CommandRenderSubpassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\"},{\"oldContent\":\"            .then(() => {\\n                console.log(\\n                    `JF: CommandDynamicRenderPassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`\\n                );\",\"newContent\":\"            .then(() => {\\n                // eslint-disable-next-line max-len\\n                console.log(`JF: CommandDynamicRenderPassInstanceNode ${node.id} - async children creation completed, children count: ${node.children.length}`);\"},{\"oldContent\":\"                for (const expandedNode of expandedNodes) {\\n                    await this.ensureLazyChildrenLoaded(expandedNode);\\n                    console.log(\\n                        `JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, children count: ${expandedNode.children.length}, children ids: ${expandedNode.children.map(c => c.id).join(', ')}`\\n                    );\\n                    nextLevelNodes.push(...expandedNode.children);\\n                }\",\"newContent\":\"                for (const expandedNode of expandedNodes) {\\n                    await this.ensureLazyChildrenLoaded(expandedNode);\\n                    const childIds = expandedNode.children.map(c => c.id).join(', ');\\n                    // eslint-disable-next-line max-len\\n                    console.log(`JF: doExpandSubTree - after ensureLazyChildrenLoaded for ${expandedNode.id}, children count: ${expandedNode.children.length}, children ids: ${childIds}`);\\n                    nextLevelNodes.push(...expandedNode.children);\\n                }\"},{\"oldContent\":\"                // Also process children of nodes that were already expanded\\n                for (const currentNode of currentLevelNodes) {\\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\\n                        await this.ensureLazyChildrenLoaded(currentNode);\\n                        console.log(\\n                            `JF: doExpandSubTree - after ensureLazyChildrenLoaded (already expanded) for ${currentNode.id}, children count: ${currentNode.children.length}, children ids: ${currentNode.children.map(c => c.id).join(', ')}`\\n                        );\\n                        nextLevelNodes.push(...currentNode.children);\\n                    }\\n                }\",\"newContent\":\"                // Also process children of nodes that were already expanded\\n                for (const currentNode of currentLevelNodes) {\\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\\n                        await this.ensureLazyChildrenLoaded(currentNode);\\n                        const childIds = currentNode.children.map(c => c.id).join(', ');\\n                        // eslint-disable-next-line max-len\\n                        console.log(`JF: doExpandSubTree - after ensureLazyChildrenLoaded (already expanded) for ${currentNode.id}, children count: ${currentNode.children.length}, children ids: ${childIds}`);\\n                        nextLevelNodes.push(...currentNode.children);\\n                    }\\n                }\"},{\"oldContent\":\"            console.log(\\n                `JF: createLazyLoadingNode - load completed for parent ${parent.id}, children count before removeChild: ${parent.children.length}`\\n            );\",\"newContent\":\"            // eslint-disable-next-line max-len\\n            console.log(`JF: createLazyLoadingNode - load completed for parent ${parent.id}, children count before removeChild: ${parent.children.length}`);\"}]}",
              "finished": true,
              "result": "Errors encountered: Content to replace not found: \"            .then(() => {\n                conso...nt: ${node.children.length}`\n                );\"; Content to replace not found: \"            .then(() => {\n                conso...nt: ${node.children.length}`\n                );\"; Content to replace not found: \"            .then(() => {\n                conso...nt: ${node.children.length}`\n                );\"; Content to replace not found: \"                for (const expandedNode of expa...sh(...expandedNode.children);\n                }\"; Content to replace not found: \"                // Also process children of nod...ldren);\n                    }\n                }\"; Content to replace not found: \"            console.log(\n                `JF: c...hild: ${parent.children.length}`\n            );\""
            },
            "fallbackMessage": ""
          },
          {
            "kind": "error",
            "data": {
              "message": "400 {\"type\":\"error\",\"error\":{\"type\":\"invalid_request_error\",\"message\":\"prompt is too long: 200344 tokens > 200000 maximum\"},\"request_id\":\"req_011CXZjRpwawv2GhpnyX23Ra\"}",
              "stack": "Error: 400 {\"type\":\"error\",\"error\":{\"type\":\"invalid_request_error\",\"message\":\"prompt is too long: 200344 tokens > 200000 maximum\"},\"request_id\":\"req_011CXZjRpwawv2GhpnyX23Ra\"}\n    at o.generate (/tmp/.mount_theiaiOVrizY/resources/app/lib/backend/944.js:2:96679)\n    at R.makeStatusError (/tmp/.mount_theiaiOVrizY/resources/app/lib/backend/944.js:8:2262565)\n    at R.makeRequest (/tmp/.mount_theiaiOVrizY/resources/app/lib/backend/944.js:8:2266245)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)"
            }
          }
        ]
      }
    ]
  }
}