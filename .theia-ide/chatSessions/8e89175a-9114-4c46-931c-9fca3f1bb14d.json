{
  "version": 1,
  "title": "Remove JF Debug Logs from Command Tree",
  "pinnedAgentId": "Coder",
  "saveDate": 1769614397298,
  "model": {
    "sessionId": "8e89175a-9114-4c46-931c-9fca3f1bb14d",
    "location": "panel",
    "hierarchy": {
      "rootBranchId": "b74b1f27-3f78-471b-869d-27b0db1a0459",
      "branches": {
        "b74b1f27-3f78-471b-869d-27b0db1a0459": {
          "id": "b74b1f27-3f78-471b-869d-27b0db1a0459",
          "items": [
            {
              "requestId": "1c88f29c-f44e-4be1-b9a4-c22abe0deca1"
            }
          ],
          "activeBranchIndex": 0
        }
      }
    },
    "requests": [
      {
        "id": "1c88f29c-f44e-4be1-b9a4-c22abe0deca1",
        "text": "@Coder Remove all debug logging statements that were added with the \"JF:\" prefix for investigating the Expand Subtree issue.\n\n## File 1: `app/packages/capture/src/browser/command-tree/command-tree-model.ts`\n\n### Step 1: Remove all console.log statements containing \"JF:\" from the `doExpandSubTree` method\n\nRemove these log statements:\n- `console.log('JF: doExpandSubTree START', ...)`\n- `console.log('JF: doExpandSubTree - processing level', ...)`\n- `console.log('JF: doExpandSubTree - after bulkExpandNodes', ...)`\n- `console.log('JF: doExpandSubTree - calling ensureLazyChildrenLoaded for', ...)`\n- `console.log('JF: doExpandSubTree - after ensureLazyChildrenLoaded', ...)`\n- `console.log('JF: doExpandSubTree - processing already expanded node', ...)`\n- `console.log('JF: doExpandSubTree - next level', ...)`\n- `console.log('JF: doExpandSubTree END', ...)`\n\n### Step 2: Remove all console.log statements containing \"JF:\" from the `ensureLazyChildrenLoaded` method\n\nRemove these log statements:\n- `console.log('JF: ensureLazyChildrenLoaded START', ...)`\n- `console.log('JF: ensureLazyChildrenLoaded - found loading nodes', ...)`\n- `console.log('JF: ensureLazyChildrenLoaded - no loading nodes, returning')`\n- `console.log('JF: ensureLazyChildrenLoaded - triggering loads')`\n- `console.log('JF: ensureLazyChildrenLoaded END', ...)`\n\n### Step 3: Remove all console.log statements containing \"JF:\" from the `createLazyLoadingNode` function\n\nRemove these log statements:\n- `console.log('JF: lazyLoad START', ...)`\n- `console.log('JF: lazyLoad - already in progress, returning false')`\n- `console.log('JF: lazyLoad - calling load function')`\n- `console.log('JF: lazyLoad - load function completed')`\n- `console.log('JF: lazyLoad - removing loading node and refreshing structure')`\n- `console.log('JF: lazyLoad - refreshStructure completed', ...)`\n- `console.log('JF: lazyLoad - already loaded, returning false')`\n\n### Step 4: Remove all console.log statements containing \"JF:\" from the `refreshStructure` and `fireStructureChanged` methods\n\nRemove these log statements:\n- `console.log('JF: CommandTree.refreshStructure START', ...)`\n- `console.log('JF: CommandTree.refreshStructure - calling fireStructureChanged')`\n- `console.log('JF: CommandTree.refreshStructure END')`\n- `console.log('JF: CommandTree.fireStructureChanged', ...)`\n\n## File 2: `app/packages/capture/src/browser/command-tree/lazy-load-utils.ts`\n\n### Step 5: Remove all console.log and console.warn statements containing \"JF:\" from `waitForLoadingNodeRemoval`\n\nRemove these log statements:\n- `console.log('JF: waitForLoadingNodeRemoval START', ...)`\n- `console.log('JF: waitForLoadingNodeRemoval - node removed after', ...)`\n- `console.log('JF: waitForLoadingNodeRemoval - still waiting', ...)`\n- `console.warn('JF: Loading node still not removed after ...')` - change this back to the original message without \"JF:\" prefix\n\n### Step 6: Remove all console.log statements containing \"JF:\" from `triggerLazyLoadAndWaitForRemoval`\n\nRemove these log statements:\n- `console.log('JF: triggerLazyLoadAndWaitForRemoval START', ...)`\n- `console.log('JF: triggerLazyLoadAndWaitForRemoval - calling node.load()')`\n- `console.log('JF: triggerLazyLoadAndWaitForRemoval - node.load() completed')`\n- `console.log('JF: triggerLazyLoadAndWaitForRemoval END', ...)`\n\n## File 3: `app/packages/platform/src/browser/tree-table/tree-table-widget.tsx`\n\n### Step 7: Remove all console.log statements containing \"JF:\" from `setupOnChangedListener`\n\nRemove these log statements:\n- `console.log('JF: TreeTableWidget.onStructureChanged received', ...)`\n- `console.log('JF: TreeTableWidget.onExpansionChanged received')`\n- `console.log('JF: TreeTableWidget.onChanged received')`\n- `console.log('JF: TreeTableWidget.onChanged (fallback) received')`\n\n### Step 8: Remove the console.log statement containing \"JF:\" from `updateRows`\n\nRemove this log statement:\n- `console.log('JF: TreeTableWidget.updateRows called', ...)`",
        "agentId": "Coder",
        "changeSet": {
          "title": "Changes proposed",
          "elements": [
            {
              "kind": "file",
              "uri": "file:///home/johannes/Git/sokatoa/app/packages/capture/src/browser/command-tree/command-tree-model.ts",
              "name": "command-tree-model.ts",
              "icon": "ts-icon medium-blue theia-file-icons-js",
              "additionalInfo": "app/packages/capture/src/browser/command-tree",
              "state": "stale",
              "type": "modify",
              "data": {
                "targetState": "/********************************************************************************\n    Copyright 2024-2026 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\nimport { GFXRQueryBuilderService } from '@sokatoa/gfxr-consumer/lib/';\nimport {\n    DynamicStateEntry,\n    PipelineBindPoint,\n    PipelineBindPointShaderStageFlags,\n    StateType\n} from '@sokatoa/gfxr-consumer/lib/browser/gfxr-data-service';\nimport { PartialRecord } from '@sokatoa/platform/lib';\nimport { BulkTree, BulkTreeModel, ResourceTreeNode, SokatoaLifecycleTreeNode } from '@sokatoa/platform/lib/browser';\nimport { GroupByOptions, MiscPreferences, MiscPrefs } from '@sokatoa/platform/lib/browser/misc-preferences';\nimport { TreeStructureChangeEmitter } from '@sokatoa/platform/lib/browser/tree-table/tree-table-widget';\nimport { ImageAccessorService } from '@sokatoa/platform/lib/common';\nimport { CompressedFileService, usesCompressionExtension } from '@sokatoa/platform/lib/common/compressed-file-service';\nimport { asError } from '@sokatoa/platform/lib/common/error-utils';\nimport { ApiResources, DescriptorResource, DrawApiResult } from '@sokatoa/platform/lib/common/gfxr-apis';\nimport { CancellationToken, Disposable, Emitter, Event, Path, URI } from '@theia/core';\nimport {\n    CompositeTreeNode,\n    DepthFirstTreeIterator,\n    ExpandableTreeNode,\n    SelectableTreeNode,\n    TreeModelImpl,\n    TreeNode\n} from '@theia/core/lib/browser';\nimport { RGBA } from '@theia/core/lib/common/color';\nimport { inject, injectable, postConstruct } from '@theia/core/shared/inversify';\nimport { PNG } from 'pngjs/browser';\nimport { lookupResourceFormat, UncompressedResourceFormat } from '../../common/format-handler';\nimport { extractData } from '../../common/geometry-utils';\nimport { GfxrScreenshotService, requestThumbnails, ScreenshotType, ThumbnailRequestOptions } from '../../common/gfxr-screenshot-service';\nimport { convertDataToImageData } from '../../common/host-side-conversion/vulkan-image';\nimport { FrameRangeSelectionService } from '../capture-widget/frame-range-selection-service';\nimport { placeholderScale } from '../graphics-pipeline-widget/graphics-pipeline-screenshot-requests';\nimport {\n    CaptureDatasetWidgetContext,\n    CaptureDatasetWidgetProfile,\n    CaptureDatasetWidgetReplayContext\n} from '../profile-ui/capture-dataset-widget-types';\nimport { CommandTreePreferenceState } from './command-tree-model-preferences';\nimport {\n    CommandTreeAccelerationStructureBuildInstance,\n    CommandTreeAccelerationStructureCopyInstance,\n    CommandTreeApiEvent,\n    CommandTreeCommandBufferInstance,\n    CommandTreeDataWithFunctionAndDebugNames,\n    CommandTreeDebugLabelGroupInstance,\n    CommandTreeDynamicRenderPassInstance,\n    CommandTreeFrame,\n    CommandTreeQueueDebugLabelGroup,\n    CommandTreeQueueDebugLabelInsert,\n    CommandTreeQueuePresent,\n    CommandTreeQueueSubmit,\n    CommandTreeRenderPassInstance,\n    CommandTreeRenderSubpassInstance,\n    CommandTreeSecondaryCommandBufferInstance,\n    CommandTreeTransferCommandInstance,\n    overrideDynamicState,\n    queryClusterInstanceDynamicState,\n    queryClusterInstanceDynamicStateBatched,\n    queryDispatchInstanceDynamicState,\n    queryDispatchInstanceDynamicStateBatched,\n    queryDrawInstanceDynamicState,\n    queryDrawInstanceDynamicStateBatched,\n    queryMeshTaskInstanceDynamicState,\n    queryMeshTaskInstanceDynamicStateBatched,\n    queryRaytracingInstanceDynamicState,\n    queryRaytracingInstanceDynamicStateBatched,\n    querySecondaryCommandBufferEndDynamicState,\n    QueryTreeDataOptions\n} from './command-tree-service';\nimport { LazyLoadableNode, triggerLazyLoadAndWaitForRemoval } from './lazy-load-utils';\nimport { CommandTreeDataQueriedRootProvider } from './providers/command-tree-root-provider';\n\n// Extension names\nconst VK_NV_COMMAND_BUFFER_INHERITANCE = 'VK_NV_command_buffer_inheritance';\nconst VK_NV_INHERITED_VIEWPORT_SCISSOR = 'VK_NV_inherited_viewport_scissor';\n\n/**\n * Helper type to make TreeNode.parent writable during node construction.\n * TreeNode.parent is readonly, but during tree construction we need to update it.\n */\ninterface MutableParent {\n    parent: CompositeTreeNode | undefined;\n}\n\n/**\n * Check if VK_NV_command_buffer_inheritance extension is enabled for a device.\n * This extension enables full state inheritance between command buffers and leak-back.\n */\nfunction hasCommandBufferInheritance(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_COMMAND_BUFFER_INHERITANCE) ?? false;\n}\n\n/**\n * Check if VK_NV_inherited_viewport_scissor extension is enabled for a device.\n * This extension enables limited viewport/scissor inheritance for secondary command buffers.\n */\nfunction hasInheritedViewportScissor(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_INHERITED_VIEWPORT_SCISSOR) ?? false;\n}\n\n/**\n * Filter dynamic state to only viewport and scissor entries.\n * Used for VK_NV_inherited_viewport_scissor extension.\n */\nasync function filterDynamicStateForViewportScissor(statePromise: Promise<DynamicStateEntry[]>): Promise<DynamicStateEntry[]> {\n    const state = await statePromise;\n    return state.filter(entry => entry.stateType === StateType.VIEWPORT || entry.stateType === StateType.SCISSOR);\n}\n\n/**\n * Tracks dynamic state that may be updated as secondary command buffers execute\n * (when VK_NV_command_buffer_inheritance is enabled).\n */\nclass DynamicStateTracker {\n    private currentStatePromise: Promise<DynamicStateEntry[]>;\n\n    constructor(initialState: Promise<DynamicStateEntry[]>) {\n        this.currentStatePromise = initialState;\n    }\n\n    getCurrentState(): Promise<DynamicStateEntry[]> {\n        return this.currentStatePromise;\n    }\n\n    updateState(newState: Promise<DynamicStateEntry[]>): void {\n        this.currentStatePromise = newState;\n    }\n}\n\n/** Internal context for a command tree model.\n *\n * contains all the fixed data needed for the model,\n * e.g. services, etc.\n */\ninterface CommandTreeContext {\n    dbId: number;\n    data: CommandTreeDataWithFunctionAndDebugNames;\n    screenshotService: GfxrScreenshotService;\n    fileService: CompressedFileService;\n    profile: CaptureDatasetWidgetProfile;\n    context: CaptureDatasetWidgetContext;\n    tree: CommandTree;\n    gfxrQueryBuilderService: GFXRQueryBuilderService;\n    imageAccessorService: ImageAccessorService;\n    createDrawOrDispatchChildren: boolean;\n    rootNode: CommandRootNode;\n    deviceExtensions: Map<number, Set<string>>;\n}\n\n/**\n * Helper function to look up the debug name for an object at a specific API event.\n * Finds the most recent debug name that was set at or before the target API event.\n * @param debugNameLookup - Map of objectHandle to array of {apiEvent, name} sorted by apiEvent\n * @param objectHandle - The object handle to look up\n * @param targetApiEvent - The API event at which we want to know the object's name\n * @returns The debug name if found, undefined otherwise\n */\nfunction getDebugNameAtApiEvent(\n    debugNameLookup: Map<number, Array<{ apiEvent: number; name: string }>>,\n    objectHandle: number | null | undefined,\n    targetApiEvent: number\n): string | undefined {\n    if (typeof objectHandle !== 'number') {\n        return undefined;\n    }\n\n    const entries = debugNameLookup.get(objectHandle);\n    if (!entries || entries.length === 0) {\n        return undefined;\n    }\n\n    // Binary search for the most recent name at or before targetApiEvent\n    let left = 0;\n    let right = entries.length - 1;\n    let result: string | undefined = undefined;\n\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (entries[mid].apiEvent <= targetApiEvent) {\n            result = entries[mid].name;\n            left = mid + 1; // Look for a more recent name\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n\nexport interface CommandRootNode extends ResourceTreeNode<CommandTreeDataWithFunctionAndDebugNames>, CompositeTreeNode, ExpandableTreeNode {\n    resourceType: typeof CommandRootNode.RESOURCE_TYPE;\n    children: CommandFrameNode[];\n    dbId: number;\n    profile: CaptureDatasetWidgetProfile;\n    tree?: CommandTree; // Back-reference to the tree that owns this root\n    // Cached maps for queue debug labels to avoid rebuilding for each frame\n    queueDebugLabelGroupsBySubmitId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelGroupsByPresentId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelInsertsByApiEvent: Map<number, CommandTreeQueueDebugLabelInsert>;\n}\n\nexport namespace CommandRootNode {\n    export const ID = 'sokatoa-command-tree-widget';\n\n    export const RESOURCE_TYPE = '__root__';\n\n    export function is(node: TreeNode | undefined): node is CommandRootNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRootNode.RESOURCE_TYPE);\n    }\n\n    export function create(\n        dbId: number,\n        data: CommandTreeDataWithFunctionAndDebugNames,\n        screenshotService: GfxrScreenshotService,\n        profile: CaptureDatasetWidgetProfile,\n        context: CaptureDatasetWidgetContext,\n        tree: CommandTree,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        imageAccessorService: ImageAccessorService,\n        fileService: CompressedFileService,\n        createDrawOrDispatchChildren: boolean,\n        deviceExtensions: Map<number, Set<string>>\n    ): CommandRootNode {\n        // Build maps for queue debug labels once for all frames\n        const queueDebugLabelGroupsBySubmitId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelGroupsByPresentId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelInsertsByApiEvent = new Map<number, CommandTreeQueueDebugLabelInsert>();\n\n        for (const group of Object.values(data.queueDebugLabelGroups)) {\n            if (group) {\n                for (const submitId of group.queueSubmitIds) {\n                    queueDebugLabelGroupsBySubmitId.set(submitId, group);\n                }\n                for (const presentId of group.queuePresentIds) {\n                    queueDebugLabelGroupsByPresentId.set(presentId, group);\n                }\n            }\n        }\n\n        for (const insert of Object.values(data.queueDebugLabelInserts)) {\n            if (insert) {\n                queueDebugLabelInsertsByApiEvent.set(insert.apiEvent, insert);\n            }\n        }\n\n        const rootNode: CommandRootNode = {\n            visible: false,\n            id: CommandRootNode.ID,\n            name: 'ProfileTree',\n            parent: undefined,\n            expanded: true,\n            children: [],\n            resourceType: CommandRootNode.RESOURCE_TYPE,\n            resource: data,\n            dbId,\n            profile,\n            queueDebugLabelGroupsBySubmitId,\n            queueDebugLabelGroupsByPresentId,\n            queueDebugLabelInsertsByApiEvent\n        };\n        const ctx: CommandTreeContext = {\n            dbId,\n            data,\n            screenshotService,\n            fileService,\n            profile,\n            context,\n            tree,\n            gfxrQueryBuilderService,\n            imageAccessorService,\n            createDrawOrDispatchChildren,\n            rootNode,\n            deviceExtensions\n        };\n        const modelBuildStart = Date.now();\n        const frames = Object.values(data.frames);\n        rootNode.children = frames.flatMap(child => (child ? CommandFrameNode.create(ctx, child, rootNode) : []));\n        console.debug(`Model loaded in ${Date.now() - modelBuildStart} ms`);\n        return rootNode;\n    }\n}\n\nexport interface DebugMarker {\n    name: string;\n    color?: RGBA;\n}\n\nexport interface WithDebugMarker {\n    debugMarker?: DebugMarker;\n}\n\nexport namespace WithDebugMarker {\n    /** Type guard for a `node` that is or has a debug marker. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugMarker> {\n        return 'debugMarker' in node && node.debugMarker !== undefined;\n    }\n}\n\nexport interface WithDebugName {\n    debugName?: string;\n}\n\nexport namespace WithDebugName {\n    /** Type guard for a `node` that has a debug name. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugName> {\n        return 'debugName' in node && node.debugName !== undefined;\n    }\n}\n\ninterface LabelData {\n    labelName: string | undefined | null;\n    colorR: number | undefined | null;\n    colorG: number | undefined | null;\n    colorB: number | undefined | null;\n    colorA: number | undefined | null;\n}\n\nfunction setDebugMarkerData(node: WithDebugMarker, labelData: LabelData): void {\n    const name = labelData.labelName ?? 'Debug marker';\n    const color = {\n        r: (labelData.colorR ?? 1) * 255,\n        g: (labelData.colorG ?? 1) * 255,\n        b: (labelData.colorB ?? 1) * 255,\n        a: (labelData.colorA ?? 1) * 255\n    };\n\n    node.debugMarker = { name };\n    if (color.a !== 0 || color.b !== 0 || color.g !== 0 || color.r !== 0) {\n        node.debugMarker.color = color;\n    }\n}\n\nexport interface CommandFrameNode extends ResourceTreeNode<CommandTreeFrame>, ExpandableTreeNode, SelectableTreeNode {\n    label: string;\n    frameIndex: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandFrameNode.RESOURCE_TYPE;\n    thumbnail?: string;\n}\n\nexport namespace CommandFrameNode {\n    export const RESOURCE_TYPE = 'frame';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandFrameNode {\n        return ResourceTreeNode.hasResourceType(node, CommandFrameNode.RESOURCE_TYPE);\n    }\n\n    export function getId(frame: CommandTreeFrame): string {\n        return frame.frameIndex.toString();\n    }\n\n    export function create(ctx: CommandTreeContext, element: CommandTreeFrame, parent: CompositeTreeNode): CommandFrameNode {\n        const node: CommandFrameNode & SokatoaLifecycleTreeNode = {\n            id: getId(element),\n            frameIndex: element.frameIndex,\n            label: `Frame ${element.frameIndex}`,\n            children: [],\n            expanded: false,\n            selected: false,\n            parent,\n            resourceType: CommandFrameNode.RESOURCE_TYPE,\n            resource: element\n        };\n\n        const root = ctx.rootNode;\n\n        const children: CommandTreeNode[] = [];\n        let queueSubmitIndex = 0;\n        let queuePresentIndex = 0;\n        let accelerationStructureBuildIndex = 0;\n        let accelerationStructureCopyIndex = 0;\n\n        // Track current active debug label group and its children\n        let activeDebugLabelGroup: CommandTreeQueueDebugLabelGroup | undefined;\n        let activeGroupChildren: (CommandQueueSubmitNode | CommandQueuePresentNode)[] = [];\n        let queueDebugLabelGroupInstanceIndex = 0;\n\n        // Helper to finalize the active group and add it to children\n        const finalizeActiveGroup = (): void => {\n            if (activeDebugLabelGroup && activeGroupChildren.length > 0) {\n                children.push(\n                    CommandQueueDebugLabelGroupNode.create(\n                        ctx,\n                        activeDebugLabelGroup,\n                        node,\n                        activeGroupChildren,\n                        queueDebugLabelGroupInstanceIndex++\n                    )\n                );\n                activeDebugLabelGroup = undefined;\n                activeGroupChildren = [];\n            }\n        };\n\n        for (let id = element.beginApiEvent; id <= (element.endApiEvent ?? element.beginApiEvent); id++) {\n            // Check for queue debug label insert at this apiEvent\n            const queueDebugLabelInsert = root.queueDebugLabelInsertsByApiEvent.get(id);\n            if (queueDebugLabelInsert) {\n                // Inserts can appear in the middle of groups, so finalize any active group first\n                finalizeActiveGroup();\n                children.push(CommandQueueDebugLabelNode.create(ctx, queueDebugLabelInsert, node));\n            }\n\n            const apiEvent = root.resource.apiEvents[id];\n            if (apiEvent) {\n                if (apiEvent.submissionId && element.queueSubmitIds.includes(apiEvent.submissionId)) {\n                    const queueSubmit = root.resource.queueSubmits[apiEvent.submissionId];\n                    if (queueSubmit) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsBySubmitId.get(apiEvent.submissionId);\n\n                        // Check if this submit is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queueSubmit not found for submissionId ${apiEvent.submissionId}`);\n                    }\n                } else if (apiEvent.presentId && element.queuePresentIds.includes(apiEvent.presentId)) {\n                    const queuePresent = root.resource.queuePresents[apiEvent.presentId];\n                    if (queuePresent) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsByPresentId.get(apiEvent.presentId);\n\n                        // Check if this present is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queuePresent not found for presentId ${apiEvent.presentId}`);\n                    }\n                } else if (\n                    apiEvent.accelerationStructureBuildInstanceId &&\n                    element.accelerationStructureBuildIds.includes(apiEvent.accelerationStructureBuildInstanceId)\n                ) {\n                    // Acceleration structure builds interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureBuild =\n                        root.resource.topLevelAccelerationStructureBuilds[apiEvent.accelerationStructureBuildInstanceId];\n                    if (accelerationStructureBuild) {\n                        children.push(\n                            CommandAccelerationStructureBuildNode.create(\n                                accelerationStructureBuild,\n                                node,\n                                accelerationStructureBuildIndex++\n                            )\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureBuildInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureBuild not found for accelerationStructureBuildInstanceId ${iId}`\n                        );\n                    }\n                } else if (\n                    apiEvent.accelerationStructureCopyInstanceId &&\n                    element.accelerationStructureCopyIds.includes(apiEvent.accelerationStructureCopyInstanceId)\n                ) {\n                    // Acceleration structure copies interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureCopy =\n                        root.resource.topLevelAccelerationStructureCopies[apiEvent.accelerationStructureCopyInstanceId];\n                    if (accelerationStructureCopy) {\n                        children.push(\n                            CommandAccelerationStructureCopyNode.create(accelerationStructureCopy, node, accelerationStructureCopyIndex++)\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureCopyInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureCopy not found for accelerationStructureCopyInstanceId ${iId}`\n                        );\n                    }\n                }\n            }\n        }\n\n        // Finalize any remaining active debug label group at the end\n        finalizeActiveGroup();\n\n        node.children = children;\n\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        const request: ThumbnailRequestOptions = {\n            profileOrReplay: replay ?? ctx.profile,\n            startFrame: element.frameIndex,\n            endFrame: element.frameIndex,\n            requesterDbgName: `Command tree frame ${element.frameIndex}`,\n            onScreenshotReady: result => {\n                ctx.imageAccessorService\n                    .accessImage(new URL(URI.fromFilePath(result.path).toString()))\n                    .then(url => {\n                        node.thumbnail = url.url.toString();\n                        ctx.tree.addToDispose(url);\n                        void ctx.tree.refresh(node);\n                    })\n                    .catch(reason => {\n                        const error = asError(reason);\n                        console.error(error);\n                    });\n            },\n            onRequestComplete: (success, message) => {\n                if (!success) {\n                    console.error(`Request for frame thumbnails failed: ${message}`);\n                }\n            }\n        };\n        const onWillRender = (): void => {\n            requestThumbnails(ctx.screenshotService, request);\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', onWillRender);\n        };\n        SokatoaLifecycleTreeNode.register(node, 'onWillRender', onWillRender);\n        return node;\n    }\n\n    /**\n     * Retrieve the `CommandFrameNode` that is or contains the given `node`.\n     * Returns `undefined` in the case that the `node` is an ancestor of or\n     * otherwise not contained in an `CommandFrameNode`.\n     */\n    export function getCommandFrameNodeContaining(node: TreeNode): CommandFrameNode | undefined {\n        return CommandFrameNode.is(node) ? node : node.parent ? CommandFrameNode.getCommandFrameNodeContaining(node.parent) : undefined;\n    }\n}\n\nexport interface CommandEmptyNode extends LazyLoadableNode {\n    label: string;\n}\n\nexport namespace CommandEmptyNode {\n    export const GENERALIZED_TYPE = 'empty';\n\n    export function is(node: unknown): node is CommandEmptyNode {\n        return TreeNode.is(node) && node.id.endsWith('_empty');\n    }\n\n    export function getId(parent: CompositeTreeNode): string {\n        return `${parent.id}_empty`;\n    }\n\n    export function create(parent: CompositeTreeNode, load: CommandEmptyNode['load']): CommandEmptyNode {\n        return {\n            id: getId(parent),\n            label: 'Loading...',\n            parent,\n            load\n        };\n    }\n}\n\nexport interface CommandApiEventNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandApiEventNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandApiEventNode {\n    export const RESOURCE_TYPE = 'api-event';\n    export const GENERALIZED_TYPE = RESOURCE_TYPE;\n\n    export function is(node: TreeNode | undefined): node is CommandApiEventNode {\n        return ResourceTreeNode.hasResourceType(node, CommandApiEventNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEventId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex?: number\n    ): CommandApiEventNode {\n        const root = ctx.rootNode;\n        const node: CommandApiEventNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEventId,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex ?? ''}`,\n            parent,\n            resourceType: CommandApiEventNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId,\n            selected: false\n        };\n        // set debug marker data if node is a debug marker\n        if (element.debugLabelId) {\n            const labelData = root.resource.debugLabels[element.debugLabelId];\n            if (labelData) {\n                setDebugMarkerData(node, labelData);\n            }\n        }\n        return node;\n    }\n}\n\nexport interface CommandDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeDebugLabelGroupInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'debug-label-group';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDebugLabelGroupInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDebugLabelGroupInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDebugLabelGroupNode = {\n            id: getId(element, parent),\n            debugLabelInstanceId: element.labelId,\n            label: `${root.resource.functionNameLookup[element.functionNameId ?? -1] ?? '<not defined>'}`,\n            parent,\n            resourceType: CommandDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this debug label range\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this debug label group, add it to array\n            // - not self\n            // - only commands with same command buffer id\n            if (event && event.debugLabelId !== element.labelId && event.commandBufferInstanceId === element.commandBufferInstance) {\n                apiEventCommandArray.push(event);\n            }\n        }\n        // get array of debug label ranges with api event numbers within this debug label range\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this debug label range\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderPassInstance'\n        );\n        // get array of render subpass ranges with api event numbers within this debug label range\n        const renderSubpassInstances = createRangeInstanceArray(\n            element.renderSubpassInstanceIds,\n            root.resource.renderSubpassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderSubpassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this debug label range\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('subpassIndex' in rangeElement) {\n                    const renderSubpassInstanceNode = CommandRenderSubpassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderSubpassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            renderSubpassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for debug label group:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `debug label group ${element.labelId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelGroup>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'queue-debug-label-group';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelGroup, parent: CompositeTreeNode, instanceIndex: number): string {\n        return `${parent.id}_qdl_group_${element.labelId}_${instanceIndex}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelGroup,\n        parent: CompositeTreeNode,\n        children: (CommandQueueSubmitNode | CommandQueuePresentNode)[],\n        instanceIndex: number\n    ): CommandQueueDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelGroupNode = {\n            id: getId(element, parent, instanceIndex),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label Group',\n            queue: element.queue!,\n            parent,\n            resourceType: CommandQueueDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        // Update parent references for children since they were created with a different parent\n        // and are now being reparented to this debug label group node\n        for (const child of children) {\n            // Cast away readonly to update parent during node construction\n            (child as MutableParent).parent = node;\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelInsert>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    apiEventId: number;\n    resourceType: typeof CommandQueueDebugLabelNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelNode {\n    export const RESOURCE_TYPE = 'queue-debug-label';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelInsert, parent: CompositeTreeNode): string {\n        return `${parent.id}_qdl_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelInsert,\n        parent: CompositeTreeNode\n    ): CommandQueueDebugLabelNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelNode = {\n            id: getId(element, parent),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label',\n            queue: element.queue!,\n            apiEventId: element.apiEvent,\n            parent,\n            resourceType: CommandQueueDebugLabelNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandCommandBufferInstanceNode\n    extends ResourceTreeNode<CommandTreeCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    commandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandCommandBufferInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandCommandBufferInstanceNode {\n    export const RESOURCE_TYPE = 'command-buffer-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandCommandBufferInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandCommandBufferInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeCommandBufferInstance,\n        parent: CompositeTreeNode,\n        commandBufferIndex: number,\n        baseDynamicStatePromise?: Promise<DynamicStateEntry[]>\n    ): CommandCommandBufferInstanceNode {\n        const node: CommandCommandBufferInstanceNode = {\n            id: getId(element, parent),\n            commandBufferInstanceId: element.instanceId,\n            label: `Command Buffer ${commandBufferIndex}`,\n            parent,\n            resourceType: CommandCommandBufferInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this command buffer\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this command buffer, add it to array\n            // - omit commands that reference render pass id\n            // - if api event is a debug label, check the debug label itself for a render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                event.commandBufferInstanceId === element.instanceId &&\n                event.renderPassInstanceId === undefined &&\n                event.dynamicRenderPassInstanceId === undefined &&\n                (event.debugLabelId === undefined ||\n                    (debugLabel?.beginApiEvent === event.apiEventId &&\n                        debugLabel?.beginRenderPassInstance === undefined &&\n                        debugLabel?.beginDynamicRenderPassInstance === undefined) ||\n                    (debugLabel?.endApiEvent === event.apiEventId &&\n                        debugLabel?.endRenderPassInstance === undefined &&\n                        debugLabel?.endDynamicRenderPassInstance === undefined))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this command buffer\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this command buffer\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'RenderPassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this command buffer\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        const emptyDynamicStatePromise = new Promise<DynamicStateEntry[]>(resolve => resolve([]));\n        const effectiveBaseState = baseDynamicStatePromise ?? emptyDynamicStatePromise;\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            effectiveBaseState,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        effectiveBaseState\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for command buffer:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `command buffer ${commandBufferIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandSecondaryCommandBufferExecutionNode\n    extends ResourceTreeNode<CommandTreeSecondaryCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    parentCommandBufferInstanceId: number;\n    secondaryCommandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n}\n\nexport namespace CommandSecondaryCommandBufferExecutionNode {\n    export const RESOURCE_TYPE = 'secondary-command-buffer-execution';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: unknown): node is CommandSecondaryCommandBufferExecutionNode {\n        return (\n            ExpandableTreeNode.is(node) && SelectableTreeNode.is(node) && ResourceTreeNode.is(node, 'secondary-command-buffer-execution')\n        );\n    }\n\n    export function getId(element: CommandTreeSecondaryCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_secondary_${element.secondaryCommandBufferInstance}_${element.executionId}_${element.executionIndex}`;\n    }\n\n    export async function create(\n        ctx: CommandTreeContext,\n        elements: CommandTreeSecondaryCommandBufferInstance[],\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n        stateTracker?: DynamicStateTracker\n    ): Promise<CommandSecondaryCommandBufferExecutionNode> {\n        if (elements.length === 0) {\n            throw new Error('elements array must not be empty');\n        }\n        // Use the first element for the node's resource (they all share the same executionId and apiEvent)\n        const element = elements[0];\n        const node: CommandSecondaryCommandBufferExecutionNode = {\n            id: getId(element, parent),\n            parentCommandBufferInstanceId: element.parentCommandBufferInstance || 0,\n            secondaryCommandBufferInstanceId: element.secondaryCommandBufferInstance || 0,\n            label: `Secondary Command Buffer Execution ${commandIndex}`,\n            parent,\n            resourceType: 'secondary-command-buffer-execution',\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        createLazyLoadingNode(ctx.tree, node, async () => {\n            // Sort elements by executionIndex to maintain proper order\n            const sortedElements = [...elements].sort((a, b) => (a.executionIndex || 0) - (b.executionIndex || 0));\n\n            // Get device and check extensions\n            const firstSecondary = sortedElements[0]?.secondaryCommandBufferInstance;\n            let deviceExtensions: Set<string> | undefined;\n\n            if (firstSecondary !== undefined) {\n                const commandBufferInstance = root.resource.commandBufferInstances[firstSecondary];\n                const device = commandBufferInstance?.device;\n                if (typeof device === 'number') {\n                    deviceExtensions = ctx.deviceExtensions.get(device);\n                }\n            }\n\n            const hasInheritance = hasCommandBufferInheritance(deviceExtensions);\n            const hasViewportScissorOnly = hasInheritedViewportScissor(deviceExtensions) && !hasInheritance;\n\n            // Calculate effective base state for INHERITANCE INTO secondary\n            let effectiveBaseState: Promise<DynamicStateEntry[]>;\n            if (hasInheritance) {\n                effectiveBaseState = baseDynamicStatePromise;\n            } else if (hasViewportScissorOnly) {\n                effectiveBaseState = filterDynamicStateForViewportScissor(baseDynamicStatePromise);\n            } else {\n                effectiveBaseState = Promise.resolve([]);\n            }\n\n            // Create a CommandCommandBufferInstanceNode for each secondary command buffer in the execution\n            const childNodes: CommandCommandBufferInstanceNode[] = [];\n            sortedElements.forEach((secondaryInstance, index) => {\n                if (secondaryInstance.secondaryCommandBufferInstance) {\n                    const commandBufferInstance = root.resource.commandBufferInstances[secondaryInstance.secondaryCommandBufferInstance];\n                    if (commandBufferInstance) {\n                        const childNode = CommandCommandBufferInstanceNode.create(\n                            ctx,\n                            commandBufferInstance,\n                            node,\n                            index,\n                            effectiveBaseState\n                        );\n                        childNodes.push(childNode);\n                    } else {\n                        console.warn(\n                            `Command buffer instance ${secondaryInstance.secondaryCommandBufferInstance} ` +\n                                'not found in root.resource.commandBufferInstances'\n                        );\n                    }\n                }\n            });\n            CompositeTreeNode.addChildren(node, childNodes);\n\n            // Handle LEAK-BACK: Update parent's state tracker if extension is enabled\n            if (hasInheritance && stateTracker && element.executionId) {\n                const db = ctx.gfxrQueryBuilderService.builderFor(ctx.dbId);\n                const endStatePromise = querySecondaryCommandBufferEndDynamicState(db, [element.executionId]);\n                stateTracker.updateState(endStatePromise);\n            }\n        });\n\n        // Register for thumbnail updates\n        registerThumbnailUpdate(ctx, node, `secondary command buffer execution ${node.resource.executionId}`);\n        return node;\n    }\n}\n\nexport interface CommandQueueSubmitNode\n    extends ResourceTreeNode<CommandTreeQueueSubmit>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    submissionId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueSubmitNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueSubmitNode {\n    export const RESOURCE_TYPE = 'queue-submit';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueSubmitNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueSubmitNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueSubmit, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.submissionId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueSubmit,\n        parent: CompositeTreeNode,\n        queueSubmitIndex: number\n    ): CommandQueueSubmitNode {\n        const root = ctx.rootNode;\n        const node: CommandQueueSubmitNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            threadId: element.threadId || 0,\n            submissionId: element.submissionId,\n            label: `Queue Submit ${queueSubmitIndex}`,\n            queue: element.queue,\n            parent,\n            resourceType: CommandQueueSubmitNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        const children =\n            element.queueSubmitBuffers\n                ?.filter(b => b.commandBufferInstance)\n                .flatMap(b => {\n                    const instance = root.resource.commandBufferInstances[b.commandBufferInstance!];\n                    if (!instance) {\n                        console.warn(`CommandQueueSubmitNode.create: commandBufferInstance not found for id ${b.commandBufferInstance}`);\n                        return [];\n                    }\n                    return instance;\n                }) ?? [];\n        let commandBufferIndex = 0;\n        node.children = children.map(child => CommandCommandBufferInstanceNode.create(ctx, child, node, commandBufferIndex++));\n\n        registerThumbnailUpdate(ctx, node, `queue submit ${queueSubmitIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueuePresentNode extends ResourceTreeNode<CommandTreeQueuePresent>, SelectableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    resourceType: typeof CommandQueuePresentNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueuePresentNode {\n    export const RESOURCE_TYPE = 'queue-present';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueuePresentNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueuePresentNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueuePresent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEvent}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueuePresent,\n        parent: CompositeTreeNode,\n        queuePresentIndex: number\n    ): CommandQueuePresentNode {\n        const root = ctx.rootNode;\n        const node: CommandQueuePresentNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            label: `Queue Present ${queuePresentIndex}`,\n            parent,\n            resourceType: CommandQueuePresentNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            queue: element.queue,\n            selected: false\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureBuildNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureBuildInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    buildInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureBuildNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureBuildNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-build';\n    export const GENERALIZED_TYPE = 'acceleration-structure-build';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureBuildNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureBuildNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureBuildInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.buildApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureBuildInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureBuildNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureBuildNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            buildInstanceId: element.instanceId,\n            apiEventId: element.buildApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureBuildNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureCopyNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureCopyInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    copyInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureCopyNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureCopyNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-copy';\n    export const GENERALIZED_TYPE = 'acceleration-structure-copy';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureCopyNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureCopyNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureCopyInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.copyApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureCopyInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureCopyNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureCopyNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            copyInstanceId: element.instanceId,\n            apiEventId: element.copyApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureCopyNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandTransferCommandNode\n    extends ResourceTreeNode<CommandTreeTransferCommandInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    transferCommandInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandTransferCommandNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandTransferCommandNode {\n    export const RESOURCE_TYPE = 'transfer-command';\n    export const GENERALIZED_TYPE = 'transfer-command';\n\n    export function is(node: TreeNode | undefined): node is CommandTransferCommandNode {\n        return ResourceTreeNode.hasResourceType(node, CommandTransferCommandNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeTransferCommandInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.transferApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeTransferCommandInstance,\n        parent: CompositeTreeNode,\n        transferCommandIndex: number\n    ): CommandTransferCommandNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandTransferCommandNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            transferCommandInstanceId: element.instanceId,\n            apiEventId: element.transferApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${transferCommandIndex}`,\n            parent,\n            resourceType: CommandTransferCommandNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nfunction setThumbnailUrl(\n    ctx: CommandTreeContext,\n    resources: ApiResources[],\n    node: TreeNode & { thumbnail?: string },\n    requesterDbgName: string\n): void {\n    if (resources.length > 0) {\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        ctx.screenshotService.requestScreenshots({\n            profileOrReplay: replay ?? ctx.profile,\n            scale: placeholderScale,\n            screenshotType: ScreenshotType.API_EVENT,\n            requestData: resources,\n            moreRequests: true,\n            requesterDbgName,\n            options: {\n                DumpDepth: true\n            },\n            onScreenshotReady: result => {\n                if (result.resultData.resultType === ScreenshotType.API_EVENT && DrawApiResult.is(result.resultData.apiResult)) {\n                    const images = [...(result.resultData.apiResult.colorAttachments || [])];\n                    if (result.resultData.apiResult.depthAttachment) {\n                        images.push(result.resultData.apiResult.depthAttachment);\n                    }\n                    if (images.length > 0) {\n                        const possibleImage = images[0].subresources?.[0];\n                        if (possibleImage) {\n                            if (usesCompressionExtension(possibleImage.file)) {\n                                // Use VkImageConversionService to get a png\n                                // Do the same as the else case, but with the new png file\n                                const format = lookupResourceFormat(images[0].format);\n                                if (UncompressedResourceFormat.is(format)) {\n                                    ctx.fileService\n                                        .read(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString(), {\n                                            uncompressedSize: possibleImage.size\n                                        })\n                                        .then(async content => {\n                                            const extractedData = await extractData(format, content);\n                                            const dim = {\n                                                width: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[0]\n                                                    : possibleImage.dimensions[0] * placeholderScale,\n                                                height: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[1]\n                                                    : possibleImage.dimensions[1] * placeholderScale\n                                            };\n                                            const conversionResult = await convertDataToImageData(extractedData, format, dim, {\n                                                channelOptions: { alpha: { disabled: true } }\n                                            });\n                                            const png = new PNG({\n                                                width: conversionResult.dimensions.width,\n                                                height: conversionResult.dimensions.height\n                                            });\n                                            png.data = conversionResult.data;\n                                            const pngBuffer = PNG.sync.write(png);\n                                            node.thumbnail = `data:image/png;base64, ${pngBuffer.toString('base64')}`;\n                                            void ctx.tree.refresh(node.parent);\n                                        })\n                                        .catch(reason => {\n                                            const error = asError(reason);\n                                            console.error(error);\n                                        });\n                                }\n                            } else {\n                                ctx.imageAccessorService\n                                    .accessImage(new URL(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString()))\n                                    .then(url => {\n                                        node.thumbnail = url.url.toString();\n                                        ctx.tree.addToDispose(url);\n                                        void ctx.tree.refresh(node.parent);\n                                    })\n                                    .catch(reason => {\n                                        const error = asError(reason);\n                                        console.error(error);\n                                    });\n                            }\n                        }\n                    }\n                }\n            },\n            onRequestComplete: (result, message) => {\n                if (!result) {\n                    console.error(message);\n                }\n            }\n        });\n    }\n}\n\n/**\n * Registers a thumbnail update callback that triggers on the node's first render.\n * When triggered, finds the last draw instance and requests a screenshot for it.\n *\n * @param ctx - Command tree context\n * @param node - Node to register thumbnail update for\n * @param descriptionContext - Description for the requester debug name (e.g., \"render pass 5\", \"dynamic render pass\")\n */\nfunction registerThumbnailUpdate(\n    ctx: CommandTreeContext,\n    node: CommandTreeNode & { thumbnail?: string },\n    descriptionContext: string\n): void {\n    const updateThumbnail = (): void => {\n        const lastDraw = findLastDrawInstanceNode(node);\n        if (lastDraw) {\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', updateThumbnail);\n            const requesterDbgName = `Command tree ${descriptionContext} last draw: ${lastDraw.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(lastDraw), node, requesterDbgName);\n        }\n    };\n    SokatoaLifecycleTreeNode.register(node, 'onWillRender', updateThumbnail);\n}\n\nexport interface CommandRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    renderPassInstanceId: number;\n    renderPassId?: number;\n    renderSubpassEventIds: number[];\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderPassInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.instanceId,\n            renderPassId: element.renderPass,\n            renderSubpassEventIds: [],\n            label: `Render Pass ${element.passIndex}`,\n            parent,\n            resourceType: CommandRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        // A render pass will only contain render subpasses and will always contain at least one subpass\n        const renderSubpassInstances = element.renderSubpassInstanceIds.flatMap(id => {\n            const instance = root.resource.renderSubpassInstances[id];\n            if (!instance) {\n                console.warn(`CommandRenderPassInstanceNode.create: renderSubpassInstance not found for id ${id}`);\n                return [];\n            }\n            return instance;\n        });\n        renderSubpassInstances.forEach(subpass => {\n            if (subpass.beginApiEvent !== node.resource.beginApiEvent) {\n                node.renderSubpassEventIds.push(subpass.beginApiEvent);\n            }\n        });\n        node.children.push(\n            ...renderSubpassInstances.map(instance => {\n                const subpassNode = CommandRenderSubpassInstanceNode.create(ctx, instance, node, baseDynamicStatePromise);\n                return subpassNode;\n            })\n        );\n\n        registerThumbnailUpdate(ctx, node, `render pass ${node.renderPassId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandRenderSubpassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderSubpassInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    renderPassInstanceId: number;\n    renderSubpassInstanceId: number;\n    renderSubpassIndex: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderSubpassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderSubpassInstanceNode {\n    export const RESOURCE_TYPE = 'render-subpass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderSubpassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderSubpassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderSubpassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderSubpassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderSubpassInstanceNode {\n        const node: CommandRenderSubpassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.renderPassInstance,\n            renderSubpassInstanceId: element.instanceId,\n            renderSubpassIndex: element.subpassIndex,\n            label: `Subpass ${element.subpassIndex}`,\n            parent,\n            resourceType: CommandRenderSubpassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this render subpass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference render subpass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a render subpass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.renderSubpassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginRenderSubpassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endRenderSubpassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this render subpass\n        const debugLabelGroupInstances = {\n            array: element.debugLabelGroupInstanceIds.flatMap(id => {\n                const result = root.resource.debugLabelGroupInstances[id];\n                if (!result) {\n                    console.warn(`Missing debugLabelGroupInstances for ${id}.`);\n                    return [];\n                }\n                return result;\n            }),\n            getSortNumber: (debugLabelGroupInstance: CommandTreeDebugLabelGroupInstance) => debugLabelGroupInstance.beginApiEvent\n        };\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'render subpass');\n\n        return node;\n    }\n}\n\nexport interface CommandDynamicRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeDynamicRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    dynamicRenderPassInstanceId: number;\n    dynamicRenderPassId?: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDynamicRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'dynamic-render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDynamicRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDynamicRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDynamicRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDynamicRenderPassInstanceNode {\n        const node: CommandDynamicRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dynamicRenderPassInstanceId: element.instanceId,\n            label: `Dynamic Render Pass ${element.dynamicPassIndex}`,\n            parent,\n            resourceType: CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this dynamic render pass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this dynamic render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference dynamic render pass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a dynamic render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.dynamicRenderPassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginDynamicRenderPassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endDynamicRenderPassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this dynamic render pass\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDynamicRenderPassInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'dynamic render pass');\n\n        return node;\n    }\n}\n\nasync function createChildEventNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    stateTracker: DynamicStateTracker\n): Promise<number> {\n    let endCommandIndex = commandIndex;\n    const baseDynamicStatePromise = stateTracker.getCurrentState();\n\n    if (command.secondaryCommandBufferExecutionId) {\n        // Look up the execution to get the apiEvent, which is the key for secondaryCommandBufferInstances\n        const execution = root.resource.secondaryCommandBufferExecutions[command.secondaryCommandBufferExecutionId];\n        if (execution) {\n            const secondaryInstances = root.resource.secondaryCommandBufferInstances[execution.apiEvent];\n            if (secondaryInstances && secondaryInstances.length > 0) {\n                const node = await CommandSecondaryCommandBufferExecutionNode.create(\n                    ctx,\n                    secondaryInstances,\n                    parentNode,\n                    endCommandIndex++,\n                    baseDynamicStatePromise,\n                    stateTracker\n                );\n                parentNode.children.push(node);\n            }\n        }\n    } else {\n        endCommandIndex = createDrawOrDispatchChildNode(ctx, command, root, parentNode, commandIndex, baseDynamicStatePromise);\n    }\n    return endCommandIndex;\n}\n\nfunction createDrawOrDispatchChildNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n): number {\n    let currentCommandIndex = commandIndex;\n    let accelerationStructureBuildIndex = 0;\n    let accelerationStructureCopyIndex = 0;\n    if (command) {\n        if (command.drawInstanceId && root.resource.drawInstances[command.drawInstanceId]) {\n            parentNode.children.push(\n                CommandDrawInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.dispatchInstanceId && root.resource.dispatchInstances[command.dispatchInstanceId]) {\n            parentNode.children.push(\n                CommandDispatchInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.meshTaskInstanceId && root.resource.meshTaskInstances[command.meshTaskInstanceId]) {\n            parentNode.children.push(\n                CommandMeshTaskInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.clusterInstanceId && root.resource.clusterInstances[command.clusterInstanceId]) {\n            parentNode.children.push(\n                CommandClusterInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.raytracingInstanceId && root.resource.raytracingInstances[command.raytracingInstanceId]) {\n            parentNode.children.push(\n                CommandRaytracingInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (\n            command.accelerationStructureBuildInstanceId &&\n            root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureBuildNode.create(\n                    root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]!,\n                    parentNode,\n                    accelerationStructureBuildIndex++\n                )\n            );\n        } else if (\n            command.accelerationStructureCopyInstanceId &&\n            root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureCopyNode.create(\n                    root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]!,\n                    parentNode,\n                    accelerationStructureCopyIndex++\n                )\n            );\n        } else if (command.transferCommandInstanceId && root.resource.transferCommands[command.transferCommandInstanceId]) {\n            parentNode.children.push(\n                CommandTransferCommandNode.create(\n                    root.resource.transferCommands[command.transferCommandInstanceId]!,\n                    parentNode,\n                    currentCommandIndex++\n                )\n            );\n        } else if (command.debugLabelId && root.resource.debugLabels[command.debugLabelId]) {\n            // Only add debug label nodes if this is the BEGIN event (not END event)\n            // The END event has debugLabelId set but should not create a node\n            const debugLabel = root.resource.debugLabels[command.debugLabelId];\n            if (debugLabel && debugLabel.beginApiEvent === command.apiEventId) {\n                // Check if this is a group (has both begin and end and they differ) or just an insert\n                if (debugLabel.endApiEvent && debugLabel.beginApiEvent !== debugLabel.endApiEvent) {\n                    // This is a debug label group - it should be handled by the range processing logic\n                    // Don't create any node here, just skip it\n                    // (The group will be created if it's in debugLabelGroupInstances, or omitted if it crosses boundaries)\n                } else {\n                    // This is a debug label insert - create as simple API event node\n                    parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode));\n                }\n            }\n        } else if (command.commandInstanceId && root.resource.commandInstances[command.commandInstanceId]) {\n            parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode, currentCommandIndex++));\n        }\n    }\n    return currentCommandIndex;\n}\n\nexport interface CommandDrawInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    drawInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDrawInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandDrawInstanceNode {\n    export const RESOURCE_TYPE = 'draw-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDrawInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDrawInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_draw_${element.drawInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDrawInstanceNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDrawInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            drawInstanceId: element.drawInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDrawInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query draw instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n            const requesterDbgName = `Command draw instance ${node.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(node), node, requesterDbgName);\n        });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDrawInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const drawInstanceDynamicStatePromise = batchQuery\n                ? queryDrawInstanceDynamicStateBatched(db, [node.resource.drawInstanceId || 0])\n                : queryDrawInstanceDynamicState(db, [node.resource.drawInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                drawInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.GRAPHICS\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandDispatchInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    dispatchInstanceId: number;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandDispatchInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n    thumbnail?: string;\n}\n\nexport namespace CommandDispatchInstanceNode {\n    export const RESOURCE_TYPE = 'dispatch-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDispatchInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDispatchInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_dispatch_${element.dispatchInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDispatchInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandDispatchInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dispatchInstanceId: element.dispatchInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDispatchInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query dispatch instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for dispatch nodes\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command dispatch instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDispatchInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const dispatchInstanceDynamicStatePromise = batchQuery\n                ? queryDispatchInstanceDynamicStateBatched(db, [node.resource.dispatchInstanceId || 0])\n                : queryDispatchInstanceDynamicState(db, [node.resource.dispatchInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                dispatchInstanceDynamicStatePromise,\n                PipelineBindPoint.COMPUTE,\n                PipelineBindPointShaderStageFlags.COMPUTE\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandMeshTaskInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    meshTaskInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandMeshTaskInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandMeshTaskInstanceNode {\n    export const RESOURCE_TYPE = 'mesh-task-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandMeshTaskInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandMeshTaskInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_meshtask_${element.meshTaskInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandMeshTaskInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandMeshTaskInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            meshTaskInstanceId: element.meshTaskInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandMeshTaskInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query mesh instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for mesh task dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command mesh instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandMeshTaskInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const meshTaskInstanceDynamicStatePromise = batchQuery\n                ? queryMeshTaskInstanceDynamicStateBatched(db, [node.resource.meshTaskInstanceId || 0])\n                : queryMeshTaskInstanceDynamicState(db, [node.resource.meshTaskInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                meshTaskInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.TASK_MESH\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandClusterInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    clusterInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandClusterInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandClusterInstanceNode {\n    export const RESOURCE_TYPE = 'cluster-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandClusterInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandClusterInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_cluster_${element.clusterInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandClusterInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandClusterInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            clusterInstanceId: element.clusterInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandClusterInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query cluster instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for cluster dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command cluster instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandClusterInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const clusterInstanceDynamicStatePromise = batchQuery\n                ? queryClusterInstanceDynamicStateBatched(db, [node.resource.clusterInstanceId || 0])\n                : queryClusterInstanceDynamicState(db, [node.resource.clusterInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                clusterInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.CLUSTER\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandRaytracingInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    raytracingInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandRaytracingInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandRaytracingInstanceNode {\n    export const RESOURCE_TYPE = 'raytracing-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandRaytracingInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRaytracingInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_raytracing_${element.raytracingInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRaytracingInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRaytracingInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            raytracingInstanceId: element.raytracingInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandRaytracingInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query raytracing instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for raytracing dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command raytracing instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandRaytracingInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const raytracingInstanceDynamicStatePromise = batchQuery\n                ? queryRaytracingInstanceDynamicStateBatched(db, [node.resource.raytracingInstanceId || 0])\n                : queryRaytracingInstanceDynamicState(db, [node.resource.raytracingInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                raytracingInstanceDynamicStatePromise,\n                PipelineBindPoint.RAY_TRACING,\n                PipelineBindPointShaderStageFlags.RAY_TRACING\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport function getQueueSubmitId(node: CommandTreeNode): number | undefined {\n    let currentNode: CompositeTreeNode | undefined;\n    if (\n        CommandEmptyNode.is(node) ||\n        CommandApiEventNode.is(node) ||\n        CommandTreeDrawOrDispatchNode.is(node) ||\n        CommandAccelerationStructureBuildNode.is(node) ||\n        CommandAccelerationStructureCopyNode.is(node) ||\n        CommandTransferCommandNode.is(node)\n    ) {\n        currentNode = node.parent;\n    } else if (CommandQueuePresentNode.is(node) || CommandQueueDebugLabelNode.is(node)) {\n        return undefined;\n    } else {\n        currentNode = node;\n    }\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(currentNode, CommandQueueSubmitNode.is);\n    return queueSubmitNode ? queueSubmitNode.resource.submissionId : undefined;\n}\n\nexport function findLastDrawInstanceNode(node: CommandTreeNode): CommandDrawInstanceNode | undefined {\n    if (CommandDrawInstanceNode.is(node)) {\n        return node;\n    }\n    let lastDraw: CommandDrawInstanceNode | undefined;\n    if (!CommandDrawInstanceNode.is(node) && ExpandableTreeNode.is(node)) {\n        for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n            lastDraw = findLastDrawInstanceNode(node.children[commandIndex]);\n            if (lastDraw) {\n                break;\n            }\n        }\n    }\n    return lastDraw;\n}\n\nexport function createExecuteCommandsApiResources(\n    node: CommandSecondaryCommandBufferExecutionNode,\n    primaryNode: CommandCommandBufferInstanceNode,\n    queueSubmitNode: CommandQueueSubmitNode,\n    specificSecondaryCommandBufferBeginId?: number // If provided, only include this specific secondary CB\n): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    // findParentNode checks the given node for its type so we have to start looking from this node's parent\n    // otherwise we run into infinite recursion\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node.parent,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n\n    // Collect secondary command buffer begin IDs from the children\n    const commandBufferBeginIds: number[] = [];\n    if (specificSecondaryCommandBufferBeginId !== undefined) {\n        // Only include the specific secondary CB that was requested\n        commandBufferBeginIds.push(specificSecondaryCommandBufferBeginId);\n    } else {\n        // Include all secondary CBs (for when the execution node itself requests a thumbnail)\n        for (const child of node.children) {\n            if (CommandCommandBufferInstanceNode.is(child)) {\n                commandBufferBeginIds.push(child.resource.beginApiEvent);\n            }\n        }\n    }\n\n    const resources: ApiResources[] = [];\n    if (secondaryCommandBufferExecutionNode) {\n        const renderpassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n            renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n            CommandSecondaryCommandBufferExecutionNode.is\n        );\n\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: secondaryCommandBufferExecutionNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n                renderpassSecondaryCommandBufferExecutionNode &&\n                renderpassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n        const executionResources = createExecuteCommandsApiResources(secondaryCommandBufferExecutionNode, primaryNode, queueSubmitNode);\n        if (executionResources.length > 0) {\n            resources.push(...executionResources);\n        }\n    } else {\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: primaryNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                renderPassInstanceNode || dynamicRenderPassInstanceNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n    }\n    return resources;\n}\n\nexport function createDrawApiResources(node: CommandDrawInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    // This will find the immediate parent command buffer (secondary if in a secondary CB, primary otherwise)\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n\n    const resources: ApiResources[] = [];\n    if (\n        (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n        queueSubmitNode &&\n        commandBufferInstanceNode &&\n        primaryCommandBufferInstanceNode\n    ) {\n        if (secondaryCommandBufferExecutionNode) {\n            const renderPassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n                CommandSecondaryCommandBufferExecutionNode.is\n            );\n\n            // Add draw resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses:\n                    renderPassSecondaryCommandBufferExecutionNode &&\n                    renderPassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                        ? [\n                              {\n                                  beginId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                                  subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                                  endId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                        dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                              }\n                          ]\n                        : []\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses: [\n                    {\n                        beginId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                        subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                        endId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.endApiEvent || dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                    }\n                ]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createComputeApiResources(node: CommandDispatchInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add dispatch resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createTraceRaysApiResources(node: CommandRaytracingInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTransferNode = CommandAccelerationStructureBuildNode | CommandAccelerationStructureCopyNode | CommandTransferCommandNode;\n\nexport function createTransferApiResources(node: CommandTransferNode): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    let transferEvent: number = 0;\n    if (CommandAccelerationStructureBuildNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureBuildNode).resource.buildApiEvent;\n    } else if (CommandAccelerationStructureCopyNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureCopyNode).resource.copyApiEvent;\n    } else if (CommandTransferCommandNode.is(node)) {\n        transferEvent = (node as CommandTransferCommandNode).resource.transferApiEvent;\n    }\n\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTreeNode =\n    | CommandFrameNode\n    | CommandEmptyNode\n    | CommandApiEventNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandQueuePresentNode\n    | CommandQueueDebugLabelGroupNode\n    | CommandQueueDebugLabelNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandEmptyNode.is(node) ||\n            CommandApiEventNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandQueuePresentNode.is(node) ||\n            CommandQueueDebugLabelGroupNode.is(node) ||\n            CommandQueueDebugLabelNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n\n    export function findApiEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandSecondaryCommandBufferExecutionNode.is(current)) {\n            // For secondary command buffer execution nodes, return the VkCmdExecuteCommands apiEvent\n            // rather than the VkCommandBufferBegin apiEvent\n            return current.resource.apiEvent;\n        } else if (CommandTreeRangeNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (\n            CommandApiEventNode.is(current) ||\n            CommandQueueSubmitNode.is(current) ||\n            CommandQueuePresentNode.is(current) ||\n            CommandQueueDebugLabelNode.is(current)\n        ) {\n            return current.apiEventId;\n        } else if (CommandQueueDebugLabelGroupNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (CommandAccelerationStructureBuildNode.is(current)) {\n            return current.resource.buildApiEvent;\n        } else if (CommandAccelerationStructureCopyNode.is(current)) {\n            return current.resource.copyApiEvent;\n        } else if (CommandTransferCommandNode.is(current)) {\n            return current.apiEventId;\n        } else if (CommandTreeDrawOrDispatchNode.is(current)) {\n            return current.resource.apiEventId;\n        }\n        return undefined;\n    }\n\n    export function findFilterEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandFrameNode.is(current)) {\n            return current.resource.beginApiEvent;\n        }\n        let maybeQueueSubmitOrPresent: TreeNode | undefined = current;\n        while (\n            maybeQueueSubmitOrPresent !== undefined &&\n            !(\n                CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueuePresentNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)\n            )\n        ) {\n            maybeQueueSubmitOrPresent = maybeQueueSubmitOrPresent.parent;\n        }\n        let queueSubmitEventId: number | undefined;\n        if (maybeQueueSubmitOrPresent !== undefined) {\n            if (CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) || CommandQueuePresentNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            } else if (CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.resource.beginApiEvent;\n            } else if (CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            }\n        }\n        return queueSubmitEventId;\n    }\n\n    export function findRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const renderPassNode = findParentNode<CommandRenderPassInstanceNode>(current, CommandRenderPassInstanceNode.is);\n        return renderPassNode ? renderPassNode.renderPassInstanceId : undefined;\n    }\n\n    export function findDynamicRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const dynamicRenderPassNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n            current,\n            CommandDynamicRenderPassInstanceNode.is\n        );\n        return dynamicRenderPassNode ? dynamicRenderPassNode.dynamicRenderPassInstanceId : undefined;\n    }\n\n    export function findDrawInstanceId(current?: CommandTreeNode): number | undefined {\n        const drawInstanceNode = findParentNode<CommandDrawInstanceNode>(current, CommandDrawInstanceNode.is);\n        return drawInstanceNode ? drawInstanceNode.drawInstanceId : undefined;\n    }\n\n    export function findDispatchInstanceId(current?: CommandTreeNode): number | undefined {\n        const dispatchInstanceNode = findParentNode<CommandDispatchInstanceNode>(current, CommandDispatchInstanceNode.is);\n        return dispatchInstanceNode ? dispatchInstanceNode.dispatchInstanceId : undefined;\n    }\n\n    export function findMeshTaskInstanceId(current?: CommandTreeNode): number | undefined {\n        const meshTaskInstanceNode = findParentNode<CommandMeshTaskInstanceNode>(current, CommandMeshTaskInstanceNode.is);\n        return meshTaskInstanceNode ? meshTaskInstanceNode.meshTaskInstanceId : undefined;\n    }\n\n    export function findClusterInstanceId(current?: CommandTreeNode): number | undefined {\n        const clusterInstanceNode = findParentNode<CommandClusterInstanceNode>(current, CommandClusterInstanceNode.is);\n        return clusterInstanceNode ? clusterInstanceNode.clusterInstanceId : undefined;\n    }\n\n    export function findRaytracingInstanceId(current?: CommandTreeNode): number | undefined {\n        const raytracingInstanceNode = findParentNode<CommandRaytracingInstanceNode>(current, CommandRaytracingInstanceNode.is);\n        return raytracingInstanceNode ? raytracingInstanceNode.raytracingInstanceId : undefined;\n    }\n\n    export function findAccelerationBuildInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelBuildNode = findParentNode<CommandAccelerationStructureBuildNode>(current, CommandAccelerationStructureBuildNode.is);\n        return accelBuildNode ? accelBuildNode.buildInstanceId : undefined;\n    }\n\n    export function findAccelerationCopyInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelCopyNode = findParentNode<CommandAccelerationStructureCopyNode>(current, CommandAccelerationStructureCopyNode.is);\n        return accelCopyNode ? accelCopyNode.copyInstanceId : undefined;\n    }\n\n    export function findTransferCommandInstanceId(current?: CommandTreeNode): number | undefined {\n        const transferCommandNode = findParentNode<CommandTransferCommandNode>(current, CommandTransferCommandNode.is);\n        return transferCommandNode ? transferCommandNode.transferCommandInstanceId : undefined;\n    }\n\n    export function findMergedDynamicStatePromise(\n        current: CommandTreeNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> | undefined {\n        let maybeDrawOrDispatchInstance: TreeNode | undefined = current;\n        while (maybeDrawOrDispatchInstance !== undefined && !CommandTreeDrawOrDispatchNode.is(maybeDrawOrDispatchInstance)) {\n            maybeDrawOrDispatchInstance = maybeDrawOrDispatchInstance.parent;\n        }\n        let mergedDynamicStatePromise: Promise<DynamicStateEntry[]> | undefined;\n        if (maybeDrawOrDispatchInstance !== undefined && CommandDrawInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDrawInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandDispatchInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDispatchInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandMeshTaskInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandMeshTaskInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandClusterInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandClusterInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandRaytracingInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandRaytracingInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        }\n        return mergedDynamicStatePromise;\n    }\n\n    export function getRoot(node?: CompositeTreeNode | CommandRootNode | CommandTreeNode): CommandRootNode | undefined {\n        return findParentNode<CommandRootNode>(node, CommandRootNode.is);\n    }\n\n    export function getDbId(node: CommandRootNode | CommandTreeNode): number {\n        return getRoot(node)?.dbId ?? -1;\n    }\n\n    type GeneralizableNodes =\n        | typeof CommandApiEventNode\n        | typeof CommandClusterInstanceNode\n        | typeof CommandCommandBufferInstanceNode\n        | typeof CommandDispatchInstanceNode\n        | typeof CommandDrawInstanceNode\n        | typeof CommandEmptyNode\n        | typeof CommandFrameNode\n        | typeof CommandMeshTaskInstanceNode\n        | typeof CommandQueuePresentNode\n        | typeof CommandQueueSubmitNode\n        | typeof CommandQueueDebugLabelGroupNode\n        | typeof CommandQueueDebugLabelNode\n        | typeof CommandAccelerationStructureBuildNode\n        | typeof CommandAccelerationStructureCopyNode\n        | typeof CommandTransferCommandNode\n        | typeof CommandRaytracingInstanceNode\n        | typeof CommandRenderPassInstanceNode\n        | typeof CommandRenderSubpassInstanceNode\n        | typeof CommandDynamicRenderPassInstanceNode\n        | typeof CommandDebugLabelGroupNode;\n\n    /**\n     * An aggregate type label for command-tree nodes, roughly corresponding to some of the union\n     * types defined in this module.\n     */\n    export type GeneralizedType = GeneralizableNodes['GENERALIZED_TYPE'];\n\n    /**\n     * Query the generalized type of a given node, if it is a Command Tree node.\n     *\n     * @param node a tree node that may or may not be a `CommandTreeNode`\n     * @return its generalized type, or `undefined` if it isn't a `CommandTreeNode`\n     */\n    export function getGeneralizedNodeType(node: TreeNode): GeneralizedType | undefined {\n        const resourceType = 'resourceType' in node ? node.resourceType : undefined;\n        if (!resourceType) {\n            return CommandEmptyNode.is(node) ? 'empty' : undefined;\n        }\n\n        switch (resourceType) {\n            case 'frame':\n            case 'command-buffer-instance':\n            case 'render-pass-instance':\n            case 'render-subpass-instance':\n            case 'secondary-command-buffer-execution':\n            case 'debug-label-group':\n                return 'range';\n            case 'queue-submit':\n            case 'queue-present':\n                return 'queue';\n            case 'acceleration-structure-build':\n                return 'acceleration-structure-build';\n            case 'acceleration-structure-copy':\n                return 'acceleration-structure-copy';\n            case 'transfer-command':\n                return 'transfer-command';\n            case 'draw-instance':\n            case 'dispatch-instance':\n            case 'mesh-task-instance':\n            case 'cluster-instance':\n            case 'raytracing-instance':\n                return 'draw-or-dispatch';\n            case 'api-event':\n                return 'api-event';\n            default:\n                return undefined;\n        }\n    }\n\n    /** Type assertion for a range-type node. */\n    export function generalize(node: TreeNode, type: 'range'): asserts node is CommandTreeRangeNode;\n    /** Type assertion for a queue-type node. */\n    export function generalize(node: TreeNode, type: 'queue'): asserts node is CommandQueueSubmitNode | CommandQueuePresentNode;\n    /** Type assertion for a queue-debug-label-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'queue-debug-label'\n    ): asserts node is CommandQueueDebugLabelGroupNode | CommandQueueDebugLabelNode;\n    /** Type assertion for a acceleration-structure-build-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-build'): asserts node is CommandAccelerationStructureBuildNode;\n    /** Type assertion for a acceleration-structure-copy-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-copy'): asserts node is CommandAccelerationStructureCopyNode;\n    /** Type assertion for a transfer-command-type node. */\n    export function generalize(node: TreeNode, type: 'transfer-command'): asserts node is CommandTransferCommandNode;\n    /** Type assertion for a draw-or-dispatch-type node. */\n    export function generalize(node: TreeNode, type: 'draw-or-dispatch'): asserts node is CommandTreeDrawOrDispatchNode;\n    /** Type assertion for an api-event-type node. */\n    export function generalize(node: TreeNode, type: 'api-event'): asserts node is CommandApiEventNode;\n    /** Type assertion for a draw-or-dispatch- or api-event-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'draw-or-dispatch' | 'api-event'\n    ): asserts node is CommandTreeDrawOrDispatchNode | CommandApiEventNode;\n    /** Type assertion for an empty-type node. */\n    export function generalize(node: TreeNode, type: 'empty'): asserts node is CommandEmptyNode;\n    export function generalize(node: TreeNode, _type: GeneralizedType): asserts node is CommandTreeNode {\n        // Pass\n    }\n}\n\nexport type CommandTreeRangeNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeRangeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeRangeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n}\n\nexport type CommandTreeDrawOrDispatchNode =\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode;\n\nexport namespace CommandTreeDrawOrDispatchNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeDrawOrDispatchNode {\n        return (\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node)\n        );\n    }\n}\n\ninterface ArrayWithSortNumber<RangeType> {\n    array: RangeType[];\n    getSortNumber(element: RangeType): number;\n}\n\ntype AllRangeTypes =\n    | CommandTreeDebugLabelGroupInstance\n    | CommandTreeRenderPassInstance\n    | CommandTreeRenderSubpassInstance\n    | CommandTreeDynamicRenderPassInstance;\n\ntype CommandTreeRangeParentNode =\n    | CommandRenderPassInstanceNode\n    | CommandCommandBufferInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandDebugLabelGroupNode;\n\nfunction findNextRangeElementToProcess<RangeType>(...arrays: ArrayWithSortNumber<RangeType>[]): RangeType | undefined {\n    // designate which array is the api event array vs a range array\n    // when processing a range, shift off any api events that are within the range\n    // so they aren't processed (because they actually reside within a sub-group)\n\n    const arraysToProcess: ArrayWithSortNumber<RangeType>[] = [];\n    arrays.forEach(arr => {\n        if (arr.array.length) {\n            arraysToProcess.push(arr);\n        }\n    });\n\n    if (!arraysToProcess.length) {\n        return undefined;\n    }\n\n    // get the sort number of the first element of each array and sort them\n    const sortedElements = arraysToProcess\n        .map(array => ({ subarray: array.array, sortNumber: array.getSortNumber(array.array[0]) }))\n        .sort((a, b) => a.sortNumber - b.sortNumber);\n\n    return sortedElements[0].subarray.shift();\n}\n\n/**\n * Process commands and ranges together in API event order.\n * For each range element, creates child nodes for commands that come before it,\n * skips commands that fall within the range, and creates a node for the range itself.\n * After processing all ranges, any remaining commands are processed.\n *\n * @param ctx - Command tree context\n * @param root - Root node\n * @param parentNode - Parent node to add children to\n * @param apiEventCommandArray - Array of commands sorted by API event ID (will be mutated)\n * @param childCommandIndex - Starting index for child commands\n * @param baseDynamicStatePromise - Promise for dynamic state\n * @param createRangeNode - Callback to create a node for each range element\n * @param rangeArrays - Variable number of range arrays to process together\n * @returns The final child command index\n */\nasync function createChildEventNodesForRange<RangeType extends { beginApiEvent: number; endApiEvent?: number }>(\n    ctx: CommandTreeContext,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    apiEventCommandArray: CommandTreeApiEvent[],\n    childCommandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n    createRangeNode: (rangeElement: RangeType, parentNode: CommandTreeRangeParentNode) => void,\n    ...rangeArrays: ArrayWithSortNumber<RangeType>[]\n): Promise<number> {\n    const stateTracker = new DynamicStateTracker(baseDynamicStatePromise);\n    let nextRangeElement: RangeType | undefined;\n    let priorRangeEndApiEvent: number | undefined;\n\n    while ((nextRangeElement = findNextRangeElementToProcess<RangeType>(...rangeArrays))) {\n        // create a node for any command that comes BEFORE the next range element\n        while (apiEventCommandArray.length && apiEventCommandArray[0].apiEventId < nextRangeElement.beginApiEvent) {\n            const command = apiEventCommandArray.shift();\n            childCommandIndex = await createChildEventNode(ctx, command!, root, parentNode, childCommandIndex, stateTracker);\n        }\n\n        // shift off any command that falls WITHIN next range since it will be processed when creating next range node\n        while (\n            apiEventCommandArray.length &&\n            nextRangeElement.endApiEvent !== undefined &&\n            apiEventCommandArray[0].apiEventId >= nextRangeElement.beginApiEvent &&\n            apiEventCommandArray[0].apiEventId <= nextRangeElement.endApiEvent\n        ) {\n            apiEventCommandArray.shift();\n        }\n\n        // skip next range if it falls within the prior range since it will be processed when creating prior range node\n        if (\n            priorRangeEndApiEvent !== undefined &&\n            nextRangeElement.endApiEvent !== undefined &&\n            nextRangeElement.endApiEvent <= priorRangeEndApiEvent\n        ) {\n            continue;\n        }\n        priorRangeEndApiEvent = nextRangeElement.endApiEvent;\n\n        // create a node for the next range element\n        createRangeNode(nextRangeElement, parentNode);\n    }\n\n    // process any remaining command elements after all range elements have been processed\n    for (const command of apiEventCommandArray) {\n        childCommandIndex = await createChildEventNode(ctx, command, root, parentNode, childCommandIndex, stateTracker);\n    }\n\n    return childCommandIndex;\n}\n\n/**\n * Find node from descendent node for which isNode is true\n */\nexport const findParentNode = <T extends TreeNode>(\n    node: TreeNode | undefined,\n    isNode: (node: TreeNode | undefined) => node is T\n): T | undefined => {\n    let targetNode: TreeNode | undefined = node;\n    while (targetNode && targetNode.parent && !isNode(targetNode)) {\n        targetNode = targetNode.parent;\n    }\n\n    return targetNode && isNode(targetNode) ? targetNode : undefined;\n};\n\n/**\n * Find the primary command buffer instance node from a given command buffer instance node.\n * If the given node is in a secondary command buffer, traverses up through nested secondary\n * command buffers until finding the primary command buffer (one with no parent execution node).\n * If the given node is already in a primary command buffer, returns it as-is.\n */\nexport const findPrimaryCommandBufferInstanceNode = (\n    commandBufferInstanceNode: CommandCommandBufferInstanceNode | undefined,\n    secondaryCommandBufferExecutionNode: CommandSecondaryCommandBufferExecutionNode | undefined\n): CommandCommandBufferInstanceNode | undefined => {\n    let primaryCommandBufferInstanceNode = commandBufferInstanceNode;\n    if (secondaryCommandBufferExecutionNode) {\n        let currentExecution: CommandSecondaryCommandBufferExecutionNode | undefined = secondaryCommandBufferExecutionNode;\n        while (currentExecution) {\n            const parentCB: CommandCommandBufferInstanceNode | undefined = findParentNode<CommandCommandBufferInstanceNode>(\n                currentExecution,\n                CommandCommandBufferInstanceNode.is\n            );\n            if (parentCB) {\n                primaryCommandBufferInstanceNode = parentCB;\n                // Check if this CB is also inside another secondary execution (nested case)\n                currentExecution = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                    parentCB.parent,\n                    CommandSecondaryCommandBufferExecutionNode.is\n                );\n            } else {\n                break;\n            }\n        }\n    }\n    return primaryCommandBufferInstanceNode;\n};\n\n/**\n * find a frame node from descendent node or self\n */\nexport const findFrameNode = (node: TreeNode): CommandFrameNode | undefined => findParentNode<CommandFrameNode>(node, CommandFrameNode.is);\n\n@injectable()\nexport class CommandTree extends BulkTree implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTree {\n        return tree instanceof CommandTree;\n    }\n\n    @inject(CaptureDatasetWidgetProfile)\n    protected readonly profile: CaptureDatasetWidgetProfile;\n    @inject(CaptureDatasetWidgetContext)\n    protected readonly context: CaptureDatasetWidgetContext;\n\n    @inject(CommandTreeDataQueriedRootProvider)\n    protected readonly rootProvider: CommandTreeDataQueriedRootProvider;\n    @inject(GFXRQueryBuilderService)\n    protected readonly gfxrQueryBuilderService: GFXRQueryBuilderService;\n\n    protected override _root: CommandRootNode | undefined;\n\n    // Back-reference to the model that manages this tree\n    model?: CommandTreeModel;\n\n    protected readonly onStructureChangedEmitter = new Emitter<TreeNode | undefined>();\n    readonly onStructureChanged = this.onStructureChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this._root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        super.root = root;\n        // Set back-reference from root to tree\n        if (root) {\n            root.tree = this;\n        }\n    }\n\n    async initTree(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        this.root = await this.rootProvider.provide(dbId, { tree: this }, options, createDrawOrDispatchChildren);\n\n        // tree structure is fully built at this point, report structure change\n        this.onStructureChangedEmitter.fire(undefined);\n    }\n\n    async refreshStructure(node?: CompositeTreeNode, cancellationToken?: CancellationToken): Promise<void> {\n        await this.refresh(node, cancellationToken);\n        this.fireStructureChanged(node);\n    }\n\n    fireStructureChanged(node?: TreeNode): void {\n        this.onStructureChangedEmitter.fire(node);\n    }\n\n    addToDispose(disposable: Disposable): void {\n        this.toDispose.push(disposable);\n    }\n\n    override dispose(): void {\n        this.rootProvider.dispose();\n        super.dispose();\n    }\n}\n\n@injectable()\nexport class CommandTreeModelPreferenceStateAccessImpl implements CommandTreePreferenceState.Access {\n    private readonly models = new Map<CommandTree, CommandTreeModel>();\n\n    private readonly commandTreeStateChangedEmitter = new Emitter<{ tree: CommandTree; state: CommandTreePreferenceState }>();\n    readonly onCommandTreeStateChanged = this.commandTreeStateChangedEmitter.event;\n\n    getCommandTreeState(tree: CommandTree): CommandTreePreferenceState {\n        return this.models.get(tree)?.getPreferenceState() ?? {};\n    }\n\n    fireCommandTreeStateChanged(tree: CommandTree): void {\n        this.commandTreeStateChangedEmitter.fire({ tree, state: this.getCommandTreeState(tree) });\n    }\n\n    registerCommandTreeModel(tree: CommandTree, model: CommandTreeModel): void {\n        this.models.set(tree, model);\n        this.fireCommandTreeStateChanged(tree);\n    }\n}\n\n@injectable()\nexport class CommandTreeModel extends BulkTreeModel implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTreeModel {\n        return tree instanceof CommandTreeModel;\n    }\n\n    @inject(MiscPreferences)\n    protected readonly miscPreferences: MiscPreferences;\n    @inject(CommandTree) override readonly tree: CommandTree;\n    protected _groupBy: GroupByOptions = GroupByOptions.Frame;\n    private groupByChangedEmitter = new Emitter<GroupByOptions>();\n    readonly onGroupByChanged = this.groupByChangedEmitter.event;\n    protected _isThumbnailEnabled = true;\n    protected _isApiEventIdsEnabled = true;\n    protected _isShowingEmptyRows = false;\n    protected _isVulkanEnabled = true;\n    protected _isDebugNamesEnabled = true;\n    protected _isDebugLabelsEnabled = true;\n    protected _isLinksEnabled = true;\n    protected _isThreadsEnabled = true;\n\n    @inject(FrameRangeSelectionService)\n    protected readonly frameRangeSelectionService: FrameRangeSelectionService;\n\n    @inject(CommandTreeModelPreferenceStateAccessImpl)\n    private readonly preferenceStateAccess: CommandTreeModelPreferenceStateAccessImpl;\n\n    protected isCollapsingSubTree = false;\n\n    // Proxies to prevent calls on sub tree expansion\n    protected readonly onExpansionChangedEmitterProxy = new Emitter<ExpandableTreeNode>();\n    protected readonly onChangedEmitterProxy = new Emitter<void>();\n\n    protected readonly onSubTreeExpansionChangedEmitter = new Emitter<ExpandableTreeNode>();\n    readonly onSubTreeExpansionChanged = this.onSubTreeExpansionChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this.tree.root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        this.tree.root = root;\n    }\n\n    override get onChanged(): Event<void> {\n        return this.onChangedEmitterProxy.event;\n    }\n\n    override get onExpansionChanged(): Event<ExpandableTreeNode> {\n        return this.onExpansionChangedEmitterProxy.event;\n    }\n\n    get onStructureChanged(): Event<TreeNode | undefined> {\n        return this.tree.onStructureChanged;\n    }\n\n    async initModel(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        await this.tree.initTree(dbId, createDrawOrDispatchChildren, options);\n    }\n\n    set groupBy(value: GroupByOptions) {\n        if (this._groupBy !== value) {\n            this._groupBy = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n            this.groupByChangedEmitter.fire(value);\n        }\n    }\n\n    get groupBy(): GroupByOptions {\n        return this._groupBy;\n    }\n\n    /**\n     * Obtain the tree nodes that are the top-level groups according to\n     * the current {@link groupBy} mode.\n     */\n    *groupNodes(): IterableIterator<CompositeTreeNode> {\n        if (!this.root) {\n            return;\n        }\n\n        const group = this.groupBy;\n        const treeIterator = new (class extends DepthFirstTreeIterator {\n            protected override children(node: TreeNode): TreeNode[] | undefined {\n                // Prune group nodes because we needn't look in them for more groups\n                return CommandTreeModel.isOfGroup(node, group) ? undefined : super.children(node);\n            }\n        })(this.root);\n\n        for (const next of treeIterator) {\n            if (CommandTreeModel.isOfGroup(next, group)) {\n                yield next;\n            }\n        }\n    }\n\n    set isApiEventIdsEnabled(value: boolean) {\n        if (this._isApiEventIdsEnabled !== value) {\n            this._isApiEventIdsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isApiEventIdsEnabled(): boolean {\n        return this._isApiEventIdsEnabled;\n    }\n\n    set isShowingEmptyRows(value: boolean) {\n        if (this._isShowingEmptyRows !== value) {\n            this._isShowingEmptyRows = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isShowingEmptyRows(): boolean {\n        return this._isShowingEmptyRows;\n    }\n\n    set isThumbnailEnabled(value: boolean) {\n        if (this._isThumbnailEnabled !== value) {\n            this._isThumbnailEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThumbnailEnabled(): boolean {\n        return this._isThumbnailEnabled;\n    }\n\n    set isVulkanEnabled(value: boolean) {\n        if (this._isVulkanEnabled !== value) {\n            this._isVulkanEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isVulkanEnabled(): boolean {\n        return this._isVulkanEnabled;\n    }\n\n    set isDebugNamesEnabled(value: boolean) {\n        if (this._isDebugNamesEnabled !== value) {\n            this._isDebugNamesEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugNamesEnabled(): boolean {\n        return this._isDebugNamesEnabled;\n    }\n\n    set isDebugLabelsEnabled(value: boolean) {\n        if (this._isDebugLabelsEnabled !== value) {\n            this._isDebugLabelsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugLabelsEnabled(): boolean {\n        return this._isDebugLabelsEnabled;\n    }\n\n    set isLinksEnabled(value: boolean) {\n        if (this._isLinksEnabled !== value) {\n            this._isLinksEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isLinksEnabled(): boolean {\n        return this._isLinksEnabled;\n    }\n\n    set isThreadsEnabled(value: boolean) {\n        if (this._isThreadsEnabled !== value) {\n            this._isThreadsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThreadsEnabled(): boolean {\n        return this._isThreadsEnabled;\n    }\n\n    getPreferenceState(nonDefaultOnly = false): CommandTreePreferenceState {\n        const result: CommandTreePreferenceState = {};\n\n        if (!nonDefaultOnly || this.groupBy !== this.miscPreferences[MiscPrefs.GroupBy]) {\n            result.groupBy = this.groupBy;\n        }\n        if (!nonDefaultOnly || this.isApiEventIdsEnabled !== this.miscPreferences[MiscPrefs.ShowApiEventIds]) {\n            result.isApiEventIdsEnabled = this.isApiEventIdsEnabled;\n        }\n        if (!nonDefaultOnly || this.isShowingEmptyRows !== this.miscPreferences[MiscPrefs.ShowEmptyRows]) {\n            result.isShowingEmptyRows = this.isShowingEmptyRows;\n        }\n        if (!nonDefaultOnly || this.isThumbnailEnabled !== this.miscPreferences[MiscPrefs.ShowThumbnails]) {\n            result.isThumbnailEnabled = this.isThumbnailEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugNamesEnabled !== true) {\n            result.isDebugNamesEnabled = this.isDebugNamesEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugLabelsEnabled !== true) {\n            result.isDebugLabelsEnabled = this.isDebugLabelsEnabled;\n        }\n        if (!nonDefaultOnly || this.isLinksEnabled !== true) {\n            result.isLinksEnabled = this.isLinksEnabled;\n        }\n        if (!nonDefaultOnly || this.isThreadsEnabled !== true) {\n            result.isThreadsEnabled = this.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (!nonDefaultOnly || this.isVulkanEnabled !== this.miscPreferences[MiscPrefs.ShowVulkanCalls]) {\n        //     result.isVulkanEnabled = this.isVulkanEnabled;\n        // }\n\n        return result;\n    }\n\n    override restoreState(state: CommandTreeModel.State): void {\n        if (state.groupBy !== undefined) {\n            this.groupBy = state.groupBy;\n        }\n        if (state.isApiEventIdsEnabled !== undefined) {\n            this.isApiEventIdsEnabled = state.isApiEventIdsEnabled;\n        }\n        if (state.isShowingEmptyRows !== undefined) {\n            this.isShowingEmptyRows = state.isShowingEmptyRows;\n        }\n        if (state.isThumbnailEnabled !== undefined) {\n            this.isThumbnailEnabled = state.isThumbnailEnabled;\n        }\n        if (state.isDebugNamesEnabled !== undefined) {\n            this.isDebugNamesEnabled = state.isDebugNamesEnabled;\n        }\n        if (state.isDebugLabelsEnabled !== undefined) {\n            this.isDebugLabelsEnabled = state.isDebugLabelsEnabled;\n        }\n        if (state.isLinksEnabled !== undefined) {\n            this.isLinksEnabled = state.isLinksEnabled;\n        }\n        if (state.isThreadsEnabled !== undefined) {\n            this.isThreadsEnabled = state.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (state.isVulkanEnabled !== undefined) {\n        //     this.isVulkanEnabled = state.isVulkanEnabled;\n        // }\n    }\n    override storeState(): CommandTreeModel.State {\n        return {\n            ...super.storeState(),\n            ...this.getPreferenceState(true)\n        };\n    }\n\n    @postConstruct()\n    protected override init(): void {\n        super.init();\n\n        // Set back-reference from tree to model\n        this.tree.model = this;\n\n        this.toDispose.pushAll([\n            this.onChangedEmitterProxy,\n            this.onExpansionChangedEmitterProxy,\n            this.onSubTreeExpansionChangedEmitter,\n\n            super.onChanged(() => {\n                if (!this.isCollapsingSubTree) {\n                    this.onChangedEmitterProxy.fire();\n                }\n            }),\n            super.onExpansionChanged(node => {\n                if (!this.isCollapsingSubTree) {\n                    this.onExpansionChangedEmitterProxy.fire(node);\n                }\n            })\n        ]);\n\n        this._isApiEventIdsEnabled = this.miscPreferences[MiscPrefs.ShowApiEventIds];\n        this._isShowingEmptyRows = this.miscPreferences[MiscPrefs.ShowEmptyRows];\n        this.isThumbnailEnabled = this.miscPreferences[MiscPrefs.ShowThumbnails];\n        this.groupBy = this.miscPreferences[MiscPrefs.GroupBy];\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // this.isVulkanEnabled = this.miscPreferences[MiscPrefs.ShowVulkanCalls];\n\n        this.preferenceStateAccess.registerCommandTreeModel(this.tree, this);\n    }\n\n    /**\n     * Collapses the entire tree.\n     */\n    async collapseTree(): Promise<void> {\n        const root = this.root;\n\n        if (CompositeTreeNode.is(root) && root.children.length > 0) {\n            await Promise.all(\n                root.children.filter(CompositeTreeNode.is).map((child: CompositeTreeNode) => this.expansionService.collapseAll(child))\n            );\n        }\n    }\n\n    /**\n     * Expands the given node and all its children recursively.\n     */\n    async expandSubTree(node?: Readonly<TreeNode>, includeDrawOrDispatchNodes = false): Promise<void> {\n        node ??= this.root;\n        if (!ExpandableTreeNode.is(node)) {\n            return;\n        }\n\n        try {\n            this.isCollapsingSubTree = true;\n            await this.doExpandSubTree(node, includeDrawOrDispatchNodes);\n            this.onSubTreeExpansionChangedEmitter.fire(node);\n        } finally {\n            this.isCollapsingSubTree = false;\n        }\n    }\n\n    protected async doExpandSubTree(node: TreeNode, includeDrawOrDispatchNodes: boolean): Promise<void> {\n        const YIELD_AFTER_MS = 200;\n\n        const processedNodes = new Set<TreeNode>();\n        const pendingNodes: TreeNode[] = [node];\n        let lastYieldTime = performance.now();\n\n        while (pendingNodes.length > 0) {\n            const currentLevelNodes: ExpandableTreeNode[] = [];\n            const nextLevelNodes: TreeNode[] = [];\n\n            while (pendingNodes.length > 0) {\n                const currentNode = pendingNodes.shift()!;\n                if (processedNodes.has(currentNode)) {\n                    continue;\n                }\n                processedNodes.add(currentNode);\n\n                // stop expansion at draw and dispatch nodes to avoid creation of low-utility nodes\n                // if this logic gets changed please also update enablement of ExpandSubtreeCommand accordingly\n                if (ExpandableTreeNode.is(currentNode) && (includeDrawOrDispatchNodes || !CommandTreeDrawOrDispatchNode.is(currentNode))) {\n                    currentLevelNodes.push(currentNode);\n                }\n            }\n\n            if (currentLevelNodes.length > 0) {\n                const expandedNodes = await this.expansionService.bulkExpandNodes(currentLevelNodes[Symbol.iterator]());\n                for (const expandedNode of expandedNodes) {\n                    await this.ensureLazyChildrenLoaded(expandedNode);\n                    nextLevelNodes.push(...expandedNode.children);\n                    // For draw/dispatch nodes that won't be expanded, still trigger their lazy loading\n                    if (!includeDrawOrDispatchNodes) {\n                        for (const child of expandedNode.children) {\n                            if (CommandTreeDrawOrDispatchNode.is(child) && ExpandableTreeNode.is(child)) {\n                                await this.ensureLazyChildrenLoaded(child);\n                            }\n                        }\n                    }\n                }\n                // Also process children of nodes that were already expanded\n                for (const currentNode of currentLevelNodes) {\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\n                        await this.ensureLazyChildrenLoaded(currentNode);\n                        nextLevelNodes.push(...currentNode.children);\n                        // For draw/dispatch nodes that won't be expanded, still trigger their lazy loading\n                        if (!includeDrawOrDispatchNodes) {\n                            for (const child of currentNode.children) {\n                                if (CommandTreeDrawOrDispatchNode.is(child) && ExpandableTreeNode.is(child)) {\n                                    await this.ensureLazyChildrenLoaded(child);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            pendingNodes.push(...nextLevelNodes);\n\n            // Yield control back to the event loop periodically based on time\n            const currentTime = performance.now();\n            if (currentTime - lastYieldTime >= YIELD_AFTER_MS) {\n                await new Promise(resolve => setTimeout(resolve, 0));\n                lastYieldTime = performance.now();\n            }\n        }\n    }\n\n    protected async ensureLazyChildrenLoaded(node: ExpandableTreeNode): Promise<void> {\n        // Find all loading nodes among children\n        const loadingNodes = node.children.filter(CommandEmptyNode.is);\n\n        if (loadingNodes.length === 0) {\n            return;\n        }\n\n        // Trigger load for all loading nodes and wait for them to complete\n        await Promise.all(loadingNodes.map(loadingNode => triggerLazyLoadAndWaitForRemoval(loadingNode)));\n    }\n\n    hasTrailingSuffixes(node: TreeNode): boolean {\n        if (CommandQueueSubmitNode.is(node)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    protected override isVisibleSelectableNode(node: TreeNode): node is SelectableTreeNode {\n        return super.isVisibleSelectableNode(node) && this.isInFrameRange(node);\n    }\n\n    protected isInFrameRange(node: TreeNode): boolean {\n        const frameNode = CommandFrameNode.getCommandFrameNodeContaining(node);\n        if (frameNode === undefined) {\n            return true; // Assume it's good\n        }\n        const range = this.frameRangeSelectionService.frameSpan;\n        if (range === undefined) {\n            return true; // No constraint\n        }\n        return frameNode.frameIndex >= range.startFrame && frameNode.frameIndex <= range.endFrame;\n    }\n}\n\nexport namespace CommandTreeModel {\n    export interface State extends TreeModelImpl.State, CommandTreePreferenceState {}\n\n    /**\n     * Test whether a `node` is of the kind that implements the given `group` mode.\n     * As groups are _a priori_ composite nodes, this additionally infers that type\n     * for the `node` if successful.\n     */\n    export function isOfGroup(node: TreeNode, group: GroupByOptions): node is CompositeTreeNode {\n        switch (group) {\n            case GroupByOptions.Frame:\n                return CommandFrameNode.is(node);\n            case GroupByOptions.RenderPass:\n                return CommandRenderPassInstanceNode.is(node) || CommandDynamicRenderPassInstanceNode.is(node);\n            case GroupByOptions.RenderSubpass:\n                return CommandRenderSubpassInstanceNode.is(node);\n            case GroupByOptions.CommandBuffer:\n                return CommandCommandBufferInstanceNode.is(node);\n            case GroupByOptions.QueueSubmission:\n                return CommandQueueSubmitNode.is(node);\n        }\n    }\n}\n\ntype TextureSupportingNode =\n    | CommandFrameNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode;\n\nexport namespace TextureSupportingNode {\n    export function is(node: CommandTreeNode): node is TextureSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node)\n        );\n    }\n    export function getLast(node: CommandTreeNode): TextureSupportingNode | undefined {\n        if (TextureSupportingNode.is(node)) {\n            return node;\n        }\n        let lastSupportingNode: TextureSupportingNode | undefined;\n        if (CompositeTreeNode.is(node)) {\n            for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n                lastSupportingNode = TextureSupportingNode.getLast(node.children[commandIndex]);\n                if (lastSupportingNode) {\n                    break;\n                }\n            }\n        }\n        return lastSupportingNode;\n    }\n}\n\n/**\n * Union type of all command tree nodes that support thumbnails.\n * Nodes with heavy thumbnail costs are commented out.\n */\ntype ThumbnailSupportingNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandDebugLabelGroupNode\n    | CommandRenderPassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDrawInstanceNode;\n// Below currently have a possibly heavy cost to getting thumbnails\n// | CommandDispatchInstanceNode\n// | CommandMeshTaskInstanceNode\n// | CommandClusterInstanceNode\n// | CommandRaytracingInstanceNode;\n\nexport namespace ThumbnailSupportingNode {\n    export function is(node: CommandTreeNode): node is ThumbnailSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node)\n        );\n    }\n}\n\nfunction getCommandTreeApiEventChildren(eventIds: Array<{ apiEvent: number }>, root: CommandRootNode): CommandTreeApiEvent[] {\n    return eventIds.reduce<CommandTreeApiEvent[]>((collected, id) => {\n        const event = root.resource.apiEvents[id.apiEvent];\n        if (event) {\n            collected.push(event);\n        } else {\n            console.warn(`No event found for ${id.apiEvent}`);\n        }\n        return collected;\n    }, []);\n}\n\nfunction getInstancesByIds<T>(ids: number[], container: PartialRecord<number, T>, source?: string, target?: string): T[] {\n    return ids.flatMap(id => {\n        const instance = container[id];\n        if (!instance) {\n            if (target) {\n                console.warn(`${source ? `${source} expected` : 'Expected'} ${target} with ${id} but found none.`);\n            }\n            return [];\n        }\n        return instance;\n    });\n}\n\n/**\n * Creates an ArrayWithSortNumber for range instances, used by createChildEventNodesForRange.\n * Fetches instances by IDs and provides sorting by beginApiEvent.\n *\n * @param ids - Array of instance IDs to fetch\n * @param container - Container object mapping IDs to instances\n * @param sourceContext - Context string for error messages (e.g., \"CommandRenderPassInstanceNode.create\")\n * @param targetName - Target instance type name for error messages (e.g., \"DebugLabelGroupInstance\")\n * @returns ArrayWithSortNumber object ready for use with getNextRangeElementToProcess\n */\nfunction createRangeInstanceArray<T extends { beginApiEvent: number }>(\n    ids: number[],\n    container: PartialRecord<number, T>,\n    sourceContext: string,\n    targetName: string\n): ArrayWithSortNumber<T> {\n    return {\n        array: getInstancesByIds(ids, container, sourceContext, targetName),\n        getSortNumber: (element: T) => element.beginApiEvent\n    };\n}\n\nexport function createLazyLoadingNode(\n    tree: CommandTree,\n    parent: ExpandableTreeNode,\n    load: (batchQuery?: boolean) => Promise<void>\n): CommandEmptyNode {\n    let loaded = false;\n    let loadingInProgress = false;\n\n    const lazyLoad: (batchQuery?: boolean) => Promise<boolean> = async (batchQuery = true) => {\n        if (loadingInProgress) {\n            return false;\n        }\n\n        if (!loaded) {\n            loaded = true;\n            loadingInProgress = true;\n            loadOnExpanded.dispose();\n            try {\n                await load(batchQuery);\n            } catch (error) {\n                console.error(`LazyLoad failed for node ${parent.id}:`, error);\n            } finally {\n                loadingInProgress = false;\n            }\n            CompositeTreeNode.removeChild(parent, loadingNode);\n            await tree.refreshStructure(parent);\n            return true;\n        }\n        return false;\n    };\n\n    // create lazy loading node\n    const loadingNode: CommandEmptyNode = CommandEmptyNode.create(parent, lazyLoad);\n    CompositeTreeNode.addChild(parent, loadingNode);\n\n    // register for lazy loading when the node is expanded\n    const loadOnExpanded = SokatoaLifecycleTreeNode.register(parent, 'onWillRender', async () => {\n        if (parent.expanded) {\n            // do not batch queries for expansion manually\n            await lazyLoad(false);\n        }\n    });\n    return loadingNode;\n}\n",
                "originalState": "/********************************************************************************\n    Copyright 2024-2026 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\nimport { GFXRQueryBuilderService } from '@sokatoa/gfxr-consumer/lib/';\nimport {\n    DynamicStateEntry,\n    PipelineBindPoint,\n    PipelineBindPointShaderStageFlags,\n    StateType\n} from '@sokatoa/gfxr-consumer/lib/browser/gfxr-data-service';\nimport { PartialRecord } from '@sokatoa/platform/lib';\nimport { BulkTree, BulkTreeModel, ResourceTreeNode, SokatoaLifecycleTreeNode } from '@sokatoa/platform/lib/browser';\nimport { GroupByOptions, MiscPreferences, MiscPrefs } from '@sokatoa/platform/lib/browser/misc-preferences';\nimport { TreeStructureChangeEmitter } from '@sokatoa/platform/lib/browser/tree-table/tree-table-widget';\nimport { ImageAccessorService } from '@sokatoa/platform/lib/common';\nimport { CompressedFileService, usesCompressionExtension } from '@sokatoa/platform/lib/common/compressed-file-service';\nimport { asError } from '@sokatoa/platform/lib/common/error-utils';\nimport { ApiResources, DescriptorResource, DrawApiResult } from '@sokatoa/platform/lib/common/gfxr-apis';\nimport { CancellationToken, Disposable, Emitter, Event, Path, URI } from '@theia/core';\nimport {\n    CompositeTreeNode,\n    DepthFirstTreeIterator,\n    ExpandableTreeNode,\n    SelectableTreeNode,\n    TreeModelImpl,\n    TreeNode\n} from '@theia/core/lib/browser';\nimport { RGBA } from '@theia/core/lib/common/color';\nimport { inject, injectable, postConstruct } from '@theia/core/shared/inversify';\nimport { PNG } from 'pngjs/browser';\nimport { lookupResourceFormat, UncompressedResourceFormat } from '../../common/format-handler';\nimport { extractData } from '../../common/geometry-utils';\nimport { GfxrScreenshotService, requestThumbnails, ScreenshotType, ThumbnailRequestOptions } from '../../common/gfxr-screenshot-service';\nimport { convertDataToImageData } from '../../common/host-side-conversion/vulkan-image';\nimport { FrameRangeSelectionService } from '../capture-widget/frame-range-selection-service';\nimport { placeholderScale } from '../graphics-pipeline-widget/graphics-pipeline-screenshot-requests';\nimport {\n    CaptureDatasetWidgetContext,\n    CaptureDatasetWidgetProfile,\n    CaptureDatasetWidgetReplayContext\n} from '../profile-ui/capture-dataset-widget-types';\nimport { CommandTreePreferenceState } from './command-tree-model-preferences';\nimport {\n    CommandTreeAccelerationStructureBuildInstance,\n    CommandTreeAccelerationStructureCopyInstance,\n    CommandTreeApiEvent,\n    CommandTreeCommandBufferInstance,\n    CommandTreeDataWithFunctionAndDebugNames,\n    CommandTreeDebugLabelGroupInstance,\n    CommandTreeDynamicRenderPassInstance,\n    CommandTreeFrame,\n    CommandTreeQueueDebugLabelGroup,\n    CommandTreeQueueDebugLabelInsert,\n    CommandTreeQueuePresent,\n    CommandTreeQueueSubmit,\n    CommandTreeRenderPassInstance,\n    CommandTreeRenderSubpassInstance,\n    CommandTreeSecondaryCommandBufferInstance,\n    CommandTreeTransferCommandInstance,\n    overrideDynamicState,\n    queryClusterInstanceDynamicState,\n    queryClusterInstanceDynamicStateBatched,\n    queryDispatchInstanceDynamicState,\n    queryDispatchInstanceDynamicStateBatched,\n    queryDrawInstanceDynamicState,\n    queryDrawInstanceDynamicStateBatched,\n    queryMeshTaskInstanceDynamicState,\n    queryMeshTaskInstanceDynamicStateBatched,\n    queryRaytracingInstanceDynamicState,\n    queryRaytracingInstanceDynamicStateBatched,\n    querySecondaryCommandBufferEndDynamicState,\n    QueryTreeDataOptions\n} from './command-tree-service';\nimport { LazyLoadableNode, triggerLazyLoadAndWaitForRemoval } from './lazy-load-utils';\nimport { CommandTreeDataQueriedRootProvider } from './providers/command-tree-root-provider';\n\n// Extension names\nconst VK_NV_COMMAND_BUFFER_INHERITANCE = 'VK_NV_command_buffer_inheritance';\nconst VK_NV_INHERITED_VIEWPORT_SCISSOR = 'VK_NV_inherited_viewport_scissor';\n\n/**\n * Helper type to make TreeNode.parent writable during node construction.\n * TreeNode.parent is readonly, but during tree construction we need to update it.\n */\ninterface MutableParent {\n    parent: CompositeTreeNode | undefined;\n}\n\n/**\n * Check if VK_NV_command_buffer_inheritance extension is enabled for a device.\n * This extension enables full state inheritance between command buffers and leak-back.\n */\nfunction hasCommandBufferInheritance(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_COMMAND_BUFFER_INHERITANCE) ?? false;\n}\n\n/**\n * Check if VK_NV_inherited_viewport_scissor extension is enabled for a device.\n * This extension enables limited viewport/scissor inheritance for secondary command buffers.\n */\nfunction hasInheritedViewportScissor(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_INHERITED_VIEWPORT_SCISSOR) ?? false;\n}\n\n/**\n * Filter dynamic state to only viewport and scissor entries.\n * Used for VK_NV_inherited_viewport_scissor extension.\n */\nasync function filterDynamicStateForViewportScissor(statePromise: Promise<DynamicStateEntry[]>): Promise<DynamicStateEntry[]> {\n    const state = await statePromise;\n    return state.filter(entry => entry.stateType === StateType.VIEWPORT || entry.stateType === StateType.SCISSOR);\n}\n\n/**\n * Tracks dynamic state that may be updated as secondary command buffers execute\n * (when VK_NV_command_buffer_inheritance is enabled).\n */\nclass DynamicStateTracker {\n    private currentStatePromise: Promise<DynamicStateEntry[]>;\n\n    constructor(initialState: Promise<DynamicStateEntry[]>) {\n        this.currentStatePromise = initialState;\n    }\n\n    getCurrentState(): Promise<DynamicStateEntry[]> {\n        return this.currentStatePromise;\n    }\n\n    updateState(newState: Promise<DynamicStateEntry[]>): void {\n        this.currentStatePromise = newState;\n    }\n}\n\n/** Internal context for a command tree model.\n *\n * contains all the fixed data needed for the model,\n * e.g. services, etc.\n */\ninterface CommandTreeContext {\n    dbId: number;\n    data: CommandTreeDataWithFunctionAndDebugNames;\n    screenshotService: GfxrScreenshotService;\n    fileService: CompressedFileService;\n    profile: CaptureDatasetWidgetProfile;\n    context: CaptureDatasetWidgetContext;\n    tree: CommandTree;\n    gfxrQueryBuilderService: GFXRQueryBuilderService;\n    imageAccessorService: ImageAccessorService;\n    createDrawOrDispatchChildren: boolean;\n    rootNode: CommandRootNode;\n    deviceExtensions: Map<number, Set<string>>;\n}\n\n/**\n * Helper function to look up the debug name for an object at a specific API event.\n * Finds the most recent debug name that was set at or before the target API event.\n * @param debugNameLookup - Map of objectHandle to array of {apiEvent, name} sorted by apiEvent\n * @param objectHandle - The object handle to look up\n * @param targetApiEvent - The API event at which we want to know the object's name\n * @returns The debug name if found, undefined otherwise\n */\nfunction getDebugNameAtApiEvent(\n    debugNameLookup: Map<number, Array<{ apiEvent: number; name: string }>>,\n    objectHandle: number | null | undefined,\n    targetApiEvent: number\n): string | undefined {\n    if (typeof objectHandle !== 'number') {\n        return undefined;\n    }\n\n    const entries = debugNameLookup.get(objectHandle);\n    if (!entries || entries.length === 0) {\n        return undefined;\n    }\n\n    // Binary search for the most recent name at or before targetApiEvent\n    let left = 0;\n    let right = entries.length - 1;\n    let result: string | undefined = undefined;\n\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (entries[mid].apiEvent <= targetApiEvent) {\n            result = entries[mid].name;\n            left = mid + 1; // Look for a more recent name\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n\nexport interface CommandRootNode extends ResourceTreeNode<CommandTreeDataWithFunctionAndDebugNames>, CompositeTreeNode, ExpandableTreeNode {\n    resourceType: typeof CommandRootNode.RESOURCE_TYPE;\n    children: CommandFrameNode[];\n    dbId: number;\n    profile: CaptureDatasetWidgetProfile;\n    tree?: CommandTree; // Back-reference to the tree that owns this root\n    // Cached maps for queue debug labels to avoid rebuilding for each frame\n    queueDebugLabelGroupsBySubmitId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelGroupsByPresentId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelInsertsByApiEvent: Map<number, CommandTreeQueueDebugLabelInsert>;\n}\n\nexport namespace CommandRootNode {\n    export const ID = 'sokatoa-command-tree-widget';\n\n    export const RESOURCE_TYPE = '__root__';\n\n    export function is(node: TreeNode | undefined): node is CommandRootNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRootNode.RESOURCE_TYPE);\n    }\n\n    export function create(\n        dbId: number,\n        data: CommandTreeDataWithFunctionAndDebugNames,\n        screenshotService: GfxrScreenshotService,\n        profile: CaptureDatasetWidgetProfile,\n        context: CaptureDatasetWidgetContext,\n        tree: CommandTree,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        imageAccessorService: ImageAccessorService,\n        fileService: CompressedFileService,\n        createDrawOrDispatchChildren: boolean,\n        deviceExtensions: Map<number, Set<string>>\n    ): CommandRootNode {\n        // Build maps for queue debug labels once for all frames\n        const queueDebugLabelGroupsBySubmitId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelGroupsByPresentId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelInsertsByApiEvent = new Map<number, CommandTreeQueueDebugLabelInsert>();\n\n        for (const group of Object.values(data.queueDebugLabelGroups)) {\n            if (group) {\n                for (const submitId of group.queueSubmitIds) {\n                    queueDebugLabelGroupsBySubmitId.set(submitId, group);\n                }\n                for (const presentId of group.queuePresentIds) {\n                    queueDebugLabelGroupsByPresentId.set(presentId, group);\n                }\n            }\n        }\n\n        for (const insert of Object.values(data.queueDebugLabelInserts)) {\n            if (insert) {\n                queueDebugLabelInsertsByApiEvent.set(insert.apiEvent, insert);\n            }\n        }\n\n        const rootNode: CommandRootNode = {\n            visible: false,\n            id: CommandRootNode.ID,\n            name: 'ProfileTree',\n            parent: undefined,\n            expanded: true,\n            children: [],\n            resourceType: CommandRootNode.RESOURCE_TYPE,\n            resource: data,\n            dbId,\n            profile,\n            queueDebugLabelGroupsBySubmitId,\n            queueDebugLabelGroupsByPresentId,\n            queueDebugLabelInsertsByApiEvent\n        };\n        const ctx: CommandTreeContext = {\n            dbId,\n            data,\n            screenshotService,\n            fileService,\n            profile,\n            context,\n            tree,\n            gfxrQueryBuilderService,\n            imageAccessorService,\n            createDrawOrDispatchChildren,\n            rootNode,\n            deviceExtensions\n        };\n        const modelBuildStart = Date.now();\n        const frames = Object.values(data.frames);\n        rootNode.children = frames.flatMap(child => (child ? CommandFrameNode.create(ctx, child, rootNode) : []));\n        console.debug(`Model loaded in ${Date.now() - modelBuildStart} ms`);\n        return rootNode;\n    }\n}\n\nexport interface DebugMarker {\n    name: string;\n    color?: RGBA;\n}\n\nexport interface WithDebugMarker {\n    debugMarker?: DebugMarker;\n}\n\nexport namespace WithDebugMarker {\n    /** Type guard for a `node` that is or has a debug marker. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugMarker> {\n        return 'debugMarker' in node && node.debugMarker !== undefined;\n    }\n}\n\nexport interface WithDebugName {\n    debugName?: string;\n}\n\nexport namespace WithDebugName {\n    /** Type guard for a `node` that has a debug name. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugName> {\n        return 'debugName' in node && node.debugName !== undefined;\n    }\n}\n\ninterface LabelData {\n    labelName: string | undefined | null;\n    colorR: number | undefined | null;\n    colorG: number | undefined | null;\n    colorB: number | undefined | null;\n    colorA: number | undefined | null;\n}\n\nfunction setDebugMarkerData(node: WithDebugMarker, labelData: LabelData): void {\n    const name = labelData.labelName ?? 'Debug marker';\n    const color = {\n        r: (labelData.colorR ?? 1) * 255,\n        g: (labelData.colorG ?? 1) * 255,\n        b: (labelData.colorB ?? 1) * 255,\n        a: (labelData.colorA ?? 1) * 255\n    };\n\n    node.debugMarker = { name };\n    if (color.a !== 0 || color.b !== 0 || color.g !== 0 || color.r !== 0) {\n        node.debugMarker.color = color;\n    }\n}\n\nexport interface CommandFrameNode extends ResourceTreeNode<CommandTreeFrame>, ExpandableTreeNode, SelectableTreeNode {\n    label: string;\n    frameIndex: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandFrameNode.RESOURCE_TYPE;\n    thumbnail?: string;\n}\n\nexport namespace CommandFrameNode {\n    export const RESOURCE_TYPE = 'frame';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandFrameNode {\n        return ResourceTreeNode.hasResourceType(node, CommandFrameNode.RESOURCE_TYPE);\n    }\n\n    export function getId(frame: CommandTreeFrame): string {\n        return frame.frameIndex.toString();\n    }\n\n    export function create(ctx: CommandTreeContext, element: CommandTreeFrame, parent: CompositeTreeNode): CommandFrameNode {\n        const node: CommandFrameNode & SokatoaLifecycleTreeNode = {\n            id: getId(element),\n            frameIndex: element.frameIndex,\n            label: `Frame ${element.frameIndex}`,\n            children: [],\n            expanded: false,\n            selected: false,\n            parent,\n            resourceType: CommandFrameNode.RESOURCE_TYPE,\n            resource: element\n        };\n\n        const root = ctx.rootNode;\n\n        const children: CommandTreeNode[] = [];\n        let queueSubmitIndex = 0;\n        let queuePresentIndex = 0;\n        let accelerationStructureBuildIndex = 0;\n        let accelerationStructureCopyIndex = 0;\n\n        // Track current active debug label group and its children\n        let activeDebugLabelGroup: CommandTreeQueueDebugLabelGroup | undefined;\n        let activeGroupChildren: (CommandQueueSubmitNode | CommandQueuePresentNode)[] = [];\n        let queueDebugLabelGroupInstanceIndex = 0;\n\n        // Helper to finalize the active group and add it to children\n        const finalizeActiveGroup = (): void => {\n            if (activeDebugLabelGroup && activeGroupChildren.length > 0) {\n                children.push(\n                    CommandQueueDebugLabelGroupNode.create(\n                        ctx,\n                        activeDebugLabelGroup,\n                        node,\n                        activeGroupChildren,\n                        queueDebugLabelGroupInstanceIndex++\n                    )\n                );\n                activeDebugLabelGroup = undefined;\n                activeGroupChildren = [];\n            }\n        };\n\n        for (let id = element.beginApiEvent; id <= (element.endApiEvent ?? element.beginApiEvent); id++) {\n            // Check for queue debug label insert at this apiEvent\n            const queueDebugLabelInsert = root.queueDebugLabelInsertsByApiEvent.get(id);\n            if (queueDebugLabelInsert) {\n                // Inserts can appear in the middle of groups, so finalize any active group first\n                finalizeActiveGroup();\n                children.push(CommandQueueDebugLabelNode.create(ctx, queueDebugLabelInsert, node));\n            }\n\n            const apiEvent = root.resource.apiEvents[id];\n            if (apiEvent) {\n                if (apiEvent.submissionId && element.queueSubmitIds.includes(apiEvent.submissionId)) {\n                    const queueSubmit = root.resource.queueSubmits[apiEvent.submissionId];\n                    if (queueSubmit) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsBySubmitId.get(apiEvent.submissionId);\n\n                        // Check if this submit is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queueSubmit not found for submissionId ${apiEvent.submissionId}`);\n                    }\n                } else if (apiEvent.presentId && element.queuePresentIds.includes(apiEvent.presentId)) {\n                    const queuePresent = root.resource.queuePresents[apiEvent.presentId];\n                    if (queuePresent) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsByPresentId.get(apiEvent.presentId);\n\n                        // Check if this present is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queuePresent not found for presentId ${apiEvent.presentId}`);\n                    }\n                } else if (\n                    apiEvent.accelerationStructureBuildInstanceId &&\n                    element.accelerationStructureBuildIds.includes(apiEvent.accelerationStructureBuildInstanceId)\n                ) {\n                    // Acceleration structure builds interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureBuild =\n                        root.resource.topLevelAccelerationStructureBuilds[apiEvent.accelerationStructureBuildInstanceId];\n                    if (accelerationStructureBuild) {\n                        children.push(\n                            CommandAccelerationStructureBuildNode.create(\n                                accelerationStructureBuild,\n                                node,\n                                accelerationStructureBuildIndex++\n                            )\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureBuildInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureBuild not found for accelerationStructureBuildInstanceId ${iId}`\n                        );\n                    }\n                } else if (\n                    apiEvent.accelerationStructureCopyInstanceId &&\n                    element.accelerationStructureCopyIds.includes(apiEvent.accelerationStructureCopyInstanceId)\n                ) {\n                    // Acceleration structure copies interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureCopy =\n                        root.resource.topLevelAccelerationStructureCopies[apiEvent.accelerationStructureCopyInstanceId];\n                    if (accelerationStructureCopy) {\n                        children.push(\n                            CommandAccelerationStructureCopyNode.create(accelerationStructureCopy, node, accelerationStructureCopyIndex++)\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureCopyInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureCopy not found for accelerationStructureCopyInstanceId ${iId}`\n                        );\n                    }\n                }\n            }\n        }\n\n        // Finalize any remaining active debug label group at the end\n        finalizeActiveGroup();\n\n        node.children = children;\n\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        const request: ThumbnailRequestOptions = {\n            profileOrReplay: replay ?? ctx.profile,\n            startFrame: element.frameIndex,\n            endFrame: element.frameIndex,\n            requesterDbgName: `Command tree frame ${element.frameIndex}`,\n            onScreenshotReady: result => {\n                ctx.imageAccessorService\n                    .accessImage(new URL(URI.fromFilePath(result.path).toString()))\n                    .then(url => {\n                        node.thumbnail = url.url.toString();\n                        ctx.tree.addToDispose(url);\n                        void ctx.tree.refresh(node);\n                    })\n                    .catch(reason => {\n                        const error = asError(reason);\n                        console.error(error);\n                    });\n            },\n            onRequestComplete: (success, message) => {\n                if (!success) {\n                    console.error(`Request for frame thumbnails failed: ${message}`);\n                }\n            }\n        };\n        const onWillRender = (): void => {\n            requestThumbnails(ctx.screenshotService, request);\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', onWillRender);\n        };\n        SokatoaLifecycleTreeNode.register(node, 'onWillRender', onWillRender);\n        return node;\n    }\n\n    /**\n     * Retrieve the `CommandFrameNode` that is or contains the given `node`.\n     * Returns `undefined` in the case that the `node` is an ancestor of or\n     * otherwise not contained in an `CommandFrameNode`.\n     */\n    export function getCommandFrameNodeContaining(node: TreeNode): CommandFrameNode | undefined {\n        return CommandFrameNode.is(node) ? node : node.parent ? CommandFrameNode.getCommandFrameNodeContaining(node.parent) : undefined;\n    }\n}\n\nexport interface CommandEmptyNode extends LazyLoadableNode {\n    label: string;\n}\n\nexport namespace CommandEmptyNode {\n    export const GENERALIZED_TYPE = 'empty';\n\n    export function is(node: unknown): node is CommandEmptyNode {\n        return TreeNode.is(node) && node.id.endsWith('_empty');\n    }\n\n    export function getId(parent: CompositeTreeNode): string {\n        return `${parent.id}_empty`;\n    }\n\n    export function create(parent: CompositeTreeNode, load: CommandEmptyNode['load']): CommandEmptyNode {\n        return {\n            id: getId(parent),\n            label: 'Loading...',\n            parent,\n            load\n        };\n    }\n}\n\nexport interface CommandApiEventNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandApiEventNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandApiEventNode {\n    export const RESOURCE_TYPE = 'api-event';\n    export const GENERALIZED_TYPE = RESOURCE_TYPE;\n\n    export function is(node: TreeNode | undefined): node is CommandApiEventNode {\n        return ResourceTreeNode.hasResourceType(node, CommandApiEventNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEventId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex?: number\n    ): CommandApiEventNode {\n        const root = ctx.rootNode;\n        const node: CommandApiEventNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEventId,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex ?? ''}`,\n            parent,\n            resourceType: CommandApiEventNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId,\n            selected: false\n        };\n        // set debug marker data if node is a debug marker\n        if (element.debugLabelId) {\n            const labelData = root.resource.debugLabels[element.debugLabelId];\n            if (labelData) {\n                setDebugMarkerData(node, labelData);\n            }\n        }\n        return node;\n    }\n}\n\nexport interface CommandDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeDebugLabelGroupInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'debug-label-group';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDebugLabelGroupInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDebugLabelGroupInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDebugLabelGroupNode = {\n            id: getId(element, parent),\n            debugLabelInstanceId: element.labelId,\n            label: `${root.resource.functionNameLookup[element.functionNameId ?? -1] ?? '<not defined>'}`,\n            parent,\n            resourceType: CommandDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this debug label range\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this debug label group, add it to array\n            // - not self\n            // - only commands with same command buffer id\n            if (event && event.debugLabelId !== element.labelId && event.commandBufferInstanceId === element.commandBufferInstance) {\n                apiEventCommandArray.push(event);\n            }\n        }\n        // get array of debug label ranges with api event numbers within this debug label range\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this debug label range\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderPassInstance'\n        );\n        // get array of render subpass ranges with api event numbers within this debug label range\n        const renderSubpassInstances = createRangeInstanceArray(\n            element.renderSubpassInstanceIds,\n            root.resource.renderSubpassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderSubpassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this debug label range\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('subpassIndex' in rangeElement) {\n                    const renderSubpassInstanceNode = CommandRenderSubpassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderSubpassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            renderSubpassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for debug label group:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `debug label group ${element.labelId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelGroup>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'queue-debug-label-group';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelGroup, parent: CompositeTreeNode, instanceIndex: number): string {\n        return `${parent.id}_qdl_group_${element.labelId}_${instanceIndex}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelGroup,\n        parent: CompositeTreeNode,\n        children: (CommandQueueSubmitNode | CommandQueuePresentNode)[],\n        instanceIndex: number\n    ): CommandQueueDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelGroupNode = {\n            id: getId(element, parent, instanceIndex),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label Group',\n            queue: element.queue!,\n            parent,\n            resourceType: CommandQueueDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        // Update parent references for children since they were created with a different parent\n        // and are now being reparented to this debug label group node\n        for (const child of children) {\n            // Cast away readonly to update parent during node construction\n            (child as MutableParent).parent = node;\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelInsert>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    apiEventId: number;\n    resourceType: typeof CommandQueueDebugLabelNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelNode {\n    export const RESOURCE_TYPE = 'queue-debug-label';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelInsert, parent: CompositeTreeNode): string {\n        return `${parent.id}_qdl_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelInsert,\n        parent: CompositeTreeNode\n    ): CommandQueueDebugLabelNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelNode = {\n            id: getId(element, parent),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label',\n            queue: element.queue!,\n            apiEventId: element.apiEvent,\n            parent,\n            resourceType: CommandQueueDebugLabelNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandCommandBufferInstanceNode\n    extends ResourceTreeNode<CommandTreeCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    commandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandCommandBufferInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandCommandBufferInstanceNode {\n    export const RESOURCE_TYPE = 'command-buffer-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandCommandBufferInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandCommandBufferInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeCommandBufferInstance,\n        parent: CompositeTreeNode,\n        commandBufferIndex: number,\n        baseDynamicStatePromise?: Promise<DynamicStateEntry[]>\n    ): CommandCommandBufferInstanceNode {\n        const node: CommandCommandBufferInstanceNode = {\n            id: getId(element, parent),\n            commandBufferInstanceId: element.instanceId,\n            label: `Command Buffer ${commandBufferIndex}`,\n            parent,\n            resourceType: CommandCommandBufferInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this command buffer\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this command buffer, add it to array\n            // - omit commands that reference render pass id\n            // - if api event is a debug label, check the debug label itself for a render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                event.commandBufferInstanceId === element.instanceId &&\n                event.renderPassInstanceId === undefined &&\n                event.dynamicRenderPassInstanceId === undefined &&\n                (event.debugLabelId === undefined ||\n                    (debugLabel?.beginApiEvent === event.apiEventId &&\n                        debugLabel?.beginRenderPassInstance === undefined &&\n                        debugLabel?.beginDynamicRenderPassInstance === undefined) ||\n                    (debugLabel?.endApiEvent === event.apiEventId &&\n                        debugLabel?.endRenderPassInstance === undefined &&\n                        debugLabel?.endDynamicRenderPassInstance === undefined))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this command buffer\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this command buffer\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'RenderPassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this command buffer\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        const emptyDynamicStatePromise = new Promise<DynamicStateEntry[]>(resolve => resolve([]));\n        const effectiveBaseState = baseDynamicStatePromise ?? emptyDynamicStatePromise;\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            effectiveBaseState,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        effectiveBaseState\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for command buffer:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `command buffer ${commandBufferIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandSecondaryCommandBufferExecutionNode\n    extends ResourceTreeNode<CommandTreeSecondaryCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    parentCommandBufferInstanceId: number;\n    secondaryCommandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n}\n\nexport namespace CommandSecondaryCommandBufferExecutionNode {\n    export const RESOURCE_TYPE = 'secondary-command-buffer-execution';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: unknown): node is CommandSecondaryCommandBufferExecutionNode {\n        return (\n            ExpandableTreeNode.is(node) && SelectableTreeNode.is(node) && ResourceTreeNode.is(node, 'secondary-command-buffer-execution')\n        );\n    }\n\n    export function getId(element: CommandTreeSecondaryCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_secondary_${element.secondaryCommandBufferInstance}_${element.executionId}_${element.executionIndex}`;\n    }\n\n    export async function create(\n        ctx: CommandTreeContext,\n        elements: CommandTreeSecondaryCommandBufferInstance[],\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n        stateTracker?: DynamicStateTracker\n    ): Promise<CommandSecondaryCommandBufferExecutionNode> {\n        if (elements.length === 0) {\n            throw new Error('elements array must not be empty');\n        }\n        // Use the first element for the node's resource (they all share the same executionId and apiEvent)\n        const element = elements[0];\n        const node: CommandSecondaryCommandBufferExecutionNode = {\n            id: getId(element, parent),\n            parentCommandBufferInstanceId: element.parentCommandBufferInstance || 0,\n            secondaryCommandBufferInstanceId: element.secondaryCommandBufferInstance || 0,\n            label: `Secondary Command Buffer Execution ${commandIndex}`,\n            parent,\n            resourceType: 'secondary-command-buffer-execution',\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        createLazyLoadingNode(ctx.tree, node, async () => {\n            // Sort elements by executionIndex to maintain proper order\n            const sortedElements = [...elements].sort((a, b) => (a.executionIndex || 0) - (b.executionIndex || 0));\n\n            // Get device and check extensions\n            const firstSecondary = sortedElements[0]?.secondaryCommandBufferInstance;\n            let deviceExtensions: Set<string> | undefined;\n\n            if (firstSecondary !== undefined) {\n                const commandBufferInstance = root.resource.commandBufferInstances[firstSecondary];\n                const device = commandBufferInstance?.device;\n                if (typeof device === 'number') {\n                    deviceExtensions = ctx.deviceExtensions.get(device);\n                }\n            }\n\n            const hasInheritance = hasCommandBufferInheritance(deviceExtensions);\n            const hasViewportScissorOnly = hasInheritedViewportScissor(deviceExtensions) && !hasInheritance;\n\n            // Calculate effective base state for INHERITANCE INTO secondary\n            let effectiveBaseState: Promise<DynamicStateEntry[]>;\n            if (hasInheritance) {\n                effectiveBaseState = baseDynamicStatePromise;\n            } else if (hasViewportScissorOnly) {\n                effectiveBaseState = filterDynamicStateForViewportScissor(baseDynamicStatePromise);\n            } else {\n                effectiveBaseState = Promise.resolve([]);\n            }\n\n            // Create a CommandCommandBufferInstanceNode for each secondary command buffer in the execution\n            const childNodes: CommandCommandBufferInstanceNode[] = [];\n            sortedElements.forEach((secondaryInstance, index) => {\n                if (secondaryInstance.secondaryCommandBufferInstance) {\n                    const commandBufferInstance = root.resource.commandBufferInstances[secondaryInstance.secondaryCommandBufferInstance];\n                    if (commandBufferInstance) {\n                        const childNode = CommandCommandBufferInstanceNode.create(\n                            ctx,\n                            commandBufferInstance,\n                            node,\n                            index,\n                            effectiveBaseState\n                        );\n                        childNodes.push(childNode);\n                    } else {\n                        console.warn(\n                            `Command buffer instance ${secondaryInstance.secondaryCommandBufferInstance} ` +\n                                'not found in root.resource.commandBufferInstances'\n                        );\n                    }\n                }\n            });\n            CompositeTreeNode.addChildren(node, childNodes);\n\n            // Handle LEAK-BACK: Update parent's state tracker if extension is enabled\n            if (hasInheritance && stateTracker && element.executionId) {\n                const db = ctx.gfxrQueryBuilderService.builderFor(ctx.dbId);\n                const endStatePromise = querySecondaryCommandBufferEndDynamicState(db, [element.executionId]);\n                stateTracker.updateState(endStatePromise);\n            }\n        });\n\n        // Register for thumbnail updates\n        registerThumbnailUpdate(ctx, node, `secondary command buffer execution ${node.resource.executionId}`);\n        return node;\n    }\n}\n\nexport interface CommandQueueSubmitNode\n    extends ResourceTreeNode<CommandTreeQueueSubmit>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    submissionId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueSubmitNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueSubmitNode {\n    export const RESOURCE_TYPE = 'queue-submit';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueSubmitNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueSubmitNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueSubmit, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.submissionId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueSubmit,\n        parent: CompositeTreeNode,\n        queueSubmitIndex: number\n    ): CommandQueueSubmitNode {\n        const root = ctx.rootNode;\n        const node: CommandQueueSubmitNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            threadId: element.threadId || 0,\n            submissionId: element.submissionId,\n            label: `Queue Submit ${queueSubmitIndex}`,\n            queue: element.queue,\n            parent,\n            resourceType: CommandQueueSubmitNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        const children =\n            element.queueSubmitBuffers\n                ?.filter(b => b.commandBufferInstance)\n                .flatMap(b => {\n                    const instance = root.resource.commandBufferInstances[b.commandBufferInstance!];\n                    if (!instance) {\n                        console.warn(`CommandQueueSubmitNode.create: commandBufferInstance not found for id ${b.commandBufferInstance}`);\n                        return [];\n                    }\n                    return instance;\n                }) ?? [];\n        let commandBufferIndex = 0;\n        node.children = children.map(child => CommandCommandBufferInstanceNode.create(ctx, child, node, commandBufferIndex++));\n\n        registerThumbnailUpdate(ctx, node, `queue submit ${queueSubmitIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueuePresentNode extends ResourceTreeNode<CommandTreeQueuePresent>, SelectableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    resourceType: typeof CommandQueuePresentNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueuePresentNode {\n    export const RESOURCE_TYPE = 'queue-present';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueuePresentNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueuePresentNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueuePresent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEvent}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueuePresent,\n        parent: CompositeTreeNode,\n        queuePresentIndex: number\n    ): CommandQueuePresentNode {\n        const root = ctx.rootNode;\n        const node: CommandQueuePresentNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            label: `Queue Present ${queuePresentIndex}`,\n            parent,\n            resourceType: CommandQueuePresentNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            queue: element.queue,\n            selected: false\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureBuildNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureBuildInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    buildInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureBuildNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureBuildNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-build';\n    export const GENERALIZED_TYPE = 'acceleration-structure-build';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureBuildNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureBuildNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureBuildInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.buildApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureBuildInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureBuildNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureBuildNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            buildInstanceId: element.instanceId,\n            apiEventId: element.buildApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureBuildNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureCopyNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureCopyInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    copyInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureCopyNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureCopyNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-copy';\n    export const GENERALIZED_TYPE = 'acceleration-structure-copy';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureCopyNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureCopyNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureCopyInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.copyApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureCopyInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureCopyNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureCopyNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            copyInstanceId: element.instanceId,\n            apiEventId: element.copyApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureCopyNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandTransferCommandNode\n    extends ResourceTreeNode<CommandTreeTransferCommandInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    transferCommandInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandTransferCommandNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandTransferCommandNode {\n    export const RESOURCE_TYPE = 'transfer-command';\n    export const GENERALIZED_TYPE = 'transfer-command';\n\n    export function is(node: TreeNode | undefined): node is CommandTransferCommandNode {\n        return ResourceTreeNode.hasResourceType(node, CommandTransferCommandNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeTransferCommandInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.transferApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeTransferCommandInstance,\n        parent: CompositeTreeNode,\n        transferCommandIndex: number\n    ): CommandTransferCommandNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandTransferCommandNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            transferCommandInstanceId: element.instanceId,\n            apiEventId: element.transferApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${transferCommandIndex}`,\n            parent,\n            resourceType: CommandTransferCommandNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nfunction setThumbnailUrl(\n    ctx: CommandTreeContext,\n    resources: ApiResources[],\n    node: TreeNode & { thumbnail?: string },\n    requesterDbgName: string\n): void {\n    if (resources.length > 0) {\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        ctx.screenshotService.requestScreenshots({\n            profileOrReplay: replay ?? ctx.profile,\n            scale: placeholderScale,\n            screenshotType: ScreenshotType.API_EVENT,\n            requestData: resources,\n            moreRequests: true,\n            requesterDbgName,\n            options: {\n                DumpDepth: true\n            },\n            onScreenshotReady: result => {\n                if (result.resultData.resultType === ScreenshotType.API_EVENT && DrawApiResult.is(result.resultData.apiResult)) {\n                    const images = [...(result.resultData.apiResult.colorAttachments || [])];\n                    if (result.resultData.apiResult.depthAttachment) {\n                        images.push(result.resultData.apiResult.depthAttachment);\n                    }\n                    if (images.length > 0) {\n                        const possibleImage = images[0].subresources?.[0];\n                        if (possibleImage) {\n                            if (usesCompressionExtension(possibleImage.file)) {\n                                // Use VkImageConversionService to get a png\n                                // Do the same as the else case, but with the new png file\n                                const format = lookupResourceFormat(images[0].format);\n                                if (UncompressedResourceFormat.is(format)) {\n                                    ctx.fileService\n                                        .read(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString(), {\n                                            uncompressedSize: possibleImage.size\n                                        })\n                                        .then(async content => {\n                                            const extractedData = await extractData(format, content);\n                                            const dim = {\n                                                width: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[0]\n                                                    : possibleImage.dimensions[0] * placeholderScale,\n                                                height: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[1]\n                                                    : possibleImage.dimensions[1] * placeholderScale\n                                            };\n                                            const conversionResult = await convertDataToImageData(extractedData, format, dim, {\n                                                channelOptions: { alpha: { disabled: true } }\n                                            });\n                                            const png = new PNG({\n                                                width: conversionResult.dimensions.width,\n                                                height: conversionResult.dimensions.height\n                                            });\n                                            png.data = conversionResult.data;\n                                            const pngBuffer = PNG.sync.write(png);\n                                            node.thumbnail = `data:image/png;base64, ${pngBuffer.toString('base64')}`;\n                                            void ctx.tree.refresh(node.parent);\n                                        })\n                                        .catch(reason => {\n                                            const error = asError(reason);\n                                            console.error(error);\n                                        });\n                                }\n                            } else {\n                                ctx.imageAccessorService\n                                    .accessImage(new URL(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString()))\n                                    .then(url => {\n                                        node.thumbnail = url.url.toString();\n                                        ctx.tree.addToDispose(url);\n                                        void ctx.tree.refresh(node.parent);\n                                    })\n                                    .catch(reason => {\n                                        const error = asError(reason);\n                                        console.error(error);\n                                    });\n                            }\n                        }\n                    }\n                }\n            },\n            onRequestComplete: (result, message) => {\n                if (!result) {\n                    console.error(message);\n                }\n            }\n        });\n    }\n}\n\n/**\n * Registers a thumbnail update callback that triggers on the node's first render.\n * When triggered, finds the last draw instance and requests a screenshot for it.\n *\n * @param ctx - Command tree context\n * @param node - Node to register thumbnail update for\n * @param descriptionContext - Description for the requester debug name (e.g., \"render pass 5\", \"dynamic render pass\")\n */\nfunction registerThumbnailUpdate(\n    ctx: CommandTreeContext,\n    node: CommandTreeNode & { thumbnail?: string },\n    descriptionContext: string\n): void {\n    const updateThumbnail = (): void => {\n        const lastDraw = findLastDrawInstanceNode(node);\n        if (lastDraw) {\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', updateThumbnail);\n            const requesterDbgName = `Command tree ${descriptionContext} last draw: ${lastDraw.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(lastDraw), node, requesterDbgName);\n        }\n    };\n    SokatoaLifecycleTreeNode.register(node, 'onWillRender', updateThumbnail);\n}\n\nexport interface CommandRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    renderPassInstanceId: number;\n    renderPassId?: number;\n    renderSubpassEventIds: number[];\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderPassInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.instanceId,\n            renderPassId: element.renderPass,\n            renderSubpassEventIds: [],\n            label: `Render Pass ${element.passIndex}`,\n            parent,\n            resourceType: CommandRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        // A render pass will only contain render subpasses and will always contain at least one subpass\n        const renderSubpassInstances = element.renderSubpassInstanceIds.flatMap(id => {\n            const instance = root.resource.renderSubpassInstances[id];\n            if (!instance) {\n                console.warn(`CommandRenderPassInstanceNode.create: renderSubpassInstance not found for id ${id}`);\n                return [];\n            }\n            return instance;\n        });\n        renderSubpassInstances.forEach(subpass => {\n            if (subpass.beginApiEvent !== node.resource.beginApiEvent) {\n                node.renderSubpassEventIds.push(subpass.beginApiEvent);\n            }\n        });\n        node.children.push(\n            ...renderSubpassInstances.map(instance => {\n                const subpassNode = CommandRenderSubpassInstanceNode.create(ctx, instance, node, baseDynamicStatePromise);\n                return subpassNode;\n            })\n        );\n\n        registerThumbnailUpdate(ctx, node, `render pass ${node.renderPassId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandRenderSubpassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderSubpassInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    renderPassInstanceId: number;\n    renderSubpassInstanceId: number;\n    renderSubpassIndex: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderSubpassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderSubpassInstanceNode {\n    export const RESOURCE_TYPE = 'render-subpass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderSubpassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderSubpassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderSubpassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderSubpassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderSubpassInstanceNode {\n        const node: CommandRenderSubpassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.renderPassInstance,\n            renderSubpassInstanceId: element.instanceId,\n            renderSubpassIndex: element.subpassIndex,\n            label: `Subpass ${element.subpassIndex}`,\n            parent,\n            resourceType: CommandRenderSubpassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this render subpass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference render subpass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a render subpass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.renderSubpassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginRenderSubpassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endRenderSubpassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this render subpass\n        const debugLabelGroupInstances = {\n            array: element.debugLabelGroupInstanceIds.flatMap(id => {\n                const result = root.resource.debugLabelGroupInstances[id];\n                if (!result) {\n                    console.warn(`Missing debugLabelGroupInstances for ${id}.`);\n                    return [];\n                }\n                return result;\n            }),\n            getSortNumber: (debugLabelGroupInstance: CommandTreeDebugLabelGroupInstance) => debugLabelGroupInstance.beginApiEvent\n        };\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'render subpass');\n\n        return node;\n    }\n}\n\nexport interface CommandDynamicRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeDynamicRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    dynamicRenderPassInstanceId: number;\n    dynamicRenderPassId?: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDynamicRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'dynamic-render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDynamicRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDynamicRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDynamicRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDynamicRenderPassInstanceNode {\n        const node: CommandDynamicRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dynamicRenderPassInstanceId: element.instanceId,\n            label: `Dynamic Render Pass ${element.dynamicPassIndex}`,\n            parent,\n            resourceType: CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this dynamic render pass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this dynamic render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference dynamic render pass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a dynamic render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.dynamicRenderPassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginDynamicRenderPassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endDynamicRenderPassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this dynamic render pass\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDynamicRenderPassInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'dynamic render pass');\n\n        return node;\n    }\n}\n\nasync function createChildEventNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    stateTracker: DynamicStateTracker\n): Promise<number> {\n    let endCommandIndex = commandIndex;\n    const baseDynamicStatePromise = stateTracker.getCurrentState();\n\n    if (command.secondaryCommandBufferExecutionId) {\n        // Look up the execution to get the apiEvent, which is the key for secondaryCommandBufferInstances\n        const execution = root.resource.secondaryCommandBufferExecutions[command.secondaryCommandBufferExecutionId];\n        if (execution) {\n            const secondaryInstances = root.resource.secondaryCommandBufferInstances[execution.apiEvent];\n            if (secondaryInstances && secondaryInstances.length > 0) {\n                const node = await CommandSecondaryCommandBufferExecutionNode.create(\n                    ctx,\n                    secondaryInstances,\n                    parentNode,\n                    endCommandIndex++,\n                    baseDynamicStatePromise,\n                    stateTracker\n                );\n                parentNode.children.push(node);\n            }\n        }\n    } else {\n        endCommandIndex = createDrawOrDispatchChildNode(ctx, command, root, parentNode, commandIndex, baseDynamicStatePromise);\n    }\n    return endCommandIndex;\n}\n\nfunction createDrawOrDispatchChildNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n): number {\n    let currentCommandIndex = commandIndex;\n    let accelerationStructureBuildIndex = 0;\n    let accelerationStructureCopyIndex = 0;\n    if (command) {\n        if (command.drawInstanceId && root.resource.drawInstances[command.drawInstanceId]) {\n            parentNode.children.push(\n                CommandDrawInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.dispatchInstanceId && root.resource.dispatchInstances[command.dispatchInstanceId]) {\n            parentNode.children.push(\n                CommandDispatchInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.meshTaskInstanceId && root.resource.meshTaskInstances[command.meshTaskInstanceId]) {\n            parentNode.children.push(\n                CommandMeshTaskInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.clusterInstanceId && root.resource.clusterInstances[command.clusterInstanceId]) {\n            parentNode.children.push(\n                CommandClusterInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.raytracingInstanceId && root.resource.raytracingInstances[command.raytracingInstanceId]) {\n            parentNode.children.push(\n                CommandRaytracingInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (\n            command.accelerationStructureBuildInstanceId &&\n            root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureBuildNode.create(\n                    root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]!,\n                    parentNode,\n                    accelerationStructureBuildIndex++\n                )\n            );\n        } else if (\n            command.accelerationStructureCopyInstanceId &&\n            root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureCopyNode.create(\n                    root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]!,\n                    parentNode,\n                    accelerationStructureCopyIndex++\n                )\n            );\n        } else if (command.transferCommandInstanceId && root.resource.transferCommands[command.transferCommandInstanceId]) {\n            parentNode.children.push(\n                CommandTransferCommandNode.create(\n                    root.resource.transferCommands[command.transferCommandInstanceId]!,\n                    parentNode,\n                    currentCommandIndex++\n                )\n            );\n        } else if (command.debugLabelId && root.resource.debugLabels[command.debugLabelId]) {\n            // Only add debug label nodes if this is the BEGIN event (not END event)\n            // The END event has debugLabelId set but should not create a node\n            const debugLabel = root.resource.debugLabels[command.debugLabelId];\n            if (debugLabel && debugLabel.beginApiEvent === command.apiEventId) {\n                // Check if this is a group (has both begin and end and they differ) or just an insert\n                if (debugLabel.endApiEvent && debugLabel.beginApiEvent !== debugLabel.endApiEvent) {\n                    // This is a debug label group - it should be handled by the range processing logic\n                    // Don't create any node here, just skip it\n                    // (The group will be created if it's in debugLabelGroupInstances, or omitted if it crosses boundaries)\n                } else {\n                    // This is a debug label insert - create as simple API event node\n                    parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode));\n                }\n            }\n        } else if (command.commandInstanceId && root.resource.commandInstances[command.commandInstanceId]) {\n            parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode, currentCommandIndex++));\n        }\n    }\n    return currentCommandIndex;\n}\n\nexport interface CommandDrawInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    drawInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDrawInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandDrawInstanceNode {\n    export const RESOURCE_TYPE = 'draw-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDrawInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDrawInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_draw_${element.drawInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDrawInstanceNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDrawInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            drawInstanceId: element.drawInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDrawInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query draw instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n            const requesterDbgName = `Command draw instance ${node.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(node), node, requesterDbgName);\n        });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDrawInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const drawInstanceDynamicStatePromise = batchQuery\n                ? queryDrawInstanceDynamicStateBatched(db, [node.resource.drawInstanceId || 0])\n                : queryDrawInstanceDynamicState(db, [node.resource.drawInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                drawInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.GRAPHICS\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandDispatchInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    dispatchInstanceId: number;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandDispatchInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n    thumbnail?: string;\n}\n\nexport namespace CommandDispatchInstanceNode {\n    export const RESOURCE_TYPE = 'dispatch-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDispatchInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDispatchInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_dispatch_${element.dispatchInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDispatchInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandDispatchInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dispatchInstanceId: element.dispatchInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDispatchInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query dispatch instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for dispatch nodes\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command dispatch instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDispatchInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const dispatchInstanceDynamicStatePromise = batchQuery\n                ? queryDispatchInstanceDynamicStateBatched(db, [node.resource.dispatchInstanceId || 0])\n                : queryDispatchInstanceDynamicState(db, [node.resource.dispatchInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                dispatchInstanceDynamicStatePromise,\n                PipelineBindPoint.COMPUTE,\n                PipelineBindPointShaderStageFlags.COMPUTE\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandMeshTaskInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    meshTaskInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandMeshTaskInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandMeshTaskInstanceNode {\n    export const RESOURCE_TYPE = 'mesh-task-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandMeshTaskInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandMeshTaskInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_meshtask_${element.meshTaskInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandMeshTaskInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandMeshTaskInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            meshTaskInstanceId: element.meshTaskInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandMeshTaskInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query mesh instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for mesh task dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command mesh instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandMeshTaskInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const meshTaskInstanceDynamicStatePromise = batchQuery\n                ? queryMeshTaskInstanceDynamicStateBatched(db, [node.resource.meshTaskInstanceId || 0])\n                : queryMeshTaskInstanceDynamicState(db, [node.resource.meshTaskInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                meshTaskInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.TASK_MESH\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandClusterInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    clusterInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandClusterInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandClusterInstanceNode {\n    export const RESOURCE_TYPE = 'cluster-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandClusterInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandClusterInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_cluster_${element.clusterInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandClusterInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandClusterInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            clusterInstanceId: element.clusterInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandClusterInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query cluster instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for cluster dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command cluster instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandClusterInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const clusterInstanceDynamicStatePromise = batchQuery\n                ? queryClusterInstanceDynamicStateBatched(db, [node.resource.clusterInstanceId || 0])\n                : queryClusterInstanceDynamicState(db, [node.resource.clusterInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                clusterInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.CLUSTER\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandRaytracingInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    raytracingInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandRaytracingInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandRaytracingInstanceNode {\n    export const RESOURCE_TYPE = 'raytracing-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandRaytracingInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRaytracingInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_raytracing_${element.raytracingInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRaytracingInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRaytracingInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            raytracingInstanceId: element.raytracingInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandRaytracingInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query raytracing instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for raytracing dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command raytracing instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandRaytracingInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const raytracingInstanceDynamicStatePromise = batchQuery\n                ? queryRaytracingInstanceDynamicStateBatched(db, [node.resource.raytracingInstanceId || 0])\n                : queryRaytracingInstanceDynamicState(db, [node.resource.raytracingInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                raytracingInstanceDynamicStatePromise,\n                PipelineBindPoint.RAY_TRACING,\n                PipelineBindPointShaderStageFlags.RAY_TRACING\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport function getQueueSubmitId(node: CommandTreeNode): number | undefined {\n    let currentNode: CompositeTreeNode | undefined;\n    if (\n        CommandEmptyNode.is(node) ||\n        CommandApiEventNode.is(node) ||\n        CommandTreeDrawOrDispatchNode.is(node) ||\n        CommandAccelerationStructureBuildNode.is(node) ||\n        CommandAccelerationStructureCopyNode.is(node) ||\n        CommandTransferCommandNode.is(node)\n    ) {\n        currentNode = node.parent;\n    } else if (CommandQueuePresentNode.is(node) || CommandQueueDebugLabelNode.is(node)) {\n        return undefined;\n    } else {\n        currentNode = node;\n    }\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(currentNode, CommandQueueSubmitNode.is);\n    return queueSubmitNode ? queueSubmitNode.resource.submissionId : undefined;\n}\n\nexport function findLastDrawInstanceNode(node: CommandTreeNode): CommandDrawInstanceNode | undefined {\n    if (CommandDrawInstanceNode.is(node)) {\n        return node;\n    }\n    let lastDraw: CommandDrawInstanceNode | undefined;\n    if (!CommandDrawInstanceNode.is(node) && ExpandableTreeNode.is(node)) {\n        for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n            lastDraw = findLastDrawInstanceNode(node.children[commandIndex]);\n            if (lastDraw) {\n                break;\n            }\n        }\n    }\n    return lastDraw;\n}\n\nexport function createExecuteCommandsApiResources(\n    node: CommandSecondaryCommandBufferExecutionNode,\n    primaryNode: CommandCommandBufferInstanceNode,\n    queueSubmitNode: CommandQueueSubmitNode,\n    specificSecondaryCommandBufferBeginId?: number // If provided, only include this specific secondary CB\n): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    // findParentNode checks the given node for its type so we have to start looking from this node's parent\n    // otherwise we run into infinite recursion\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node.parent,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n\n    // Collect secondary command buffer begin IDs from the children\n    const commandBufferBeginIds: number[] = [];\n    if (specificSecondaryCommandBufferBeginId !== undefined) {\n        // Only include the specific secondary CB that was requested\n        commandBufferBeginIds.push(specificSecondaryCommandBufferBeginId);\n    } else {\n        // Include all secondary CBs (for when the execution node itself requests a thumbnail)\n        for (const child of node.children) {\n            if (CommandCommandBufferInstanceNode.is(child)) {\n                commandBufferBeginIds.push(child.resource.beginApiEvent);\n            }\n        }\n    }\n\n    const resources: ApiResources[] = [];\n    if (secondaryCommandBufferExecutionNode) {\n        const renderpassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n            renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n            CommandSecondaryCommandBufferExecutionNode.is\n        );\n\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: secondaryCommandBufferExecutionNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n                renderpassSecondaryCommandBufferExecutionNode &&\n                renderpassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n        const executionResources = createExecuteCommandsApiResources(secondaryCommandBufferExecutionNode, primaryNode, queueSubmitNode);\n        if (executionResources.length > 0) {\n            resources.push(...executionResources);\n        }\n    } else {\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: primaryNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                renderPassInstanceNode || dynamicRenderPassInstanceNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n    }\n    return resources;\n}\n\nexport function createDrawApiResources(node: CommandDrawInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    // This will find the immediate parent command buffer (secondary if in a secondary CB, primary otherwise)\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n\n    const resources: ApiResources[] = [];\n    if (\n        (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n        queueSubmitNode &&\n        commandBufferInstanceNode &&\n        primaryCommandBufferInstanceNode\n    ) {\n        if (secondaryCommandBufferExecutionNode) {\n            const renderPassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n                CommandSecondaryCommandBufferExecutionNode.is\n            );\n\n            // Add draw resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses:\n                    renderPassSecondaryCommandBufferExecutionNode &&\n                    renderPassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                        ? [\n                              {\n                                  beginId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                                  subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                                  endId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                        dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                              }\n                          ]\n                        : []\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses: [\n                    {\n                        beginId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                        subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                        endId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.endApiEvent || dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                    }\n                ]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createComputeApiResources(node: CommandDispatchInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add dispatch resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createTraceRaysApiResources(node: CommandRaytracingInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTransferNode = CommandAccelerationStructureBuildNode | CommandAccelerationStructureCopyNode | CommandTransferCommandNode;\n\nexport function createTransferApiResources(node: CommandTransferNode): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    let transferEvent: number = 0;\n    if (CommandAccelerationStructureBuildNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureBuildNode).resource.buildApiEvent;\n    } else if (CommandAccelerationStructureCopyNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureCopyNode).resource.copyApiEvent;\n    } else if (CommandTransferCommandNode.is(node)) {\n        transferEvent = (node as CommandTransferCommandNode).resource.transferApiEvent;\n    }\n\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTreeNode =\n    | CommandFrameNode\n    | CommandEmptyNode\n    | CommandApiEventNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandQueuePresentNode\n    | CommandQueueDebugLabelGroupNode\n    | CommandQueueDebugLabelNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandEmptyNode.is(node) ||\n            CommandApiEventNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandQueuePresentNode.is(node) ||\n            CommandQueueDebugLabelGroupNode.is(node) ||\n            CommandQueueDebugLabelNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n\n    export function findApiEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandSecondaryCommandBufferExecutionNode.is(current)) {\n            // For secondary command buffer execution nodes, return the VkCmdExecuteCommands apiEvent\n            // rather than the VkCommandBufferBegin apiEvent\n            return current.resource.apiEvent;\n        } else if (CommandTreeRangeNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (\n            CommandApiEventNode.is(current) ||\n            CommandQueueSubmitNode.is(current) ||\n            CommandQueuePresentNode.is(current) ||\n            CommandQueueDebugLabelNode.is(current)\n        ) {\n            return current.apiEventId;\n        } else if (CommandQueueDebugLabelGroupNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (CommandAccelerationStructureBuildNode.is(current)) {\n            return current.resource.buildApiEvent;\n        } else if (CommandAccelerationStructureCopyNode.is(current)) {\n            return current.resource.copyApiEvent;\n        } else if (CommandTransferCommandNode.is(current)) {\n            return current.apiEventId;\n        } else if (CommandTreeDrawOrDispatchNode.is(current)) {\n            return current.resource.apiEventId;\n        }\n        return undefined;\n    }\n\n    export function findFilterEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandFrameNode.is(current)) {\n            return current.resource.beginApiEvent;\n        }\n        let maybeQueueSubmitOrPresent: TreeNode | undefined = current;\n        while (\n            maybeQueueSubmitOrPresent !== undefined &&\n            !(\n                CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueuePresentNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)\n            )\n        ) {\n            maybeQueueSubmitOrPresent = maybeQueueSubmitOrPresent.parent;\n        }\n        let queueSubmitEventId: number | undefined;\n        if (maybeQueueSubmitOrPresent !== undefined) {\n            if (CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) || CommandQueuePresentNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            } else if (CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.resource.beginApiEvent;\n            } else if (CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            }\n        }\n        return queueSubmitEventId;\n    }\n\n    export function findRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const renderPassNode = findParentNode<CommandRenderPassInstanceNode>(current, CommandRenderPassInstanceNode.is);\n        return renderPassNode ? renderPassNode.renderPassInstanceId : undefined;\n    }\n\n    export function findDynamicRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const dynamicRenderPassNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n            current,\n            CommandDynamicRenderPassInstanceNode.is\n        );\n        return dynamicRenderPassNode ? dynamicRenderPassNode.dynamicRenderPassInstanceId : undefined;\n    }\n\n    export function findDrawInstanceId(current?: CommandTreeNode): number | undefined {\n        const drawInstanceNode = findParentNode<CommandDrawInstanceNode>(current, CommandDrawInstanceNode.is);\n        return drawInstanceNode ? drawInstanceNode.drawInstanceId : undefined;\n    }\n\n    export function findDispatchInstanceId(current?: CommandTreeNode): number | undefined {\n        const dispatchInstanceNode = findParentNode<CommandDispatchInstanceNode>(current, CommandDispatchInstanceNode.is);\n        return dispatchInstanceNode ? dispatchInstanceNode.dispatchInstanceId : undefined;\n    }\n\n    export function findMeshTaskInstanceId(current?: CommandTreeNode): number | undefined {\n        const meshTaskInstanceNode = findParentNode<CommandMeshTaskInstanceNode>(current, CommandMeshTaskInstanceNode.is);\n        return meshTaskInstanceNode ? meshTaskInstanceNode.meshTaskInstanceId : undefined;\n    }\n\n    export function findClusterInstanceId(current?: CommandTreeNode): number | undefined {\n        const clusterInstanceNode = findParentNode<CommandClusterInstanceNode>(current, CommandClusterInstanceNode.is);\n        return clusterInstanceNode ? clusterInstanceNode.clusterInstanceId : undefined;\n    }\n\n    export function findRaytracingInstanceId(current?: CommandTreeNode): number | undefined {\n        const raytracingInstanceNode = findParentNode<CommandRaytracingInstanceNode>(current, CommandRaytracingInstanceNode.is);\n        return raytracingInstanceNode ? raytracingInstanceNode.raytracingInstanceId : undefined;\n    }\n\n    export function findAccelerationBuildInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelBuildNode = findParentNode<CommandAccelerationStructureBuildNode>(current, CommandAccelerationStructureBuildNode.is);\n        return accelBuildNode ? accelBuildNode.buildInstanceId : undefined;\n    }\n\n    export function findAccelerationCopyInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelCopyNode = findParentNode<CommandAccelerationStructureCopyNode>(current, CommandAccelerationStructureCopyNode.is);\n        return accelCopyNode ? accelCopyNode.copyInstanceId : undefined;\n    }\n\n    export function findTransferCommandInstanceId(current?: CommandTreeNode): number | undefined {\n        const transferCommandNode = findParentNode<CommandTransferCommandNode>(current, CommandTransferCommandNode.is);\n        return transferCommandNode ? transferCommandNode.transferCommandInstanceId : undefined;\n    }\n\n    export function findMergedDynamicStatePromise(\n        current: CommandTreeNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> | undefined {\n        let maybeDrawOrDispatchInstance: TreeNode | undefined = current;\n        while (maybeDrawOrDispatchInstance !== undefined && !CommandTreeDrawOrDispatchNode.is(maybeDrawOrDispatchInstance)) {\n            maybeDrawOrDispatchInstance = maybeDrawOrDispatchInstance.parent;\n        }\n        let mergedDynamicStatePromise: Promise<DynamicStateEntry[]> | undefined;\n        if (maybeDrawOrDispatchInstance !== undefined && CommandDrawInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDrawInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandDispatchInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDispatchInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandMeshTaskInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandMeshTaskInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandClusterInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandClusterInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandRaytracingInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandRaytracingInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        }\n        return mergedDynamicStatePromise;\n    }\n\n    export function getRoot(node?: CompositeTreeNode | CommandRootNode | CommandTreeNode): CommandRootNode | undefined {\n        return findParentNode<CommandRootNode>(node, CommandRootNode.is);\n    }\n\n    export function getDbId(node: CommandRootNode | CommandTreeNode): number {\n        return getRoot(node)?.dbId ?? -1;\n    }\n\n    type GeneralizableNodes =\n        | typeof CommandApiEventNode\n        | typeof CommandClusterInstanceNode\n        | typeof CommandCommandBufferInstanceNode\n        | typeof CommandDispatchInstanceNode\n        | typeof CommandDrawInstanceNode\n        | typeof CommandEmptyNode\n        | typeof CommandFrameNode\n        | typeof CommandMeshTaskInstanceNode\n        | typeof CommandQueuePresentNode\n        | typeof CommandQueueSubmitNode\n        | typeof CommandQueueDebugLabelGroupNode\n        | typeof CommandQueueDebugLabelNode\n        | typeof CommandAccelerationStructureBuildNode\n        | typeof CommandAccelerationStructureCopyNode\n        | typeof CommandTransferCommandNode\n        | typeof CommandRaytracingInstanceNode\n        | typeof CommandRenderPassInstanceNode\n        | typeof CommandRenderSubpassInstanceNode\n        | typeof CommandDynamicRenderPassInstanceNode\n        | typeof CommandDebugLabelGroupNode;\n\n    /**\n     * An aggregate type label for command-tree nodes, roughly corresponding to some of the union\n     * types defined in this module.\n     */\n    export type GeneralizedType = GeneralizableNodes['GENERALIZED_TYPE'];\n\n    /**\n     * Query the generalized type of a given node, if it is a Command Tree node.\n     *\n     * @param node a tree node that may or may not be a `CommandTreeNode`\n     * @return its generalized type, or `undefined` if it isn't a `CommandTreeNode`\n     */\n    export function getGeneralizedNodeType(node: TreeNode): GeneralizedType | undefined {\n        const resourceType = 'resourceType' in node ? node.resourceType : undefined;\n        if (!resourceType) {\n            return CommandEmptyNode.is(node) ? 'empty' : undefined;\n        }\n\n        switch (resourceType) {\n            case 'frame':\n            case 'command-buffer-instance':\n            case 'render-pass-instance':\n            case 'render-subpass-instance':\n            case 'secondary-command-buffer-execution':\n            case 'debug-label-group':\n                return 'range';\n            case 'queue-submit':\n            case 'queue-present':\n                return 'queue';\n            case 'acceleration-structure-build':\n                return 'acceleration-structure-build';\n            case 'acceleration-structure-copy':\n                return 'acceleration-structure-copy';\n            case 'transfer-command':\n                return 'transfer-command';\n            case 'draw-instance':\n            case 'dispatch-instance':\n            case 'mesh-task-instance':\n            case 'cluster-instance':\n            case 'raytracing-instance':\n                return 'draw-or-dispatch';\n            case 'api-event':\n                return 'api-event';\n            default:\n                return undefined;\n        }\n    }\n\n    /** Type assertion for a range-type node. */\n    export function generalize(node: TreeNode, type: 'range'): asserts node is CommandTreeRangeNode;\n    /** Type assertion for a queue-type node. */\n    export function generalize(node: TreeNode, type: 'queue'): asserts node is CommandQueueSubmitNode | CommandQueuePresentNode;\n    /** Type assertion for a queue-debug-label-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'queue-debug-label'\n    ): asserts node is CommandQueueDebugLabelGroupNode | CommandQueueDebugLabelNode;\n    /** Type assertion for a acceleration-structure-build-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-build'): asserts node is CommandAccelerationStructureBuildNode;\n    /** Type assertion for a acceleration-structure-copy-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-copy'): asserts node is CommandAccelerationStructureCopyNode;\n    /** Type assertion for a transfer-command-type node. */\n    export function generalize(node: TreeNode, type: 'transfer-command'): asserts node is CommandTransferCommandNode;\n    /** Type assertion for a draw-or-dispatch-type node. */\n    export function generalize(node: TreeNode, type: 'draw-or-dispatch'): asserts node is CommandTreeDrawOrDispatchNode;\n    /** Type assertion for an api-event-type node. */\n    export function generalize(node: TreeNode, type: 'api-event'): asserts node is CommandApiEventNode;\n    /** Type assertion for a draw-or-dispatch- or api-event-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'draw-or-dispatch' | 'api-event'\n    ): asserts node is CommandTreeDrawOrDispatchNode | CommandApiEventNode;\n    /** Type assertion for an empty-type node. */\n    export function generalize(node: TreeNode, type: 'empty'): asserts node is CommandEmptyNode;\n    export function generalize(node: TreeNode, _type: GeneralizedType): asserts node is CommandTreeNode {\n        // Pass\n    }\n}\n\nexport type CommandTreeRangeNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeRangeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeRangeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n}\n\nexport type CommandTreeDrawOrDispatchNode =\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode;\n\nexport namespace CommandTreeDrawOrDispatchNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeDrawOrDispatchNode {\n        return (\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node)\n        );\n    }\n}\n\ninterface ArrayWithSortNumber<RangeType> {\n    array: RangeType[];\n    getSortNumber(element: RangeType): number;\n}\n\ntype AllRangeTypes =\n    | CommandTreeDebugLabelGroupInstance\n    | CommandTreeRenderPassInstance\n    | CommandTreeRenderSubpassInstance\n    | CommandTreeDynamicRenderPassInstance;\n\ntype CommandTreeRangeParentNode =\n    | CommandRenderPassInstanceNode\n    | CommandCommandBufferInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandDebugLabelGroupNode;\n\nfunction findNextRangeElementToProcess<RangeType>(...arrays: ArrayWithSortNumber<RangeType>[]): RangeType | undefined {\n    // designate which array is the api event array vs a range array\n    // when processing a range, shift off any api events that are within the range\n    // so they aren't processed (because they actually reside within a sub-group)\n\n    const arraysToProcess: ArrayWithSortNumber<RangeType>[] = [];\n    arrays.forEach(arr => {\n        if (arr.array.length) {\n            arraysToProcess.push(arr);\n        }\n    });\n\n    if (!arraysToProcess.length) {\n        return undefined;\n    }\n\n    // get the sort number of the first element of each array and sort them\n    const sortedElements = arraysToProcess\n        .map(array => ({ subarray: array.array, sortNumber: array.getSortNumber(array.array[0]) }))\n        .sort((a, b) => a.sortNumber - b.sortNumber);\n\n    return sortedElements[0].subarray.shift();\n}\n\n/**\n * Process commands and ranges together in API event order.\n * For each range element, creates child nodes for commands that come before it,\n * skips commands that fall within the range, and creates a node for the range itself.\n * After processing all ranges, any remaining commands are processed.\n *\n * @param ctx - Command tree context\n * @param root - Root node\n * @param parentNode - Parent node to add children to\n * @param apiEventCommandArray - Array of commands sorted by API event ID (will be mutated)\n * @param childCommandIndex - Starting index for child commands\n * @param baseDynamicStatePromise - Promise for dynamic state\n * @param createRangeNode - Callback to create a node for each range element\n * @param rangeArrays - Variable number of range arrays to process together\n * @returns The final child command index\n */\nasync function createChildEventNodesForRange<RangeType extends { beginApiEvent: number; endApiEvent?: number }>(\n    ctx: CommandTreeContext,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    apiEventCommandArray: CommandTreeApiEvent[],\n    childCommandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n    createRangeNode: (rangeElement: RangeType, parentNode: CommandTreeRangeParentNode) => void,\n    ...rangeArrays: ArrayWithSortNumber<RangeType>[]\n): Promise<number> {\n    const stateTracker = new DynamicStateTracker(baseDynamicStatePromise);\n    let nextRangeElement: RangeType | undefined;\n    let priorRangeEndApiEvent: number | undefined;\n\n    while ((nextRangeElement = findNextRangeElementToProcess<RangeType>(...rangeArrays))) {\n        // create a node for any command that comes BEFORE the next range element\n        while (apiEventCommandArray.length && apiEventCommandArray[0].apiEventId < nextRangeElement.beginApiEvent) {\n            const command = apiEventCommandArray.shift();\n            childCommandIndex = await createChildEventNode(ctx, command!, root, parentNode, childCommandIndex, stateTracker);\n        }\n\n        // shift off any command that falls WITHIN next range since it will be processed when creating next range node\n        while (\n            apiEventCommandArray.length &&\n            nextRangeElement.endApiEvent !== undefined &&\n            apiEventCommandArray[0].apiEventId >= nextRangeElement.beginApiEvent &&\n            apiEventCommandArray[0].apiEventId <= nextRangeElement.endApiEvent\n        ) {\n            apiEventCommandArray.shift();\n        }\n\n        // skip next range if it falls within the prior range since it will be processed when creating prior range node\n        if (\n            priorRangeEndApiEvent !== undefined &&\n            nextRangeElement.endApiEvent !== undefined &&\n            nextRangeElement.endApiEvent <= priorRangeEndApiEvent\n        ) {\n            continue;\n        }\n        priorRangeEndApiEvent = nextRangeElement.endApiEvent;\n\n        // create a node for the next range element\n        createRangeNode(nextRangeElement, parentNode);\n    }\n\n    // process any remaining command elements after all range elements have been processed\n    for (const command of apiEventCommandArray) {\n        childCommandIndex = await createChildEventNode(ctx, command, root, parentNode, childCommandIndex, stateTracker);\n    }\n\n    return childCommandIndex;\n}\n\n/**\n * Find node from descendent node for which isNode is true\n */\nexport const findParentNode = <T extends TreeNode>(\n    node: TreeNode | undefined,\n    isNode: (node: TreeNode | undefined) => node is T\n): T | undefined => {\n    let targetNode: TreeNode | undefined = node;\n    while (targetNode && targetNode.parent && !isNode(targetNode)) {\n        targetNode = targetNode.parent;\n    }\n\n    return targetNode && isNode(targetNode) ? targetNode : undefined;\n};\n\n/**\n * Find the primary command buffer instance node from a given command buffer instance node.\n * If the given node is in a secondary command buffer, traverses up through nested secondary\n * command buffers until finding the primary command buffer (one with no parent execution node).\n * If the given node is already in a primary command buffer, returns it as-is.\n */\nexport const findPrimaryCommandBufferInstanceNode = (\n    commandBufferInstanceNode: CommandCommandBufferInstanceNode | undefined,\n    secondaryCommandBufferExecutionNode: CommandSecondaryCommandBufferExecutionNode | undefined\n): CommandCommandBufferInstanceNode | undefined => {\n    let primaryCommandBufferInstanceNode = commandBufferInstanceNode;\n    if (secondaryCommandBufferExecutionNode) {\n        let currentExecution: CommandSecondaryCommandBufferExecutionNode | undefined = secondaryCommandBufferExecutionNode;\n        while (currentExecution) {\n            const parentCB: CommandCommandBufferInstanceNode | undefined = findParentNode<CommandCommandBufferInstanceNode>(\n                currentExecution,\n                CommandCommandBufferInstanceNode.is\n            );\n            if (parentCB) {\n                primaryCommandBufferInstanceNode = parentCB;\n                // Check if this CB is also inside another secondary execution (nested case)\n                currentExecution = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                    parentCB.parent,\n                    CommandSecondaryCommandBufferExecutionNode.is\n                );\n            } else {\n                break;\n            }\n        }\n    }\n    return primaryCommandBufferInstanceNode;\n};\n\n/**\n * find a frame node from descendent node or self\n */\nexport const findFrameNode = (node: TreeNode): CommandFrameNode | undefined => findParentNode<CommandFrameNode>(node, CommandFrameNode.is);\n\n@injectable()\nexport class CommandTree extends BulkTree implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTree {\n        return tree instanceof CommandTree;\n    }\n\n    @inject(CaptureDatasetWidgetProfile)\n    protected readonly profile: CaptureDatasetWidgetProfile;\n    @inject(CaptureDatasetWidgetContext)\n    protected readonly context: CaptureDatasetWidgetContext;\n\n    @inject(CommandTreeDataQueriedRootProvider)\n    protected readonly rootProvider: CommandTreeDataQueriedRootProvider;\n    @inject(GFXRQueryBuilderService)\n    protected readonly gfxrQueryBuilderService: GFXRQueryBuilderService;\n\n    protected override _root: CommandRootNode | undefined;\n\n    // Back-reference to the model that manages this tree\n    model?: CommandTreeModel;\n\n    protected readonly onStructureChangedEmitter = new Emitter<TreeNode | undefined>();\n    readonly onStructureChanged = this.onStructureChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this._root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        super.root = root;\n        // Set back-reference from root to tree\n        if (root) {\n            root.tree = this;\n        }\n    }\n\n    async initTree(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        this.root = await this.rootProvider.provide(dbId, { tree: this }, options, createDrawOrDispatchChildren);\n\n        // tree structure is fully built at this point, report structure change\n        this.onStructureChangedEmitter.fire(undefined);\n    }\n\n    async refreshStructure(node?: CompositeTreeNode, cancellationToken?: CancellationToken): Promise<void> {\n        console.log('JF: CommandTree.refreshStructure START', { nodeId: node?.id });\n        await this.refresh(node, cancellationToken);\n        console.log('JF: CommandTree.refreshStructure - calling fireStructureChanged');\n        this.fireStructureChanged(node);\n        console.log('JF: CommandTree.refreshStructure END');\n    }\n\n    fireStructureChanged(node?: TreeNode): void {\n        console.log('JF: CommandTree.fireStructureChanged', { nodeId: node?.id });\n        this.onStructureChangedEmitter.fire(node);\n    }\n\n    addToDispose(disposable: Disposable): void {\n        this.toDispose.push(disposable);\n    }\n\n    override dispose(): void {\n        this.rootProvider.dispose();\n        super.dispose();\n    }\n}\n\n@injectable()\nexport class CommandTreeModelPreferenceStateAccessImpl implements CommandTreePreferenceState.Access {\n    private readonly models = new Map<CommandTree, CommandTreeModel>();\n\n    private readonly commandTreeStateChangedEmitter = new Emitter<{ tree: CommandTree; state: CommandTreePreferenceState }>();\n    readonly onCommandTreeStateChanged = this.commandTreeStateChangedEmitter.event;\n\n    getCommandTreeState(tree: CommandTree): CommandTreePreferenceState {\n        return this.models.get(tree)?.getPreferenceState() ?? {};\n    }\n\n    fireCommandTreeStateChanged(tree: CommandTree): void {\n        this.commandTreeStateChangedEmitter.fire({ tree, state: this.getCommandTreeState(tree) });\n    }\n\n    registerCommandTreeModel(tree: CommandTree, model: CommandTreeModel): void {\n        this.models.set(tree, model);\n        this.fireCommandTreeStateChanged(tree);\n    }\n}\n\n@injectable()\nexport class CommandTreeModel extends BulkTreeModel implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTreeModel {\n        return tree instanceof CommandTreeModel;\n    }\n\n    @inject(MiscPreferences)\n    protected readonly miscPreferences: MiscPreferences;\n    @inject(CommandTree) override readonly tree: CommandTree;\n    protected _groupBy: GroupByOptions = GroupByOptions.Frame;\n    private groupByChangedEmitter = new Emitter<GroupByOptions>();\n    readonly onGroupByChanged = this.groupByChangedEmitter.event;\n    protected _isThumbnailEnabled = true;\n    protected _isApiEventIdsEnabled = true;\n    protected _isShowingEmptyRows = false;\n    protected _isVulkanEnabled = true;\n    protected _isDebugNamesEnabled = true;\n    protected _isDebugLabelsEnabled = true;\n    protected _isLinksEnabled = true;\n    protected _isThreadsEnabled = true;\n\n    @inject(FrameRangeSelectionService)\n    protected readonly frameRangeSelectionService: FrameRangeSelectionService;\n\n    @inject(CommandTreeModelPreferenceStateAccessImpl)\n    private readonly preferenceStateAccess: CommandTreeModelPreferenceStateAccessImpl;\n\n    protected isCollapsingSubTree = false;\n\n    // Proxies to prevent calls on sub tree expansion\n    protected readonly onExpansionChangedEmitterProxy = new Emitter<ExpandableTreeNode>();\n    protected readonly onChangedEmitterProxy = new Emitter<void>();\n\n    protected readonly onSubTreeExpansionChangedEmitter = new Emitter<ExpandableTreeNode>();\n    readonly onSubTreeExpansionChanged = this.onSubTreeExpansionChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this.tree.root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        this.tree.root = root;\n    }\n\n    override get onChanged(): Event<void> {\n        return this.onChangedEmitterProxy.event;\n    }\n\n    override get onExpansionChanged(): Event<ExpandableTreeNode> {\n        return this.onExpansionChangedEmitterProxy.event;\n    }\n\n    get onStructureChanged(): Event<TreeNode | undefined> {\n        return this.tree.onStructureChanged;\n    }\n\n    async initModel(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        await this.tree.initTree(dbId, createDrawOrDispatchChildren, options);\n    }\n\n    set groupBy(value: GroupByOptions) {\n        if (this._groupBy !== value) {\n            this._groupBy = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n            this.groupByChangedEmitter.fire(value);\n        }\n    }\n\n    get groupBy(): GroupByOptions {\n        return this._groupBy;\n    }\n\n    /**\n     * Obtain the tree nodes that are the top-level groups according to\n     * the current {@link groupBy} mode.\n     */\n    *groupNodes(): IterableIterator<CompositeTreeNode> {\n        if (!this.root) {\n            return;\n        }\n\n        const group = this.groupBy;\n        const treeIterator = new (class extends DepthFirstTreeIterator {\n            protected override children(node: TreeNode): TreeNode[] | undefined {\n                // Prune group nodes because we needn't look in them for more groups\n                return CommandTreeModel.isOfGroup(node, group) ? undefined : super.children(node);\n            }\n        })(this.root);\n\n        for (const next of treeIterator) {\n            if (CommandTreeModel.isOfGroup(next, group)) {\n                yield next;\n            }\n        }\n    }\n\n    set isApiEventIdsEnabled(value: boolean) {\n        if (this._isApiEventIdsEnabled !== value) {\n            this._isApiEventIdsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isApiEventIdsEnabled(): boolean {\n        return this._isApiEventIdsEnabled;\n    }\n\n    set isShowingEmptyRows(value: boolean) {\n        if (this._isShowingEmptyRows !== value) {\n            this._isShowingEmptyRows = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isShowingEmptyRows(): boolean {\n        return this._isShowingEmptyRows;\n    }\n\n    set isThumbnailEnabled(value: boolean) {\n        if (this._isThumbnailEnabled !== value) {\n            this._isThumbnailEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThumbnailEnabled(): boolean {\n        return this._isThumbnailEnabled;\n    }\n\n    set isVulkanEnabled(value: boolean) {\n        if (this._isVulkanEnabled !== value) {\n            this._isVulkanEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isVulkanEnabled(): boolean {\n        return this._isVulkanEnabled;\n    }\n\n    set isDebugNamesEnabled(value: boolean) {\n        if (this._isDebugNamesEnabled !== value) {\n            this._isDebugNamesEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugNamesEnabled(): boolean {\n        return this._isDebugNamesEnabled;\n    }\n\n    set isDebugLabelsEnabled(value: boolean) {\n        if (this._isDebugLabelsEnabled !== value) {\n            this._isDebugLabelsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugLabelsEnabled(): boolean {\n        return this._isDebugLabelsEnabled;\n    }\n\n    set isLinksEnabled(value: boolean) {\n        if (this._isLinksEnabled !== value) {\n            this._isLinksEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isLinksEnabled(): boolean {\n        return this._isLinksEnabled;\n    }\n\n    set isThreadsEnabled(value: boolean) {\n        if (this._isThreadsEnabled !== value) {\n            this._isThreadsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThreadsEnabled(): boolean {\n        return this._isThreadsEnabled;\n    }\n\n    getPreferenceState(nonDefaultOnly = false): CommandTreePreferenceState {\n        const result: CommandTreePreferenceState = {};\n\n        if (!nonDefaultOnly || this.groupBy !== this.miscPreferences[MiscPrefs.GroupBy]) {\n            result.groupBy = this.groupBy;\n        }\n        if (!nonDefaultOnly || this.isApiEventIdsEnabled !== this.miscPreferences[MiscPrefs.ShowApiEventIds]) {\n            result.isApiEventIdsEnabled = this.isApiEventIdsEnabled;\n        }\n        if (!nonDefaultOnly || this.isShowingEmptyRows !== this.miscPreferences[MiscPrefs.ShowEmptyRows]) {\n            result.isShowingEmptyRows = this.isShowingEmptyRows;\n        }\n        if (!nonDefaultOnly || this.isThumbnailEnabled !== this.miscPreferences[MiscPrefs.ShowThumbnails]) {\n            result.isThumbnailEnabled = this.isThumbnailEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugNamesEnabled !== true) {\n            result.isDebugNamesEnabled = this.isDebugNamesEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugLabelsEnabled !== true) {\n            result.isDebugLabelsEnabled = this.isDebugLabelsEnabled;\n        }\n        if (!nonDefaultOnly || this.isLinksEnabled !== true) {\n            result.isLinksEnabled = this.isLinksEnabled;\n        }\n        if (!nonDefaultOnly || this.isThreadsEnabled !== true) {\n            result.isThreadsEnabled = this.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (!nonDefaultOnly || this.isVulkanEnabled !== this.miscPreferences[MiscPrefs.ShowVulkanCalls]) {\n        //     result.isVulkanEnabled = this.isVulkanEnabled;\n        // }\n\n        return result;\n    }\n\n    override restoreState(state: CommandTreeModel.State): void {\n        if (state.groupBy !== undefined) {\n            this.groupBy = state.groupBy;\n        }\n        if (state.isApiEventIdsEnabled !== undefined) {\n            this.isApiEventIdsEnabled = state.isApiEventIdsEnabled;\n        }\n        if (state.isShowingEmptyRows !== undefined) {\n            this.isShowingEmptyRows = state.isShowingEmptyRows;\n        }\n        if (state.isThumbnailEnabled !== undefined) {\n            this.isThumbnailEnabled = state.isThumbnailEnabled;\n        }\n        if (state.isDebugNamesEnabled !== undefined) {\n            this.isDebugNamesEnabled = state.isDebugNamesEnabled;\n        }\n        if (state.isDebugLabelsEnabled !== undefined) {\n            this.isDebugLabelsEnabled = state.isDebugLabelsEnabled;\n        }\n        if (state.isLinksEnabled !== undefined) {\n            this.isLinksEnabled = state.isLinksEnabled;\n        }\n        if (state.isThreadsEnabled !== undefined) {\n            this.isThreadsEnabled = state.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (state.isVulkanEnabled !== undefined) {\n        //     this.isVulkanEnabled = state.isVulkanEnabled;\n        // }\n    }\n    override storeState(): CommandTreeModel.State {\n        return {\n            ...super.storeState(),\n            ...this.getPreferenceState(true)\n        };\n    }\n\n    @postConstruct()\n    protected override init(): void {\n        super.init();\n\n        // Set back-reference from tree to model\n        this.tree.model = this;\n\n        this.toDispose.pushAll([\n            this.onChangedEmitterProxy,\n            this.onExpansionChangedEmitterProxy,\n            this.onSubTreeExpansionChangedEmitter,\n\n            super.onChanged(() => {\n                if (!this.isCollapsingSubTree) {\n                    this.onChangedEmitterProxy.fire();\n                }\n            }),\n            super.onExpansionChanged(node => {\n                if (!this.isCollapsingSubTree) {\n                    this.onExpansionChangedEmitterProxy.fire(node);\n                }\n            })\n        ]);\n\n        this._isApiEventIdsEnabled = this.miscPreferences[MiscPrefs.ShowApiEventIds];\n        this._isShowingEmptyRows = this.miscPreferences[MiscPrefs.ShowEmptyRows];\n        this.isThumbnailEnabled = this.miscPreferences[MiscPrefs.ShowThumbnails];\n        this.groupBy = this.miscPreferences[MiscPrefs.GroupBy];\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // this.isVulkanEnabled = this.miscPreferences[MiscPrefs.ShowVulkanCalls];\n\n        this.preferenceStateAccess.registerCommandTreeModel(this.tree, this);\n    }\n\n    /**\n     * Collapses the entire tree.\n     */\n    async collapseTree(): Promise<void> {\n        const root = this.root;\n\n        if (CompositeTreeNode.is(root) && root.children.length > 0) {\n            await Promise.all(\n                root.children.filter(CompositeTreeNode.is).map((child: CompositeTreeNode) => this.expansionService.collapseAll(child))\n            );\n        }\n    }\n\n    /**\n     * Expands the given node and all its children recursively.\n     */\n    async expandSubTree(node?: Readonly<TreeNode>, includeDrawOrDispatchNodes = false): Promise<void> {\n        node ??= this.root;\n        if (!ExpandableTreeNode.is(node)) {\n            return;\n        }\n\n        try {\n            this.isCollapsingSubTree = true;\n            await this.doExpandSubTree(node, includeDrawOrDispatchNodes);\n            this.onSubTreeExpansionChangedEmitter.fire(node);\n        } finally {\n            this.isCollapsingSubTree = false;\n        }\n    }\n\n    protected async doExpandSubTree(node: TreeNode, includeDrawOrDispatchNodes: boolean): Promise<void> {\n        console.log('JF: doExpandSubTree START', { nodeId: node.id, includeDrawOrDispatchNodes });\n        const YIELD_AFTER_MS = 200;\n\n        const processedNodes = new Set<TreeNode>();\n        const pendingNodes: TreeNode[] = [node];\n        let lastYieldTime = performance.now();\n\n        while (pendingNodes.length > 0) {\n            const currentLevelNodes: ExpandableTreeNode[] = [];\n            const nextLevelNodes: TreeNode[] = [];\n\n            while (pendingNodes.length > 0) {\n                const currentNode = pendingNodes.shift()!;\n                if (processedNodes.has(currentNode)) {\n                    continue;\n                }\n                processedNodes.add(currentNode);\n\n                // stop expansion at draw and dispatch nodes to avoid creation of low-utility nodes\n                // if this logic gets changed please also update enablement of ExpandSubtreeCommand accordingly\n                if (ExpandableTreeNode.is(currentNode) && (includeDrawOrDispatchNodes || !CommandTreeDrawOrDispatchNode.is(currentNode))) {\n                    currentLevelNodes.push(currentNode);\n                }\n            }\n\n            console.log('JF: doExpandSubTree - processing level', {\n                currentLevelNodesCount: currentLevelNodes.length,\n                nodeIds: currentLevelNodes.map(n => n.id)\n            });\n\n            if (currentLevelNodes.length > 0) {\n                const expandedNodes = await this.expansionService.bulkExpandNodes(currentLevelNodes[Symbol.iterator]());\n                console.log('JF: doExpandSubTree - after bulkExpandNodes', {\n                    expandedNodesCount: expandedNodes.length,\n                    expandedNodeIds: expandedNodes.map(n => n.id)\n                });\n                for (const expandedNode of expandedNodes) {\n                    console.log('JF: doExpandSubTree - calling ensureLazyChildrenLoaded for', {\n                        nodeId: expandedNode.id,\n                        childrenCount: expandedNode.children.length,\n                        childrenIds: expandedNode.children.map(c => c.id)\n                    });\n                    await this.ensureLazyChildrenLoaded(expandedNode);\n                    console.log('JF: doExpandSubTree - after ensureLazyChildrenLoaded', {\n                        nodeId: expandedNode.id,\n                        childrenCountAfter: expandedNode.children.length,\n                        childrenIdsAfter: expandedNode.children.map(c => c.id)\n                    });\n                    nextLevelNodes.push(...expandedNode.children);\n                    // For draw/dispatch nodes that won't be expanded, still trigger their lazy loading\n                    if (!includeDrawOrDispatchNodes) {\n                        for (const child of expandedNode.children) {\n                            if (CommandTreeDrawOrDispatchNode.is(child) && ExpandableTreeNode.is(child)) {\n                                await this.ensureLazyChildrenLoaded(child);\n                            }\n                        }\n                    }\n                }\n                // Also process children of nodes that were already expanded\n                for (const currentNode of currentLevelNodes) {\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\n                        console.log('JF: doExpandSubTree - processing already expanded node', { nodeId: currentNode.id });\n                        await this.ensureLazyChildrenLoaded(currentNode);\n                        nextLevelNodes.push(...currentNode.children);\n                        // For draw/dispatch nodes that won't be expanded, still trigger their lazy loading\n                        if (!includeDrawOrDispatchNodes) {\n                            for (const child of currentNode.children) {\n                                if (CommandTreeDrawOrDispatchNode.is(child) && ExpandableTreeNode.is(child)) {\n                                    await this.ensureLazyChildrenLoaded(child);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            pendingNodes.push(...nextLevelNodes);\n            console.log('JF: doExpandSubTree - next level', { nextLevelNodesCount: nextLevelNodes.length });\n\n            // Yield control back to the event loop periodically based on time\n            const currentTime = performance.now();\n            if (currentTime - lastYieldTime >= YIELD_AFTER_MS) {\n                await new Promise(resolve => setTimeout(resolve, 0));\n                lastYieldTime = performance.now();\n            }\n        }\n        console.log('JF: doExpandSubTree END', { nodeId: node.id, totalProcessed: processedNodes.size });\n    }\n\n    protected async ensureLazyChildrenLoaded(node: ExpandableTreeNode): Promise<void> {\n        console.log('JF: ensureLazyChildrenLoaded START', {\n            nodeId: node.id,\n            childrenCount: node.children.length,\n            childrenIds: node.children.map(c => c.id)\n        });\n        // Find all loading nodes among children\n        const loadingNodes = node.children.filter(CommandEmptyNode.is);\n        console.log('JF: ensureLazyChildrenLoaded - found loading nodes', {\n            loadingNodesCount: loadingNodes.length,\n            loadingNodeIds: loadingNodes.map(n => n.id)\n        });\n\n        if (loadingNodes.length === 0) {\n            console.log('JF: ensureLazyChildrenLoaded - no loading nodes, returning');\n            return;\n        }\n\n        // Trigger load for all loading nodes and wait for them to complete\n        console.log('JF: ensureLazyChildrenLoaded - triggering loads');\n        await Promise.all(loadingNodes.map(loadingNode => triggerLazyLoadAndWaitForRemoval(loadingNode)));\n        console.log('JF: ensureLazyChildrenLoaded END', {\n            nodeId: node.id,\n            childrenCountAfter: node.children.length,\n            childrenIdsAfter: node.children.map(c => c.id)\n        });\n    }\n\n    hasTrailingSuffixes(node: TreeNode): boolean {\n        if (CommandQueueSubmitNode.is(node)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    protected override isVisibleSelectableNode(node: TreeNode): node is SelectableTreeNode {\n        return super.isVisibleSelectableNode(node) && this.isInFrameRange(node);\n    }\n\n    protected isInFrameRange(node: TreeNode): boolean {\n        const frameNode = CommandFrameNode.getCommandFrameNodeContaining(node);\n        if (frameNode === undefined) {\n            return true; // Assume it's good\n        }\n        const range = this.frameRangeSelectionService.frameSpan;\n        if (range === undefined) {\n            return true; // No constraint\n        }\n        return frameNode.frameIndex >= range.startFrame && frameNode.frameIndex <= range.endFrame;\n    }\n}\n\nexport namespace CommandTreeModel {\n    export interface State extends TreeModelImpl.State, CommandTreePreferenceState {}\n\n    /**\n     * Test whether a `node` is of the kind that implements the given `group` mode.\n     * As groups are _a priori_ composite nodes, this additionally infers that type\n     * for the `node` if successful.\n     */\n    export function isOfGroup(node: TreeNode, group: GroupByOptions): node is CompositeTreeNode {\n        switch (group) {\n            case GroupByOptions.Frame:\n                return CommandFrameNode.is(node);\n            case GroupByOptions.RenderPass:\n                return CommandRenderPassInstanceNode.is(node) || CommandDynamicRenderPassInstanceNode.is(node);\n            case GroupByOptions.RenderSubpass:\n                return CommandRenderSubpassInstanceNode.is(node);\n            case GroupByOptions.CommandBuffer:\n                return CommandCommandBufferInstanceNode.is(node);\n            case GroupByOptions.QueueSubmission:\n                return CommandQueueSubmitNode.is(node);\n        }\n    }\n}\n\ntype TextureSupportingNode =\n    | CommandFrameNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode;\n\nexport namespace TextureSupportingNode {\n    export function is(node: CommandTreeNode): node is TextureSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node)\n        );\n    }\n    export function getLast(node: CommandTreeNode): TextureSupportingNode | undefined {\n        if (TextureSupportingNode.is(node)) {\n            return node;\n        }\n        let lastSupportingNode: TextureSupportingNode | undefined;\n        if (CompositeTreeNode.is(node)) {\n            for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n                lastSupportingNode = TextureSupportingNode.getLast(node.children[commandIndex]);\n                if (lastSupportingNode) {\n                    break;\n                }\n            }\n        }\n        return lastSupportingNode;\n    }\n}\n\n/**\n * Union type of all command tree nodes that support thumbnails.\n * Nodes with heavy thumbnail costs are commented out.\n */\ntype ThumbnailSupportingNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandDebugLabelGroupNode\n    | CommandRenderPassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDrawInstanceNode;\n// Below currently have a possibly heavy cost to getting thumbnails\n// | CommandDispatchInstanceNode\n// | CommandMeshTaskInstanceNode\n// | CommandClusterInstanceNode\n// | CommandRaytracingInstanceNode;\n\nexport namespace ThumbnailSupportingNode {\n    export function is(node: CommandTreeNode): node is ThumbnailSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node)\n        );\n    }\n}\n\nfunction getCommandTreeApiEventChildren(eventIds: Array<{ apiEvent: number }>, root: CommandRootNode): CommandTreeApiEvent[] {\n    return eventIds.reduce<CommandTreeApiEvent[]>((collected, id) => {\n        const event = root.resource.apiEvents[id.apiEvent];\n        if (event) {\n            collected.push(event);\n        } else {\n            console.warn(`No event found for ${id.apiEvent}`);\n        }\n        return collected;\n    }, []);\n}\n\nfunction getInstancesByIds<T>(ids: number[], container: PartialRecord<number, T>, source?: string, target?: string): T[] {\n    return ids.flatMap(id => {\n        const instance = container[id];\n        if (!instance) {\n            if (target) {\n                console.warn(`${source ? `${source} expected` : 'Expected'} ${target} with ${id} but found none.`);\n            }\n            return [];\n        }\n        return instance;\n    });\n}\n\n/**\n * Creates an ArrayWithSortNumber for range instances, used by createChildEventNodesForRange.\n * Fetches instances by IDs and provides sorting by beginApiEvent.\n *\n * @param ids - Array of instance IDs to fetch\n * @param container - Container object mapping IDs to instances\n * @param sourceContext - Context string for error messages (e.g., \"CommandRenderPassInstanceNode.create\")\n * @param targetName - Target instance type name for error messages (e.g., \"DebugLabelGroupInstance\")\n * @returns ArrayWithSortNumber object ready for use with getNextRangeElementToProcess\n */\nfunction createRangeInstanceArray<T extends { beginApiEvent: number }>(\n    ids: number[],\n    container: PartialRecord<number, T>,\n    sourceContext: string,\n    targetName: string\n): ArrayWithSortNumber<T> {\n    return {\n        array: getInstancesByIds(ids, container, sourceContext, targetName),\n        getSortNumber: (element: T) => element.beginApiEvent\n    };\n}\n\nexport function createLazyLoadingNode(\n    tree: CommandTree,\n    parent: ExpandableTreeNode,\n    load: (batchQuery?: boolean) => Promise<void>\n): CommandEmptyNode {\n    let loaded = false;\n    let loadingInProgress = false;\n\n    const lazyLoad: (batchQuery?: boolean) => Promise<boolean> = async (batchQuery = true) => {\n        console.log('JF: lazyLoad START', { parentId: parent.id, batchQuery, loaded, loadingInProgress });\n        if (loadingInProgress) {\n            console.log('JF: lazyLoad - already in progress, returning false');\n            return false;\n        }\n\n        if (!loaded) {\n            loaded = true;\n            loadingInProgress = true;\n            loadOnExpanded.dispose();\n            try {\n                console.log('JF: lazyLoad - calling load function');\n                await load(batchQuery);\n                console.log('JF: lazyLoad - load function completed');\n            } catch (error) {\n                console.error(`LazyLoad failed for node ${parent.id}:`, error);\n            } finally {\n                loadingInProgress = false;\n            }\n            console.log('JF: lazyLoad - removing loading node and refreshing structure');\n            CompositeTreeNode.removeChild(parent, loadingNode);\n            await tree.refreshStructure(parent);\n            console.log('JF: lazyLoad - refreshStructure completed', {\n                parentChildrenCount: parent.children.length,\n                parentChildrenIds: parent.children.map(c => c.id)\n            });\n            return true;\n        }\n        console.log('JF: lazyLoad - already loaded, returning false');\n        return false;\n    };\n\n    // create lazy loading node\n    const loadingNode: CommandEmptyNode = CommandEmptyNode.create(parent, lazyLoad);\n    CompositeTreeNode.addChild(parent, loadingNode);\n\n    // register for lazy loading when the node is expanded\n    const loadOnExpanded = SokatoaLifecycleTreeNode.register(parent, 'onWillRender', async () => {\n        if (parent.expanded) {\n            // do not batch queries for expansion manually\n            await lazyLoad(false);\n        }\n    });\n    return loadingNode;\n}\n"
              }
            },
            {
              "kind": "file",
              "uri": "file:///home/johannes/Git/sokatoa/app/packages/capture/src/browser/command-tree/lazy-load-utils.ts",
              "name": "lazy-load-utils.ts",
              "icon": "ts-icon medium-blue theia-file-icons-js",
              "additionalInfo": "app/packages/capture/src/browser/command-tree",
              "state": "applied",
              "type": "modify",
              "data": {
                "targetState": "/********************************************************************************\n    Copyright 2026 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\n\nimport { CompositeTreeNode, TreeNode } from '@theia/core/lib/browser';\nimport { wait } from '@theia/core/lib/common/promise-util';\n\nexport interface LazyLoadWaitOptions {\n    /** Maximum time to wait in milliseconds. */\n    timeoutMs?: number;\n    /** Interval between checks in milliseconds. */\n    checkIntervalMs?: number;\n}\n\nconst DEFAULT_LAZY_LOAD_WAIT_OPTIONS: Required<LazyLoadWaitOptions> = {\n    timeoutMs: 60000,\n    checkIntervalMs: 100\n};\n\n/**\n * Waits until a loading node is removed from its parent's children list.\n * @returns Promise that resolves when the loading node is removed, or logs a warning on timeout\n */\nexport async function waitForLoadingNodeRemoval(\n    loadingNodeId: string,\n    parent: CompositeTreeNode | undefined,\n    options?: LazyLoadWaitOptions\n): Promise<void> {\n    const opts = { ...DEFAULT_LAZY_LOAD_WAIT_OPTIONS, ...options };\n    const parentId = parent?.id ?? 'unknown';\n\n    const maxTries = Math.ceil(opts.timeoutMs / opts.checkIntervalMs);\n    for (let i = 0; i < maxTries; i++) {\n        await wait(opts.checkIntervalMs);\n        const children = parent ? parent.children : [];\n        const loadingNodeStillPresent = children.some(child => child.id === loadingNodeId);\n        if (!loadingNodeStillPresent) {\n            return;\n        }\n    }\n    console.warn(`Loading node still not removed after ${opts.timeoutMs}ms for parent: ${parentId}`);\n}\n\nexport interface LazyLoadableNode extends TreeNode {\n    load(batchQuery?: boolean): Promise<boolean>;\n    parent: CompositeTreeNode | undefined;\n}\n\nexport async function triggerLazyLoadAndWaitForRemoval(node: LazyLoadableNode, options?: LazyLoadWaitOptions): Promise<void> {\n    const loadingNodeId = node.id;\n\n    // Directly call the load function - this triggers the lazy loading\n    // without requiring the node to be rendered\n    await node.load();\n\n    // Wait until the loading node is removed from children list\n    await waitForLoadingNodeRemoval(loadingNodeId, node.parent, options);\n}\n",
                "originalState": "/********************************************************************************\n    Copyright 2026 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\n\nimport { CompositeTreeNode, TreeNode } from '@theia/core/lib/browser';\nimport { wait } from '@theia/core/lib/common/promise-util';\n\nexport interface LazyLoadWaitOptions {\n    /** Maximum time to wait in milliseconds. */\n    timeoutMs?: number;\n    /** Interval between checks in milliseconds. */\n    checkIntervalMs?: number;\n}\n\nconst DEFAULT_LAZY_LOAD_WAIT_OPTIONS: Required<LazyLoadWaitOptions> = {\n    timeoutMs: 60000,\n    checkIntervalMs: 100\n};\n\n/**\n * Waits until a loading node is removed from its parent's children list.\n * @returns Promise that resolves when the loading node is removed, or logs a warning on timeout\n */\nexport async function waitForLoadingNodeRemoval(\n    loadingNodeId: string,\n    parent: CompositeTreeNode | undefined,\n    options?: LazyLoadWaitOptions\n): Promise<void> {\n    const opts = { ...DEFAULT_LAZY_LOAD_WAIT_OPTIONS, ...options };\n    const parentId = parent?.id ?? 'unknown';\n    console.log('JF: waitForLoadingNodeRemoval START', { loadingNodeId, parentId, timeoutMs: opts.timeoutMs });\n\n    const maxTries = Math.ceil(opts.timeoutMs / opts.checkIntervalMs);\n    for (let i = 0; i < maxTries; i++) {\n        await wait(opts.checkIntervalMs);\n        const children = parent ? parent.children : [];\n        const loadingNodeStillPresent = children.some(child => child.id === loadingNodeId);\n        if (!loadingNodeStillPresent) {\n            console.log('JF: waitForLoadingNodeRemoval - node removed after', { tries: i + 1 });\n            return;\n        }\n        if (i % 10 === 0) {\n            console.log('JF: waitForLoadingNodeRemoval - still waiting', { tries: i + 1, loadingNodeId });\n        }\n    }\n    console.warn(`JF: Loading node still not removed after ${opts.timeoutMs}ms for parent: ${parentId}`);\n}\n\nexport interface LazyLoadableNode extends TreeNode {\n    load(batchQuery?: boolean): Promise<boolean>;\n    parent: CompositeTreeNode | undefined;\n}\n\nexport async function triggerLazyLoadAndWaitForRemoval(node: LazyLoadableNode, options?: LazyLoadWaitOptions): Promise<void> {\n    const loadingNodeId = node.id;\n    console.log('JF: triggerLazyLoadAndWaitForRemoval START', { loadingNodeId, parentId: node.parent?.id });\n\n    // Directly call the load function - this triggers the lazy loading\n    // without requiring the node to be rendered\n    console.log('JF: triggerLazyLoadAndWaitForRemoval - calling node.load()');\n    await node.load();\n    console.log('JF: triggerLazyLoadAndWaitForRemoval - node.load() completed');\n\n    // Wait until the loading node is removed from children list\n    await waitForLoadingNodeRemoval(loadingNodeId, node.parent, options);\n    console.log('JF: triggerLazyLoadAndWaitForRemoval END', { loadingNodeId });\n}\n"
              }
            },
            {
              "kind": "file",
              "uri": "file:///home/johannes/Git/sokatoa/app/packages/platform/src/browser/tree-table/tree-table-widget.tsx",
              "name": "tree-table-widget.tsx",
              "icon": "tsx-icon light-blue theia-file-icons-js",
              "additionalInfo": "app/packages/platform/src/browser/tree-table",
              "state": "applied",
              "type": "modify",
              "data": {
                "targetState": "/********************************************************************************\n    Copyright 2024-2025 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\n\n// This is a fork of Theia's tree-widget.tsx implementation with the aim of\n// reusing as much common models and services as possible\n// Below is the original copyright header\n\n// *****************************************************************************\n// Copyright (C) 2018 TypeFox and others.\n//\n// This program and the accompanying materials are made available under the\n// terms of the Eclipse Public License v. 2.0 which is available at\n// http://www.eclipse.org/legal/epl-2.0.\n//\n// This Source Code may also be made available under the following Secondary\n// Licenses when the conditions for such availability set forth in the Eclipse\n// Public License v. 2.0 are satisfied: GNU General Public License, version 2\n// with the GNU Classpath Exception which is available at\n// https://www.gnu.org/software/classpath/license.html.\n//\n// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n// *****************************************************************************\n\nimport {\n    CancellationError,\n    CancellationToken,\n    CancellationTokenSource,\n    CorePreferences,\n    Disposable,\n    DisposableCollection,\n    Emitter,\n    Event,\n    isOSX,\n    MenuPath,\n    Mutable,\n    notEmpty,\n    PreferenceChange,\n    PreferenceService,\n    Progress,\n    ProgressService,\n    SelectionService,\n    unreachable\n} from '@theia/core';\nimport {\n    animationFrame,\n    codicon,\n    CompositeTreeNode,\n    ContextMenuRenderer,\n    DecoratedTreeNode,\n    defaultTreeProps,\n    ExpandableTreeNode,\n    Key,\n    KeyCode,\n    KeyModifier,\n    LabelProvider,\n    Message,\n    SelectableTreeNode,\n    StatefulWidget,\n    Tree,\n    TreeDecoratorService,\n    TreeModel,\n    TreeNode,\n    TreeProps,\n    TreeSearch,\n    TreeSelection,\n    TreeWidget,\n    UnsafeWidgetUtilities,\n    Widget\n} from '@theia/core/lib/browser';\nimport { SearchBox, SearchBoxFactory, SearchBoxProps as SearchBoxPropsInterface } from '@theia/core/lib/browser/tree/search-box';\nimport { SearchBoxDebounce } from '@theia/core/lib/browser/tree/search-box-debounce';\nimport { TreeFocusService } from '@theia/core/lib/browser/tree/tree-focus-service';\nimport { WidgetDecoration as TreeDecoration } from '@theia/core/lib/browser/widget-decoration';\nimport { Deferred } from '@theia/core/lib/common/promise-util';\nimport { PREFERENCE_NAME_TREE_INDENT } from '@theia/core/lib/common/tree-preference';\nimport { inject, injectable, postConstruct } from '@theia/core/shared/inversify';\nimport debounce from '@theia/core/shared/lodash.debounce';\nimport React, { CSSProperties, useEffect } from '@theia/core/shared/react';\nimport { GetProp, Table, Tooltip } from 'antd';\nimport { ColumnsType, ColumnType } from 'antd/es/table';\nimport {\n    ExpandableConfig,\n    FilterValue,\n    SorterResult,\n    SortOrder,\n    TableCurrentDataSource,\n    TablePaginationConfig\n} from 'antd/es/table/interface';\nimport { classNames as classNamesUtils } from 'primereact/utils';\nimport { AlignType, GetComponentProps, RenderExpandIconProps, ScrollConfig, SpecialString } from 'rc-table/lib/interface';\nimport { type DotPathOf, hasObjectProperty, Iterators, Objects } from '../../common/utils';\nimport { ContextMenuHelper } from '../context-menu-helper';\nimport { waitForElement } from '../core';\nimport { SearchPreferenceHelper } from '../search-preferences';\nimport { SokatoaCachingTreeDecoratorService } from '../widgets';\nimport { SokatoaReactWidget } from '../widgets/sokatoa-base-widget';\nimport { VisibilityGateFactory } from '../widgets/visibility-gate';\nimport { TreeTableContextService } from './tree-table-context-service';\nimport { TreeTableWidgetSelection } from './tree-table-widget-selection';\n\nexport const TREE_TABLE_CLASS = 'sokatoa-TreeTable';\nexport const TREE_CONTAINER_CLASS = 'sokatoa-TreeTableContainer';\nexport const TREE_TABLE_NODE_CLASS = 'sokatoa-TreeTableNode';\nexport const TREE_TABLE_NODE_CONTENT_CLASS = 'sokatoa-TreeTableNodeContent';\nexport const TREE_TABLE_NODE_TAIL_CLASS = 'sokatoa-TreeTableNodeTail';\nexport const TREE_TABLE_NODE_SEGMENT_CLASS = 'sokatoa-TreeTableNodeSegment';\nexport const TREE_TABLE_NODE_SEGMENT_GROW_CLASS = 'sokatoa-TreeTableNodeSegmentGrow';\nexport const TREE_TABLE_NON_HIGHLIGHT = 'sokatoa-non-highlight';\n\nexport const TreeTableProps = Symbol('TreeTableProps');\n\n/**\n * Allows to separate UI updates and model (structure) updates.\n *\n * This is useful when updating the structure is more expensive than rendering.\n * A single update is triggered for the whole subtree.\n */\nexport interface TreeStructureChangeEmitter {\n    readonly onStructureChanged: Event<TreeNode | undefined>;\n}\n\nexport function isTreeStructureChangeEmitter(toCheck: any): toCheck is TreeStructureChangeEmitter {\n    return typeof toCheck === 'object' && 'onStructureChanged' in toCheck;\n}\n\n/**\n * Representation of tree table properties.\n */\nexport type TreeTableProps = Omit<TreeProps, 'virtualized'>;\n\n/**\n * The default tree table properties.\n */\nexport const defaultTreeTableProps: TreeTableProps = {\n    ...defaultTreeProps\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface TreeTableColumnData {}\n\nexport interface TreeTableColumnHeaderProps {\n    title?: string;\n    sortable?: boolean;\n    description?: string;\n    align?: AlignType;\n}\n\nexport interface TreeTableRoot<T extends TreeTableColumnData = any> {\n    children: TreeTableRow<T>[];\n}\n\nexport type TreeTableRowParent<T extends TreeTableColumnData = any> = TreeTableRow<T> | TreeTableRoot<T>;\n\nexport interface TreeTableRow<T extends TreeTableColumnData = any> {\n    /** The identifier of this row. */\n    key: string;\n    /** The Theia tree node on which this row is based. */\n    node: Mutable<TreeNode>;\n    /** The column data associated with this row. */\n    columnData: T;\n    /** The parent node. */\n    parent: TreeTableRowParent<T>;\n    /** The children of this row. The property name must match with the 'expandable.childrenColumnName' in the table rendering. */\n    children?: TreeTableRow<T>[];\n}\n\nexport function isTreeTableRow<T extends TreeTableColumnData = any>(toCheck: any): toCheck is TreeTableRow<T> {\n    return hasObjectProperty<TreeTableRow>(toCheck, 'key', 'node', 'columnData', 'parent');\n}\n\nexport interface LazyTreeTableRow<T extends TreeTableColumnData = any> extends TreeTableRow<T> {\n    isResolved: boolean;\n    isResolving: boolean;\n    onResolved: Event<T>;\n    resolveColumnData(): Promise<T>;\n}\n\nexport namespace LazyTreeTableRow {\n    export function is<T extends TreeTableColumnData = any>(toCheck: any): toCheck is LazyTreeTableRow<T> {\n        return isTreeTableRow(toCheck) && hasObjectProperty<LazyTreeTableRow>(toCheck, 'isResolved', 'resolveColumnData');\n    }\n\n    export function resolve<T extends TreeTableColumnData = any>(toCheck: any): Promise<T> {\n        return is(toCheck) ? toCheck.resolveColumnData() : Promise.resolve(toCheck.columnData);\n    }\n\n    export function isUnresolved<T extends TreeTableColumnData = any>(toCheck: any): toCheck is LazyTreeTableRow<T> {\n        return is(toCheck) && !toCheck.isResolved;\n    }\n\n    export function isResolving<T extends TreeTableColumnData = any>(toCheck: any): toCheck is LazyTreeTableRow<T> {\n        return is(toCheck) && toCheck.isResolving;\n    }\n}\n\nexport interface TreeTableStructuralChange {\n    regenerateTreeTableRows?: boolean;\n    sortTreeTableRows?: boolean;\n    updateExpandedRowKeys?: boolean;\n    updateFilteredRows?: boolean;\n    affectedNodes?: TreeNode[];\n}\n\nexport type TreeTableDataKey<T extends TreeTableColumnData> = DotPathOf<T>;\n\nexport interface TreeTableColumn<D extends TreeTableColumnData, T = TreeTableRow<D>> extends ColumnType<T> {\n    key: 'node' | TreeTableDataKey<D> | string;\n    dataIndex: SpecialString<T> | number | (SpecialString<T> | number)[];\n}\n\nexport interface TreeTableRepresentationModel<T extends TreeTableColumnData = any> {\n    tree: TreeTableRow<T>[];\n    size: number;\n}\n\nexport interface TreeTableRowRepresentationModel<T extends TreeTableColumnData = any> {\n    node: TreeNode;\n    treeRow: TreeTableRow<T>;\n}\n\n/** Properties for the internal tree table view rendering. */\nexport interface TreeTableViewProps<T extends TreeTableColumnData> {\n    // data model\n    rows: TreeTableRow<T>[];\n    columns: ColumnsType<TreeTableRow<T>>;\n\n    // state\n    expandedRowsKeys: React.Key[];\n\n    onToggle(expanded: boolean, data: TreeTableRow<T>): void;\n    getRowClassName(row: TreeTableRow<T>, index?: number): string | undefined;\n    onChange: (\n        pagination: TablePaginationConfig,\n        filters: Record<string, FilterValue | null>,\n        sorter: SorterResult<TreeTableRow<T>> | SorterResult<TreeTableRow<T>>[],\n        extra: TableCurrentDataSource<TreeTableRow<T>>\n    ) => void;\n    showHeader: boolean;\n    onRender(): void;\n\n    scroll?: {\n        x: number | 'max-content' | 'dynamic-content';\n        y: number | 'max-content';\n    };\n    scrollTo?: TreeTableScrollToConfig;\n    onScrollTo?: (scrolledTo: TreeTableScrollToConfig) => void;\n    indentSize?: number;\n    getExpanderDataTestId(row: TreeTableRow<T>): string | undefined;\n    locale?: GetProp<typeof Table, 'locale'>;\n    isExpandable: (candidate: TreeTableRow<T>) => boolean;\n}\n\ninterface TreeTableScrollToConfig extends ScrollConfig {\n    /** number of pixels the scrollbar is moved from the left */\n    left?: number;\n}\n\n/**\n * Enhanced Expand Icon Props\n * @dataTestId string for the data-test-id attribute\n */\nexport interface RenderExpandIconEnhProps<RecordType> extends RenderExpandIconProps<RecordType> {\n    dataTestId: string | undefined;\n}\n\nexport type DropOperation = 'insert-before' | 'insert-after' | 'insert-into';\n\nexport interface Unsorted {\n    type: 'none';\n}\n\nexport type SortMode = 'ascending' | 'descending' | 'none';\n\nexport type ColumnKey = React.Key;\nexport interface SingleColumnSort {\n    type: 'single-column';\n    columnKey: ColumnKey;\n    mode: Exclude<SortMode, 'none'>;\n}\n\nexport type SortDescriptor = Unsorted | SingleColumnSort;\nexport namespace SortDescriptor {\n    export function equals(sort1: SortDescriptor, sort2: SortDescriptor): boolean {\n        if (sort1.type !== sort2.type) {\n            return false;\n        }\n        // Check both to let TypeScript infer the remaining type\n        if (sort1.type === 'none' || sort2.type === 'none') {\n            return true;\n        }\n        return sort2.columnKey === sort1.columnKey && sort2.mode === sort1.mode;\n    }\n}\n\nexport interface RowUpdateConfig {\n    regenerateRowModel?: boolean;\n    sortTreeTableRows?: boolean;\n    updateFilteredRows?: boolean;\n    updateExpandedRowKeys?: boolean;\n    decorationsPotentiallyIncomplete?: boolean;\n}\n\nexport namespace RowUpdateConfig {\n    export function allTrue(...except: Array<keyof RowUpdateConfig>): RowUpdateConfig {\n        const res = {\n            regenerateRowModel: true,\n            sortTreeTableRows: true,\n            updateFilteredRows: true,\n            updateExpandedRowKeys: true,\n            decorationsPotentiallyIncomplete: true\n        };\n        for (const notTrue of except) {\n            res[notTrue] = false;\n        }\n        return res;\n    }\n\n    export function allFalse(...except: Array<keyof RowUpdateConfig>): RowUpdateConfig {\n        const res = {\n            regenerateRowModel: false,\n            sortTreeTableRows: false,\n            updateFilteredRows: false,\n            updateExpandedRowKeys: false,\n            decorationsPotentiallyIncomplete: false\n        };\n        for (const notFalse of except) {\n            res[notFalse] = true;\n        }\n        return res;\n    }\n}\n\nconst MIN_TABLE_SIZE_PX = 10;\n\nconst THEIA_EXPANSION_TOGGLE_CLASS = 'theia-ExpansionToggle';\n\nexport const BASIC_SCROLL_HYSTERESIS_MS = 50;\nexport const EXPANSION_SCROLL_HYSTERESIS_MS = BASIC_SCROLL_HYSTERESIS_MS * 4;\n\ntype UpdateDecorationsParams = TreeNode | TreeNode[];\n\nconst FETCHING_DATA_CLASS = 'fetching-data';\n/**\n * A tree table widget that can be used as an in-place replacement for the Theia tree widget.\n */\n@injectable()\nexport abstract class TreeTableWidget<T extends TreeTableColumnData> extends SokatoaReactWidget implements StatefulWidget {\n    protected searchBox: SearchBox;\n    protected searchHighlights?: Map<string, TreeDecoration.CaptionHighlight>;\n\n    @inject(TreeDecoratorService)\n    protected readonly decoratorService: TreeDecoratorService;\n\n    @inject(Tree)\n    protected readonly tree: Tree;\n\n    @inject(TreeSearch)\n    protected readonly treeSearch: TreeSearch;\n\n    @inject(SearchBoxFactory)\n    protected readonly searchBoxFactory: SearchBoxFactory;\n\n    @inject(TreeFocusService)\n    protected readonly focusService: TreeFocusService;\n\n    protected decorations: Map<string, TreeDecoration.Data[]> = new Map();\n\n    @inject(SelectionService)\n    protected readonly selectionService: SelectionService;\n\n    @inject(PreferenceService)\n    protected readonly preferenceService: PreferenceService;\n\n    @inject(LabelProvider)\n    protected readonly labelProvider: LabelProvider;\n\n    @inject(CorePreferences)\n    protected readonly corePreferences: CorePreferences;\n\n    @inject(ProgressService)\n    protected readonly progressService: ProgressService;\n\n    @inject(TreeTableContextService)\n    protected readonly contextService: TreeTableContextService;\n\n    @inject(SearchPreferenceHelper)\n    protected searchPreferenceHelper: SearchPreferenceHelper;\n\n    @inject(VisibilityGateFactory)\n    protected readonly visibilityGateFactory: VisibilityGateFactory;\n\n    protected readonly contextMenuHelper: ContextMenuHelper;\n\n    protected treeIndent: number;\n    protected shouldCalcScroll = true;\n    protected scroll: NonNullable<TreeTableViewProps<T>['scroll']> = { x: -1, y: -1 };\n    protected focused = false;\n    protected styleChildrenOfSelection = false;\n\n    constructor(\n        @inject(TreeTableProps) readonly props: TreeTableProps,\n        @inject(TreeModel) readonly model: TreeModel,\n        @inject(ContextMenuRenderer)\n        protected readonly contextMenuRenderer: ContextMenuRenderer\n    ) {\n        super();\n        this.contextMenuHelper = ContextMenuHelper.for(contextMenuRenderer);\n        this.scrollOptions = {\n            suppressScrollX: true,\n            minScrollbarLength: 35\n        };\n        this.addClass(TREE_TABLE_CLASS);\n        this.addClass('sokatoa-tree');\n        this.node.tabIndex = 0;\n\n        // add focus listeners to update styling based on focus\n        const focusIn = (): void => {\n            this.focused = true;\n            this.update();\n        };\n        const focusOut = (): void => {\n            this.focused = false;\n            this.update();\n        };\n        this.node.addEventListener('focusin', focusIn);\n        this.node.addEventListener('focusout', focusOut);\n        this.toDispose.pushAll([\n            Disposable.create(() => this.node.removeEventListener('focusin', focusIn)),\n            Disposable.create(() => this.node.removeEventListener('focusout', focusOut))\n        ]);\n    }\n\n    @postConstruct()\n    protected init(): void {\n        this.contextService.init(this.node);\n        this.treeIndent = this.preferenceService.get(PREFERENCE_NAME_TREE_INDENT, this.treeIndent);\n        if (this.props.search) {\n            this.searchBox = this.searchBoxFactory({\n                ...SearchBoxPropsInterface.DEFAULT,\n                showButtons: true,\n                showFilter: true\n            });\n            this.searchBox.node.addEventListener('focus', () => {\n                this.node.focus();\n            });\n            const applyFilter = this.searchPreferenceHelper.debounce(this.doHandleFilterChange.bind(this));\n            this.toDispose.pushAll([\n                this.searchBox,\n                applyFilter,\n                this.searchBox.onTextChange(applyFilter),\n                this.searchBox.onClose(data => this.treeSearch.filter(undefined)),\n                this.searchBox.onNext(() => {\n                    // Enable next selection if there are currently highlights.\n                    if (this.searchHighlights && this.searchHighlights.size > 1) {\n                        this.model.selectNextNode();\n                    }\n                }),\n                this.searchBox.onPrevious(() => {\n                    // Enable previous selection if there are currently highlights.\n                    if (this.searchHighlights && this.searchHighlights.size > 1) {\n                        this.model.selectPrevNode();\n                    }\n                }),\n                this.searchBox.onFilterToggled(e => {\n                    this.updateRows({\n                        regenerateTreeTableRows: true\n                    });\n                }),\n                this.treeSearch,\n                this.treeSearch.onFilteredNodesChanged(nodes => {\n                    if (this.searchBox.isFiltering) {\n                        this.updateRows({\n                            regenerateTreeTableRows: true\n                        });\n                    }\n                    this.updateFilteredNodesSelection(nodes, this.treeSearch);\n                })\n            ]);\n        }\n\n        // as of now no special handling of middle click event as in theia table\n\n        this.toDispose.pushAll([\n            this.model,\n            this.setupOnChangedListener(),\n            this.model.onSelectionChanged(nodes => {\n                if (nodes.length > 0) {\n                    this.scheduleUpdateScrollToRow(nodes[0].id);\n                }\n            }),\n            this.focusService.onDidChangeFocus(node => {\n                if (node !== undefined) {\n                    this.scheduleUpdateScrollToRow(node.id);\n                }\n            }),\n            this.model.onDidChangeBusy(() => this.update()),\n            this.model.onDidUpdate(() => this.update()),\n            this.model.onNodeRefreshed(node => this.doUpdateDecorations(node)),\n            this.model.onExpansionChanged(node => this.doUpdateDecorations(node)),\n            this.decoratorService,\n            this.decoratorService.onDidChangeDecorations(() => this.updateDecorations()),\n            this.labelProvider.onDidChange(e => {\n                for (const row of this.asList()) {\n                    if (e.affects(row.node)) {\n                        this.update();\n                        return;\n                    }\n                }\n            }),\n            this.preferenceService.onPreferenceChanged((event: PreferenceChange) => {\n                if (event.preferenceName === PREFERENCE_NAME_TREE_INDENT) {\n                    this.treeIndent = Number(event.newValue ?? 0);\n                    this.update();\n                }\n            }),\n            this.dragOverExpansion\n        ]);\n        setTimeout(() => {\n            this.updateRows({\n                regenerateTreeTableRows: true\n            });\n            this.updateDecorations();\n        });\n\n        // update selection in tree table framework + styling\n        this.toDispose.push(this.model.onSelectionChanged(() => this.updateSelection()));\n\n        if (this.props.globalSelection) {\n            this.toDispose.pushAll([\n                this.model.onSelectionChanged(() => {\n                    if (this.shouldUpdateGlobalSelection()) {\n                        this.updateGlobalSelection();\n                    }\n                }),\n                this.focusService.onDidChangeFocus(focus => {\n                    if (\n                        focus &&\n                        this.shouldUpdateGlobalSelection() &&\n                        this.model.selectedNodes[0] !== focus &&\n                        this.model.selectedNodes.includes(focus)\n                    ) {\n                        this.updateGlobalSelection();\n                    }\n                }),\n                Disposable.create(() => {\n                    const selection = this.selectionService.selection;\n                    if (TreeTableWidgetSelection.isSource(selection, this)) {\n                        this.selectionService.selection = undefined;\n                    }\n                })\n            ]);\n\n            this.node.addEventListener('focusin', e => {\n                if (\n                    this.model.selectedNodes.length &&\n                    (!this.selectionService.selection || !TreeTableWidgetSelection.isSource(this.selectionService.selection, this))\n                ) {\n                    this.updateGlobalSelection();\n                }\n            });\n        }\n        this.toDispose.push(\n            this.corePreferences.onPreferenceChanged(preference => {\n                if (preference.preferenceName === 'workbench.tree.renderIndentGuides') {\n                    this.update();\n                }\n            })\n        );\n        this.toDispose.push(\n            Disposable.create(() => {\n                // reset internal model on dispose to help with GC\n                this.rowModel.tree.length = 0;\n                this.rows.length = 0;\n                this.expandedRowKeys.length = 0;\n                this.sorter = undefined;\n                this.scrollTo = undefined;\n                this.rowCache.clear();\n            })\n        );\n\n        // Trigger initial scroll constraint calculation after the view is ready.\n        const cancellationToken = new CancellationTokenSource();\n\n        void waitForElement(this.node, '.ant-table-tbody-virtual-holder', cancellationToken.token)\n            .then(() => {\n                this.updateScrollConstraints();\n            })\n            .catch(e => {\n                if (e instanceof CancellationError) {\n                    return;\n                }\n\n                console.error(e);\n            });\n        this.toDispose.push(cancellationToken);\n    }\n\n    protected updateFilteredNodesSelection(newFilteredNodes: readonly Readonly<TreeNode>[], treeSearch: TreeSearch): void {\n        if (\n            this.model.selectedNodes.length > 0 &&\n            (newFilteredNodes.length === 0 || treeSearch.passesFilters(this.model.selectedNodes[0]))\n        ) {\n            // If there is an existing selection and either:\n            // - no filters are applied (i.e. all nodes are shown), or\n            // - the current selection (including its parent nodes) passes the active filters,\n            // then we want to ensure that this selection is visible.\n            // We delay scrolling slightly because the number of shown nodes may grow drastically\n            this.scheduleUpdateScrollToRow(this.model.selectedNodes[0].id, true)?.catch(e => console.error(e));\n        } else {\n            // Otherwise, if the current selection doesn't pass the filters,\n            // select the first node from the filtered list that is selectable\n            // and scroll to it.\n            const node = newFilteredNodes.find(SelectableTreeNode.is);\n            if (node) {\n                this.model.selectNode(node);\n                this.scheduleUpdateScrollToRow(node.id)?.catch(e => console.error(e));\n            }\n        }\n    }\n\n    protected async doHandleFilterChange(data?: string): Promise<void> {\n        await this.treeSearch.filter(data);\n        this.searchHighlights = this.treeSearch.getHighlights();\n        this.searchBox.updateHighlightInfo({\n            filterText: data,\n            total: this.rowModel.size,\n            matched: this.searchHighlights.size\n        });\n        this.update();\n    }\n\n    protected shouldUpdateGlobalSelection(): boolean {\n        return this.node.contains(document.activeElement) || TreeTableWidgetSelection.isSource(this.selectionService.selection, this);\n    }\n\n    protected setupOnChangedListener(): Disposable {\n        if (isTreeStructureChangeEmitter(this.model)) {\n            const structureChange = this.model.onStructureChanged(node => {\n                // FIXME(GH-2093): Performance Issues (don't recreate all rows, support partial update)\n                this.updateRows({\n                    regenerateTreeTableRows: true\n                });\n            });\n            const expansionChange = this.model.onExpansionChanged(() => {\n                this.updateRows({\n                    updateExpandedRowKeys: true\n                });\n            });\n            const modelChange = this.model.onChanged(() => {\n                this.update();\n            });\n            return Disposable.create(() => {\n                structureChange.dispose();\n                expansionChange.dispose();\n                modelChange.dispose();\n            });\n        } else {\n            /* we only have the regular information from Theia -> assume all structure changes */\n            return this.model.onChanged(() => {\n                this.updateRows({\n                    regenerateTreeTableRows: true\n                });\n            });\n        }\n    }\n\n    /**\n     * Update the global selection for the tree.\n     */\n    protected updateGlobalSelection(): void {\n        this.selectionService.selection = TreeTableWidgetSelection.create(this);\n    }\n\n    protected rowModel: TreeTableRepresentationModel<T> = { tree: [], size: 0 };\n    protected rowCache: Map<string, TreeTableRow<T>> = new Map();\n    /** The actually used row model depending on the configuration. */\n    protected rows: TreeTableRow<T>[] = this.rowModel.tree;\n\n    protected asList(): IterableIterator<TreeTableRow<T>> {\n        return Iterators.childrenFromArray(this.rowModel.tree);\n    }\n\n    protected expandedRowKeys: React.Key[] = [];\n    protected sorter?: SorterResult<TreeTableRow<T>> = undefined;\n    protected scrollTo?: TreeTableScrollToConfig;\n\n    private updateRowsCancellation?: CancellationTokenSource;\n    protected updateRows(change: TreeTableStructuralChange = {}): void {\n        this.doSetUpdateRowsConfig(change);\n        this.updateRowsCancellation?.dispose();\n        const localCancellation = (this.updateRowsCancellation = new CancellationTokenSource());\n        this.debouncedDoUpdateRows(localCancellation.token);\n    }\n\n    protected rowUpdateConfig: RowUpdateConfig = {\n        regenerateRowModel: true,\n        sortTreeTableRows: true,\n        updateFilteredRows: true,\n        updateExpandedRowKeys: true,\n        decorationsPotentiallyIncomplete: true\n    };\n\n    protected doSetUpdateRowsConfig(change: TreeTableStructuralChange = {}): void {\n        const { regenerateTreeTableRows, sortTreeTableRows, updateExpandedRowKeys, updateFilteredRows } = change;\n        // with this method we can tell the update rows method to update certain aspects if true is passed\n        // when false is passed, this does not override/prevent an update requested by a different caller\n        // update rows will reset the config once consumed\n        if (!this.rowUpdateConfig.regenerateRowModel && regenerateTreeTableRows) {\n            // if we have a structural change, everything should be recomputed\n            this.rowUpdateConfig = RowUpdateConfig.allTrue();\n        }\n        this.rowUpdateConfig.sortTreeTableRows ||= sortTreeTableRows;\n        this.rowUpdateConfig.updateExpandedRowKeys ||= updateExpandedRowKeys;\n        this.rowUpdateConfig.updateFilteredRows ||= updateFilteredRows;\n    }\n    protected toDisposeOnUpdateRows = new DisposableCollection();\n    // execute immediately, if further calls within 100ms execute only last one after 100ms\n    protected debouncedDoUpdateRows = debounce(this.doUpdateRows, 100, {\n        leading: true,\n        trailing: true\n    });\n    protected async doUpdateRows(token: CancellationToken): Promise<void> {\n        if (token.isCancellationRequested) {\n            return;\n        }\n        const config = { ...this.rowUpdateConfig };\n        if (config.regenerateRowModel) {\n            const root = this.model.root;\n            const visitedKeys = new Set<string>();\n            const model = CompositeTreeNode.is(root)\n                ? this.createRowModel(root.children, token, { children: [] }, visitedKeys, undefined)\n                : undefined;\n            await this.setRowModel(model, token, visitedKeys);\n        }\n        if (token.isCancellationRequested) {\n            return;\n        }\n        await this.setRows(config);\n        if (token.isCancellationRequested) {\n            return;\n        }\n        this.update();\n        await animationFrame(1);\n        if (token.isCancellationRequested) {\n            return;\n        }\n        this.toDisposeOnUpdateRows.dispose();\n        this.update();\n        if (Objects.partialEqual(config, this.rowUpdateConfig)) {\n            this.rowUpdateConfig = RowUpdateConfig.allFalse();\n        }\n    }\n\n    protected async setRowModel(\n        model: TreeTableRepresentationModel<T> = { tree: [], size: 0 },\n        cancellationToken: CancellationToken,\n        visitedKeys: Set<string>\n    ): Promise<void> {\n        if (cancellationToken.isCancellationRequested) {\n            return;\n        }\n        if (model.size === 0) {\n            this.rowCache.clear();\n        } else if (visitedKeys) {\n            this.pruneRowCache(visitedKeys);\n        }\n        this.rowModel = model;\n    }\n\n    protected async setRows(config: RowUpdateConfig): Promise<void> {\n        if (config.sortTreeTableRows) {\n            // if we have sorting enabled, we need to use the sorted list\n            if (this.requiresSorting()) {\n                // the decorations may rely on the tree node structure for lazy initialization\n                // on sort we are using a flat list of all the tree nodes though\n                // make sure the decorations are fully initialized\n                if (config.decorationsPotentiallyIncomplete) {\n                    this.doUpdateDecorations(Array.from(this.asList()).map(row => row.node)).catch(e => console.error(e));\n                }\n                this.rows = this.rowModel.tree;\n                await this.sort();\n            }\n        }\n        if (config.updateFilteredRows) {\n            if (this.shouldResolveLazyTreeNodesOnFilter()) {\n                await this.resolveLazyTreeNodes();\n            }\n            this.rows = this.filterRows();\n        }\n        if (config.updateExpandedRowKeys) {\n            this.expandedRowKeys = Array.from(\n                Iterators.filter(this.asList(), row => ExpandableTreeNode.isExpanded(row.node)),\n                row => row.key\n            );\n        }\n    }\n\n    protected filterRows(): TreeTableRow<T>[] {\n        // no op by default\n        return this.rowModel.tree;\n    }\n\n    requiresSorting(): boolean {\n        return !!this.sorter?.order && !!this.sorter.columnKey;\n    }\n\n    protected onScrollTo = (scrolledTo: TreeTableScrollToConfig): void => {\n        // Clear only if execution and current request are identical.\n        if (\n            this.scrollTo &&\n            scrolledTo.index === this.scrollTo.index &&\n            scrolledTo.key === this.scrollTo.key &&\n            scrolledTo.top === this.scrollTo.top &&\n            scrolledTo.left === this.scrollTo.left\n        ) {\n            this.scrollTo = undefined;\n        }\n    };\n\n    protected shouldResolveLazyTreeNodesOnFilter(): boolean {\n        return false;\n    }\n\n    protected getUnresolvedData(rows: Iterable<TreeTableRow<T>>): Promise<T>[] {\n        return Array.from(Iterators.filter(rows, LazyTreeTableRow.isUnresolved<T>), row => row.resolveColumnData());\n    }\n\n    protected async showProgressWhileResolving(sorting: boolean): Promise<Progress> {\n        return this.progressService.showProgress({\n            text: sorting ? 'Fetching data to sort...' : 'Fetching data...',\n            options: { cancelable: false, location: 'notification' }\n        });\n    }\n\n    protected async resolveLazyTreeNodes(): Promise<void> {\n        let fetchingDataAdded = false;\n        let rows = this.rowModel.tree.slice();\n        let progress: Progress | undefined = undefined;\n        const startTime = Date.now();\n\n        try {\n            while (rows.length > 0) {\n                const unresolvedData = this.getUnresolvedData(rows);\n                if (unresolvedData.length > 0) {\n                    if (!fetchingDataAdded) {\n                        this.node.classList.add(FETCHING_DATA_CLASS);\n                        fetchingDataAdded = true;\n                    }\n\n                    await Promise.all(unresolvedData);\n\n                    // also show progress if resolution seems to be taking longer\n                    if (progress === undefined && Date.now() - startTime > 200) {\n                        progress = await this.showProgressWhileResolving(false);\n                    }\n                }\n\n                const newRows: TreeTableRow<T>[] = [];\n                for (const row of rows) {\n                    if (row.children && row.children.length > 0) {\n                        newRows.push(...row.children);\n                    }\n                }\n                rows = newRows;\n            }\n        } finally {\n            this.node.classList.remove(FETCHING_DATA_CLASS);\n            progress?.cancel();\n        }\n    }\n\n    protected requestId = 0;\n    protected currentSortOperationId: number | undefined;\n    protected currentSortOperationProgress: Promise<Progress> | undefined;\n    protected async sort(): Promise<void> {\n        const sortOperationId = this.requestId++;\n        this.currentSortOperationId = sortOperationId;\n\n        // get all data before updating rows so that sorting will work\n        const unresolvedData = this.getUnresolvedData(this.asList());\n        const cancelProgress = (): void => {\n            if (this.currentSortOperationProgress !== undefined) {\n                this.currentSortOperationProgress.then(progress => progress.cancel()).catch(e => console.error(e));\n                this.currentSortOperationProgress = undefined;\n            }\n        };\n        if (unresolvedData.length > 0) {\n            this.node.classList.add(FETCHING_DATA_CLASS);\n            if (this.currentSortOperationProgress === undefined) {\n                this.currentSortOperationProgress = this.showProgressWhileResolving(true);\n                this.toDispose.push(Disposable.create(cancelProgress));\n            }\n            try {\n                await Promise.all(unresolvedData);\n            } catch (e) {\n                console.error(e);\n            }\n        }\n        if (this.currentSortOperationId === sortOperationId) {\n            cancelProgress();\n            this.node.classList.remove('fetching-data');\n            this.sortRecursively(this.rowModel.tree);\n            this.currentSortOperationId = undefined;\n        }\n    }\n\n    protected sortRecursively(siblings: TreeTableRow<T>[]): void {\n        siblings.sort((l, r) => this.sortRows(l, r));\n        siblings.forEach(current => {\n            if (Array.isArray(current.children)) {\n                this.sortRecursively(current.children);\n            }\n        });\n    }\n\n    get sortDescriptor(): SortDescriptor {\n        if (!this.sorter?.columnKey) {\n            return { type: 'none' };\n        }\n\n        const mode = this.sorter.order === 'descend' ? 'descending' : 'ascending';\n        return {\n            type: 'single-column',\n            columnKey: this.sorter.columnKey,\n            mode\n        };\n    }\n\n    set sortDescriptor(sortDescriptor: SortDescriptor) {\n        const sortColumnKey = this.sorter?.columnKey;\n        const sortOrder = this.sorter?.order;\n        const sortColumn = sortColumnKey && sortOrder ? this.getColumns().find(column => column.key === sortColumnKey) : undefined;\n\n        const updateForSortChange = (): void => {\n            this.update();\n            this.updateRowsToSort().catch(e => console.error(e));\n        };\n\n        switch (sortDescriptor.type) {\n            case 'none':\n                if (sortColumn) {\n                    sortColumn.sortOrder = undefined;\n                    this.sorter = undefined;\n                }\n                updateForSortChange();\n                break;\n            case 'single-column': {\n                const newSortOrder = sortDescriptor.mode === 'descending' ? 'descend' : 'ascend';\n                if (sortColumn?.key === sortDescriptor.columnKey && sortColumn?.sortOrder === newSortOrder) {\n                    // No change\n                    return;\n                }\n\n                if (sortColumn) {\n                    sortColumn.sortOrder = undefined;\n                }\n\n                const newSortColumn = this.getColumns().find(column => column.key === sortDescriptor.columnKey);\n                if (newSortColumn && newSortColumn.sorter) {\n                    newSortColumn.sortOrder = newSortOrder;\n                    this.sorter = {\n                        column: newSortColumn,\n                        columnKey: sortDescriptor.columnKey,\n                        order: newSortOrder\n                    };\n                }\n                updateForSortChange();\n                break;\n            }\n            default:\n                unreachable(sortDescriptor);\n        }\n    }\n\n    /**\n     * Transforms the Theia TreeModel into a TreeTableModel.\n     */\n    protected createRowModel(\n        nodes: readonly TreeNode[],\n        cancellationToken: CancellationToken,\n        treeParent: TreeTableRowParent<T> = { children: [] },\n        visitedKeys: Set<string>,\n        props?: any\n    ): TreeTableRepresentationModel<T> {\n        const tree: TreeTableRow<T>[] = [];\n        let size = 0;\n        for (const node of nodes) {\n            if (cancellationToken.isCancellationRequested) {\n                return { tree, size };\n            }\n            if (!this.shouldDisplayNode(node)) {\n                continue;\n            }\n            visitedKeys.add(node.id);\n            const row = this.toRow(node, treeParent, props);\n            tree.push(row.treeRow);\n            size++;\n\n            if (CompositeTreeNode.is(node)) {\n                const subModel = this.createRowModel(node.children, cancellationToken, row.treeRow, visitedKeys, props);\n                row.treeRow.children = subModel.tree;\n                size += subModel.size;\n            }\n        }\n        return { tree, size };\n    }\n\n    protected toRow(node: TreeNode, treeParent: TreeTableRowParent<T>, props?: any): TreeTableRowRepresentationModel<T> {\n        const cachedRow = this.rowCache.get(node.id);\n\n        if (cachedRow && cachedRow.node === node) {\n            cachedRow.parent = treeParent;\n            cachedRow.children = undefined;\n            treeParent.children?.push(cachedRow);\n            return { node, treeRow: cachedRow };\n        }\n\n        const columnData = this.getColumnData(node);\n        const treeRow: TreeTableRow<T> = {\n            key: node.id,\n            node,\n            columnData,\n            parent: treeParent\n        };\n        treeParent.children?.push(treeRow);\n\n        this.rowCache.set(node.id, treeRow);\n\n        const model = { node, treeRow };\n        return this.decorateLazyRow(model);\n    }\n\n    protected pruneRowCache(visitedKeys: Set<string>): void {\n        if (this.rowCache.size === 0) {\n            return;\n        }\n        for (const cachedKey of this.rowCache.keys()) {\n            if (!visitedKeys.has(cachedKey)) {\n                this.rowCache.delete(cachedKey);\n            }\n        }\n    }\n\n    protected isLazyNode(node: TreeNode): boolean {\n        return false;\n    }\n\n    protected decorateLazyRow(model: TreeTableRowRepresentationModel<T>): TreeTableRowRepresentationModel<T> {\n        return !this.isLazyNode(model.node) || LazyTreeTableRow.is(model.treeRow) ? model : this.doDecorateLazyRow(model);\n    }\n\n    protected doDecorateLazyRow(model: TreeTableRowRepresentationModel<T>): TreeTableRowRepresentationModel<T> {\n        const listAndTreeRow = [model.treeRow as LazyTreeTableRow<T>];\n\n        // decorate the row with lazy loading capabilities\n        const resolution = new Deferred<T>();\n        const onResolvedEmitter = new Emitter<T>();\n        const resolveColumnData = async (): Promise<T> => {\n            // only resolve data once\n            if (listAndTreeRow.every(row => !row.isResolving && !row.isResolved)) {\n                listAndTreeRow.forEach(row => (row.isResolving = true));\n                this.resolveColumnData(model.node).then(data => {\n                    listAndTreeRow.forEach(row => {\n                        row.isResolving = false;\n                        row.columnData = data;\n                        row.isResolved = true;\n                        onResolvedEmitter.fire(data);\n                    });\n                    resolution.resolve(data);\n                }, resolution.reject);\n            }\n            return resolution.promise;\n        };\n        listAndTreeRow.forEach(row => {\n            row.isResolving = false;\n            row.isResolved = false;\n            row.onResolved = onResolvedEmitter.event;\n            row.resolveColumnData = resolveColumnData;\n        });\n        return model;\n    }\n\n    protected shouldDisplayNode(node: TreeNode): boolean {\n        return TreeNode.isVisible(node) && !this.isNodeFiltered(node);\n    }\n\n    protected isNodeFiltered(node: TreeNode): boolean {\n        return this.isFiltering && !this.treeSearch.passesFilters(node);\n    }\n\n    /**\n     * Schedules scrolling to a node and prepares the Tree accordingly (e.g. expanding parents)\n     *\n     * @param id the node's id to scroll to\n     * @param delayedScroll whether scrolling should be delayed. This might be required after expensive\n     *                      updates to give the ui time to render all nodes\n     * @returns\n     */\n    protected async scrollToNode(id: string, delayedScroll = false): Promise<void> {\n        const node = this.model.getNode(id);\n\n        if (node === undefined) {\n            return;\n        }\n\n        // expand all parents\n        let expandRequired = false;\n        let parent = node.parent;\n        while (parent !== undefined) {\n            if (ExpandableTreeNode.is(parent) && !parent.expanded) {\n                expandRequired = true;\n                await this.model.toggleNodeExpansion(parent);\n            }\n            parent = parent.parent;\n        }\n\n        if (expandRequired || delayedScroll) {\n            // give extra time to expand before scrolling\n            this.updateScrollToOnExpand({ key: id });\n        } else {\n            // we are using virtual rendering, give some time before scrolling\n            // usually this is only needed with rapid keyboard navigation\n            this.updateScrollToRegular({ key: id });\n        }\n    }\n    scheduleUpdateScrollToRow = debounce(this.scrollToNode);\n    protected updateScrollToOnExpand = debounce(this.updateScrollTo, EXPANSION_SCROLL_HYSTERESIS_MS);\n    protected updateScrollToRegular = debounce(this.updateScrollTo, BASIC_SCROLL_HYSTERESIS_MS);\n    protected async updateScrollTo(opts: TreeTableScrollToConfig): Promise<void> {\n        this.scrollTo = opts;\n        this.update();\n        await animationFrame(1);\n        this.update();\n    }\n\n    /**\n     * Update tree decorations.\n     * - Updating decorations are debounced in order to limit the number of expensive updates.\n     */\n    protected readonly updateDecorations = debounce((nodes?: UpdateDecorationsParams) => this.doUpdateDecorations(nodes), 150);\n    protected async doUpdateDecorations(nodes?: UpdateDecorationsParams): Promise<void> {\n        const treeNodes = Array.isArray(nodes) ? nodes : [nodes];\n        // Use the cached decorations if available\n        if (SokatoaCachingTreeDecoratorService.is(this.decoratorService)) {\n            // Initialize the decorations if not already done\n            if (!this.decoratorService.hasCachedDecorations(this.id) || treeNodes[0] === undefined) {\n                this.decorations = await this.decoratorService.cacheDecorations(this.id, this.model);\n            } else {\n                // Refresh the decorations for the given node\n                this.decorations = await this.decoratorService.refreshDecorationCache(this.id, treeNodes as TreeNode[]);\n            }\n        } else {\n            this.decorations = await this.decoratorService.getDecorations(this.model);\n        }\n        this.update();\n    }\n\n    protected override onActivateRequest(msg: Message): void {\n        super.onActivateRequest(msg);\n        this.node.focus({ preventScroll: true });\n    }\n\n    /**\n     * Actually focus the tree node.\n     */\n    protected doFocus(): void {\n        if (!this.model.selectedNodes.length) {\n            const node = this.getNodeToFocus();\n            if (SelectableTreeNode.is(node)) {\n                this.model.selectNode(node);\n            }\n        }\n    }\n\n    /**\n     * Get the tree node to focus.\n     *\n     * @returns the node to focus if available.\n     */\n    protected getNodeToFocus(): SelectableTreeNode | undefined {\n        const { focusedNode } = this.focusService;\n        if (focusedNode) {\n            return focusedNode;\n        }\n        const { root } = this.model;\n        if (SelectableTreeNode.isVisible(root)) {\n            return root;\n        }\n        return this.model.getNextSelectableNode(root);\n    }\n\n    protected override onUpdateRequest(msg: Message): void {\n        if (!this.isAttached) {\n            return;\n        }\n        // This doesn't create a new visibility gate every time because it's a cached singleton\n        const visibilityGate = this.visibilityGateFactory(this);\n        visibilityGate.doWhenVisible('update', () => super.onUpdateRequest(msg));\n    }\n\n    protected get isFiltering(): boolean {\n        return this.searchBox?.isFiltering === true;\n    }\n\n    protected override onResize(msg: Widget.ResizeMessage): void {\n        super.onResize(msg);\n        // re-calculate table size\n        this.updateScrollConstraints();\n    }\n\n    updateScrollConstraints(): void {\n        this.shouldCalcScroll = true;\n        this.update();\n    }\n\n    protected override render(): React.ReactNode {\n        return React.createElement('div', this.createContainerAttributes(), this.renderTreeTable(this.model));\n    }\n\n    /**\n     * Create the container attributes for the widget.\n     */\n    protected createContainerAttributes(): React.HTMLAttributes<HTMLElement> {\n        const classNames = [TREE_CONTAINER_CLASS];\n        if (!this.rowModel.size) {\n            classNames.push('empty');\n        }\n        if (this.model.selectedNodes.length === 0 && !this.focusService.focusedNode) {\n            classNames.push('focused');\n        }\n        return {\n            className: classNames.join(' '),\n            onContextMenu: event => this.handleContextMenuEvent(this.getContainerTreeNode(), event),\n            onDragEnter: event => this.handleDragEnterEvent(this.model.root, event),\n            onDragOver: event => this.handleDragOverEvent(this.model.root, event),\n            onDragLeave: event => this.handleDragLeaveEvent(this.model.root, event),\n            onDrop: event => void this.handleDropEvent(this.model.root, event)\n        };\n    }\n    /**\n     * Get the container tree node.\n     *\n     * @returns the tree node for the container if available.\n     */\n    protected getContainerTreeNode(): TreeNode | undefined {\n        return this.model.root;\n    }\n\n    protected renderTreeTable(model: TreeModel): React.ReactNode {\n        if (this.isTreeModelEmpty(model)) {\n            return this.renderEmptyTreeTable();\n        }\n\n        if (this.shouldCalcScroll) {\n            this.shouldCalcScroll = false;\n            let contentRect: DOMRect | undefined = undefined;\n            if (this.showHeader()) {\n                contentRect = getTreeTableBodyBounds(this.node);\n            } else {\n                contentRect = getTreeTableContainerBounds(this.node);\n            }\n\n            if (!contentRect || contentRect.width <= MIN_TABLE_SIZE_PX || contentRect.height <= MIN_TABLE_SIZE_PX) {\n                contentRect = this.node.getBoundingClientRect();\n            }\n\n            this.scroll = this.calculateScroll(contentRect);\n        }\n\n        const renderEmpty: () => React.ReactNode = () => {\n            if (this.isFiltering && this.treeSearch?.filteredNodes?.length === 0) {\n                return this.renderEmptySearchResult();\n            }\n            return this.renderEmptyTreeTable();\n        };\n\n        return (\n            <this.TreeTableView\n                rows={this.rows}\n                expandedRowsKeys={this.expandedRowKeys}\n                scroll={this.getTableScroll()}\n                scrollTo={this.scrollTo}\n                onScrollTo={this.onScrollTo}\n                columns={this.getColumns()}\n                onToggle={this.doToggle.bind(this)}\n                getRowClassName={this.getRowClassName.bind(this)}\n                onChange={this.onChange.bind(this)}\n                onRender={this.onTableRender.bind(this)}\n                showHeader={this.showHeader()}\n                indentSize={this.treeIndent}\n                getExpanderDataTestId={this.getDataTestId.bind(this)}\n                locale={{ emptyText: renderEmpty }}\n                isExpandable={this.isRowExpandable.bind(this)}\n            />\n        );\n    }\n\n    protected calculateScroll(contentRect: DOMRect): NonNullable<TreeTableViewProps<T>['scroll']> {\n        const scroll = { ...this.scroll };\n\n        if (typeof scroll.x === 'number' && (contentRect.width > 0 || scroll.x <= MIN_TABLE_SIZE_PX)) {\n            // We have a new size calculation or we have never had and still have no size\n            scroll.x = Math.max(contentRect.width, MIN_TABLE_SIZE_PX);\n        }\n\n        if (typeof scroll.y === 'number' && (contentRect.height > 0 || scroll.y <= MIN_TABLE_SIZE_PX)) {\n            // We have a new size calculation or we have never had and still have no size\n            scroll.y = Math.max(contentRect.height, MIN_TABLE_SIZE_PX);\n        }\n\n        return scroll;\n    }\n\n    protected isTreeModelEmpty(model: TreeModel): boolean {\n        return !model.root || (CompositeTreeNode.is(model.root) && model.root.children.length === 0);\n    }\n\n    protected getTableScroll(): TreeTableViewProps<T>['scroll'] {\n        return this.scroll;\n    }\n\n    protected renderEmptyTreeTable(): React.ReactNode {\n        return (\n            <div className='theia-widget-noInfo'>\n                {this.renderEmptyTreeTableLoader()}\n                <div>No data available</div>\n            </div>\n        );\n    }\n\n    protected renderEmptySearchResult(): React.ReactNode {\n        return (\n            <div className='theia-widget-noInfo'>\n                <div>No rows match filter</div>\n            </div>\n        );\n    }\n\n    protected renderEmptyTreeTableLoader(): React.ReactNode {\n        return (\n            <div>\n                <span className={'codicon codicon-loading theia-animation-spin   mr-2'}></span>\n                Loading\n            </div>\n        );\n    }\n\n    // no scroll to selected yet\n\n    /**\n     * Render the tree node given the node properties.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected renderIcon(node: TreeNode, props?: any): React.ReactNode {\n        return undefined;\n    }\n\n    /**\n     * Actually toggle the tree node.\n     * @param expanded the expanded state\n     * @param data the toggled data\n     */\n    protected doToggle(expanded: boolean, data: TreeTableRow<T>): void {\n        const node = this.model.getNode(data.key);\n        if (node !== undefined && ExpandableTreeNode.is(node) && node.expanded !== expanded) {\n            this.model.toggleNodeExpansion(node).catch(e => console.error(e));\n        }\n    }\n\n    /**\n     * Render the tree node caption given the node properties.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected renderCaption(node: TreeNode, props?: any): React.ReactNode {\n        const attrs = this.getCaptionAttributes(node, props);\n        const children = this.getCaptionChildren(node, props);\n        return React.createElement('div', attrs, children);\n    }\n\n    protected getCaptionAttributes(node: TreeNode, props?: any): React.Attributes & React.HTMLAttributes<HTMLElement> {\n        const tooltip = this.getDecorationData(node, 'tooltip').filter(notEmpty).join('  ');\n        const classes = [TREE_TABLE_NODE_SEGMENT_CLASS];\n        if (!this.hasTrailingSuffixes(node)) {\n            classes.push(TREE_TABLE_NODE_SEGMENT_GROW_CLASS);\n        }\n        const className = classes.join(' ');\n        const attrs = this.decorateCaption(node, {\n            className,\n            id: `${TREE_TABLE_CLASS}-${node.id}`\n        });\n        if (tooltip.length > 0) {\n            attrs.title = tooltip;\n        }\n        return attrs;\n    }\n\n    protected getCaptionChildren(node: TreeNode, props?: any): React.ReactNode {\n        const children = [];\n        const caption = this.toNodeName(node);\n        const highlight = this.getDecorationData(node, 'highlight')[0];\n        if (highlight) {\n            children.push(this.toReactNode(caption, highlight));\n        }\n        const searchHighlight = this.searchHighlights?.get(node.id);\n        if (searchHighlight) {\n            children.push(...this.toReactNode(caption, searchHighlight));\n        } else if (!highlight) {\n            children.push(caption);\n        }\n        return children;\n    }\n\n    /**\n     * Update the node given the caption and highlight.\n     * @param caption the caption.\n     * @param highlight the tree decoration caption highlight.\n     */\n    protected toReactNode(caption: string, highlight: TreeDecoration.CaptionHighlight): React.ReactNode[] {\n        let style: React.CSSProperties = {};\n        if (highlight.color) {\n            style = {\n                ...style,\n                color: highlight.color\n            };\n        }\n        if (highlight.backgroundColor) {\n            style = {\n                ...style,\n                backgroundColor: highlight.backgroundColor\n            };\n        }\n        const createChildren = (fragment: TreeDecoration.CaptionHighlight.Fragment, index: number): React.ReactNode => {\n            const { data } = fragment;\n            if (fragment.highlight) {\n                return (\n                    <mark className={TreeDecoration.Styles.CAPTION_HIGHLIGHT_CLASS} style={style} key={index}>\n                        {data}\n                    </mark>\n                );\n            } else {\n                return data;\n            }\n        };\n        return TreeDecoration.CaptionHighlight.split(caption, highlight).map(createChildren);\n    }\n\n    /**\n     * Decorate the tree caption.\n     * @param node the tree node.\n     * @param attrs the additional attributes.\n     */\n    protected decorateCaption(\n        node: TreeNode,\n        attrs: React.HTMLAttributes<HTMLElement>\n    ): React.Attributes & React.HTMLAttributes<HTMLElement> {\n        const style = this.getDecorationData(node, 'fontData')\n            .filter(notEmpty)\n            .reverse()\n            .map(fontData => this.applyFontStyles({}, fontData))\n            .reduce(\n                (acc, current) => ({\n                    ...acc,\n                    ...current\n                }),\n                {}\n            );\n        return {\n            ...attrs,\n            style\n        };\n    }\n\n    /**\n     * Determine if the tree node contains trailing suffixes.\n     * @param node the tree node.\n     *\n     * @returns `true` if the tree node contains trailing suffices.\n     */\n    protected hasTrailingSuffixes(node: TreeNode): boolean {\n        return (\n            this.getDecorationData(node, 'captionSuffixes')\n                .filter(notEmpty)\n                .reduce((acc, current) => acc.concat(current), []).length > 0\n        );\n    }\n\n    /**\n     * Apply font styles to the tree.\n     * @param original the original css properties.\n     * @param fontData the optional `fontData`.\n     */\n    protected applyFontStyles(original: React.CSSProperties, fontData: TreeDecoration.FontData | undefined): React.CSSProperties {\n        if (fontData === undefined) {\n            return original;\n        }\n        const modified = { ...original }; // make a copy to mutate\n        const { color, style } = fontData;\n        if (color) {\n            modified.color = color;\n        }\n        if (style) {\n            (Array.isArray(style) ? style : [style]).forEach(s => {\n                switch (s) {\n                    case 'bold':\n                        modified.fontWeight = s;\n                        break;\n                    case 'normal':\n                    case 'oblique':\n                    case 'italic':\n                        modified.fontStyle = s;\n                        break;\n                    case 'underline':\n                    case 'line-through':\n                        modified.textDecoration = s;\n                        break;\n                    default:\n                        throw new Error(`Unexpected font style: \"${s}\".`);\n                }\n            });\n        }\n        return modified;\n    }\n\n    /**\n     * Render caption affixes for the given tree node.\n     * @param node the tree node.\n     * @param props the node properties.\n     * @param affixKey the affix key.\n     */\n    protected renderCaptionAffixes(\n        node: TreeNode,\n        props: any | undefined,\n        affixKey: 'captionPrefixes' | 'captionSuffixes'\n    ): React.ReactNode {\n        const suffix = affixKey === 'captionSuffixes';\n        const affixClass = suffix ? TreeDecoration.Styles.CAPTION_SUFFIX_CLASS : TreeDecoration.Styles.CAPTION_PREFIX_CLASS;\n        const classes = [TREE_TABLE_NODE_SEGMENT_CLASS, affixClass];\n        const affixes = this.getDecorationData(node, affixKey)\n            .filter(notEmpty)\n            .reduce((acc, current) => acc.concat(current), []);\n        const children: React.ReactNode[] = [];\n        for (let i = 0; i < affixes.length; i++) {\n            const affix = affixes[i];\n            if (suffix && i === affixes.length - 1) {\n                classes.push(TREE_TABLE_NODE_SEGMENT_GROW_CLASS);\n            }\n            const style = this.applyFontStyles({}, affix.fontData);\n            const className = classes.join(' ');\n            const key = node.id + '_' + i;\n            const attrs = {\n                className,\n                style,\n                key\n            };\n            children.push(React.createElement('div', attrs, affix.data));\n        }\n        return <React.Fragment>{children}</React.Fragment>;\n    }\n\n    /**\n     * Render the node expansion toggle.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected renderCheckbox(node: TreeNode, props?: any): React.ReactNode {\n        if (node.checkboxInfo === undefined) {\n            // eslint-disable-next-line no-null/no-null\n            return null;\n        }\n        return (\n            <input\n                data-node-id={node.id}\n                readOnly\n                type='checkbox'\n                checked={!!node.checkboxInfo.checked}\n                title={node.checkboxInfo.tooltip}\n                aria-label={node.checkboxInfo.accessibilityInformation?.label}\n                role={node.checkboxInfo.accessibilityInformation?.role}\n                className='theia-input'\n                onClick={event => this.toggleChecked(event)}\n            />\n        );\n    }\n\n    protected toggleChecked(event: React.MouseEvent<HTMLElement>): void {\n        const nodeId = event.currentTarget.getAttribute('data-node-id');\n        if (nodeId) {\n            const node = this.model.getNode(nodeId);\n            if (node) {\n                this.model.markAsChecked(node, !node.checkboxInfo!.checked);\n            } else {\n                this.handleClickEvent(node, event);\n            }\n        }\n        event.stopPropagation();\n    }\n\n    /**\n     * Decorate the tree node icon.\n     * @param node the tree node.\n     * @param icon the icon.\n     */\n    protected decorateIcon(node: TreeNode, icon: React.ReactNode): React.ReactNode {\n        if (!icon) {\n            return;\n        }\n        const overlayIcons: React.ReactNode[] = [];\n        // if multiple overlays have the same overlay.position attribute,\n        // we'll de-duplicate those and only process the first one from the decoration array\n        const seenPositions = new Set<TreeDecoration.IconOverlayPosition>();\n        const overlays = this.getDecorationData(node, 'iconOverlay').filter(notEmpty);\n\n        for (const overlay of overlays) {\n            if (!seenPositions.has(overlay.position)) {\n                seenPositions.add(overlay.position);\n                const iconClasses = [\n                    TreeDecoration.Styles.DECORATOR_SIZE_CLASS,\n                    TreeDecoration.IconOverlayPosition.getStyle(overlay.position)\n                ];\n                const style = (color?: string): CSSProperties | undefined => (color === undefined ? {} : { color });\n\n                if (overlay.background) {\n                    overlayIcons.push(\n                        <span\n                            key={node.id + 'bg'}\n                            className={this.getIconClass(overlay.background.shape, iconClasses)}\n                            style={style(overlay.background.color)}\n                        ></span>\n                    );\n                }\n\n                const overlayIcon = 'icon' in overlay ? overlay.icon : overlay.iconClass;\n                overlayIcons.push(\n                    <span key={node.id} className={this.getIconClass(overlayIcon, iconClasses)} style={style(overlay.color)}></span>\n                );\n            }\n        }\n\n        if (overlayIcons.length > 0) {\n            return (\n                <div className={TreeDecoration.Styles.ICON_WRAPPER_CLASS}>\n                    {icon}\n                    {overlayIcons}\n                </div>\n            );\n        }\n\n        return icon;\n    }\n\n    /**\n     * Render the tree node tail decorations.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected renderTailDecorations(node: TreeNode, props?: any): React.ReactNode {\n        const tailDecorations = this.getDecorationData(node, 'tailDecorations').reduce((acc, current) => acc.concat(current), []);\n        if (tailDecorations.length === 0) {\n            return;\n        }\n        return this.renderTailDecorationsForNode(node, props, tailDecorations);\n    }\n\n    protected renderTailDecorationsForNode(\n        node: TreeNode,\n        props: any | undefined,\n        tailDecorations: TreeDecoration.TailDecoration.AnyPartial[]\n    ): React.ReactNode {\n        let dotDecoration: TreeDecoration.TailDecoration.AnyPartial | undefined;\n        const otherDecorations: TreeDecoration.TailDecoration.AnyPartial[] = [];\n        tailDecorations.reverse().forEach(decoration => {\n            if (TreeDecoration.TailDecoration.isDotDecoration(decoration)) {\n                dotDecoration ||= decoration;\n            } else if (decoration.data || decoration.icon || decoration.iconClass) {\n                otherDecorations.push(decoration);\n            }\n        });\n        const decorationsToRender = dotDecoration ? [dotDecoration, ...otherDecorations] : otherDecorations;\n        return (\n            <React.Fragment>\n                {decorationsToRender.map((decoration, index) => {\n                    const { tooltip, data, fontData, color, icon, iconClass } = decoration;\n                    const iconToRender = icon ?? iconClass;\n                    const className = [TREE_TABLE_NODE_SEGMENT_CLASS, TREE_TABLE_NODE_TAIL_CLASS, 'flex'].join(' ');\n                    const style = fontData ? this.applyFontStyles({}, fontData) : color ? { color } : undefined;\n                    const content = data ? (\n                        data\n                    ) : iconToRender ? (\n                        <span\n                            key={node.id + 'icon' + index}\n                            className={this.getIconClass(\n                                iconToRender,\n                                iconToRender === 'circle' ? [TreeDecoration.Styles.DECORATOR_SIZE_CLASS] : []\n                            )}\n                        ></span>\n                    ) : (\n                        ''\n                    );\n                    return (\n                        <div key={node.id + className + index} className={className} style={style} title={tooltip}>\n                            {content}\n                            {index !== decorationsToRender.length - 1 ? ',' : ''}\n                        </div>\n                    );\n                })}\n            </React.Fragment>\n        );\n    }\n\n    protected renderTailCommands(_node: TreeNode, _props?: any): React.ReactNode {\n        return undefined;\n    }\n\n    /**\n     * Determine the classes to use for an icon\n     * - Assumes a Font Awesome name when passed a single string, otherwise uses the passed string array\n     * @param iconName the icon name or list of icon names.\n     * @param additionalClasses additional CSS classes.\n     *\n     * @returns the icon class name.\n     */\n    protected getIconClass(iconName: string | string[], additionalClasses: string[] = []): string {\n        const iconClass = typeof iconName === 'string' ? ['a', 'fa', `fa-${iconName}`] : ['a'].concat(iconName);\n        return iconClass.concat(additionalClasses).join(' ');\n    }\n\n    protected renderNode(node: TreeNode, props?: any): React.ReactNode {\n        const attributes = this.createNodeAttributes(node);\n        const content = (\n            <div className={this.getNodeContentClasses(node).join(' ')}>\n                {this.renderCheckbox(node, props)}\n                {this.decorateIcon(node, this.renderIcon(node, props))}\n                {this.renderCaptionAffixes(node, props, 'captionPrefixes')}\n                {this.renderCaption(node, props)}\n                {this.renderCaptionAffixes(node, props, 'captionSuffixes')}\n                {this.renderTailDecorations(node, props)}\n            </div>\n        );\n        return React.createElement('div', attributes, content);\n    }\n\n    protected getNodeContentClasses(_node: TreeNode): string[] {\n        return [TREE_TABLE_NODE_CONTENT_CLASS, TREE_TABLE_NODE_SEGMENT_GROW_CLASS];\n    }\n\n    /**\n     * Render the row given the tree node and node properties.\n     * @param row the tree row.\n     * @param props the node properties.\n     */\n    protected renderNodeColumn(row: TreeTableRow<T>, props?: any): React.ReactNode {\n        if (this.isRenaming(row.key)) {\n            return this.renderRename(row, props);\n        } else {\n            return this.renderNode(row.node, props);\n        }\n    }\n\n    /**\n     * Create node attributes for the tree node given the node properties.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected createNodeAttributes(node: TreeNode, props?: any): React.Attributes & React.HTMLAttributes<HTMLElement> {\n        return { className: this.createNodeClassNames(node, props).join(' ') };\n    }\n\n    protected getNodeDragHandlers(node: TreeNode): React.Attributes & React.HtmlHTMLAttributes<HTMLElement> {\n        return {\n            onDragStart: event => this.handleDragStartEvent(node, event),\n            onDragEnter: event => this.handleDragEnterEvent(node, event),\n            onDragOver: event => this.handleDragOverEvent(node, event),\n            onDragLeave: event => this.handleDragLeaveEvent(node, event),\n            onDrop: event => void this.handleDropEvent(node, event),\n            onDragEnd: event => void this.handleDragEndEvent(node, event),\n            draggable: !this.isRenaming(node) && this.isDraggable(node)\n        };\n    }\n\n    /**\n     * Create the node class names.\n     * @param node the tree node.\n     * @param props the node properties.\n     *\n     * @returns the list of tree node class names.\n     */\n    protected createNodeClassNames(node: TreeNode, props?: any): string[] {\n        return [TREE_TABLE_NODE_CLASS, TREE_TABLE_NODE_SEGMENT_GROW_CLASS];\n    }\n\n    /**\n     * Determine if the tree node is expandable.\n     * @param node the tree node.\n     *\n     * @returns `true` if the tree node is expandable.\n     */\n    protected isExpandable(node: TreeNode): node is ExpandableTreeNode {\n        return ExpandableTreeNode.is(node);\n    }\n\n    protected isRowExpandable(row: TreeTableRow<T>): boolean {\n        return this.isExpandable(row.node);\n    }\n\n    /**\n     * Get the tree node decorations.\n     * @param node the tree node.\n     *\n     * @returns the list of tree decoration data.\n     */\n    protected getDecorations(node: TreeNode): TreeDecoration.Data[] {\n        const decorations: TreeDecoration.Data[] = [];\n        if (DecoratedTreeNode.is(node)) {\n            decorations.push(node.decorationData);\n        }\n        if (this.decorations.has(node.id)) {\n            decorations.push(...this.decorations.get(node.id)!);\n        }\n        return decorations.sort(TreeDecoration.Data.comparePriority);\n    }\n\n    /**\n     * Get the tree decoration data for the given key.\n     * @param node the tree node.\n     * @param key the tree decoration data key.\n     *\n     * @returns the tree decoration data at the given key.\n     */\n    protected getDecorationData<K extends keyof TreeDecoration.Data>(node: TreeNode, key: K): Required<Pick<TreeDecoration.Data, K>>[K][] {\n        return this.getDecorations(node)\n            .filter(data => data[key] !== undefined)\n            .map(data => data[key]);\n    }\n\n    protected override onAfterAttach(msg: Message): void {\n        const up = [\n            Key.ARROW_UP,\n            KeyCode.createKeyCode({\n                first: Key.ARROW_UP,\n                modifiers: [KeyModifier.Shift]\n            })\n        ];\n        const down = [\n            Key.ARROW_DOWN,\n            KeyCode.createKeyCode({\n                first: Key.ARROW_DOWN,\n                modifiers: [KeyModifier.Shift]\n            })\n        ];\n        if (this.props.search) {\n            if (this.searchBox.isAttached) {\n                Widget.detach(this.searchBox);\n            }\n            UnsafeWidgetUtilities.attach(this.searchBox, this.node.parentElement!);\n            this.addKeyListener(\n                this.node,\n                this.searchBox.keyCodePredicate.bind(this.searchBox),\n                this.searchBox.handle.bind(this.searchBox)\n            );\n            this.toDisposeOnDetach.push(\n                Disposable.create(() => {\n                    Widget.detach(this.searchBox);\n                })\n            );\n        }\n        super.onAfterAttach(msg);\n        this.addKeyListener(this.node, Key.ARROW_LEFT, event => this.handleKeyEvent(event, this.handleLeft.bind(this)));\n        this.addKeyListener(this.node, Key.ARROW_RIGHT, event => this.handleKeyEvent(event, this.handleRight.bind(this)));\n        this.addKeyListener(this.node, up, event => this.handleKeyEvent(event, this.handleUp.bind(this)));\n        this.addKeyListener(this.node, down, event => this.handleKeyEvent(event, this.handleDown.bind(this)));\n        this.addKeyListener(this.node, Key.ENTER, event => this.handleKeyEvent(event, this.handleEnter.bind(this)));\n        this.addKeyListener(this.node, Key.SPACE, event => this.handleKeyEvent(event, this.handleSpace.bind(this)));\n        this.addKeyListener(this.node, Key.ESCAPE, event => this.handleKeyEvent(event, this.handleEscape.bind(this)));\n    }\n\n    protected handleKeyEvent(event: KeyboardEvent, action: (event: KeyboardEvent) => boolean | void | object): boolean | void | object {\n        if (event.target && event.target instanceof HTMLInputElement) {\n            /* don't stop propagation and let input element take care of key */\n            return false;\n        }\n        return action(event);\n    }\n\n    /**\n     * Handle the `left arrow` keyboard event.\n     * @param event the `left arrow` keyboard event.\n     */\n    protected handleLeft(event: KeyboardEvent): boolean | void | object {\n        if (!!this.props.multiSelect && (this.hasCtrlCmdMask(event) || this.hasShiftMask(event))) {\n            return;\n        }\n        const selectedNode = this.model.selectedNodes[0];\n        if (!selectedNode || !this.isExpandable(selectedNode)) {\n            const parent = this.getVisibleParent();\n            if (parent) {\n                this.model.selectNode(parent);\n            }\n            return;\n        }\n        void this.model.collapseNode().then(collapsed => {\n            if (!collapsed) {\n                const parent = this.getVisibleParent();\n                if (parent) {\n                    this.model.selectNode(parent);\n                }\n            }\n        });\n    }\n\n    /**\n     * Handle the `right arrow` keyboard event.\n     * @param event the `right arrow` keyboard event.\n     */\n    protected handleRight(event: KeyboardEvent): boolean | void | object {\n        if (!!this.props.multiSelect && (this.hasCtrlCmdMask(event) || this.hasShiftMask(event))) {\n            return;\n        }\n        const selectedNode = this.model.selectedNodes[0];\n        // If the node is not expandable (no visible children), don't try to expand\n        if (!selectedNode || !this.isExpandable(selectedNode)) {\n            return;\n        }\n        void this.model.expandNode().then(expanded => {\n            if (!expanded) {\n                // Node is already expanded, select first visible child\n                const firstChild = this.getFirstVisibleChild();\n                if (firstChild) {\n                    this.model.selectNode(firstChild);\n                }\n            }\n        });\n    }\n\n    /**\n     * Handle the `up arrow` keyboard event.\n     * @param event the `up arrow` keyboard event.\n     */\n    protected handleUp(event: KeyboardEvent): boolean | void | object {\n        const prevNode = this.getPreviousSelectableTreeNode();\n        if (prevNode) {\n            if (!!this.props.multiSelect && this.hasShiftMask(event)) {\n                this.model.selectRange(prevNode);\n            } else {\n                this.model.selectNode(prevNode);\n            }\n        }\n        this.node.focus();\n    }\n\n    /**\n     * Handle the `down arrow` keyboard event.\n     * @param event the `down arrow` keyboard event.\n     */\n    protected handleDown(event: KeyboardEvent): boolean | void | object {\n        const nextNode = this.getNextSelectableTreeNode();\n        if (nextNode) {\n            if (!!this.props.multiSelect && this.hasShiftMask(event)) {\n                this.model.selectRange(nextNode);\n            } else {\n                this.model.selectNode(nextNode);\n            }\n        }\n        this.node.focus();\n    }\n\n    /**\n     * Handle the `enter key` keyboard event.\n     * - `enter` opens the tree node.\n     * @param event the `enter key` keyboard event.\n     */\n    protected handleEnter(event: KeyboardEvent): boolean | void | object {\n        this.model.openNode();\n    }\n\n    /**\n     * Handle the `space key` keyboard event.\n     * - If the element has a checkbox, it will be toggled.\n     * - Otherwise, it should be similar to a single-click action.\n     * @param event the `space key` keyboard event.\n     */\n    protected handleSpace(event: KeyboardEvent): boolean | void | object {\n        const { focusedNode } = this.focusService;\n        if (focusedNode && focusedNode.checkboxInfo) {\n            this.model.markAsChecked(focusedNode, !focusedNode.checkboxInfo.checked);\n        } else if (!this.props.multiSelect || (!event.ctrlKey && !event.metaKey && !event.shiftKey)) {\n            this.tapNode(focusedNode);\n        }\n    }\n\n    protected handleEscape(event: KeyboardEvent): boolean | void | object {\n        if (this.model.selectedNodes.length <= 1) {\n            this.focusService.setFocus(undefined);\n            this.node.focus();\n        }\n        this.model.clearSelection();\n    }\n\n    /**\n     * Handle the single-click mouse event.\n     * @param node the tree node if available.\n     * @param event the mouse single-click event.\n     */\n    protected handleClickEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n        if (node) {\n            event.stopPropagation();\n            const shiftMask = this.hasShiftMask(event);\n            const ctrlCmdMask = this.hasCtrlCmdMask(event);\n            if (this.props.multiSelect && (shiftMask || ctrlCmdMask) && SelectableTreeNode.is(node)) {\n                if (shiftMask) {\n                    this.model.selectRange(node);\n                } else if (ctrlCmdMask) {\n                    this.model.toggleNode(node);\n                }\n            } else if (!this.inExpander(node, event)) {\n                // The expander handles its own expansion toggle, so don't do it here\n                this.tapNode(node);\n            }\n        }\n    }\n\n    private inExpander(node: TreeNode, event: React.MouseEvent<HTMLElement, MouseEvent>): boolean {\n        const target = event.target as HTMLElement;\n        return target.classList.contains(THEIA_EXPANSION_TOGGLE_CLASS);\n    }\n\n    /**\n     * The effective handler of an unmodified single-click event.\n     */\n    protected tapNode(node?: TreeNode): void {\n        if (SelectableTreeNode.is(node)) {\n            this.model.selectNode(node);\n        }\n        if (node && !this.props.expandOnlyOnExpansionToggleClick && this.isExpandable(node) && !this.isRenaming(node.id)) {\n            this.model.toggleNodeExpansion(node).catch(e => console.error(e));\n        }\n    }\n\n    //\n    // DnD\n    //\n    protected draggedElement?: HTMLElement;\n    protected draggedSelection?: TreeNode[];\n    protected dropOperation?: DropOperation;\n    protected readonly dropOperationFeedback = new DisposableCollection();\n    protected readonly dragOverExpansion = new DisposableCollection();\n\n    protected isDraggable(node: TreeNode): boolean {\n        return false;\n    }\n\n    protected handleDragStartEvent(node: TreeNode, event: React.DragEvent): TreeNode[] {\n        event.stopPropagation();\n        if (event.dataTransfer) {\n            // we either drag the whole selection if the dragged node is part of the existing selection or we drag just the node\n            const selectedNodes = this.model.selectedNodes.find(selected => TreeNode.equals(selected, node))\n                ? [...this.model.selectedNodes]\n                : [node];\n            this.draggedSelection = selectedNodes;\n            this.draggedElement = event.target as HTMLElement;\n            return selectedNodes;\n        }\n        return [];\n    }\n\n    protected handleDragEndEvent(node: TreeNode, event: React.DragEvent): TreeNode[] {\n        event.stopPropagation();\n        this.dropOperationFeedback.dispose();\n        this.draggedSelection = undefined;\n        this.draggedElement = undefined;\n        return [];\n    }\n\n    protected override onAfterShow(msg: Message): void {\n        super.onAfterShow(msg);\n        const selectedNode = this.model.selectedNodes[0];\n        this.scrollTo = selectedNode ? { key: selectedNode.id } : { top: 0 };\n        if (this.scroll.y === MIN_TABLE_SIZE_PX) {\n            // we might have been rendered while not visible and have the min size\n            // -> recompute size\n            this.updateScrollConstraints();\n        } else {\n            this.update();\n        }\n    }\n\n    protected handleDragEnterEvent(node: TreeNode | undefined, event: React.DragEvent): void {\n        event.preventDefault();\n        event.stopPropagation();\n        this.dragOverExpansion.dispose();\n    }\n\n    protected handleDragOverEvent(node: TreeNode | undefined, event: React.DragEvent): void {\n        event.preventDefault();\n        event.stopPropagation();\n\n        // properly provide feedback for drop operation\n        const dropOperations = this.getSupportedDropOperations(node, event);\n        event.dataTransfer.dropEffect = 'none';\n        if (dropOperations.length > 0) {\n            const dropTarget = this.detectDropTarget(node, event);\n            if (dropTarget && dropTarget !== this.draggedElement) {\n                this.dropOperationFeedback.dispose();\n                this.dropOperation = this.detectDropOperation(event, dropTarget, dropOperations);\n                dropTarget.classList.add('drop-' + this.dropOperation);\n                event.dataTransfer.dropEffect = 'move';\n                this.dropOperationFeedback.pushAll([\n                    Disposable.create(() => dropTarget.classList.remove('drop-insert-before', 'drop-insert-after', 'drop-insert-into')),\n                    Disposable.create(() => (this.dropOperation = undefined))\n                ]);\n            }\n        }\n\n        // install expansion timer\n        if (this.dragOverExpansion.disposed) {\n            // expand node when hovering over it\n            const expandTimer = setTimeout(() => ExpandableTreeNode.is(node) && !node.expanded && void this.model.expandNode(node), 1000);\n            this.dragOverExpansion.push(Disposable.create(() => clearTimeout(expandTimer)));\n        }\n    }\n\n    protected detectDropTarget(node: TreeNode | undefined, event: React.DragEvent): HTMLElement | undefined {\n        const eventTarget = event.currentTarget as HTMLElement;\n        // we want to use the node content as target for rows but the tree container for the root node\n        return eventTarget.classList.contains(TREE_CONTAINER_CLASS)\n            ? eventTarget\n            : (eventTarget.closest<HTMLElement>('.ant-table-row') ?? undefined);\n    }\n\n    protected detectDropOperation(event: React.DragEvent, element: HTMLElement, operations: DropOperation[]): DropOperation {\n        // based on the supported operations, we split the drop target into sections\n        if (operations.length === 1) {\n            // only a single operation is enabled\n            return operations[0];\n        }\n        if (operations.length === 3) {\n            // all operations are supported\n            const rect = element.getBoundingClientRect();\n            const firstQuarterMark = rect.top + rect.height * 0.25;\n            const thirdQuarterMark = rect.top + rect.height * 0.75;\n            return event.clientY < firstQuarterMark ? 'insert-before' : event.clientY > thirdQuarterMark ? 'insert-after' : 'insert-into';\n        }\n        // two operations are enabled\n        if (!operations.includes('insert-into')) {\n            const rect = element.getBoundingClientRect();\n            const firstHalfMark = rect.top + rect.height * 0.5;\n            return event.clientY < firstHalfMark ? 'insert-before' : 'insert-after';\n        }\n        if (operations.includes('insert-before')) {\n            const rect = element.getBoundingClientRect();\n            const firstQuarterMark = rect.top + rect.height * 0.25;\n            return event.clientY < firstQuarterMark ? 'insert-before' : 'insert-into';\n        } else {\n            const rect = element.getBoundingClientRect();\n            const thirdQuarterMark = rect.top + rect.height * 0.75;\n            return event.clientY < thirdQuarterMark ? 'insert-into' : 'insert-after';\n        }\n    }\n\n    protected handleDragLeaveEvent(node: TreeNode | undefined, event: React.DragEvent): void {\n        event.preventDefault();\n        event.stopPropagation();\n        this.dropOperationFeedback.dispose();\n        this.dragOverExpansion.dispose();\n    }\n\n    protected getSupportedDropOperations(node: TreeNode | undefined, event: React.DragEvent): DropOperation[] {\n        if (node === undefined || this.draggedSelection === undefined || this.draggedSelection.length === 0) {\n            return [];\n        }\n        return this.calculateDropOperations(this.draggedSelection, node);\n    }\n\n    protected calculateDropOperations(nodes: TreeNode[], target: TreeNode | undefined): DropOperation[] {\n        return [];\n    }\n\n    protected async handleDropEvent(node: TreeNode | undefined, event: React.DragEvent): Promise<void> {\n        event.preventDefault();\n        event.stopPropagation();\n        if (this.dropOperation && this.draggedSelection) {\n            event.dataTransfer.dropEffect = 'move';\n            this.drop(this.draggedSelection, node, this.dropOperation);\n            this.dropOperationFeedback.dispose();\n        }\n    }\n\n    protected drop(selection: TreeNode[], target: TreeNode | undefined, operation: DropOperation): void {\n        // do nothing, subclasses can override\n    }\n\n    /**\n     * Handle the double-click mouse event.\n     * @param node the tree node if available.\n     * @param event the double-click mouse event.\n     */\n    protected handleDblClickEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n        if (!this.isRenaming(node)) {\n            this.model.openNode(node);\n            event.stopPropagation();\n        }\n    }\n\n    /**\n     * Handle the middle-click mouse event.\n     * @param node the tree node if available.\n     * @param event the middle-click mouse event.\n     */\n    protected handleAuxClickEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n        if (event.button === 1) {\n            this.model.openNode(node);\n            if (SelectableTreeNode.is(node)) {\n                this.model.selectNode(node);\n            }\n        }\n        event.stopPropagation();\n    }\n\n    /**\n     * Handle the context menu click event.\n     * - The context menu click event is triggered by the right-click.\n     * @param node the tree node if available.\n     * @param event the right-click mouse event.\n     */\n    protected handleContextMenuEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n        if (SelectableTreeNode.is(node)) {\n            // Keep the selection for the context menu, if the widget support multi-selection and the right\n            // click happens on an already selected node.\n            if (!this.props.multiSelect || !node.selected) {\n                const type =\n                    !!this.props.multiSelect && this.hasCtrlCmdMask(event)\n                        ? TreeSelection.SelectionType.TOGGLE\n                        : TreeSelection.SelectionType.DEFAULT;\n                this.model.addSelection({ node, type });\n            }\n            this.focusService.setFocus(node);\n            const contextMenuPath = this.props.contextMenuPath;\n            if (contextMenuPath) {\n                this.showContextMenu(node, event, contextMenuPath);\n            }\n        }\n        event.stopPropagation();\n        event.preventDefault();\n    }\n\n    protected showContextMenu(node: SelectableTreeNode, event: React.MouseEvent<HTMLElement>, contextMenuPath: MenuPath): void {\n        const args = this.toContextMenuArgs(node) ?? [];\n        setTimeout(() => this.contextMenuHelper.showContextMenu(event, contextMenuPath, ...args), 10);\n    }\n\n    /**\n     * Convert the tree node to context menu arguments.\n     * @param node the selectable tree node.\n     */\n    protected toContextMenuArgs(node: SelectableTreeNode): any[] | undefined {\n        return [this, node];\n    }\n\n    /**\n     * Determine if the tree modifier aware event has a `ctrlcmd` mask.\n     * @param event the tree modifier aware event.\n     *\n     * @returns `true` if the tree modifier aware event contains the `ctrlcmd` mask.\n     */\n    protected hasCtrlCmdMask(event: TreeWidget.ModifierAwareEvent): boolean {\n        return isOSX ? event.metaKey : event.ctrlKey;\n    }\n\n    /**\n     * Determine if the tree modifier aware event has a `shift` mask.\n     * @param event the tree modifier aware event.\n     *\n     * @returns `true` if the tree modifier aware event contains the `shift` mask.\n     */\n    protected hasShiftMask(event: TreeWidget.ModifierAwareEvent): boolean {\n        // Ctrl/Cmd mask overrules the Shift mask.\n        if (this.hasCtrlCmdMask(event)) {\n            return false;\n        }\n        return event.shiftKey;\n    }\n\n    /**\n     * Deflate the tree node for storage.\n     * @param node the tree node.\n     */\n    protected deflateForStorage(node: TreeNode): object {\n        const copy = { ...node } as any;\n        if (copy.parent) {\n            delete copy.parent;\n        }\n        if ('previousSibling' in copy) {\n            delete copy.previousSibling;\n        }\n        if ('nextSibling' in copy) {\n            delete copy.nextSibling;\n        }\n        if ('busy' in copy) {\n            delete copy.busy;\n        }\n        if (CompositeTreeNode.is(node)) {\n            copy.children = [];\n            for (const child of node.children) {\n                copy.children.push(this.deflateForStorage(child));\n            }\n        }\n        return copy;\n    }\n\n    /**\n     * Inflate the tree node from storage.\n     * @param node the tree node.\n     * @param parent the optional tree node.\n     */\n    protected inflateFromStorage(node: any, parent?: TreeNode): TreeNode {\n        if (node.selected) {\n            node.selected = false;\n        }\n        if (parent) {\n            node.parent = parent;\n        }\n        if (Array.isArray(node.children)) {\n            for (const child of node.children as TreeNode[]) {\n                this.inflateFromStorage(child, node);\n            }\n        }\n        return node;\n    }\n\n    /**\n     * Store the tree state.\n     */\n    storeState(): object {\n        const decorations = this.decoratorService.deflateDecorators(this.decorations);\n        let state: object = {\n            decorations\n        };\n        if (this.model.root) {\n            state = {\n                ...state,\n                root: this.deflateForStorage(this.model.root),\n                model: this.model.storeState(),\n                focusedNodeId: this.focusService.focusedNode?.id\n            };\n        }\n\n        return state;\n    }\n\n    /**\n     * Restore the state.\n     * @param oldState the old state object.\n     */\n    restoreState(oldState: object): void {\n        const { root, decorations, model, focusedNodeId } = oldState as any;\n        if (root) {\n            this.model.root = this.inflateFromStorage(root);\n        }\n        if (decorations) {\n            this.decorations = this.decoratorService.inflateDecorators(decorations);\n        }\n        if (model) {\n            this.model.restoreState(model);\n        }\n        if (focusedNodeId) {\n            const candidate = this.model.getNode(focusedNodeId);\n            if (SelectableTreeNode.is(candidate)) {\n                this.focusService.setFocus(candidate);\n            }\n        }\n    }\n\n    protected toNodeIcon(node: TreeNode): string {\n        return this.labelProvider.getIcon(node);\n    }\n\n    protected toNodeName(node: TreeNode): string {\n        return this.labelProvider.getName(node);\n    }\n\n    protected toNodeDescription(node: TreeNode): string {\n        return this.labelProvider.getLongName(node);\n    }\n\n    // Tree Table Methods from here on\n\n    protected abstract getColumnData(node: TreeNode): T;\n\n    protected async resolveColumnData(node: TreeNode): Promise<T> {\n        return this.getColumnData(node);\n    }\n\n    protected renderNodeHeader(): React.ReactNode {\n        return <div className='p-d-flex'></div>;\n    }\n\n    protected updateSelection(): void {\n        this.update();\n    }\n\n    protected getDataTestId(row: TreeTableRow<TreeTableColumnData>): string | undefined {\n        const labels = [this.getDataTestIdSegment(row.node)];\n        let parent = row.node.parent;\n        while (parent) {\n            const segment = this.getDataTestIdSegment(parent);\n            if (segment && segment.trim() !== '<unknown>') {\n                labels.push(segment);\n            }\n            parent = parent.parent;\n        }\n        return labels.reverse().join('::');\n    }\n\n    protected getDataTestIdSegment(node: TreeNode): string {\n        return this.labelProvider.getName(node);\n    }\n\n    protected getRowClassName(row: TreeTableRow<T>, index?: number): string | undefined {\n        const className: string[] = [];\n        if (!TreeNode.isVisible(row.node)) {\n            className.push('hidden-row');\n        }\n        if (this.scroll.x === 'dynamic-content') {\n            className.push('dynamic-content-row');\n        }\n        if (SelectableTreeNode.is(row.node)) {\n            if (this.model.selectedNodes.includes(row.node)) {\n                if (this.focused) {\n                    className.push('selected-row-focused');\n                } else {\n                    className.push('selected-row');\n                }\n            } else if (this.styleChildrenOfSelection) {\n                /* check if child of selected node */\n                if (this.sorter?.order === 'ascend' || this.sorter?.order === 'descend') {\n                    /* in sort mode we show a flat list -> no children */\n                    className.push('unselected-row');\n                } else {\n                    let parent = row.node.parent;\n                    while (parent !== undefined) {\n                        if (SelectableTreeNode.is(parent) && this.model.selectedNodes.includes(parent)) {\n                            if (this.focused) {\n                                className.push('selected-row-child-focused');\n                            } else {\n                                className.push('selected-row-child');\n                            }\n                            break;\n                        }\n                        parent = parent.parent;\n                    }\n                    /* parent is also not selected */\n                    className.push('unselected-row');\n                }\n            } else {\n                className.push('unselected-row');\n            }\n        }\n        if (index !== undefined) {\n            className.push(index % 2 === 0 ? 'even-row' : 'odd-row');\n        }\n        return className.length > 0 ? className.join(' ') : undefined;\n    }\n\n    protected createNodeColumn(): TreeTableColumn<T> {\n        return {\n            dataIndex: ['node'],\n            key: 'node',\n            title: () => this.renderNodeHeader(),\n            render: (_value: any, row: TreeTableRow<T>, _index: number) => this.renderNodeColumn(row),\n            width: 0\n        };\n    }\n\n    protected createTailColumn(): TreeTableColumn<T> {\n        return {\n            dataIndex: ['tail'],\n            key: 'tail',\n            title: 'tail',\n            fixed: 'right',\n            className: 'tail-column',\n            render: (_value: any, row: TreeTableRow<T>, _index: number) => this.renderTailCommands(row.node),\n            width: 128\n        };\n    }\n\n    protected createDataColumn(key: TreeTableDataKey<T>, props: TreeTableColumnHeaderProps = {}): TreeTableColumn<T> {\n        const options = { sortable: true, ...props };\n        const column: TreeTableColumn<T> = {\n            dataIndex: ['columnData', key],\n            key,\n            title: options.title,\n            onHeaderCell: (_data, index) => ({\n                title: options.description || options.title,\n                onContextMenu: event => this.onColumnHeaderContextMenu(event, options, key, index),\n                onFocus: event => this.onColumnHeaderFocus(event, options, key, index),\n                onClick: event => this.onColumnHeaderFocus(event, options, key, index)\n            }),\n            // there is no style member for this element\n            className: this.getDataColumnClassName(key, props),\n            width: 'auto',\n            render: (_value: any, row: TreeTableRow<T>, _index: number) => this.renderDataColumn(row, key, column),\n            sortOrder: this.sorter?.columnKey === key ? this.sorter?.order : undefined\n        };\n        if (options.sortable) {\n            column.sorter = true;\n            column.sortIcon = (sortProps: { sortOrder: SortOrder }) => this.renderSortIcon(sortProps);\n            column.showSorterTooltip = false;\n        }\n        return column;\n    }\n\n    protected onColumnHeaderFocus(\n        event: React.SyntheticEvent,\n        options: TreeTableColumnHeaderProps,\n        columnKey: ColumnKey,\n        index?: number\n    ): void {\n        const target = event.currentTarget as HTMLTableCellElement;\n        if (target) {\n            const scrollContainer = this.node.querySelector<HTMLDivElement>('.ant-table-header');\n            if (scrollContainer) {\n                // The header cells are shifted to the right by the width of the first column which contains the search bar and tree\n                const headerLeftShift = (target.parentElement as HTMLTableRowElement)?.cells?.[0]?.offsetWidth ?? 0;\n                const targetLeftScrollPosition = target.offsetLeft - headerLeftShift;\n                const containerLeftScrollPosition = scrollContainer.scrollLeft;\n                if (targetLeftScrollPosition < containerLeftScrollPosition) {\n                    // need to scroll to the left to ensure the header is fully visible\n                    void this.updateScrollTo({\n                        left: targetLeftScrollPosition,\n                        top: 0\n                    });\n                    return;\n                }\n                const targetRightScrollPosition = targetLeftScrollPosition + target.offsetWidth;\n                const containerRightScrollPosition = containerLeftScrollPosition + (scrollContainer.offsetWidth - headerLeftShift);\n                if (targetRightScrollPosition > containerRightScrollPosition) {\n                    // need to scroll to the right to ensure that header is fully visible\n                    void this.updateScrollTo({\n                        left: containerLeftScrollPosition + (targetRightScrollPosition - containerRightScrollPosition),\n                        top: 0\n                    });\n                    return;\n                }\n                // container already scrolled correctly, we just need to ensure that the position is stored as state in the table\n                void this.updateScrollTo({\n                    left: containerLeftScrollPosition,\n                    top: 0\n                });\n            }\n        }\n    }\n\n    protected onColumnHeaderContextMenu(\n        event: React.MouseEvent,\n        options: TreeTableColumnHeaderProps,\n        columnKey: ColumnKey,\n        index?: number\n    ): void {\n        // Nothing to do by default\n    }\n\n    protected renderDataColumn(row: TreeTableRow<T>, key: TreeTableDataKey<T>, column: TreeTableColumn<T>): React.ReactNode {\n        return LazyTreeTableRow.is(row) ? (\n            <this.LazyTreeTableCellView row={row} dataKey={key} formatValue={this.formatValue.bind(this)} />\n        ) : (\n            (row.columnData[key] as any)\n        );\n    }\n\n    protected getDataColumnClassName(key: keyof T, props?: TreeTableColumnHeaderProps): string {\n        let className = key as string;\n        if (this.sorter?.columnKey === key && (this.sorter.order === 'ascend' || this.sorter.order === 'descend')) {\n            className += ' sorted';\n        }\n        // Couldn't change column alignment property through element style to affect justify-content\n        // ,so I created some rules simple rules to apply alignment based on a classname\n        if (props?.align) {\n            className += ` align-${props.align}`;\n        }\n        return className;\n    }\n\n    protected renderSortIcon(props: { sortOrder: SortOrder }): React.ReactNode {\n        if (props.sortOrder === 'ascend') {\n            return <div className={codicon('sokatoa-sort-duration-up')}></div>;\n        } else if (props.sortOrder === 'descend') {\n            return <div className={codicon('sokatoa-sort-duration')}></div>;\n        } else {\n            return <div className={codicon('sokatoa-sort-by')}></div>;\n        }\n    }\n\n    protected getColumns(): TreeTableColumn<T>[] {\n        const columns: TreeTableColumn<T>[] = [];\n        columns.push(this.createNodeColumn());\n        return columns;\n    }\n\n    protected showHeader(): boolean {\n        const columns = this.getColumns();\n        return columns.filter(c => !c.className?.includes('tail-column')).length > 1;\n    }\n\n    protected toRenameNodeId: string | undefined = undefined;\n    protected pendingRename = new Deferred<string | undefined>();\n\n    async triggerNodeRename(nodeOrId: TreeNode | string): Promise<string | undefined> {\n        const node = typeof nodeOrId === 'string' ? this.model.getNode(nodeOrId) : nodeOrId;\n        if (!node || !this.canRename(node)) {\n            return;\n        }\n        this.toRenameNodeId = node.id;\n        this.contextService.inRenameMode = true;\n        this.pendingRename = new Deferred<string | undefined>();\n        this.update();\n        return this.pendingRename.promise;\n    }\n\n    protected handleRenameValidate(value: string): string | undefined {\n        if (value === undefined || !this.isRenaming()) {\n            return;\n        }\n        const node = this.model.getNode(this.toRenameNodeId);\n        if (!node) {\n            return;\n        }\n        return this.validateRename(node, value);\n    }\n\n    protected handleRenameSubmit(value: string): void {\n        if (value === undefined || !this.isRenaming()) {\n            return;\n        }\n        const node = this.model.getNode(this.toRenameNodeId);\n        this.toRenameNodeId = undefined;\n        this.contextService.inRenameMode = false;\n        this.update();\n        if (node) {\n            void this.rename(node, value).finally(() => this.pendingRename.resolve(value));\n        } else {\n            this.pendingRename.resolve(value);\n        }\n    }\n\n    protected handleRenameCancel(): void {\n        this.toRenameNodeId = undefined;\n        this.contextService.inRenameMode = false;\n        this.update();\n        this.pendingRename.resolve(undefined);\n    }\n\n    protected canRename(node: TreeNode): boolean {\n        return false;\n    }\n\n    protected isRenaming(node?: string | TreeNode): boolean {\n        if (!node) {\n            return this.toRenameNodeId !== undefined;\n        }\n        return typeof node === 'string' ? node === this.toRenameNodeId : node.id === this.toRenameNodeId;\n    }\n\n    /**\n     * Subclasses need to implement the actual logic for renaming.\n     */\n    protected async rename(node: TreeNode, value: string): Promise<void> {\n        console.warn(`Renaming ${node.id} to ${value} is not implemented`);\n    }\n\n    protected validateRename(node: TreeNode, value: string): string | undefined {\n        return undefined;\n    }\n\n    protected renderRename(row: TreeTableRow<T>, props?: any): React.ReactNode {\n        const node = row.node;\n        const attributes = this.createNodeAttributes(node);\n        const content = (\n            <div className={TREE_TABLE_NODE_CONTENT_CLASS} key={row.key + '_node'}>\n                {this.renderCheckbox(node, props)}\n                {this.decorateIcon(node, this.renderIcon(node, props))}\n                {this.renderCaptionAffixes(node, props, 'captionPrefixes')}\n                {\n                    <this.RenameTreeTableCellView\n                        row={row}\n                        value={this.toNodeName(node)}\n                        validate={this.handleRenameValidate.bind(this)}\n                        onCancel={this.handleRenameCancel.bind(this)}\n                        onSubmit={this.handleRenameSubmit.bind(this)}\n                    />\n                }\n                {this.renderCaptionAffixes(node, props, 'captionSuffixes')}\n                {this.renderTailDecorations(node, props)}\n            </div>\n        );\n        return React.createElement('div', attributes, content);\n    }\n\n    protected sortRows(\n        left: TreeTableRow<T>,\n        right: TreeTableRow<T>,\n        key: TreeTableDataKey<T> = this.sorter?.columnKey as TreeTableDataKey<T>,\n        order: SortOrder | undefined = this.sorter?.order\n    ): number {\n        const leftValue = this.toValue(left.columnData, key);\n        const rightValue = this.toValue(right.columnData, key);\n        if (leftValue === undefined && rightValue === undefined) {\n            return 0;\n        }\n        // always sort undefined values to the end\n        if (leftValue === undefined) {\n            return 1;\n        }\n        if (rightValue === undefined) {\n            return -1;\n        }\n        if (order === 'ascend') {\n            return leftValue < rightValue ? -1 : leftValue > rightValue ? 1 : 0;\n        }\n        return leftValue < rightValue ? 1 : leftValue > rightValue ? -1 : 0;\n    }\n\n    protected abstract toValue(data: T, key: TreeTableDataKey<T>): number | bigint | string | undefined;\n\n    protected onChange(\n        _pagination: TablePaginationConfig,\n        _filters: Record<string, FilterValue | null>,\n        sorter: SorterResult<TreeTableRow<T>> | SorterResult<TreeTableRow<T>>[],\n        _extra: TableCurrentDataSource<TreeTableRow<T>>\n    ): void {\n        this.sorter = Array.isArray(sorter) ? sorter[0] : sorter;\n        this.updateRowsToSort().catch(e => console.error(e));\n    }\n\n    protected async updateRowsToSort(): Promise<void> {\n        this.updateRows({\n            sortTreeTableRows: true,\n            updateFilteredRows: true\n        });\n    }\n\n    protected onTableRender(): void {\n        // no op, subclasses may override\n    }\n\n    getTotal(): number {\n        return this.rowModel.size;\n    }\n\n    getPreviousTreeNode(\n        predicate: (node: TreeNode) => boolean = () => true,\n        options: { skipCollapsedChildren?: boolean } = {}\n    ): TreeNode | undefined {\n        return this.getTreeNode('prev', predicate, options);\n    }\n\n    protected getSelectableTreeNodeInDirectionPredicate(): (node: TreeNode) => boolean {\n        return () => true;\n    }\n\n    /**\n     * Gets the visible parent of the given node, respecting visibility predicates.\n     * @param node the node to get the visible parent of, defaults to the first selected node\n     */\n    protected getVisibleParent(node: TreeNode | undefined = this.model.selectedNodes[0]): SelectableTreeNode | undefined {\n        if (!node) {\n            return undefined;\n        }\n        const predicate = this.getSelectableTreeNodeInDirectionPredicate();\n        let current: TreeNode | undefined = node.parent;\n        while (current) {\n            if (this.shouldDisplayNode(current) && predicate(current) && SelectableTreeNode.is(current)) {\n                return current;\n            }\n            current = current.parent;\n        }\n        return undefined;\n    }\n\n    /**\n     * Gets the first visible child of the given node, respecting visibility predicates.\n     * @param node the node to get the first visible child of, defaults to the first selected node\n     */\n    protected getFirstVisibleChild(node: TreeNode | undefined = this.model.selectedNodes[0]): SelectableTreeNode | undefined {\n        if (!node) {\n            return undefined;\n        }\n        if (!CompositeTreeNode.is(node) || node.children.length === 0) {\n            return undefined;\n        }\n        const predicate = this.getSelectableTreeNodeInDirectionPredicate();\n        for (const child of node.children) {\n            if (this.shouldDisplayNode(child) && predicate(child) && SelectableTreeNode.is(child)) {\n                return child;\n            }\n        }\n        return undefined;\n    }\n\n    getPreviousSelectableTreeNode(): SelectableTreeNode | undefined {\n        const treeNode = this.getPreviousTreeNode(this.getSelectableTreeNodeInDirectionPredicate(), { skipCollapsedChildren: true });\n        if (SelectableTreeNode.is(treeNode)) {\n            return treeNode;\n        }\n        return undefined;\n    }\n\n    getNextTreeNode(\n        predicate: (node: TreeNode) => boolean = () => true,\n        options: { skipCollapsedChildren?: boolean } = {}\n    ): TreeNode | undefined {\n        return this.getTreeNode('next', predicate, options);\n    }\n\n    getNextSelectableTreeNode(): SelectableTreeNode | undefined {\n        const treeNode = this.getNextTreeNode(this.getSelectableTreeNodeInDirectionPredicate(), { skipCollapsedChildren: true });\n        if (SelectableTreeNode.is(treeNode)) {\n            return treeNode;\n        }\n        return undefined;\n    }\n\n    private getTreeNodeDataForTreeNode(node: TreeNode): TreeTableRow<T> | undefined {\n        return Iterators.find(this.asList(), data => data.key === node.id);\n    }\n\n    /**\n     * @param toSelect the direction to navigate\n     * @param predicate if a node does not fulfil this predicate, it will be skipped over\n     * @param options navigation options\n     * @returns the tree node in the direction or undefined if none was found\n     */\n    private getTreeNode(\n        toSelect: 'prev' | 'next',\n        predicate: (node: TreeNode) => boolean = () => true,\n        options: { skipCollapsedChildren?: boolean } = {}\n    ): TreeNode | undefined {\n        if (this.model.selectedNodes.length > 0) {\n            const selection = this.model.selectedNodes[0];\n            return this.getTreeNodeInDirection(toSelect, selection, predicate, options);\n        }\n        return undefined;\n    }\n\n    private getTreeNodeInDirection(\n        toSelect: 'prev' | 'next',\n        start: TreeNode,\n        predicate: (node: TreeNode) => boolean = () => true,\n        options: { skipCollapsedChildren?: boolean } = {}\n    ): TreeNode | undefined {\n        const startData = this.getTreeNodeDataForTreeNode(start);\n        if (startData === undefined) {\n            return undefined;\n        }\n        const containingArray = startData.parent.children;\n        if (containingArray === undefined) {\n            return undefined;\n        }\n        const ownIndex = containingArray.indexOf(startData);\n        if (ownIndex < 0) {\n            return undefined;\n        }\n\n        if (toSelect === 'prev') {\n            if (ownIndex > 0) {\n                /* we have a sibling before us -> return very last child of this sibling */\n                let result = containingArray[ownIndex - 1];\n                let siblingChildren = result.children;\n                while (\n                    siblingChildren !== undefined &&\n                    siblingChildren.length > 0 &&\n                    (!options.skipCollapsedChildren || ExpandableTreeNode.isExpanded(result.node))\n                ) {\n                    result = siblingChildren[siblingChildren.length - 1];\n                    siblingChildren = result.children;\n                }\n                if (predicate(result.node)) {\n                    return result.node;\n                } else {\n                    return this.getTreeNodeInDirection(toSelect, result.node, predicate, options);\n                }\n            } else {\n                /* we have no sibling before -> return parent, if any */\n                if (isTreeTableRow(startData.parent)) {\n                    if (predicate(startData.parent.node)) {\n                        return startData.parent.node;\n                    } else {\n                        return this.getTreeNodeInDirection(toSelect, startData.parent.node, predicate, options);\n                    }\n                } else {\n                    return undefined;\n                }\n            }\n        } else if (toSelect === 'next') {\n            if (\n                startData.children !== undefined &&\n                startData.children.length > 0 &&\n                (!options.skipCollapsedChildren || ExpandableTreeNode.isExpanded(startData.node))\n            ) {\n                /* we have children -> select first child */\n                if (predicate(startData.children[0].node)) {\n                    return startData.children[0].node;\n                } else {\n                    return this.getTreeNodeInDirection(toSelect, startData.children[0].node, predicate, options);\n                }\n            } else {\n                /* we have no children, select next sibling if any */\n                if (containingArray.length > ownIndex + 1) {\n                    if (predicate(containingArray[ownIndex + 1].node)) {\n                        return containingArray[ownIndex + 1].node;\n                    } else {\n                        return this.getTreeNodeInDirection(toSelect, containingArray[ownIndex + 1].node, predicate, options);\n                    }\n                }\n\n                /* no siblings, look for next node in parents */\n                let self = startData.parent;\n                while (isTreeTableRow(self)) {\n                    const parent = self.parent;\n                    const nodes = parent.children;\n                    if (nodes === undefined) {\n                        return undefined;\n                    }\n                    const index = nodes.indexOf(self);\n                    if (index < 0) {\n                        return undefined;\n                    }\n\n                    if (nodes.length > index + 1) {\n                        if (predicate(nodes[index + 1].node)) {\n                            return nodes[index + 1].node;\n                        } else {\n                            return this.getTreeNodeInDirection(toSelect, nodes[index + 1].node, predicate, options);\n                        }\n                    }\n                    self = parent;\n                }\n\n                /* nothing found, we were the very last node */\n                return undefined;\n            }\n        } else {\n            console.warn('Unknown select direction');\n        }\n        return undefined;\n    }\n\n    // React Components from here\n\n    ExpandIcon: React.FC<RenderExpandIconEnhProps<TreeTableRow<T>>> = React.memo(function ExpandIcon({\n        expanded,\n        onExpand,\n        record,\n        expandable,\n        dataTestId\n    }: any) {\n        const expansionHandler = expandable ? (e: React.MouseEvent) => onExpand(record, e) : undefined;\n        return (\n            <span className='theia-treeTable-ExpansionToggle' onClick={expansionHandler} data-test-id={expansionHandler && dataTestId}>\n                {!expandable ? (\n                    <div className={`${THEIA_EXPANSION_TOGGLE_CLASS} ${codicon('blank')}`}></div>\n                ) : expanded ? (\n                    <div className={`${THEIA_EXPANSION_TOGGLE_CLASS} ${codicon('chevron-down')}`}></div>\n                ) : (\n                    <div className={`${THEIA_EXPANSION_TOGGLE_CLASS} ${codicon('chevron-down')} theia-mod-collapsed`}></div>\n                )}\n            </span>\n        );\n    });\n\n    /* eslint-disable react-hooks/rules-of-hooks */ // The rule thinks we're inside a class body -> inside a class component.\n    TreeTableView: React.FC<TreeTableViewProps<T>> = ({\n        expandedRowsKeys,\n        getRowClassName,\n        onChange,\n        onRender,\n        onToggle,\n        rows,\n        scroll,\n        scrollTo,\n        onScrollTo,\n        indentSize,\n        isExpandable,\n        locale = { emptyText: '' },\n        showHeader,\n        ...props\n    }) => {\n        // typing from antd virtual-list.tsx example\n        // eslint-disable-next-line no-null/no-null\n        const tableRef: Parameters<typeof Table>[0]['ref'] = React.useRef(null);\n        const [inner, setInner] = React.useState<HTMLElement>();\n        const [tableWidth, setTableWidth] = React.useState(scroll?.x === 'dynamic-content' ? 0 : (scroll?.x ?? 0));\n\n        React.useEffect(() => {\n            if (tableRef.current) {\n                // Ant Table doesn't account for the height of the header in laying out virtual table body,\n                // resulting in the body extending under whatever widget is below it. Do this accounting\n                // on its behalf\n                const tableHeader = tableRef.current.nativeElement.querySelector<HTMLElement>('.ant-table-header');\n                const tableBody = tableRef.current.nativeElement.querySelector<HTMLElement>('.ant-table-tbody-virtual');\n                if (tableHeader && tableBody) {\n                    tableBody.style.height = `calc(100% - ${tableHeader.offsetHeight}px)`;\n                }\n            }\n            onRender();\n        });\n\n        React.useEffect(() => {\n            if (scrollTo) {\n                tableRef.current?.scrollTo(scrollTo);\n                onScrollTo?.(scrollTo);\n            }\n        }, [scrollTo, onScrollTo]);\n\n        const onRow = React.useCallback<GetComponentProps<TreeTableRow<T>>>(\n            (row: TreeTableRow<T>, index?: number) => ({\n                className: getRowClassName(row, index),\n                onClick: event => this.handleClickEvent(row.node, event),\n                onDoubleClick: event => this.handleDblClickEvent(row.node, event),\n                onAuxClick: event => this.handleAuxClickEvent(row.node, event),\n                onContextMenu: event => this.handleContextMenuEvent(row.node, event),\n                ...this.getNodeDragHandlers(row.node)\n            }),\n            [getRowClassName]\n        );\n\n        const expandIcon = React.useCallback<NonNullable<ExpandableConfig<TreeTableRow<T>>['expandIcon']>>(\n            ({ expanded, onExpand, record, prefixCls }) => (\n                <this.ExpandIcon\n                    key={`${record.key}-expand-icon`}\n                    expanded={expanded}\n                    onExpand={onExpand}\n                    record={record}\n                    prefixCls={prefixCls}\n                    expandable={isExpandable(record)}\n                    dataTestId={this.getDataTestId(record)}\n                />\n            ),\n            [isExpandable]\n        );\n\n        const expandable = React.useMemo<ExpandableConfig<TreeTableRow<T>>>(\n            () => ({\n                expandedRowKeys: expandedRowsKeys,\n                onExpand: (expanded, row) => onToggle(expanded, row),\n                expandIcon: expandIcon,\n                indentSize\n            }),\n            [expandedRowsKeys, expandIcon, onToggle, indentSize]\n        );\n\n        useEffect(() => {\n            // Retrieve the inner virtual scroll container\n            // We need to use a MutationObserver because it is created/destroyed dynamically\n\n            if (!tableRef.current) {\n                return;\n            }\n\n            const table = tableRef.current.nativeElement;\n\n            const selector = '.ant-table-tbody-virtual-holder-inner';\n\n            const observer = new MutationObserver(() => {\n                if (!inner) {\n                    const element = table.querySelector<HTMLElement>(selector);\n                    if (element) {\n                        // It has been added\n                        setInner(element);\n                    }\n                } else {\n                    const element = table.querySelector<HTMLElement>(selector);\n                    if (!element) {\n                        // It has been removed\n                        setInner(undefined);\n                    }\n                }\n            });\n\n            observer.observe(table, { childList: true, subtree: true });\n\n            return () => {\n                observer.disconnect();\n            };\n        }, [tableRef, inner]);\n\n        useEffect(() => {\n            // Based on the inner element, we can calculate the table width if needed\n            if (!inner) {\n                return;\n            }\n\n            if (scroll?.x !== 'dynamic-content') {\n                setTableWidth(scroll?.x ?? 0);\n                return;\n            }\n\n            setTableWidth(inner.clientWidth);\n\n            const observer = new ResizeObserver(() => {\n                if (inner.isConnected) {\n                    setTableWidth(inner.clientWidth);\n                }\n            });\n            observer.observe(inner);\n            return () => {\n                observer.disconnect();\n            };\n        }, [scroll?.x, inner, rows]);\n\n        const columns = React.useMemo(() => {\n            if (rows.length === 0) {\n                return props.columns.filter(c => !c.className?.includes('tail-column'));\n            }\n\n            return props.columns;\n        }, [props.columns, rows]);\n\n        return (\n            <Table\n                ref={tableRef}\n                virtual\n                dataSource={rows}\n                columns={columns}\n                scroll={{\n                    x: tableWidth,\n                    y: scroll?.y ?? 'max-content'\n                }}\n                showHeader={showHeader}\n                pagination={false}\n                onRow={onRow}\n                expandable={expandable}\n                rowClassName={'sokatoa-TreeTable-row'}\n                tableLayout='fixed'\n                onChange={onChange}\n                sortDirections={['descend', 'ascend']} /* descend before ascend */\n                locale={locale}\n                className={classNamesUtils({ 'sokatoa-dynamic-content': scroll?.x === 'dynamic-content' })}\n            />\n        );\n    };\n    /* eslint-enable react-hooks/rules-of-hooks */\n\n    LazyTreeTableCellView = React.memo(function LazyTreeTableCellView({\n        row,\n        dataKey,\n        formatValue\n    }: {\n        row: LazyTreeTableRow<T>;\n        dataKey: TreeTableDataKey<T>;\n        formatValue: (value: unknown, dataKey: TreeTableDataKey<T>) => React.ReactNode;\n    }) {\n        // eslint-disable-next-line no-null/no-null\n        const [value, setValue] = React.useState<any>(null);\n        const [loading, setLoading] = React.useState<boolean>(!row.isResolved);\n\n        React.useEffect(() => {\n            let isMounted = true;\n\n            const initializeData = async (): Promise<void> => {\n                if (row.isResolved) {\n                    setValue(row.columnData[dataKey]);\n                    setLoading(false);\n                    return;\n                }\n\n                setLoading(true);\n                try {\n                    await row.resolveColumnData();\n                } catch (e) {\n                    console.error(e);\n                }\n                if (isMounted) {\n                    setValue(row.columnData[dataKey]);\n                    setLoading(false);\n                }\n            };\n\n            initializeData().catch(e => console.error(e));\n\n            return () => {\n                isMounted = false;\n            };\n        }, [dataKey, row]);\n        return loading ? <></> : <span key={`${row.key}-${dataKey}`}>{formatValue(value, dataKey)}</span>;\n    });\n\n    /* eslint-disable react-hooks/rules-of-hooks */ // Rule thinks class body -> class component\n    RenameTreeTableCellView: React.FC<{\n        row: TreeTableRow<T>;\n        value: string;\n        validate?: (value: string) => string | undefined;\n        onSubmit: (value: string) => void;\n        onCancel: () => void;\n    }> = ({ row, value, validate = () => undefined, onSubmit, onCancel }) => {\n        // eslint-disable-next-line no-null/no-null\n        const inputRef = React.useRef<HTMLInputElement>(null);\n        const [inputValue, setInputValue] = React.useState<string>(value);\n        const [errorMessage, setErrorMessage] = React.useState<string>('');\n\n        const hasError = React.useMemo(() => errorMessage.length > 0, [errorMessage]);\n\n        const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {\n            const newValue = event.target.value;\n            setInputValue(newValue);\n            setErrorMessage(validate(newValue) ?? '');\n        };\n\n        const submit = (): void => {\n            if (hasError) {\n                onCancel();\n            } else {\n                onSubmit(inputValue);\n            }\n        };\n\n        const handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>): void => {\n            if (event.key === 'Enter') {\n                submit();\n            } else if (event.key === 'Escape') {\n                onCancel();\n            }\n            event.stopPropagation();\n        };\n\n        const handleBlur = (_event: React.FocusEvent<HTMLInputElement>): void => {\n            submit();\n        };\n\n        const handleDragStart = (event: React.DragEvent<HTMLInputElement>): void => {\n            // avoid node dragging, just drag text\n            event.stopPropagation();\n        };\n\n        React.useEffect(() => {\n            inputRef.current?.focus();\n            inputRef.current?.select();\n        }, [inputRef]);\n\n        return (\n            <Tooltip title={errorMessage} open={hasError} arrow={true} rootClassName='validation-error'>\n                <input\n                    ref={inputRef}\n                    key={row.key + '_rename'}\n                    type='text'\n                    className={'theia-input theia-treeTable-Input theia-treeTable-RenameInput' + (hasError ? ' validation-error' : '')}\n                    value={inputValue}\n                    onChange={handleInputChange}\n                    onBlur={handleBlur}\n                    onDragStart={handleDragStart}\n                    onKeyDown={handleKeyDown}\n                    autoFocus\n                />\n            </Tooltip>\n        );\n    };\n    /* eslint-enable react-hooks/rules-of-hooks */\n\n    protected formatValue(value: unknown, dataKey: TreeTableDataKey<T>): React.ReactNode {\n        return value?.toString() ?? '';\n    }\n}\n\n@injectable()\nexport class AnyTreeTableWidget<T extends TreeTableColumnData = TreeTableColumnData> extends TreeTableWidget<T> {\n    protected override getColumnData(_node: TreeNode): T {\n        return {} as T;\n    }\n\n    /** No sorting if no data */\n    protected toValue(): undefined {\n        return undefined;\n    }\n}\n\nexport function getTreeTableRect(node: HTMLElement): DOMRect | undefined {\n    return node.querySelector('.' + TREE_CONTAINER_CLASS)?.getBoundingClientRect() ?? new DOMRect(0, 0, 1, 1);\n}\n\nexport function getTreeTableContainerBounds(node: HTMLElement): DOMRect | undefined {\n    return node.querySelector('.ant-table-container')?.getBoundingClientRect();\n}\n\n/**\n * Calculates the visible bounds of an HTMLElement within the tree table, considering clipping by parent\n * containers starting with the table container.\n * @param node - The HTMLElement to calculate visibility for.\n * @returns A DOMRect representing the visible area or undefined if the element is not visible.\n */\nexport function getTreeTableBodyBounds(node: HTMLElement): DOMRect | undefined {\n    // The container includes the header, which is not part of the body\n    const rect = node.querySelector('.ant-table-tbody')?.getBoundingClientRect();\n    if (!rect || rect.width <= 0 || rect.height <= 0) {\n        // The table body doesn't exist or is invisible\n        return undefined;\n    }\n\n    let visibleLeft = rect.left;\n    let visibleTop = rect.top;\n    let visibleRight = rect.right;\n    let visibleBottom = rect.bottom;\n\n    let currentElement: HTMLElement | null = node;\n\n    while (currentElement) {\n        const parent: HTMLElement | null = currentElement.parentElement;\n        if (!parent) {\n            // Reached the root of the DOM tree\n            break;\n        }\n\n        const parentRect = parent.getBoundingClientRect();\n\n        // Update visible boundaries by intersecting with the parent's bounding rectangle\n        visibleLeft = Math.max(visibleLeft, parentRect.left);\n        visibleTop = Math.max(visibleTop, parentRect.top);\n        visibleRight = Math.min(visibleRight, parentRect.right);\n        visibleBottom = Math.min(visibleBottom, parentRect.bottom);\n\n        // Early exit if the element is completely clipped by the parent\n        if (visibleLeft >= visibleRight || visibleTop >= visibleBottom) {\n            return undefined; // Element is not visible\n        }\n\n        currentElement = parent;\n    }\n\n    const visibleWidth = visibleRight - visibleLeft;\n    const visibleHeight = visibleBottom - visibleTop;\n\n    // If after all intersections, width or height is non-positive, the element is not visible\n    if (visibleWidth <= 0 || visibleHeight <= 0) {\n        return undefined;\n    }\n\n    const visibleRect = new DOMRect(visibleLeft, visibleTop, visibleWidth, visibleHeight);\n\n    return visibleRect;\n}\n\nexport const SearchBoxProps = Symbol('SearchBoxProps');\n\n@injectable()\nexport class TreeTableSearchBox extends SearchBox {\n    @inject(TreeTableContextService)\n    protected readonly contextService: TreeTableContextService;\n\n    constructor(@inject(SearchBoxProps) props: SearchBoxPropsInterface, @inject(SearchBoxDebounce) searchDebounce: SearchBoxDebounce) {\n        super(props, searchDebounce);\n    }\n\n    override handle(event: KeyboardEvent): boolean | void {\n        if (this.contextService.inRenameMode) {\n            return false;\n        }\n        return super.handle(event);\n    }\n}\n",
                "originalState": "/********************************************************************************\n    Copyright 2024-2025 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\n\n// This is a fork of Theia's tree-widget.tsx implementation with the aim of\n// reusing as much common models and services as possible\n// Below is the original copyright header\n\n// *****************************************************************************\n// Copyright (C) 2018 TypeFox and others.\n//\n// This program and the accompanying materials are made available under the\n// terms of the Eclipse Public License v. 2.0 which is available at\n// http://www.eclipse.org/legal/epl-2.0.\n//\n// This Source Code may also be made available under the following Secondary\n// Licenses when the conditions for such availability set forth in the Eclipse\n// Public License v. 2.0 are satisfied: GNU General Public License, version 2\n// with the GNU Classpath Exception which is available at\n// https://www.gnu.org/software/classpath/license.html.\n//\n// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n// *****************************************************************************\n\nimport {\n    CancellationError,\n    CancellationToken,\n    CancellationTokenSource,\n    CorePreferences,\n    Disposable,\n    DisposableCollection,\n    Emitter,\n    Event,\n    isOSX,\n    MenuPath,\n    Mutable,\n    notEmpty,\n    PreferenceChange,\n    PreferenceService,\n    Progress,\n    ProgressService,\n    SelectionService,\n    unreachable\n} from '@theia/core';\nimport {\n    animationFrame,\n    codicon,\n    CompositeTreeNode,\n    ContextMenuRenderer,\n    DecoratedTreeNode,\n    defaultTreeProps,\n    ExpandableTreeNode,\n    Key,\n    KeyCode,\n    KeyModifier,\n    LabelProvider,\n    Message,\n    SelectableTreeNode,\n    StatefulWidget,\n    Tree,\n    TreeDecoratorService,\n    TreeModel,\n    TreeNode,\n    TreeProps,\n    TreeSearch,\n    TreeSelection,\n    TreeWidget,\n    UnsafeWidgetUtilities,\n    Widget\n} from '@theia/core/lib/browser';\nimport { SearchBox, SearchBoxFactory, SearchBoxProps as SearchBoxPropsInterface } from '@theia/core/lib/browser/tree/search-box';\nimport { SearchBoxDebounce } from '@theia/core/lib/browser/tree/search-box-debounce';\nimport { TreeFocusService } from '@theia/core/lib/browser/tree/tree-focus-service';\nimport { WidgetDecoration as TreeDecoration } from '@theia/core/lib/browser/widget-decoration';\nimport { Deferred } from '@theia/core/lib/common/promise-util';\nimport { PREFERENCE_NAME_TREE_INDENT } from '@theia/core/lib/common/tree-preference';\nimport { inject, injectable, postConstruct } from '@theia/core/shared/inversify';\nimport debounce from '@theia/core/shared/lodash.debounce';\nimport React, { CSSProperties, useEffect } from '@theia/core/shared/react';\nimport { GetProp, Table, Tooltip } from 'antd';\nimport { ColumnsType, ColumnType } from 'antd/es/table';\nimport {\n    ExpandableConfig,\n    FilterValue,\n    SorterResult,\n    SortOrder,\n    TableCurrentDataSource,\n    TablePaginationConfig\n} from 'antd/es/table/interface';\nimport { classNames as classNamesUtils } from 'primereact/utils';\nimport { AlignType, GetComponentProps, RenderExpandIconProps, ScrollConfig, SpecialString } from 'rc-table/lib/interface';\nimport { type DotPathOf, hasObjectProperty, Iterators, Objects } from '../../common/utils';\nimport { ContextMenuHelper } from '../context-menu-helper';\nimport { waitForElement } from '../core';\nimport { SearchPreferenceHelper } from '../search-preferences';\nimport { SokatoaCachingTreeDecoratorService } from '../widgets';\nimport { SokatoaReactWidget } from '../widgets/sokatoa-base-widget';\nimport { VisibilityGateFactory } from '../widgets/visibility-gate';\nimport { TreeTableContextService } from './tree-table-context-service';\nimport { TreeTableWidgetSelection } from './tree-table-widget-selection';\n\nexport const TREE_TABLE_CLASS = 'sokatoa-TreeTable';\nexport const TREE_CONTAINER_CLASS = 'sokatoa-TreeTableContainer';\nexport const TREE_TABLE_NODE_CLASS = 'sokatoa-TreeTableNode';\nexport const TREE_TABLE_NODE_CONTENT_CLASS = 'sokatoa-TreeTableNodeContent';\nexport const TREE_TABLE_NODE_TAIL_CLASS = 'sokatoa-TreeTableNodeTail';\nexport const TREE_TABLE_NODE_SEGMENT_CLASS = 'sokatoa-TreeTableNodeSegment';\nexport const TREE_TABLE_NODE_SEGMENT_GROW_CLASS = 'sokatoa-TreeTableNodeSegmentGrow';\nexport const TREE_TABLE_NON_HIGHLIGHT = 'sokatoa-non-highlight';\n\nexport const TreeTableProps = Symbol('TreeTableProps');\n\n/**\n * Allows to separate UI updates and model (structure) updates.\n *\n * This is useful when updating the structure is more expensive than rendering.\n * A single update is triggered for the whole subtree.\n */\nexport interface TreeStructureChangeEmitter {\n    readonly onStructureChanged: Event<TreeNode | undefined>;\n}\n\nexport function isTreeStructureChangeEmitter(toCheck: any): toCheck is TreeStructureChangeEmitter {\n    return typeof toCheck === 'object' && 'onStructureChanged' in toCheck;\n}\n\n/**\n * Representation of tree table properties.\n */\nexport type TreeTableProps = Omit<TreeProps, 'virtualized'>;\n\n/**\n * The default tree table properties.\n */\nexport const defaultTreeTableProps: TreeTableProps = {\n    ...defaultTreeProps\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface TreeTableColumnData {}\n\nexport interface TreeTableColumnHeaderProps {\n    title?: string;\n    sortable?: boolean;\n    description?: string;\n    align?: AlignType;\n}\n\nexport interface TreeTableRoot<T extends TreeTableColumnData = any> {\n    children: TreeTableRow<T>[];\n}\n\nexport type TreeTableRowParent<T extends TreeTableColumnData = any> = TreeTableRow<T> | TreeTableRoot<T>;\n\nexport interface TreeTableRow<T extends TreeTableColumnData = any> {\n    /** The identifier of this row. */\n    key: string;\n    /** The Theia tree node on which this row is based. */\n    node: Mutable<TreeNode>;\n    /** The column data associated with this row. */\n    columnData: T;\n    /** The parent node. */\n    parent: TreeTableRowParent<T>;\n    /** The children of this row. The property name must match with the 'expandable.childrenColumnName' in the table rendering. */\n    children?: TreeTableRow<T>[];\n}\n\nexport function isTreeTableRow<T extends TreeTableColumnData = any>(toCheck: any): toCheck is TreeTableRow<T> {\n    return hasObjectProperty<TreeTableRow>(toCheck, 'key', 'node', 'columnData', 'parent');\n}\n\nexport interface LazyTreeTableRow<T extends TreeTableColumnData = any> extends TreeTableRow<T> {\n    isResolved: boolean;\n    isResolving: boolean;\n    onResolved: Event<T>;\n    resolveColumnData(): Promise<T>;\n}\n\nexport namespace LazyTreeTableRow {\n    export function is<T extends TreeTableColumnData = any>(toCheck: any): toCheck is LazyTreeTableRow<T> {\n        return isTreeTableRow(toCheck) && hasObjectProperty<LazyTreeTableRow>(toCheck, 'isResolved', 'resolveColumnData');\n    }\n\n    export function resolve<T extends TreeTableColumnData = any>(toCheck: any): Promise<T> {\n        return is(toCheck) ? toCheck.resolveColumnData() : Promise.resolve(toCheck.columnData);\n    }\n\n    export function isUnresolved<T extends TreeTableColumnData = any>(toCheck: any): toCheck is LazyTreeTableRow<T> {\n        return is(toCheck) && !toCheck.isResolved;\n    }\n\n    export function isResolving<T extends TreeTableColumnData = any>(toCheck: any): toCheck is LazyTreeTableRow<T> {\n        return is(toCheck) && toCheck.isResolving;\n    }\n}\n\nexport interface TreeTableStructuralChange {\n    regenerateTreeTableRows?: boolean;\n    sortTreeTableRows?: boolean;\n    updateExpandedRowKeys?: boolean;\n    updateFilteredRows?: boolean;\n    affectedNodes?: TreeNode[];\n}\n\nexport type TreeTableDataKey<T extends TreeTableColumnData> = DotPathOf<T>;\n\nexport interface TreeTableColumn<D extends TreeTableColumnData, T = TreeTableRow<D>> extends ColumnType<T> {\n    key: 'node' | TreeTableDataKey<D> | string;\n    dataIndex: SpecialString<T> | number | (SpecialString<T> | number)[];\n}\n\nexport interface TreeTableRepresentationModel<T extends TreeTableColumnData = any> {\n    tree: TreeTableRow<T>[];\n    size: number;\n}\n\nexport interface TreeTableRowRepresentationModel<T extends TreeTableColumnData = any> {\n    node: TreeNode;\n    treeRow: TreeTableRow<T>;\n}\n\n/** Properties for the internal tree table view rendering. */\nexport interface TreeTableViewProps<T extends TreeTableColumnData> {\n    // data model\n    rows: TreeTableRow<T>[];\n    columns: ColumnsType<TreeTableRow<T>>;\n\n    // state\n    expandedRowsKeys: React.Key[];\n\n    onToggle(expanded: boolean, data: TreeTableRow<T>): void;\n    getRowClassName(row: TreeTableRow<T>, index?: number): string | undefined;\n    onChange: (\n        pagination: TablePaginationConfig,\n        filters: Record<string, FilterValue | null>,\n        sorter: SorterResult<TreeTableRow<T>> | SorterResult<TreeTableRow<T>>[],\n        extra: TableCurrentDataSource<TreeTableRow<T>>\n    ) => void;\n    showHeader: boolean;\n    onRender(): void;\n\n    scroll?: {\n        x: number | 'max-content' | 'dynamic-content';\n        y: number | 'max-content';\n    };\n    scrollTo?: TreeTableScrollToConfig;\n    onScrollTo?: (scrolledTo: TreeTableScrollToConfig) => void;\n    indentSize?: number;\n    getExpanderDataTestId(row: TreeTableRow<T>): string | undefined;\n    locale?: GetProp<typeof Table, 'locale'>;\n    isExpandable: (candidate: TreeTableRow<T>) => boolean;\n}\n\ninterface TreeTableScrollToConfig extends ScrollConfig {\n    /** number of pixels the scrollbar is moved from the left */\n    left?: number;\n}\n\n/**\n * Enhanced Expand Icon Props\n * @dataTestId string for the data-test-id attribute\n */\nexport interface RenderExpandIconEnhProps<RecordType> extends RenderExpandIconProps<RecordType> {\n    dataTestId: string | undefined;\n}\n\nexport type DropOperation = 'insert-before' | 'insert-after' | 'insert-into';\n\nexport interface Unsorted {\n    type: 'none';\n}\n\nexport type SortMode = 'ascending' | 'descending' | 'none';\n\nexport type ColumnKey = React.Key;\nexport interface SingleColumnSort {\n    type: 'single-column';\n    columnKey: ColumnKey;\n    mode: Exclude<SortMode, 'none'>;\n}\n\nexport type SortDescriptor = Unsorted | SingleColumnSort;\nexport namespace SortDescriptor {\n    export function equals(sort1: SortDescriptor, sort2: SortDescriptor): boolean {\n        if (sort1.type !== sort2.type) {\n            return false;\n        }\n        // Check both to let TypeScript infer the remaining type\n        if (sort1.type === 'none' || sort2.type === 'none') {\n            return true;\n        }\n        return sort2.columnKey === sort1.columnKey && sort2.mode === sort1.mode;\n    }\n}\n\nexport interface RowUpdateConfig {\n    regenerateRowModel?: boolean;\n    sortTreeTableRows?: boolean;\n    updateFilteredRows?: boolean;\n    updateExpandedRowKeys?: boolean;\n    decorationsPotentiallyIncomplete?: boolean;\n}\n\nexport namespace RowUpdateConfig {\n    export function allTrue(...except: Array<keyof RowUpdateConfig>): RowUpdateConfig {\n        const res = {\n            regenerateRowModel: true,\n            sortTreeTableRows: true,\n            updateFilteredRows: true,\n            updateExpandedRowKeys: true,\n            decorationsPotentiallyIncomplete: true\n        };\n        for (const notTrue of except) {\n            res[notTrue] = false;\n        }\n        return res;\n    }\n\n    export function allFalse(...except: Array<keyof RowUpdateConfig>): RowUpdateConfig {\n        const res = {\n            regenerateRowModel: false,\n            sortTreeTableRows: false,\n            updateFilteredRows: false,\n            updateExpandedRowKeys: false,\n            decorationsPotentiallyIncomplete: false\n        };\n        for (const notFalse of except) {\n            res[notFalse] = true;\n        }\n        return res;\n    }\n}\n\nconst MIN_TABLE_SIZE_PX = 10;\n\nconst THEIA_EXPANSION_TOGGLE_CLASS = 'theia-ExpansionToggle';\n\nexport const BASIC_SCROLL_HYSTERESIS_MS = 50;\nexport const EXPANSION_SCROLL_HYSTERESIS_MS = BASIC_SCROLL_HYSTERESIS_MS * 4;\n\ntype UpdateDecorationsParams = TreeNode | TreeNode[];\n\nconst FETCHING_DATA_CLASS = 'fetching-data';\n/**\n * A tree table widget that can be used as an in-place replacement for the Theia tree widget.\n */\n@injectable()\nexport abstract class TreeTableWidget<T extends TreeTableColumnData> extends SokatoaReactWidget implements StatefulWidget {\n    protected searchBox: SearchBox;\n    protected searchHighlights?: Map<string, TreeDecoration.CaptionHighlight>;\n\n    @inject(TreeDecoratorService)\n    protected readonly decoratorService: TreeDecoratorService;\n\n    @inject(Tree)\n    protected readonly tree: Tree;\n\n    @inject(TreeSearch)\n    protected readonly treeSearch: TreeSearch;\n\n    @inject(SearchBoxFactory)\n    protected readonly searchBoxFactory: SearchBoxFactory;\n\n    @inject(TreeFocusService)\n    protected readonly focusService: TreeFocusService;\n\n    protected decorations: Map<string, TreeDecoration.Data[]> = new Map();\n\n    @inject(SelectionService)\n    protected readonly selectionService: SelectionService;\n\n    @inject(PreferenceService)\n    protected readonly preferenceService: PreferenceService;\n\n    @inject(LabelProvider)\n    protected readonly labelProvider: LabelProvider;\n\n    @inject(CorePreferences)\n    protected readonly corePreferences: CorePreferences;\n\n    @inject(ProgressService)\n    protected readonly progressService: ProgressService;\n\n    @inject(TreeTableContextService)\n    protected readonly contextService: TreeTableContextService;\n\n    @inject(SearchPreferenceHelper)\n    protected searchPreferenceHelper: SearchPreferenceHelper;\n\n    @inject(VisibilityGateFactory)\n    protected readonly visibilityGateFactory: VisibilityGateFactory;\n\n    protected readonly contextMenuHelper: ContextMenuHelper;\n\n    protected treeIndent: number;\n    protected shouldCalcScroll = true;\n    protected scroll: NonNullable<TreeTableViewProps<T>['scroll']> = { x: -1, y: -1 };\n    protected focused = false;\n    protected styleChildrenOfSelection = false;\n\n    constructor(\n        @inject(TreeTableProps) readonly props: TreeTableProps,\n        @inject(TreeModel) readonly model: TreeModel,\n        @inject(ContextMenuRenderer)\n        protected readonly contextMenuRenderer: ContextMenuRenderer\n    ) {\n        super();\n        this.contextMenuHelper = ContextMenuHelper.for(contextMenuRenderer);\n        this.scrollOptions = {\n            suppressScrollX: true,\n            minScrollbarLength: 35\n        };\n        this.addClass(TREE_TABLE_CLASS);\n        this.addClass('sokatoa-tree');\n        this.node.tabIndex = 0;\n\n        // add focus listeners to update styling based on focus\n        const focusIn = (): void => {\n            this.focused = true;\n            this.update();\n        };\n        const focusOut = (): void => {\n            this.focused = false;\n            this.update();\n        };\n        this.node.addEventListener('focusin', focusIn);\n        this.node.addEventListener('focusout', focusOut);\n        this.toDispose.pushAll([\n            Disposable.create(() => this.node.removeEventListener('focusin', focusIn)),\n            Disposable.create(() => this.node.removeEventListener('focusout', focusOut))\n        ]);\n    }\n\n    @postConstruct()\n    protected init(): void {\n        this.contextService.init(this.node);\n        this.treeIndent = this.preferenceService.get(PREFERENCE_NAME_TREE_INDENT, this.treeIndent);\n        if (this.props.search) {\n            this.searchBox = this.searchBoxFactory({\n                ...SearchBoxPropsInterface.DEFAULT,\n                showButtons: true,\n                showFilter: true\n            });\n            this.searchBox.node.addEventListener('focus', () => {\n                this.node.focus();\n            });\n            const applyFilter = this.searchPreferenceHelper.debounce(this.doHandleFilterChange.bind(this));\n            this.toDispose.pushAll([\n                this.searchBox,\n                applyFilter,\n                this.searchBox.onTextChange(applyFilter),\n                this.searchBox.onClose(data => this.treeSearch.filter(undefined)),\n                this.searchBox.onNext(() => {\n                    // Enable next selection if there are currently highlights.\n                    if (this.searchHighlights && this.searchHighlights.size > 1) {\n                        this.model.selectNextNode();\n                    }\n                }),\n                this.searchBox.onPrevious(() => {\n                    // Enable previous selection if there are currently highlights.\n                    if (this.searchHighlights && this.searchHighlights.size > 1) {\n                        this.model.selectPrevNode();\n                    }\n                }),\n                this.searchBox.onFilterToggled(e => {\n                    this.updateRows({\n                        regenerateTreeTableRows: true\n                    });\n                }),\n                this.treeSearch,\n                this.treeSearch.onFilteredNodesChanged(nodes => {\n                    if (this.searchBox.isFiltering) {\n                        this.updateRows({\n                            regenerateTreeTableRows: true\n                        });\n                    }\n                    this.updateFilteredNodesSelection(nodes, this.treeSearch);\n                })\n            ]);\n        }\n\n        // as of now no special handling of middle click event as in theia table\n\n        this.toDispose.pushAll([\n            this.model,\n            this.setupOnChangedListener(),\n            this.model.onSelectionChanged(nodes => {\n                if (nodes.length > 0) {\n                    this.scheduleUpdateScrollToRow(nodes[0].id);\n                }\n            }),\n            this.focusService.onDidChangeFocus(node => {\n                if (node !== undefined) {\n                    this.scheduleUpdateScrollToRow(node.id);\n                }\n            }),\n            this.model.onDidChangeBusy(() => this.update()),\n            this.model.onDidUpdate(() => this.update()),\n            this.model.onNodeRefreshed(node => this.doUpdateDecorations(node)),\n            this.model.onExpansionChanged(node => this.doUpdateDecorations(node)),\n            this.decoratorService,\n            this.decoratorService.onDidChangeDecorations(() => this.updateDecorations()),\n            this.labelProvider.onDidChange(e => {\n                for (const row of this.asList()) {\n                    if (e.affects(row.node)) {\n                        this.update();\n                        return;\n                    }\n                }\n            }),\n            this.preferenceService.onPreferenceChanged((event: PreferenceChange) => {\n                if (event.preferenceName === PREFERENCE_NAME_TREE_INDENT) {\n                    this.treeIndent = Number(event.newValue ?? 0);\n                    this.update();\n                }\n            }),\n            this.dragOverExpansion\n        ]);\n        setTimeout(() => {\n            this.updateRows({\n                regenerateTreeTableRows: true\n            });\n            this.updateDecorations();\n        });\n\n        // update selection in tree table framework + styling\n        this.toDispose.push(this.model.onSelectionChanged(() => this.updateSelection()));\n\n        if (this.props.globalSelection) {\n            this.toDispose.pushAll([\n                this.model.onSelectionChanged(() => {\n                    if (this.shouldUpdateGlobalSelection()) {\n                        this.updateGlobalSelection();\n                    }\n                }),\n                this.focusService.onDidChangeFocus(focus => {\n                    if (\n                        focus &&\n                        this.shouldUpdateGlobalSelection() &&\n                        this.model.selectedNodes[0] !== focus &&\n                        this.model.selectedNodes.includes(focus)\n                    ) {\n                        this.updateGlobalSelection();\n                    }\n                }),\n                Disposable.create(() => {\n                    const selection = this.selectionService.selection;\n                    if (TreeTableWidgetSelection.isSource(selection, this)) {\n                        this.selectionService.selection = undefined;\n                    }\n                })\n            ]);\n\n            this.node.addEventListener('focusin', e => {\n                if (\n                    this.model.selectedNodes.length &&\n                    (!this.selectionService.selection || !TreeTableWidgetSelection.isSource(this.selectionService.selection, this))\n                ) {\n                    this.updateGlobalSelection();\n                }\n            });\n        }\n        this.toDispose.push(\n            this.corePreferences.onPreferenceChanged(preference => {\n                if (preference.preferenceName === 'workbench.tree.renderIndentGuides') {\n                    this.update();\n                }\n            })\n        );\n        this.toDispose.push(\n            Disposable.create(() => {\n                // reset internal model on dispose to help with GC\n                this.rowModel.tree.length = 0;\n                this.rows.length = 0;\n                this.expandedRowKeys.length = 0;\n                this.sorter = undefined;\n                this.scrollTo = undefined;\n                this.rowCache.clear();\n            })\n        );\n\n        // Trigger initial scroll constraint calculation after the view is ready.\n        const cancellationToken = new CancellationTokenSource();\n\n        void waitForElement(this.node, '.ant-table-tbody-virtual-holder', cancellationToken.token)\n            .then(() => {\n                this.updateScrollConstraints();\n            })\n            .catch(e => {\n                if (e instanceof CancellationError) {\n                    return;\n                }\n\n                console.error(e);\n            });\n        this.toDispose.push(cancellationToken);\n    }\n\n    protected updateFilteredNodesSelection(newFilteredNodes: readonly Readonly<TreeNode>[], treeSearch: TreeSearch): void {\n        if (\n            this.model.selectedNodes.length > 0 &&\n            (newFilteredNodes.length === 0 || treeSearch.passesFilters(this.model.selectedNodes[0]))\n        ) {\n            // If there is an existing selection and either:\n            // - no filters are applied (i.e. all nodes are shown), or\n            // - the current selection (including its parent nodes) passes the active filters,\n            // then we want to ensure that this selection is visible.\n            // We delay scrolling slightly because the number of shown nodes may grow drastically\n            this.scheduleUpdateScrollToRow(this.model.selectedNodes[0].id, true)?.catch(e => console.error(e));\n        } else {\n            // Otherwise, if the current selection doesn't pass the filters,\n            // select the first node from the filtered list that is selectable\n            // and scroll to it.\n            const node = newFilteredNodes.find(SelectableTreeNode.is);\n            if (node) {\n                this.model.selectNode(node);\n                this.scheduleUpdateScrollToRow(node.id)?.catch(e => console.error(e));\n            }\n        }\n    }\n\n    protected async doHandleFilterChange(data?: string): Promise<void> {\n        await this.treeSearch.filter(data);\n        this.searchHighlights = this.treeSearch.getHighlights();\n        this.searchBox.updateHighlightInfo({\n            filterText: data,\n            total: this.rowModel.size,\n            matched: this.searchHighlights.size\n        });\n        this.update();\n    }\n\n    protected shouldUpdateGlobalSelection(): boolean {\n        return this.node.contains(document.activeElement) || TreeTableWidgetSelection.isSource(this.selectionService.selection, this);\n    }\n\n    protected setupOnChangedListener(): Disposable {\n        if (isTreeStructureChangeEmitter(this.model)) {\n            const structureChange = this.model.onStructureChanged(node => {\n                console.log('JF: TreeTableWidget.onStructureChanged received', { nodeId: node?.id });\n                // FIXME(GH-2093): Performance Issues (don't recreate all rows, support partial update)\n                this.updateRows({\n                    regenerateTreeTableRows: true\n                });\n            });\n            const expansionChange = this.model.onExpansionChanged(() => {\n                console.log('JF: TreeTableWidget.onExpansionChanged received');\n                this.updateRows({\n                    updateExpandedRowKeys: true\n                });\n            });\n            const modelChange = this.model.onChanged(() => {\n                console.log('JF: TreeTableWidget.onChanged received');\n                this.update();\n            });\n            return Disposable.create(() => {\n                structureChange.dispose();\n                expansionChange.dispose();\n                modelChange.dispose();\n            });\n        } else {\n            /* we only have the regular information from Theia -> assume all structure changes */\n            return this.model.onChanged(() => {\n                console.log('JF: TreeTableWidget.onChanged (fallback) received');\n                this.updateRows({\n                    regenerateTreeTableRows: true\n                });\n            });\n        }\n    }\n\n    /**\n     * Update the global selection for the tree.\n     */\n    protected updateGlobalSelection(): void {\n        this.selectionService.selection = TreeTableWidgetSelection.create(this);\n    }\n\n    protected rowModel: TreeTableRepresentationModel<T> = { tree: [], size: 0 };\n    protected rowCache: Map<string, TreeTableRow<T>> = new Map();\n    /** The actually used row model depending on the configuration. */\n    protected rows: TreeTableRow<T>[] = this.rowModel.tree;\n\n    protected asList(): IterableIterator<TreeTableRow<T>> {\n        return Iterators.childrenFromArray(this.rowModel.tree);\n    }\n\n    protected expandedRowKeys: React.Key[] = [];\n    protected sorter?: SorterResult<TreeTableRow<T>> = undefined;\n    protected scrollTo?: TreeTableScrollToConfig;\n\n    private updateRowsCancellation?: CancellationTokenSource;\n    protected updateRows(change: TreeTableStructuralChange = {}): void {\n        console.log('JF: TreeTableWidget.updateRows called', { change });\n        this.doSetUpdateRowsConfig(change);\n        this.updateRowsCancellation?.dispose();\n        const localCancellation = (this.updateRowsCancellation = new CancellationTokenSource());\n        this.debouncedDoUpdateRows(localCancellation.token);\n    }\n\n    protected rowUpdateConfig: RowUpdateConfig = {\n        regenerateRowModel: true,\n        sortTreeTableRows: true,\n        updateFilteredRows: true,\n        updateExpandedRowKeys: true,\n        decorationsPotentiallyIncomplete: true\n    };\n\n    protected doSetUpdateRowsConfig(change: TreeTableStructuralChange = {}): void {\n        const { regenerateTreeTableRows, sortTreeTableRows, updateExpandedRowKeys, updateFilteredRows } = change;\n        // with this method we can tell the update rows method to update certain aspects if true is passed\n        // when false is passed, this does not override/prevent an update requested by a different caller\n        // update rows will reset the config once consumed\n        if (!this.rowUpdateConfig.regenerateRowModel && regenerateTreeTableRows) {\n            // if we have a structural change, everything should be recomputed\n            this.rowUpdateConfig = RowUpdateConfig.allTrue();\n        }\n        this.rowUpdateConfig.sortTreeTableRows ||= sortTreeTableRows;\n        this.rowUpdateConfig.updateExpandedRowKeys ||= updateExpandedRowKeys;\n        this.rowUpdateConfig.updateFilteredRows ||= updateFilteredRows;\n    }\n    protected toDisposeOnUpdateRows = new DisposableCollection();\n    // execute immediately, if further calls within 100ms execute only last one after 100ms\n    protected debouncedDoUpdateRows = debounce(this.doUpdateRows, 100, {\n        leading: true,\n        trailing: true\n    });\n    protected async doUpdateRows(token: CancellationToken): Promise<void> {\n        if (token.isCancellationRequested) {\n            return;\n        }\n        const config = { ...this.rowUpdateConfig };\n        if (config.regenerateRowModel) {\n            const root = this.model.root;\n            const visitedKeys = new Set<string>();\n            const model = CompositeTreeNode.is(root)\n                ? this.createRowModel(root.children, token, { children: [] }, visitedKeys, undefined)\n                : undefined;\n            await this.setRowModel(model, token, visitedKeys);\n        }\n        if (token.isCancellationRequested) {\n            return;\n        }\n        await this.setRows(config);\n        if (token.isCancellationRequested) {\n            return;\n        }\n        this.update();\n        await animationFrame(1);\n        if (token.isCancellationRequested) {\n            return;\n        }\n        this.toDisposeOnUpdateRows.dispose();\n        this.update();\n        if (Objects.partialEqual(config, this.rowUpdateConfig)) {\n            this.rowUpdateConfig = RowUpdateConfig.allFalse();\n        }\n    }\n\n    protected async setRowModel(\n        model: TreeTableRepresentationModel<T> = { tree: [], size: 0 },\n        cancellationToken: CancellationToken,\n        visitedKeys: Set<string>\n    ): Promise<void> {\n        if (cancellationToken.isCancellationRequested) {\n            return;\n        }\n        if (model.size === 0) {\n            this.rowCache.clear();\n        } else if (visitedKeys) {\n            this.pruneRowCache(visitedKeys);\n        }\n        this.rowModel = model;\n    }\n\n    protected async setRows(config: RowUpdateConfig): Promise<void> {\n        if (config.sortTreeTableRows) {\n            // if we have sorting enabled, we need to use the sorted list\n            if (this.requiresSorting()) {\n                // the decorations may rely on the tree node structure for lazy initialization\n                // on sort we are using a flat list of all the tree nodes though\n                // make sure the decorations are fully initialized\n                if (config.decorationsPotentiallyIncomplete) {\n                    this.doUpdateDecorations(Array.from(this.asList()).map(row => row.node)).catch(e => console.error(e));\n                }\n                this.rows = this.rowModel.tree;\n                await this.sort();\n            }\n        }\n        if (config.updateFilteredRows) {\n            if (this.shouldResolveLazyTreeNodesOnFilter()) {\n                await this.resolveLazyTreeNodes();\n            }\n            this.rows = this.filterRows();\n        }\n        if (config.updateExpandedRowKeys) {\n            this.expandedRowKeys = Array.from(\n                Iterators.filter(this.asList(), row => ExpandableTreeNode.isExpanded(row.node)),\n                row => row.key\n            );\n        }\n    }\n\n    protected filterRows(): TreeTableRow<T>[] {\n        // no op by default\n        return this.rowModel.tree;\n    }\n\n    requiresSorting(): boolean {\n        return !!this.sorter?.order && !!this.sorter.columnKey;\n    }\n\n    protected onScrollTo = (scrolledTo: TreeTableScrollToConfig): void => {\n        // Clear only if execution and current request are identical.\n        if (\n            this.scrollTo &&\n            scrolledTo.index === this.scrollTo.index &&\n            scrolledTo.key === this.scrollTo.key &&\n            scrolledTo.top === this.scrollTo.top &&\n            scrolledTo.left === this.scrollTo.left\n        ) {\n            this.scrollTo = undefined;\n        }\n    };\n\n    protected shouldResolveLazyTreeNodesOnFilter(): boolean {\n        return false;\n    }\n\n    protected getUnresolvedData(rows: Iterable<TreeTableRow<T>>): Promise<T>[] {\n        return Array.from(Iterators.filter(rows, LazyTreeTableRow.isUnresolved<T>), row => row.resolveColumnData());\n    }\n\n    protected async showProgressWhileResolving(sorting: boolean): Promise<Progress> {\n        return this.progressService.showProgress({\n            text: sorting ? 'Fetching data to sort...' : 'Fetching data...',\n            options: { cancelable: false, location: 'notification' }\n        });\n    }\n\n    protected async resolveLazyTreeNodes(): Promise<void> {\n        let fetchingDataAdded = false;\n        let rows = this.rowModel.tree.slice();\n        let progress: Progress | undefined = undefined;\n        const startTime = Date.now();\n\n        try {\n            while (rows.length > 0) {\n                const unresolvedData = this.getUnresolvedData(rows);\n                if (unresolvedData.length > 0) {\n                    if (!fetchingDataAdded) {\n                        this.node.classList.add(FETCHING_DATA_CLASS);\n                        fetchingDataAdded = true;\n                    }\n\n                    await Promise.all(unresolvedData);\n\n                    // also show progress if resolution seems to be taking longer\n                    if (progress === undefined && Date.now() - startTime > 200) {\n                        progress = await this.showProgressWhileResolving(false);\n                    }\n                }\n\n                const newRows: TreeTableRow<T>[] = [];\n                for (const row of rows) {\n                    if (row.children && row.children.length > 0) {\n                        newRows.push(...row.children);\n                    }\n                }\n                rows = newRows;\n            }\n        } finally {\n            this.node.classList.remove(FETCHING_DATA_CLASS);\n            progress?.cancel();\n        }\n    }\n\n    protected requestId = 0;\n    protected currentSortOperationId: number | undefined;\n    protected currentSortOperationProgress: Promise<Progress> | undefined;\n    protected async sort(): Promise<void> {\n        const sortOperationId = this.requestId++;\n        this.currentSortOperationId = sortOperationId;\n\n        // get all data before updating rows so that sorting will work\n        const unresolvedData = this.getUnresolvedData(this.asList());\n        const cancelProgress = (): void => {\n            if (this.currentSortOperationProgress !== undefined) {\n                this.currentSortOperationProgress.then(progress => progress.cancel()).catch(e => console.error(e));\n                this.currentSortOperationProgress = undefined;\n            }\n        };\n        if (unresolvedData.length > 0) {\n            this.node.classList.add(FETCHING_DATA_CLASS);\n            if (this.currentSortOperationProgress === undefined) {\n                this.currentSortOperationProgress = this.showProgressWhileResolving(true);\n                this.toDispose.push(Disposable.create(cancelProgress));\n            }\n            try {\n                await Promise.all(unresolvedData);\n            } catch (e) {\n                console.error(e);\n            }\n        }\n        if (this.currentSortOperationId === sortOperationId) {\n            cancelProgress();\n            this.node.classList.remove('fetching-data');\n            this.sortRecursively(this.rowModel.tree);\n            this.currentSortOperationId = undefined;\n        }\n    }\n\n    protected sortRecursively(siblings: TreeTableRow<T>[]): void {\n        siblings.sort((l, r) => this.sortRows(l, r));\n        siblings.forEach(current => {\n            if (Array.isArray(current.children)) {\n                this.sortRecursively(current.children);\n            }\n        });\n    }\n\n    get sortDescriptor(): SortDescriptor {\n        if (!this.sorter?.columnKey) {\n            return { type: 'none' };\n        }\n\n        const mode = this.sorter.order === 'descend' ? 'descending' : 'ascending';\n        return {\n            type: 'single-column',\n            columnKey: this.sorter.columnKey,\n            mode\n        };\n    }\n\n    set sortDescriptor(sortDescriptor: SortDescriptor) {\n        const sortColumnKey = this.sorter?.columnKey;\n        const sortOrder = this.sorter?.order;\n        const sortColumn = sortColumnKey && sortOrder ? this.getColumns().find(column => column.key === sortColumnKey) : undefined;\n\n        const updateForSortChange = (): void => {\n            this.update();\n            this.updateRowsToSort().catch(e => console.error(e));\n        };\n\n        switch (sortDescriptor.type) {\n            case 'none':\n                if (sortColumn) {\n                    sortColumn.sortOrder = undefined;\n                    this.sorter = undefined;\n                }\n                updateForSortChange();\n                break;\n            case 'single-column': {\n                const newSortOrder = sortDescriptor.mode === 'descending' ? 'descend' : 'ascend';\n                if (sortColumn?.key === sortDescriptor.columnKey && sortColumn?.sortOrder === newSortOrder) {\n                    // No change\n                    return;\n                }\n\n                if (sortColumn) {\n                    sortColumn.sortOrder = undefined;\n                }\n\n                const newSortColumn = this.getColumns().find(column => column.key === sortDescriptor.columnKey);\n                if (newSortColumn && newSortColumn.sorter) {\n                    newSortColumn.sortOrder = newSortOrder;\n                    this.sorter = {\n                        column: newSortColumn,\n                        columnKey: sortDescriptor.columnKey,\n                        order: newSortOrder\n                    };\n                }\n                updateForSortChange();\n                break;\n            }\n            default:\n                unreachable(sortDescriptor);\n        }\n    }\n\n    /**\n     * Transforms the Theia TreeModel into a TreeTableModel.\n     */\n    protected createRowModel(\n        nodes: readonly TreeNode[],\n        cancellationToken: CancellationToken,\n        treeParent: TreeTableRowParent<T> = { children: [] },\n        visitedKeys: Set<string>,\n        props?: any\n    ): TreeTableRepresentationModel<T> {\n        const tree: TreeTableRow<T>[] = [];\n        let size = 0;\n        for (const node of nodes) {\n            if (cancellationToken.isCancellationRequested) {\n                return { tree, size };\n            }\n            if (!this.shouldDisplayNode(node)) {\n                continue;\n            }\n            visitedKeys.add(node.id);\n            const row = this.toRow(node, treeParent, props);\n            tree.push(row.treeRow);\n            size++;\n\n            if (CompositeTreeNode.is(node)) {\n                const subModel = this.createRowModel(node.children, cancellationToken, row.treeRow, visitedKeys, props);\n                row.treeRow.children = subModel.tree;\n                size += subModel.size;\n            }\n        }\n        return { tree, size };\n    }\n\n    protected toRow(node: TreeNode, treeParent: TreeTableRowParent<T>, props?: any): TreeTableRowRepresentationModel<T> {\n        const cachedRow = this.rowCache.get(node.id);\n\n        if (cachedRow && cachedRow.node === node) {\n            cachedRow.parent = treeParent;\n            cachedRow.children = undefined;\n            treeParent.children?.push(cachedRow);\n            return { node, treeRow: cachedRow };\n        }\n\n        const columnData = this.getColumnData(node);\n        const treeRow: TreeTableRow<T> = {\n            key: node.id,\n            node,\n            columnData,\n            parent: treeParent\n        };\n        treeParent.children?.push(treeRow);\n\n        this.rowCache.set(node.id, treeRow);\n\n        const model = { node, treeRow };\n        return this.decorateLazyRow(model);\n    }\n\n    protected pruneRowCache(visitedKeys: Set<string>): void {\n        if (this.rowCache.size === 0) {\n            return;\n        }\n        for (const cachedKey of this.rowCache.keys()) {\n            if (!visitedKeys.has(cachedKey)) {\n                this.rowCache.delete(cachedKey);\n            }\n        }\n    }\n\n    protected isLazyNode(node: TreeNode): boolean {\n        return false;\n    }\n\n    protected decorateLazyRow(model: TreeTableRowRepresentationModel<T>): TreeTableRowRepresentationModel<T> {\n        return !this.isLazyNode(model.node) || LazyTreeTableRow.is(model.treeRow) ? model : this.doDecorateLazyRow(model);\n    }\n\n    protected doDecorateLazyRow(model: TreeTableRowRepresentationModel<T>): TreeTableRowRepresentationModel<T> {\n        const listAndTreeRow = [model.treeRow as LazyTreeTableRow<T>];\n\n        // decorate the row with lazy loading capabilities\n        const resolution = new Deferred<T>();\n        const onResolvedEmitter = new Emitter<T>();\n        const resolveColumnData = async (): Promise<T> => {\n            // only resolve data once\n            if (listAndTreeRow.every(row => !row.isResolving && !row.isResolved)) {\n                listAndTreeRow.forEach(row => (row.isResolving = true));\n                this.resolveColumnData(model.node).then(data => {\n                    listAndTreeRow.forEach(row => {\n                        row.isResolving = false;\n                        row.columnData = data;\n                        row.isResolved = true;\n                        onResolvedEmitter.fire(data);\n                    });\n                    resolution.resolve(data);\n                }, resolution.reject);\n            }\n            return resolution.promise;\n        };\n        listAndTreeRow.forEach(row => {\n            row.isResolving = false;\n            row.isResolved = false;\n            row.onResolved = onResolvedEmitter.event;\n            row.resolveColumnData = resolveColumnData;\n        });\n        return model;\n    }\n\n    protected shouldDisplayNode(node: TreeNode): boolean {\n        return TreeNode.isVisible(node) && !this.isNodeFiltered(node);\n    }\n\n    protected isNodeFiltered(node: TreeNode): boolean {\n        return this.isFiltering && !this.treeSearch.passesFilters(node);\n    }\n\n    /**\n     * Schedules scrolling to a node and prepares the Tree accordingly (e.g. expanding parents)\n     *\n     * @param id the node's id to scroll to\n     * @param delayedScroll whether scrolling should be delayed. This might be required after expensive\n     *                      updates to give the ui time to render all nodes\n     * @returns\n     */\n    protected async scrollToNode(id: string, delayedScroll = false): Promise<void> {\n        const node = this.model.getNode(id);\n\n        if (node === undefined) {\n            return;\n        }\n\n        // expand all parents\n        let expandRequired = false;\n        let parent = node.parent;\n        while (parent !== undefined) {\n            if (ExpandableTreeNode.is(parent) && !parent.expanded) {\n                expandRequired = true;\n                await this.model.toggleNodeExpansion(parent);\n            }\n            parent = parent.parent;\n        }\n\n        if (expandRequired || delayedScroll) {\n            // give extra time to expand before scrolling\n            this.updateScrollToOnExpand({ key: id });\n        } else {\n            // we are using virtual rendering, give some time before scrolling\n            // usually this is only needed with rapid keyboard navigation\n            this.updateScrollToRegular({ key: id });\n        }\n    }\n    scheduleUpdateScrollToRow = debounce(this.scrollToNode);\n    protected updateScrollToOnExpand = debounce(this.updateScrollTo, EXPANSION_SCROLL_HYSTERESIS_MS);\n    protected updateScrollToRegular = debounce(this.updateScrollTo, BASIC_SCROLL_HYSTERESIS_MS);\n    protected async updateScrollTo(opts: TreeTableScrollToConfig): Promise<void> {\n        this.scrollTo = opts;\n        this.update();\n        await animationFrame(1);\n        this.update();\n    }\n\n    /**\n     * Update tree decorations.\n     * - Updating decorations are debounced in order to limit the number of expensive updates.\n     */\n    protected readonly updateDecorations = debounce((nodes?: UpdateDecorationsParams) => this.doUpdateDecorations(nodes), 150);\n    protected async doUpdateDecorations(nodes?: UpdateDecorationsParams): Promise<void> {\n        const treeNodes = Array.isArray(nodes) ? nodes : [nodes];\n        // Use the cached decorations if available\n        if (SokatoaCachingTreeDecoratorService.is(this.decoratorService)) {\n            // Initialize the decorations if not already done\n            if (!this.decoratorService.hasCachedDecorations(this.id) || treeNodes[0] === undefined) {\n                this.decorations = await this.decoratorService.cacheDecorations(this.id, this.model);\n            } else {\n                // Refresh the decorations for the given node\n                this.decorations = await this.decoratorService.refreshDecorationCache(this.id, treeNodes as TreeNode[]);\n            }\n        } else {\n            this.decorations = await this.decoratorService.getDecorations(this.model);\n        }\n        this.update();\n    }\n\n    protected override onActivateRequest(msg: Message): void {\n        super.onActivateRequest(msg);\n        this.node.focus({ preventScroll: true });\n    }\n\n    /**\n     * Actually focus the tree node.\n     */\n    protected doFocus(): void {\n        if (!this.model.selectedNodes.length) {\n            const node = this.getNodeToFocus();\n            if (SelectableTreeNode.is(node)) {\n                this.model.selectNode(node);\n            }\n        }\n    }\n\n    /**\n     * Get the tree node to focus.\n     *\n     * @returns the node to focus if available.\n     */\n    protected getNodeToFocus(): SelectableTreeNode | undefined {\n        const { focusedNode } = this.focusService;\n        if (focusedNode) {\n            return focusedNode;\n        }\n        const { root } = this.model;\n        if (SelectableTreeNode.isVisible(root)) {\n            return root;\n        }\n        return this.model.getNextSelectableNode(root);\n    }\n\n    protected override onUpdateRequest(msg: Message): void {\n        if (!this.isAttached) {\n            return;\n        }\n        // This doesn't create a new visibility gate every time because it's a cached singleton\n        const visibilityGate = this.visibilityGateFactory(this);\n        visibilityGate.doWhenVisible('update', () => super.onUpdateRequest(msg));\n    }\n\n    protected get isFiltering(): boolean {\n        return this.searchBox?.isFiltering === true;\n    }\n\n    protected override onResize(msg: Widget.ResizeMessage): void {\n        super.onResize(msg);\n        // re-calculate table size\n        this.updateScrollConstraints();\n    }\n\n    updateScrollConstraints(): void {\n        this.shouldCalcScroll = true;\n        this.update();\n    }\n\n    protected override render(): React.ReactNode {\n        return React.createElement('div', this.createContainerAttributes(), this.renderTreeTable(this.model));\n    }\n\n    /**\n     * Create the container attributes for the widget.\n     */\n    protected createContainerAttributes(): React.HTMLAttributes<HTMLElement> {\n        const classNames = [TREE_CONTAINER_CLASS];\n        if (!this.rowModel.size) {\n            classNames.push('empty');\n        }\n        if (this.model.selectedNodes.length === 0 && !this.focusService.focusedNode) {\n            classNames.push('focused');\n        }\n        return {\n            className: classNames.join(' '),\n            onContextMenu: event => this.handleContextMenuEvent(this.getContainerTreeNode(), event),\n            onDragEnter: event => this.handleDragEnterEvent(this.model.root, event),\n            onDragOver: event => this.handleDragOverEvent(this.model.root, event),\n            onDragLeave: event => this.handleDragLeaveEvent(this.model.root, event),\n            onDrop: event => void this.handleDropEvent(this.model.root, event)\n        };\n    }\n    /**\n     * Get the container tree node.\n     *\n     * @returns the tree node for the container if available.\n     */\n    protected getContainerTreeNode(): TreeNode | undefined {\n        return this.model.root;\n    }\n\n    protected renderTreeTable(model: TreeModel): React.ReactNode {\n        if (this.isTreeModelEmpty(model)) {\n            return this.renderEmptyTreeTable();\n        }\n\n        if (this.shouldCalcScroll) {\n            this.shouldCalcScroll = false;\n            let contentRect: DOMRect | undefined = undefined;\n            if (this.showHeader()) {\n                contentRect = getTreeTableBodyBounds(this.node);\n            } else {\n                contentRect = getTreeTableContainerBounds(this.node);\n            }\n\n            if (!contentRect || contentRect.width <= MIN_TABLE_SIZE_PX || contentRect.height <= MIN_TABLE_SIZE_PX) {\n                contentRect = this.node.getBoundingClientRect();\n            }\n\n            this.scroll = this.calculateScroll(contentRect);\n        }\n\n        const renderEmpty: () => React.ReactNode = () => {\n            if (this.isFiltering && this.treeSearch?.filteredNodes?.length === 0) {\n                return this.renderEmptySearchResult();\n            }\n            return this.renderEmptyTreeTable();\n        };\n\n        return (\n            <this.TreeTableView\n                rows={this.rows}\n                expandedRowsKeys={this.expandedRowKeys}\n                scroll={this.getTableScroll()}\n                scrollTo={this.scrollTo}\n                onScrollTo={this.onScrollTo}\n                columns={this.getColumns()}\n                onToggle={this.doToggle.bind(this)}\n                getRowClassName={this.getRowClassName.bind(this)}\n                onChange={this.onChange.bind(this)}\n                onRender={this.onTableRender.bind(this)}\n                showHeader={this.showHeader()}\n                indentSize={this.treeIndent}\n                getExpanderDataTestId={this.getDataTestId.bind(this)}\n                locale={{ emptyText: renderEmpty }}\n                isExpandable={this.isRowExpandable.bind(this)}\n            />\n        );\n    }\n\n    protected calculateScroll(contentRect: DOMRect): NonNullable<TreeTableViewProps<T>['scroll']> {\n        const scroll = { ...this.scroll };\n\n        if (typeof scroll.x === 'number' && (contentRect.width > 0 || scroll.x <= MIN_TABLE_SIZE_PX)) {\n            // We have a new size calculation or we have never had and still have no size\n            scroll.x = Math.max(contentRect.width, MIN_TABLE_SIZE_PX);\n        }\n\n        if (typeof scroll.y === 'number' && (contentRect.height > 0 || scroll.y <= MIN_TABLE_SIZE_PX)) {\n            // We have a new size calculation or we have never had and still have no size\n            scroll.y = Math.max(contentRect.height, MIN_TABLE_SIZE_PX);\n        }\n\n        return scroll;\n    }\n\n    protected isTreeModelEmpty(model: TreeModel): boolean {\n        return !model.root || (CompositeTreeNode.is(model.root) && model.root.children.length === 0);\n    }\n\n    protected getTableScroll(): TreeTableViewProps<T>['scroll'] {\n        return this.scroll;\n    }\n\n    protected renderEmptyTreeTable(): React.ReactNode {\n        return (\n            <div className='theia-widget-noInfo'>\n                {this.renderEmptyTreeTableLoader()}\n                <div>No data available</div>\n            </div>\n        );\n    }\n\n    protected renderEmptySearchResult(): React.ReactNode {\n        return (\n            <div className='theia-widget-noInfo'>\n                <div>No rows match filter</div>\n            </div>\n        );\n    }\n\n    protected renderEmptyTreeTableLoader(): React.ReactNode {\n        return (\n            <div>\n                <span className={'codicon codicon-loading theia-animation-spin   mr-2'}></span>\n                Loading\n            </div>\n        );\n    }\n\n    // no scroll to selected yet\n\n    /**\n     * Render the tree node given the node properties.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected renderIcon(node: TreeNode, props?: any): React.ReactNode {\n        return undefined;\n    }\n\n    /**\n     * Actually toggle the tree node.\n     * @param expanded the expanded state\n     * @param data the toggled data\n     */\n    protected doToggle(expanded: boolean, data: TreeTableRow<T>): void {\n        const node = this.model.getNode(data.key);\n        if (node !== undefined && ExpandableTreeNode.is(node) && node.expanded !== expanded) {\n            this.model.toggleNodeExpansion(node).catch(e => console.error(e));\n        }\n    }\n\n    /**\n     * Render the tree node caption given the node properties.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected renderCaption(node: TreeNode, props?: any): React.ReactNode {\n        const attrs = this.getCaptionAttributes(node, props);\n        const children = this.getCaptionChildren(node, props);\n        return React.createElement('div', attrs, children);\n    }\n\n    protected getCaptionAttributes(node: TreeNode, props?: any): React.Attributes & React.HTMLAttributes<HTMLElement> {\n        const tooltip = this.getDecorationData(node, 'tooltip').filter(notEmpty).join('  ');\n        const classes = [TREE_TABLE_NODE_SEGMENT_CLASS];\n        if (!this.hasTrailingSuffixes(node)) {\n            classes.push(TREE_TABLE_NODE_SEGMENT_GROW_CLASS);\n        }\n        const className = classes.join(' ');\n        const attrs = this.decorateCaption(node, {\n            className,\n            id: `${TREE_TABLE_CLASS}-${node.id}`\n        });\n        if (tooltip.length > 0) {\n            attrs.title = tooltip;\n        }\n        return attrs;\n    }\n\n    protected getCaptionChildren(node: TreeNode, props?: any): React.ReactNode {\n        const children = [];\n        const caption = this.toNodeName(node);\n        const highlight = this.getDecorationData(node, 'highlight')[0];\n        if (highlight) {\n            children.push(this.toReactNode(caption, highlight));\n        }\n        const searchHighlight = this.searchHighlights?.get(node.id);\n        if (searchHighlight) {\n            children.push(...this.toReactNode(caption, searchHighlight));\n        } else if (!highlight) {\n            children.push(caption);\n        }\n        return children;\n    }\n\n    /**\n     * Update the node given the caption and highlight.\n     * @param caption the caption.\n     * @param highlight the tree decoration caption highlight.\n     */\n    protected toReactNode(caption: string, highlight: TreeDecoration.CaptionHighlight): React.ReactNode[] {\n        let style: React.CSSProperties = {};\n        if (highlight.color) {\n            style = {\n                ...style,\n                color: highlight.color\n            };\n        }\n        if (highlight.backgroundColor) {\n            style = {\n                ...style,\n                backgroundColor: highlight.backgroundColor\n            };\n        }\n        const createChildren = (fragment: TreeDecoration.CaptionHighlight.Fragment, index: number): React.ReactNode => {\n            const { data } = fragment;\n            if (fragment.highlight) {\n                return (\n                    <mark className={TreeDecoration.Styles.CAPTION_HIGHLIGHT_CLASS} style={style} key={index}>\n                        {data}\n                    </mark>\n                );\n            } else {\n                return data;\n            }\n        };\n        return TreeDecoration.CaptionHighlight.split(caption, highlight).map(createChildren);\n    }\n\n    /**\n     * Decorate the tree caption.\n     * @param node the tree node.\n     * @param attrs the additional attributes.\n     */\n    protected decorateCaption(\n        node: TreeNode,\n        attrs: React.HTMLAttributes<HTMLElement>\n    ): React.Attributes & React.HTMLAttributes<HTMLElement> {\n        const style = this.getDecorationData(node, 'fontData')\n            .filter(notEmpty)\n            .reverse()\n            .map(fontData => this.applyFontStyles({}, fontData))\n            .reduce(\n                (acc, current) => ({\n                    ...acc,\n                    ...current\n                }),\n                {}\n            );\n        return {\n            ...attrs,\n            style\n        };\n    }\n\n    /**\n     * Determine if the tree node contains trailing suffixes.\n     * @param node the tree node.\n     *\n     * @returns `true` if the tree node contains trailing suffices.\n     */\n    protected hasTrailingSuffixes(node: TreeNode): boolean {\n        return (\n            this.getDecorationData(node, 'captionSuffixes')\n                .filter(notEmpty)\n                .reduce((acc, current) => acc.concat(current), []).length > 0\n        );\n    }\n\n    /**\n     * Apply font styles to the tree.\n     * @param original the original css properties.\n     * @param fontData the optional `fontData`.\n     */\n    protected applyFontStyles(original: React.CSSProperties, fontData: TreeDecoration.FontData | undefined): React.CSSProperties {\n        if (fontData === undefined) {\n            return original;\n        }\n        const modified = { ...original }; // make a copy to mutate\n        const { color, style } = fontData;\n        if (color) {\n            modified.color = color;\n        }\n        if (style) {\n            (Array.isArray(style) ? style : [style]).forEach(s => {\n                switch (s) {\n                    case 'bold':\n                        modified.fontWeight = s;\n                        break;\n                    case 'normal':\n                    case 'oblique':\n                    case 'italic':\n                        modified.fontStyle = s;\n                        break;\n                    case 'underline':\n                    case 'line-through':\n                        modified.textDecoration = s;\n                        break;\n                    default:\n                        throw new Error(`Unexpected font style: \"${s}\".`);\n                }\n            });\n        }\n        return modified;\n    }\n\n    /**\n     * Render caption affixes for the given tree node.\n     * @param node the tree node.\n     * @param props the node properties.\n     * @param affixKey the affix key.\n     */\n    protected renderCaptionAffixes(\n        node: TreeNode,\n        props: any | undefined,\n        affixKey: 'captionPrefixes' | 'captionSuffixes'\n    ): React.ReactNode {\n        const suffix = affixKey === 'captionSuffixes';\n        const affixClass = suffix ? TreeDecoration.Styles.CAPTION_SUFFIX_CLASS : TreeDecoration.Styles.CAPTION_PREFIX_CLASS;\n        const classes = [TREE_TABLE_NODE_SEGMENT_CLASS, affixClass];\n        const affixes = this.getDecorationData(node, affixKey)\n            .filter(notEmpty)\n            .reduce((acc, current) => acc.concat(current), []);\n        const children: React.ReactNode[] = [];\n        for (let i = 0; i < affixes.length; i++) {\n            const affix = affixes[i];\n            if (suffix && i === affixes.length - 1) {\n                classes.push(TREE_TABLE_NODE_SEGMENT_GROW_CLASS);\n            }\n            const style = this.applyFontStyles({}, affix.fontData);\n            const className = classes.join(' ');\n            const key = node.id + '_' + i;\n            const attrs = {\n                className,\n                style,\n                key\n            };\n            children.push(React.createElement('div', attrs, affix.data));\n        }\n        return <React.Fragment>{children}</React.Fragment>;\n    }\n\n    /**\n     * Render the node expansion toggle.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected renderCheckbox(node: TreeNode, props?: any): React.ReactNode {\n        if (node.checkboxInfo === undefined) {\n            // eslint-disable-next-line no-null/no-null\n            return null;\n        }\n        return (\n            <input\n                data-node-id={node.id}\n                readOnly\n                type='checkbox'\n                checked={!!node.checkboxInfo.checked}\n                title={node.checkboxInfo.tooltip}\n                aria-label={node.checkboxInfo.accessibilityInformation?.label}\n                role={node.checkboxInfo.accessibilityInformation?.role}\n                className='theia-input'\n                onClick={event => this.toggleChecked(event)}\n            />\n        );\n    }\n\n    protected toggleChecked(event: React.MouseEvent<HTMLElement>): void {\n        const nodeId = event.currentTarget.getAttribute('data-node-id');\n        if (nodeId) {\n            const node = this.model.getNode(nodeId);\n            if (node) {\n                this.model.markAsChecked(node, !node.checkboxInfo!.checked);\n            } else {\n                this.handleClickEvent(node, event);\n            }\n        }\n        event.stopPropagation();\n    }\n\n    /**\n     * Decorate the tree node icon.\n     * @param node the tree node.\n     * @param icon the icon.\n     */\n    protected decorateIcon(node: TreeNode, icon: React.ReactNode): React.ReactNode {\n        if (!icon) {\n            return;\n        }\n        const overlayIcons: React.ReactNode[] = [];\n        // if multiple overlays have the same overlay.position attribute,\n        // we'll de-duplicate those and only process the first one from the decoration array\n        const seenPositions = new Set<TreeDecoration.IconOverlayPosition>();\n        const overlays = this.getDecorationData(node, 'iconOverlay').filter(notEmpty);\n\n        for (const overlay of overlays) {\n            if (!seenPositions.has(overlay.position)) {\n                seenPositions.add(overlay.position);\n                const iconClasses = [\n                    TreeDecoration.Styles.DECORATOR_SIZE_CLASS,\n                    TreeDecoration.IconOverlayPosition.getStyle(overlay.position)\n                ];\n                const style = (color?: string): CSSProperties | undefined => (color === undefined ? {} : { color });\n\n                if (overlay.background) {\n                    overlayIcons.push(\n                        <span\n                            key={node.id + 'bg'}\n                            className={this.getIconClass(overlay.background.shape, iconClasses)}\n                            style={style(overlay.background.color)}\n                        ></span>\n                    );\n                }\n\n                const overlayIcon = 'icon' in overlay ? overlay.icon : overlay.iconClass;\n                overlayIcons.push(\n                    <span key={node.id} className={this.getIconClass(overlayIcon, iconClasses)} style={style(overlay.color)}></span>\n                );\n            }\n        }\n\n        if (overlayIcons.length > 0) {\n            return (\n                <div className={TreeDecoration.Styles.ICON_WRAPPER_CLASS}>\n                    {icon}\n                    {overlayIcons}\n                </div>\n            );\n        }\n\n        return icon;\n    }\n\n    /**\n     * Render the tree node tail decorations.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected renderTailDecorations(node: TreeNode, props?: any): React.ReactNode {\n        const tailDecorations = this.getDecorationData(node, 'tailDecorations').reduce((acc, current) => acc.concat(current), []);\n        if (tailDecorations.length === 0) {\n            return;\n        }\n        return this.renderTailDecorationsForNode(node, props, tailDecorations);\n    }\n\n    protected renderTailDecorationsForNode(\n        node: TreeNode,\n        props: any | undefined,\n        tailDecorations: TreeDecoration.TailDecoration.AnyPartial[]\n    ): React.ReactNode {\n        let dotDecoration: TreeDecoration.TailDecoration.AnyPartial | undefined;\n        const otherDecorations: TreeDecoration.TailDecoration.AnyPartial[] = [];\n        tailDecorations.reverse().forEach(decoration => {\n            if (TreeDecoration.TailDecoration.isDotDecoration(decoration)) {\n                dotDecoration ||= decoration;\n            } else if (decoration.data || decoration.icon || decoration.iconClass) {\n                otherDecorations.push(decoration);\n            }\n        });\n        const decorationsToRender = dotDecoration ? [dotDecoration, ...otherDecorations] : otherDecorations;\n        return (\n            <React.Fragment>\n                {decorationsToRender.map((decoration, index) => {\n                    const { tooltip, data, fontData, color, icon, iconClass } = decoration;\n                    const iconToRender = icon ?? iconClass;\n                    const className = [TREE_TABLE_NODE_SEGMENT_CLASS, TREE_TABLE_NODE_TAIL_CLASS, 'flex'].join(' ');\n                    const style = fontData ? this.applyFontStyles({}, fontData) : color ? { color } : undefined;\n                    const content = data ? (\n                        data\n                    ) : iconToRender ? (\n                        <span\n                            key={node.id + 'icon' + index}\n                            className={this.getIconClass(\n                                iconToRender,\n                                iconToRender === 'circle' ? [TreeDecoration.Styles.DECORATOR_SIZE_CLASS] : []\n                            )}\n                        ></span>\n                    ) : (\n                        ''\n                    );\n                    return (\n                        <div key={node.id + className + index} className={className} style={style} title={tooltip}>\n                            {content}\n                            {index !== decorationsToRender.length - 1 ? ',' : ''}\n                        </div>\n                    );\n                })}\n            </React.Fragment>\n        );\n    }\n\n    protected renderTailCommands(_node: TreeNode, _props?: any): React.ReactNode {\n        return undefined;\n    }\n\n    /**\n     * Determine the classes to use for an icon\n     * - Assumes a Font Awesome name when passed a single string, otherwise uses the passed string array\n     * @param iconName the icon name or list of icon names.\n     * @param additionalClasses additional CSS classes.\n     *\n     * @returns the icon class name.\n     */\n    protected getIconClass(iconName: string | string[], additionalClasses: string[] = []): string {\n        const iconClass = typeof iconName === 'string' ? ['a', 'fa', `fa-${iconName}`] : ['a'].concat(iconName);\n        return iconClass.concat(additionalClasses).join(' ');\n    }\n\n    protected renderNode(node: TreeNode, props?: any): React.ReactNode {\n        const attributes = this.createNodeAttributes(node);\n        const content = (\n            <div className={this.getNodeContentClasses(node).join(' ')}>\n                {this.renderCheckbox(node, props)}\n                {this.decorateIcon(node, this.renderIcon(node, props))}\n                {this.renderCaptionAffixes(node, props, 'captionPrefixes')}\n                {this.renderCaption(node, props)}\n                {this.renderCaptionAffixes(node, props, 'captionSuffixes')}\n                {this.renderTailDecorations(node, props)}\n            </div>\n        );\n        return React.createElement('div', attributes, content);\n    }\n\n    protected getNodeContentClasses(_node: TreeNode): string[] {\n        return [TREE_TABLE_NODE_CONTENT_CLASS, TREE_TABLE_NODE_SEGMENT_GROW_CLASS];\n    }\n\n    /**\n     * Render the row given the tree node and node properties.\n     * @param row the tree row.\n     * @param props the node properties.\n     */\n    protected renderNodeColumn(row: TreeTableRow<T>, props?: any): React.ReactNode {\n        if (this.isRenaming(row.key)) {\n            return this.renderRename(row, props);\n        } else {\n            return this.renderNode(row.node, props);\n        }\n    }\n\n    /**\n     * Create node attributes for the tree node given the node properties.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected createNodeAttributes(node: TreeNode, props?: any): React.Attributes & React.HTMLAttributes<HTMLElement> {\n        return { className: this.createNodeClassNames(node, props).join(' ') };\n    }\n\n    protected getNodeDragHandlers(node: TreeNode): React.Attributes & React.HtmlHTMLAttributes<HTMLElement> {\n        return {\n            onDragStart: event => this.handleDragStartEvent(node, event),\n            onDragEnter: event => this.handleDragEnterEvent(node, event),\n            onDragOver: event => this.handleDragOverEvent(node, event),\n            onDragLeave: event => this.handleDragLeaveEvent(node, event),\n            onDrop: event => void this.handleDropEvent(node, event),\n            onDragEnd: event => void this.handleDragEndEvent(node, event),\n            draggable: !this.isRenaming(node) && this.isDraggable(node)\n        };\n    }\n\n    /**\n     * Create the node class names.\n     * @param node the tree node.\n     * @param props the node properties.\n     *\n     * @returns the list of tree node class names.\n     */\n    protected createNodeClassNames(node: TreeNode, props?: any): string[] {\n        return [TREE_TABLE_NODE_CLASS, TREE_TABLE_NODE_SEGMENT_GROW_CLASS];\n    }\n\n    /**\n     * Determine if the tree node is expandable.\n     * @param node the tree node.\n     *\n     * @returns `true` if the tree node is expandable.\n     */\n    protected isExpandable(node: TreeNode): node is ExpandableTreeNode {\n        return ExpandableTreeNode.is(node);\n    }\n\n    protected isRowExpandable(row: TreeTableRow<T>): boolean {\n        return this.isExpandable(row.node);\n    }\n\n    /**\n     * Get the tree node decorations.\n     * @param node the tree node.\n     *\n     * @returns the list of tree decoration data.\n     */\n    protected getDecorations(node: TreeNode): TreeDecoration.Data[] {\n        const decorations: TreeDecoration.Data[] = [];\n        if (DecoratedTreeNode.is(node)) {\n            decorations.push(node.decorationData);\n        }\n        if (this.decorations.has(node.id)) {\n            decorations.push(...this.decorations.get(node.id)!);\n        }\n        return decorations.sort(TreeDecoration.Data.comparePriority);\n    }\n\n    /**\n     * Get the tree decoration data for the given key.\n     * @param node the tree node.\n     * @param key the tree decoration data key.\n     *\n     * @returns the tree decoration data at the given key.\n     */\n    protected getDecorationData<K extends keyof TreeDecoration.Data>(node: TreeNode, key: K): Required<Pick<TreeDecoration.Data, K>>[K][] {\n        return this.getDecorations(node)\n            .filter(data => data[key] !== undefined)\n            .map(data => data[key]);\n    }\n\n    protected override onAfterAttach(msg: Message): void {\n        const up = [\n            Key.ARROW_UP,\n            KeyCode.createKeyCode({\n                first: Key.ARROW_UP,\n                modifiers: [KeyModifier.Shift]\n            })\n        ];\n        const down = [\n            Key.ARROW_DOWN,\n            KeyCode.createKeyCode({\n                first: Key.ARROW_DOWN,\n                modifiers: [KeyModifier.Shift]\n            })\n        ];\n        if (this.props.search) {\n            if (this.searchBox.isAttached) {\n                Widget.detach(this.searchBox);\n            }\n            UnsafeWidgetUtilities.attach(this.searchBox, this.node.parentElement!);\n            this.addKeyListener(\n                this.node,\n                this.searchBox.keyCodePredicate.bind(this.searchBox),\n                this.searchBox.handle.bind(this.searchBox)\n            );\n            this.toDisposeOnDetach.push(\n                Disposable.create(() => {\n                    Widget.detach(this.searchBox);\n                })\n            );\n        }\n        super.onAfterAttach(msg);\n        this.addKeyListener(this.node, Key.ARROW_LEFT, event => this.handleKeyEvent(event, this.handleLeft.bind(this)));\n        this.addKeyListener(this.node, Key.ARROW_RIGHT, event => this.handleKeyEvent(event, this.handleRight.bind(this)));\n        this.addKeyListener(this.node, up, event => this.handleKeyEvent(event, this.handleUp.bind(this)));\n        this.addKeyListener(this.node, down, event => this.handleKeyEvent(event, this.handleDown.bind(this)));\n        this.addKeyListener(this.node, Key.ENTER, event => this.handleKeyEvent(event, this.handleEnter.bind(this)));\n        this.addKeyListener(this.node, Key.SPACE, event => this.handleKeyEvent(event, this.handleSpace.bind(this)));\n        this.addKeyListener(this.node, Key.ESCAPE, event => this.handleKeyEvent(event, this.handleEscape.bind(this)));\n    }\n\n    protected handleKeyEvent(event: KeyboardEvent, action: (event: KeyboardEvent) => boolean | void | object): boolean | void | object {\n        if (event.target && event.target instanceof HTMLInputElement) {\n            /* don't stop propagation and let input element take care of key */\n            return false;\n        }\n        return action(event);\n    }\n\n    /**\n     * Handle the `left arrow` keyboard event.\n     * @param event the `left arrow` keyboard event.\n     */\n    protected handleLeft(event: KeyboardEvent): boolean | void | object {\n        if (!!this.props.multiSelect && (this.hasCtrlCmdMask(event) || this.hasShiftMask(event))) {\n            return;\n        }\n        const selectedNode = this.model.selectedNodes[0];\n        if (!selectedNode || !this.isExpandable(selectedNode)) {\n            const parent = this.getVisibleParent();\n            if (parent) {\n                this.model.selectNode(parent);\n            }\n            return;\n        }\n        void this.model.collapseNode().then(collapsed => {\n            if (!collapsed) {\n                const parent = this.getVisibleParent();\n                if (parent) {\n                    this.model.selectNode(parent);\n                }\n            }\n        });\n    }\n\n    /**\n     * Handle the `right arrow` keyboard event.\n     * @param event the `right arrow` keyboard event.\n     */\n    protected handleRight(event: KeyboardEvent): boolean | void | object {\n        if (!!this.props.multiSelect && (this.hasCtrlCmdMask(event) || this.hasShiftMask(event))) {\n            return;\n        }\n        const selectedNode = this.model.selectedNodes[0];\n        // If the node is not expandable (no visible children), don't try to expand\n        if (!selectedNode || !this.isExpandable(selectedNode)) {\n            return;\n        }\n        void this.model.expandNode().then(expanded => {\n            if (!expanded) {\n                // Node is already expanded, select first visible child\n                const firstChild = this.getFirstVisibleChild();\n                if (firstChild) {\n                    this.model.selectNode(firstChild);\n                }\n            }\n        });\n    }\n\n    /**\n     * Handle the `up arrow` keyboard event.\n     * @param event the `up arrow` keyboard event.\n     */\n    protected handleUp(event: KeyboardEvent): boolean | void | object {\n        const prevNode = this.getPreviousSelectableTreeNode();\n        if (prevNode) {\n            if (!!this.props.multiSelect && this.hasShiftMask(event)) {\n                this.model.selectRange(prevNode);\n            } else {\n                this.model.selectNode(prevNode);\n            }\n        }\n        this.node.focus();\n    }\n\n    /**\n     * Handle the `down arrow` keyboard event.\n     * @param event the `down arrow` keyboard event.\n     */\n    protected handleDown(event: KeyboardEvent): boolean | void | object {\n        const nextNode = this.getNextSelectableTreeNode();\n        if (nextNode) {\n            if (!!this.props.multiSelect && this.hasShiftMask(event)) {\n                this.model.selectRange(nextNode);\n            } else {\n                this.model.selectNode(nextNode);\n            }\n        }\n        this.node.focus();\n    }\n\n    /**\n     * Handle the `enter key` keyboard event.\n     * - `enter` opens the tree node.\n     * @param event the `enter key` keyboard event.\n     */\n    protected handleEnter(event: KeyboardEvent): boolean | void | object {\n        this.model.openNode();\n    }\n\n    /**\n     * Handle the `space key` keyboard event.\n     * - If the element has a checkbox, it will be toggled.\n     * - Otherwise, it should be similar to a single-click action.\n     * @param event the `space key` keyboard event.\n     */\n    protected handleSpace(event: KeyboardEvent): boolean | void | object {\n        const { focusedNode } = this.focusService;\n        if (focusedNode && focusedNode.checkboxInfo) {\n            this.model.markAsChecked(focusedNode, !focusedNode.checkboxInfo.checked);\n        } else if (!this.props.multiSelect || (!event.ctrlKey && !event.metaKey && !event.shiftKey)) {\n            this.tapNode(focusedNode);\n        }\n    }\n\n    protected handleEscape(event: KeyboardEvent): boolean | void | object {\n        if (this.model.selectedNodes.length <= 1) {\n            this.focusService.setFocus(undefined);\n            this.node.focus();\n        }\n        this.model.clearSelection();\n    }\n\n    /**\n     * Handle the single-click mouse event.\n     * @param node the tree node if available.\n     * @param event the mouse single-click event.\n     */\n    protected handleClickEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n        if (node) {\n            event.stopPropagation();\n            const shiftMask = this.hasShiftMask(event);\n            const ctrlCmdMask = this.hasCtrlCmdMask(event);\n            if (this.props.multiSelect && (shiftMask || ctrlCmdMask) && SelectableTreeNode.is(node)) {\n                if (shiftMask) {\n                    this.model.selectRange(node);\n                } else if (ctrlCmdMask) {\n                    this.model.toggleNode(node);\n                }\n            } else if (!this.inExpander(node, event)) {\n                // The expander handles its own expansion toggle, so don't do it here\n                this.tapNode(node);\n            }\n        }\n    }\n\n    private inExpander(node: TreeNode, event: React.MouseEvent<HTMLElement, MouseEvent>): boolean {\n        const target = event.target as HTMLElement;\n        return target.classList.contains(THEIA_EXPANSION_TOGGLE_CLASS);\n    }\n\n    /**\n     * The effective handler of an unmodified single-click event.\n     */\n    protected tapNode(node?: TreeNode): void {\n        if (SelectableTreeNode.is(node)) {\n            this.model.selectNode(node);\n        }\n        if (node && !this.props.expandOnlyOnExpansionToggleClick && this.isExpandable(node) && !this.isRenaming(node.id)) {\n            this.model.toggleNodeExpansion(node).catch(e => console.error(e));\n        }\n    }\n\n    //\n    // DnD\n    //\n    protected draggedElement?: HTMLElement;\n    protected draggedSelection?: TreeNode[];\n    protected dropOperation?: DropOperation;\n    protected readonly dropOperationFeedback = new DisposableCollection();\n    protected readonly dragOverExpansion = new DisposableCollection();\n\n    protected isDraggable(node: TreeNode): boolean {\n        return false;\n    }\n\n    protected handleDragStartEvent(node: TreeNode, event: React.DragEvent): TreeNode[] {\n        event.stopPropagation();\n        if (event.dataTransfer) {\n            // we either drag the whole selection if the dragged node is part of the existing selection or we drag just the node\n            const selectedNodes = this.model.selectedNodes.find(selected => TreeNode.equals(selected, node))\n                ? [...this.model.selectedNodes]\n                : [node];\n            this.draggedSelection = selectedNodes;\n            this.draggedElement = event.target as HTMLElement;\n            return selectedNodes;\n        }\n        return [];\n    }\n\n    protected handleDragEndEvent(node: TreeNode, event: React.DragEvent): TreeNode[] {\n        event.stopPropagation();\n        this.dropOperationFeedback.dispose();\n        this.draggedSelection = undefined;\n        this.draggedElement = undefined;\n        return [];\n    }\n\n    protected override onAfterShow(msg: Message): void {\n        super.onAfterShow(msg);\n        const selectedNode = this.model.selectedNodes[0];\n        this.scrollTo = selectedNode ? { key: selectedNode.id } : { top: 0 };\n        if (this.scroll.y === MIN_TABLE_SIZE_PX) {\n            // we might have been rendered while not visible and have the min size\n            // -> recompute size\n            this.updateScrollConstraints();\n        } else {\n            this.update();\n        }\n    }\n\n    protected handleDragEnterEvent(node: TreeNode | undefined, event: React.DragEvent): void {\n        event.preventDefault();\n        event.stopPropagation();\n        this.dragOverExpansion.dispose();\n    }\n\n    protected handleDragOverEvent(node: TreeNode | undefined, event: React.DragEvent): void {\n        event.preventDefault();\n        event.stopPropagation();\n\n        // properly provide feedback for drop operation\n        const dropOperations = this.getSupportedDropOperations(node, event);\n        event.dataTransfer.dropEffect = 'none';\n        if (dropOperations.length > 0) {\n            const dropTarget = this.detectDropTarget(node, event);\n            if (dropTarget && dropTarget !== this.draggedElement) {\n                this.dropOperationFeedback.dispose();\n                this.dropOperation = this.detectDropOperation(event, dropTarget, dropOperations);\n                dropTarget.classList.add('drop-' + this.dropOperation);\n                event.dataTransfer.dropEffect = 'move';\n                this.dropOperationFeedback.pushAll([\n                    Disposable.create(() => dropTarget.classList.remove('drop-insert-before', 'drop-insert-after', 'drop-insert-into')),\n                    Disposable.create(() => (this.dropOperation = undefined))\n                ]);\n            }\n        }\n\n        // install expansion timer\n        if (this.dragOverExpansion.disposed) {\n            // expand node when hovering over it\n            const expandTimer = setTimeout(() => ExpandableTreeNode.is(node) && !node.expanded && void this.model.expandNode(node), 1000);\n            this.dragOverExpansion.push(Disposable.create(() => clearTimeout(expandTimer)));\n        }\n    }\n\n    protected detectDropTarget(node: TreeNode | undefined, event: React.DragEvent): HTMLElement | undefined {\n        const eventTarget = event.currentTarget as HTMLElement;\n        // we want to use the node content as target for rows but the tree container for the root node\n        return eventTarget.classList.contains(TREE_CONTAINER_CLASS)\n            ? eventTarget\n            : (eventTarget.closest<HTMLElement>('.ant-table-row') ?? undefined);\n    }\n\n    protected detectDropOperation(event: React.DragEvent, element: HTMLElement, operations: DropOperation[]): DropOperation {\n        // based on the supported operations, we split the drop target into sections\n        if (operations.length === 1) {\n            // only a single operation is enabled\n            return operations[0];\n        }\n        if (operations.length === 3) {\n            // all operations are supported\n            const rect = element.getBoundingClientRect();\n            const firstQuarterMark = rect.top + rect.height * 0.25;\n            const thirdQuarterMark = rect.top + rect.height * 0.75;\n            return event.clientY < firstQuarterMark ? 'insert-before' : event.clientY > thirdQuarterMark ? 'insert-after' : 'insert-into';\n        }\n        // two operations are enabled\n        if (!operations.includes('insert-into')) {\n            const rect = element.getBoundingClientRect();\n            const firstHalfMark = rect.top + rect.height * 0.5;\n            return event.clientY < firstHalfMark ? 'insert-before' : 'insert-after';\n        }\n        if (operations.includes('insert-before')) {\n            const rect = element.getBoundingClientRect();\n            const firstQuarterMark = rect.top + rect.height * 0.25;\n            return event.clientY < firstQuarterMark ? 'insert-before' : 'insert-into';\n        } else {\n            const rect = element.getBoundingClientRect();\n            const thirdQuarterMark = rect.top + rect.height * 0.75;\n            return event.clientY < thirdQuarterMark ? 'insert-into' : 'insert-after';\n        }\n    }\n\n    protected handleDragLeaveEvent(node: TreeNode | undefined, event: React.DragEvent): void {\n        event.preventDefault();\n        event.stopPropagation();\n        this.dropOperationFeedback.dispose();\n        this.dragOverExpansion.dispose();\n    }\n\n    protected getSupportedDropOperations(node: TreeNode | undefined, event: React.DragEvent): DropOperation[] {\n        if (node === undefined || this.draggedSelection === undefined || this.draggedSelection.length === 0) {\n            return [];\n        }\n        return this.calculateDropOperations(this.draggedSelection, node);\n    }\n\n    protected calculateDropOperations(nodes: TreeNode[], target: TreeNode | undefined): DropOperation[] {\n        return [];\n    }\n\n    protected async handleDropEvent(node: TreeNode | undefined, event: React.DragEvent): Promise<void> {\n        event.preventDefault();\n        event.stopPropagation();\n        if (this.dropOperation && this.draggedSelection) {\n            event.dataTransfer.dropEffect = 'move';\n            this.drop(this.draggedSelection, node, this.dropOperation);\n            this.dropOperationFeedback.dispose();\n        }\n    }\n\n    protected drop(selection: TreeNode[], target: TreeNode | undefined, operation: DropOperation): void {\n        // do nothing, subclasses can override\n    }\n\n    /**\n     * Handle the double-click mouse event.\n     * @param node the tree node if available.\n     * @param event the double-click mouse event.\n     */\n    protected handleDblClickEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n        if (!this.isRenaming(node)) {\n            this.model.openNode(node);\n            event.stopPropagation();\n        }\n    }\n\n    /**\n     * Handle the middle-click mouse event.\n     * @param node the tree node if available.\n     * @param event the middle-click mouse event.\n     */\n    protected handleAuxClickEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n        if (event.button === 1) {\n            this.model.openNode(node);\n            if (SelectableTreeNode.is(node)) {\n                this.model.selectNode(node);\n            }\n        }\n        event.stopPropagation();\n    }\n\n    /**\n     * Handle the context menu click event.\n     * - The context menu click event is triggered by the right-click.\n     * @param node the tree node if available.\n     * @param event the right-click mouse event.\n     */\n    protected handleContextMenuEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n        if (SelectableTreeNode.is(node)) {\n            // Keep the selection for the context menu, if the widget support multi-selection and the right\n            // click happens on an already selected node.\n            if (!this.props.multiSelect || !node.selected) {\n                const type =\n                    !!this.props.multiSelect && this.hasCtrlCmdMask(event)\n                        ? TreeSelection.SelectionType.TOGGLE\n                        : TreeSelection.SelectionType.DEFAULT;\n                this.model.addSelection({ node, type });\n            }\n            this.focusService.setFocus(node);\n            const contextMenuPath = this.props.contextMenuPath;\n            if (contextMenuPath) {\n                this.showContextMenu(node, event, contextMenuPath);\n            }\n        }\n        event.stopPropagation();\n        event.preventDefault();\n    }\n\n    protected showContextMenu(node: SelectableTreeNode, event: React.MouseEvent<HTMLElement>, contextMenuPath: MenuPath): void {\n        const args = this.toContextMenuArgs(node) ?? [];\n        setTimeout(() => this.contextMenuHelper.showContextMenu(event, contextMenuPath, ...args), 10);\n    }\n\n    /**\n     * Convert the tree node to context menu arguments.\n     * @param node the selectable tree node.\n     */\n    protected toContextMenuArgs(node: SelectableTreeNode): any[] | undefined {\n        return [this, node];\n    }\n\n    /**\n     * Determine if the tree modifier aware event has a `ctrlcmd` mask.\n     * @param event the tree modifier aware event.\n     *\n     * @returns `true` if the tree modifier aware event contains the `ctrlcmd` mask.\n     */\n    protected hasCtrlCmdMask(event: TreeWidget.ModifierAwareEvent): boolean {\n        return isOSX ? event.metaKey : event.ctrlKey;\n    }\n\n    /**\n     * Determine if the tree modifier aware event has a `shift` mask.\n     * @param event the tree modifier aware event.\n     *\n     * @returns `true` if the tree modifier aware event contains the `shift` mask.\n     */\n    protected hasShiftMask(event: TreeWidget.ModifierAwareEvent): boolean {\n        // Ctrl/Cmd mask overrules the Shift mask.\n        if (this.hasCtrlCmdMask(event)) {\n            return false;\n        }\n        return event.shiftKey;\n    }\n\n    /**\n     * Deflate the tree node for storage.\n     * @param node the tree node.\n     */\n    protected deflateForStorage(node: TreeNode): object {\n        const copy = { ...node } as any;\n        if (copy.parent) {\n            delete copy.parent;\n        }\n        if ('previousSibling' in copy) {\n            delete copy.previousSibling;\n        }\n        if ('nextSibling' in copy) {\n            delete copy.nextSibling;\n        }\n        if ('busy' in copy) {\n            delete copy.busy;\n        }\n        if (CompositeTreeNode.is(node)) {\n            copy.children = [];\n            for (const child of node.children) {\n                copy.children.push(this.deflateForStorage(child));\n            }\n        }\n        return copy;\n    }\n\n    /**\n     * Inflate the tree node from storage.\n     * @param node the tree node.\n     * @param parent the optional tree node.\n     */\n    protected inflateFromStorage(node: any, parent?: TreeNode): TreeNode {\n        if (node.selected) {\n            node.selected = false;\n        }\n        if (parent) {\n            node.parent = parent;\n        }\n        if (Array.isArray(node.children)) {\n            for (const child of node.children as TreeNode[]) {\n                this.inflateFromStorage(child, node);\n            }\n        }\n        return node;\n    }\n\n    /**\n     * Store the tree state.\n     */\n    storeState(): object {\n        const decorations = this.decoratorService.deflateDecorators(this.decorations);\n        let state: object = {\n            decorations\n        };\n        if (this.model.root) {\n            state = {\n                ...state,\n                root: this.deflateForStorage(this.model.root),\n                model: this.model.storeState(),\n                focusedNodeId: this.focusService.focusedNode?.id\n            };\n        }\n\n        return state;\n    }\n\n    /**\n     * Restore the state.\n     * @param oldState the old state object.\n     */\n    restoreState(oldState: object): void {\n        const { root, decorations, model, focusedNodeId } = oldState as any;\n        if (root) {\n            this.model.root = this.inflateFromStorage(root);\n        }\n        if (decorations) {\n            this.decorations = this.decoratorService.inflateDecorators(decorations);\n        }\n        if (model) {\n            this.model.restoreState(model);\n        }\n        if (focusedNodeId) {\n            const candidate = this.model.getNode(focusedNodeId);\n            if (SelectableTreeNode.is(candidate)) {\n                this.focusService.setFocus(candidate);\n            }\n        }\n    }\n\n    protected toNodeIcon(node: TreeNode): string {\n        return this.labelProvider.getIcon(node);\n    }\n\n    protected toNodeName(node: TreeNode): string {\n        return this.labelProvider.getName(node);\n    }\n\n    protected toNodeDescription(node: TreeNode): string {\n        return this.labelProvider.getLongName(node);\n    }\n\n    // Tree Table Methods from here on\n\n    protected abstract getColumnData(node: TreeNode): T;\n\n    protected async resolveColumnData(node: TreeNode): Promise<T> {\n        return this.getColumnData(node);\n    }\n\n    protected renderNodeHeader(): React.ReactNode {\n        return <div className='p-d-flex'></div>;\n    }\n\n    protected updateSelection(): void {\n        this.update();\n    }\n\n    protected getDataTestId(row: TreeTableRow<TreeTableColumnData>): string | undefined {\n        const labels = [this.getDataTestIdSegment(row.node)];\n        let parent = row.node.parent;\n        while (parent) {\n            const segment = this.getDataTestIdSegment(parent);\n            if (segment && segment.trim() !== '<unknown>') {\n                labels.push(segment);\n            }\n            parent = parent.parent;\n        }\n        return labels.reverse().join('::');\n    }\n\n    protected getDataTestIdSegment(node: TreeNode): string {\n        return this.labelProvider.getName(node);\n    }\n\n    protected getRowClassName(row: TreeTableRow<T>, index?: number): string | undefined {\n        const className: string[] = [];\n        if (!TreeNode.isVisible(row.node)) {\n            className.push('hidden-row');\n        }\n        if (this.scroll.x === 'dynamic-content') {\n            className.push('dynamic-content-row');\n        }\n        if (SelectableTreeNode.is(row.node)) {\n            if (this.model.selectedNodes.includes(row.node)) {\n                if (this.focused) {\n                    className.push('selected-row-focused');\n                } else {\n                    className.push('selected-row');\n                }\n            } else if (this.styleChildrenOfSelection) {\n                /* check if child of selected node */\n                if (this.sorter?.order === 'ascend' || this.sorter?.order === 'descend') {\n                    /* in sort mode we show a flat list -> no children */\n                    className.push('unselected-row');\n                } else {\n                    let parent = row.node.parent;\n                    while (parent !== undefined) {\n                        if (SelectableTreeNode.is(parent) && this.model.selectedNodes.includes(parent)) {\n                            if (this.focused) {\n                                className.push('selected-row-child-focused');\n                            } else {\n                                className.push('selected-row-child');\n                            }\n                            break;\n                        }\n                        parent = parent.parent;\n                    }\n                    /* parent is also not selected */\n                    className.push('unselected-row');\n                }\n            } else {\n                className.push('unselected-row');\n            }\n        }\n        if (index !== undefined) {\n            className.push(index % 2 === 0 ? 'even-row' : 'odd-row');\n        }\n        return className.length > 0 ? className.join(' ') : undefined;\n    }\n\n    protected createNodeColumn(): TreeTableColumn<T> {\n        return {\n            dataIndex: ['node'],\n            key: 'node',\n            title: () => this.renderNodeHeader(),\n            render: (_value: any, row: TreeTableRow<T>, _index: number) => this.renderNodeColumn(row),\n            width: 0\n        };\n    }\n\n    protected createTailColumn(): TreeTableColumn<T> {\n        return {\n            dataIndex: ['tail'],\n            key: 'tail',\n            title: 'tail',\n            fixed: 'right',\n            className: 'tail-column',\n            render: (_value: any, row: TreeTableRow<T>, _index: number) => this.renderTailCommands(row.node),\n            width: 128\n        };\n    }\n\n    protected createDataColumn(key: TreeTableDataKey<T>, props: TreeTableColumnHeaderProps = {}): TreeTableColumn<T> {\n        const options = { sortable: true, ...props };\n        const column: TreeTableColumn<T> = {\n            dataIndex: ['columnData', key],\n            key,\n            title: options.title,\n            onHeaderCell: (_data, index) => ({\n                title: options.description || options.title,\n                onContextMenu: event => this.onColumnHeaderContextMenu(event, options, key, index),\n                onFocus: event => this.onColumnHeaderFocus(event, options, key, index),\n                onClick: event => this.onColumnHeaderFocus(event, options, key, index)\n            }),\n            // there is no style member for this element\n            className: this.getDataColumnClassName(key, props),\n            width: 'auto',\n            render: (_value: any, row: TreeTableRow<T>, _index: number) => this.renderDataColumn(row, key, column),\n            sortOrder: this.sorter?.columnKey === key ? this.sorter?.order : undefined\n        };\n        if (options.sortable) {\n            column.sorter = true;\n            column.sortIcon = (sortProps: { sortOrder: SortOrder }) => this.renderSortIcon(sortProps);\n            column.showSorterTooltip = false;\n        }\n        return column;\n    }\n\n    protected onColumnHeaderFocus(\n        event: React.SyntheticEvent,\n        options: TreeTableColumnHeaderProps,\n        columnKey: ColumnKey,\n        index?: number\n    ): void {\n        const target = event.currentTarget as HTMLTableCellElement;\n        if (target) {\n            const scrollContainer = this.node.querySelector<HTMLDivElement>('.ant-table-header');\n            if (scrollContainer) {\n                // The header cells are shifted to the right by the width of the first column which contains the search bar and tree\n                const headerLeftShift = (target.parentElement as HTMLTableRowElement)?.cells?.[0]?.offsetWidth ?? 0;\n                const targetLeftScrollPosition = target.offsetLeft - headerLeftShift;\n                const containerLeftScrollPosition = scrollContainer.scrollLeft;\n                if (targetLeftScrollPosition < containerLeftScrollPosition) {\n                    // need to scroll to the left to ensure the header is fully visible\n                    void this.updateScrollTo({\n                        left: targetLeftScrollPosition,\n                        top: 0\n                    });\n                    return;\n                }\n                const targetRightScrollPosition = targetLeftScrollPosition + target.offsetWidth;\n                const containerRightScrollPosition = containerLeftScrollPosition + (scrollContainer.offsetWidth - headerLeftShift);\n                if (targetRightScrollPosition > containerRightScrollPosition) {\n                    // need to scroll to the right to ensure that header is fully visible\n                    void this.updateScrollTo({\n                        left: containerLeftScrollPosition + (targetRightScrollPosition - containerRightScrollPosition),\n                        top: 0\n                    });\n                    return;\n                }\n                // container already scrolled correctly, we just need to ensure that the position is stored as state in the table\n                void this.updateScrollTo({\n                    left: containerLeftScrollPosition,\n                    top: 0\n                });\n            }\n        }\n    }\n\n    protected onColumnHeaderContextMenu(\n        event: React.MouseEvent,\n        options: TreeTableColumnHeaderProps,\n        columnKey: ColumnKey,\n        index?: number\n    ): void {\n        // Nothing to do by default\n    }\n\n    protected renderDataColumn(row: TreeTableRow<T>, key: TreeTableDataKey<T>, column: TreeTableColumn<T>): React.ReactNode {\n        return LazyTreeTableRow.is(row) ? (\n            <this.LazyTreeTableCellView row={row} dataKey={key} formatValue={this.formatValue.bind(this)} />\n        ) : (\n            (row.columnData[key] as any)\n        );\n    }\n\n    protected getDataColumnClassName(key: keyof T, props?: TreeTableColumnHeaderProps): string {\n        let className = key as string;\n        if (this.sorter?.columnKey === key && (this.sorter.order === 'ascend' || this.sorter.order === 'descend')) {\n            className += ' sorted';\n        }\n        // Couldn't change column alignment property through element style to affect justify-content\n        // ,so I created some rules simple rules to apply alignment based on a classname\n        if (props?.align) {\n            className += ` align-${props.align}`;\n        }\n        return className;\n    }\n\n    protected renderSortIcon(props: { sortOrder: SortOrder }): React.ReactNode {\n        if (props.sortOrder === 'ascend') {\n            return <div className={codicon('sokatoa-sort-duration-up')}></div>;\n        } else if (props.sortOrder === 'descend') {\n            return <div className={codicon('sokatoa-sort-duration')}></div>;\n        } else {\n            return <div className={codicon('sokatoa-sort-by')}></div>;\n        }\n    }\n\n    protected getColumns(): TreeTableColumn<T>[] {\n        const columns: TreeTableColumn<T>[] = [];\n        columns.push(this.createNodeColumn());\n        return columns;\n    }\n\n    protected showHeader(): boolean {\n        const columns = this.getColumns();\n        return columns.filter(c => !c.className?.includes('tail-column')).length > 1;\n    }\n\n    protected toRenameNodeId: string | undefined = undefined;\n    protected pendingRename = new Deferred<string | undefined>();\n\n    async triggerNodeRename(nodeOrId: TreeNode | string): Promise<string | undefined> {\n        const node = typeof nodeOrId === 'string' ? this.model.getNode(nodeOrId) : nodeOrId;\n        if (!node || !this.canRename(node)) {\n            return;\n        }\n        this.toRenameNodeId = node.id;\n        this.contextService.inRenameMode = true;\n        this.pendingRename = new Deferred<string | undefined>();\n        this.update();\n        return this.pendingRename.promise;\n    }\n\n    protected handleRenameValidate(value: string): string | undefined {\n        if (value === undefined || !this.isRenaming()) {\n            return;\n        }\n        const node = this.model.getNode(this.toRenameNodeId);\n        if (!node) {\n            return;\n        }\n        return this.validateRename(node, value);\n    }\n\n    protected handleRenameSubmit(value: string): void {\n        if (value === undefined || !this.isRenaming()) {\n            return;\n        }\n        const node = this.model.getNode(this.toRenameNodeId);\n        this.toRenameNodeId = undefined;\n        this.contextService.inRenameMode = false;\n        this.update();\n        if (node) {\n            void this.rename(node, value).finally(() => this.pendingRename.resolve(value));\n        } else {\n            this.pendingRename.resolve(value);\n        }\n    }\n\n    protected handleRenameCancel(): void {\n        this.toRenameNodeId = undefined;\n        this.contextService.inRenameMode = false;\n        this.update();\n        this.pendingRename.resolve(undefined);\n    }\n\n    protected canRename(node: TreeNode): boolean {\n        return false;\n    }\n\n    protected isRenaming(node?: string | TreeNode): boolean {\n        if (!node) {\n            return this.toRenameNodeId !== undefined;\n        }\n        return typeof node === 'string' ? node === this.toRenameNodeId : node.id === this.toRenameNodeId;\n    }\n\n    /**\n     * Subclasses need to implement the actual logic for renaming.\n     */\n    protected async rename(node: TreeNode, value: string): Promise<void> {\n        console.warn(`Renaming ${node.id} to ${value} is not implemented`);\n    }\n\n    protected validateRename(node: TreeNode, value: string): string | undefined {\n        return undefined;\n    }\n\n    protected renderRename(row: TreeTableRow<T>, props?: any): React.ReactNode {\n        const node = row.node;\n        const attributes = this.createNodeAttributes(node);\n        const content = (\n            <div className={TREE_TABLE_NODE_CONTENT_CLASS} key={row.key + '_node'}>\n                {this.renderCheckbox(node, props)}\n                {this.decorateIcon(node, this.renderIcon(node, props))}\n                {this.renderCaptionAffixes(node, props, 'captionPrefixes')}\n                {\n                    <this.RenameTreeTableCellView\n                        row={row}\n                        value={this.toNodeName(node)}\n                        validate={this.handleRenameValidate.bind(this)}\n                        onCancel={this.handleRenameCancel.bind(this)}\n                        onSubmit={this.handleRenameSubmit.bind(this)}\n                    />\n                }\n                {this.renderCaptionAffixes(node, props, 'captionSuffixes')}\n                {this.renderTailDecorations(node, props)}\n            </div>\n        );\n        return React.createElement('div', attributes, content);\n    }\n\n    protected sortRows(\n        left: TreeTableRow<T>,\n        right: TreeTableRow<T>,\n        key: TreeTableDataKey<T> = this.sorter?.columnKey as TreeTableDataKey<T>,\n        order: SortOrder | undefined = this.sorter?.order\n    ): number {\n        const leftValue = this.toValue(left.columnData, key);\n        const rightValue = this.toValue(right.columnData, key);\n        if (leftValue === undefined && rightValue === undefined) {\n            return 0;\n        }\n        // always sort undefined values to the end\n        if (leftValue === undefined) {\n            return 1;\n        }\n        if (rightValue === undefined) {\n            return -1;\n        }\n        if (order === 'ascend') {\n            return leftValue < rightValue ? -1 : leftValue > rightValue ? 1 : 0;\n        }\n        return leftValue < rightValue ? 1 : leftValue > rightValue ? -1 : 0;\n    }\n\n    protected abstract toValue(data: T, key: TreeTableDataKey<T>): number | bigint | string | undefined;\n\n    protected onChange(\n        _pagination: TablePaginationConfig,\n        _filters: Record<string, FilterValue | null>,\n        sorter: SorterResult<TreeTableRow<T>> | SorterResult<TreeTableRow<T>>[],\n        _extra: TableCurrentDataSource<TreeTableRow<T>>\n    ): void {\n        this.sorter = Array.isArray(sorter) ? sorter[0] : sorter;\n        this.updateRowsToSort().catch(e => console.error(e));\n    }\n\n    protected async updateRowsToSort(): Promise<void> {\n        this.updateRows({\n            sortTreeTableRows: true,\n            updateFilteredRows: true\n        });\n    }\n\n    protected onTableRender(): void {\n        // no op, subclasses may override\n    }\n\n    getTotal(): number {\n        return this.rowModel.size;\n    }\n\n    getPreviousTreeNode(\n        predicate: (node: TreeNode) => boolean = () => true,\n        options: { skipCollapsedChildren?: boolean } = {}\n    ): TreeNode | undefined {\n        return this.getTreeNode('prev', predicate, options);\n    }\n\n    protected getSelectableTreeNodeInDirectionPredicate(): (node: TreeNode) => boolean {\n        return () => true;\n    }\n\n    /**\n     * Gets the visible parent of the given node, respecting visibility predicates.\n     * @param node the node to get the visible parent of, defaults to the first selected node\n     */\n    protected getVisibleParent(node: TreeNode | undefined = this.model.selectedNodes[0]): SelectableTreeNode | undefined {\n        if (!node) {\n            return undefined;\n        }\n        const predicate = this.getSelectableTreeNodeInDirectionPredicate();\n        let current: TreeNode | undefined = node.parent;\n        while (current) {\n            if (this.shouldDisplayNode(current) && predicate(current) && SelectableTreeNode.is(current)) {\n                return current;\n            }\n            current = current.parent;\n        }\n        return undefined;\n    }\n\n    /**\n     * Gets the first visible child of the given node, respecting visibility predicates.\n     * @param node the node to get the first visible child of, defaults to the first selected node\n     */\n    protected getFirstVisibleChild(node: TreeNode | undefined = this.model.selectedNodes[0]): SelectableTreeNode | undefined {\n        if (!node) {\n            return undefined;\n        }\n        if (!CompositeTreeNode.is(node) || node.children.length === 0) {\n            return undefined;\n        }\n        const predicate = this.getSelectableTreeNodeInDirectionPredicate();\n        for (const child of node.children) {\n            if (this.shouldDisplayNode(child) && predicate(child) && SelectableTreeNode.is(child)) {\n                return child;\n            }\n        }\n        return undefined;\n    }\n\n    getPreviousSelectableTreeNode(): SelectableTreeNode | undefined {\n        const treeNode = this.getPreviousTreeNode(this.getSelectableTreeNodeInDirectionPredicate(), { skipCollapsedChildren: true });\n        if (SelectableTreeNode.is(treeNode)) {\n            return treeNode;\n        }\n        return undefined;\n    }\n\n    getNextTreeNode(\n        predicate: (node: TreeNode) => boolean = () => true,\n        options: { skipCollapsedChildren?: boolean } = {}\n    ): TreeNode | undefined {\n        return this.getTreeNode('next', predicate, options);\n    }\n\n    getNextSelectableTreeNode(): SelectableTreeNode | undefined {\n        const treeNode = this.getNextTreeNode(this.getSelectableTreeNodeInDirectionPredicate(), { skipCollapsedChildren: true });\n        if (SelectableTreeNode.is(treeNode)) {\n            return treeNode;\n        }\n        return undefined;\n    }\n\n    private getTreeNodeDataForTreeNode(node: TreeNode): TreeTableRow<T> | undefined {\n        return Iterators.find(this.asList(), data => data.key === node.id);\n    }\n\n    /**\n     * @param toSelect the direction to navigate\n     * @param predicate if a node does not fulfil this predicate, it will be skipped over\n     * @param options navigation options\n     * @returns the tree node in the direction or undefined if none was found\n     */\n    private getTreeNode(\n        toSelect: 'prev' | 'next',\n        predicate: (node: TreeNode) => boolean = () => true,\n        options: { skipCollapsedChildren?: boolean } = {}\n    ): TreeNode | undefined {\n        if (this.model.selectedNodes.length > 0) {\n            const selection = this.model.selectedNodes[0];\n            return this.getTreeNodeInDirection(toSelect, selection, predicate, options);\n        }\n        return undefined;\n    }\n\n    private getTreeNodeInDirection(\n        toSelect: 'prev' | 'next',\n        start: TreeNode,\n        predicate: (node: TreeNode) => boolean = () => true,\n        options: { skipCollapsedChildren?: boolean } = {}\n    ): TreeNode | undefined {\n        const startData = this.getTreeNodeDataForTreeNode(start);\n        if (startData === undefined) {\n            return undefined;\n        }\n        const containingArray = startData.parent.children;\n        if (containingArray === undefined) {\n            return undefined;\n        }\n        const ownIndex = containingArray.indexOf(startData);\n        if (ownIndex < 0) {\n            return undefined;\n        }\n\n        if (toSelect === 'prev') {\n            if (ownIndex > 0) {\n                /* we have a sibling before us -> return very last child of this sibling */\n                let result = containingArray[ownIndex - 1];\n                let siblingChildren = result.children;\n                while (\n                    siblingChildren !== undefined &&\n                    siblingChildren.length > 0 &&\n                    (!options.skipCollapsedChildren || ExpandableTreeNode.isExpanded(result.node))\n                ) {\n                    result = siblingChildren[siblingChildren.length - 1];\n                    siblingChildren = result.children;\n                }\n                if (predicate(result.node)) {\n                    return result.node;\n                } else {\n                    return this.getTreeNodeInDirection(toSelect, result.node, predicate, options);\n                }\n            } else {\n                /* we have no sibling before -> return parent, if any */\n                if (isTreeTableRow(startData.parent)) {\n                    if (predicate(startData.parent.node)) {\n                        return startData.parent.node;\n                    } else {\n                        return this.getTreeNodeInDirection(toSelect, startData.parent.node, predicate, options);\n                    }\n                } else {\n                    return undefined;\n                }\n            }\n        } else if (toSelect === 'next') {\n            if (\n                startData.children !== undefined &&\n                startData.children.length > 0 &&\n                (!options.skipCollapsedChildren || ExpandableTreeNode.isExpanded(startData.node))\n            ) {\n                /* we have children -> select first child */\n                if (predicate(startData.children[0].node)) {\n                    return startData.children[0].node;\n                } else {\n                    return this.getTreeNodeInDirection(toSelect, startData.children[0].node, predicate, options);\n                }\n            } else {\n                /* we have no children, select next sibling if any */\n                if (containingArray.length > ownIndex + 1) {\n                    if (predicate(containingArray[ownIndex + 1].node)) {\n                        return containingArray[ownIndex + 1].node;\n                    } else {\n                        return this.getTreeNodeInDirection(toSelect, containingArray[ownIndex + 1].node, predicate, options);\n                    }\n                }\n\n                /* no siblings, look for next node in parents */\n                let self = startData.parent;\n                while (isTreeTableRow(self)) {\n                    const parent = self.parent;\n                    const nodes = parent.children;\n                    if (nodes === undefined) {\n                        return undefined;\n                    }\n                    const index = nodes.indexOf(self);\n                    if (index < 0) {\n                        return undefined;\n                    }\n\n                    if (nodes.length > index + 1) {\n                        if (predicate(nodes[index + 1].node)) {\n                            return nodes[index + 1].node;\n                        } else {\n                            return this.getTreeNodeInDirection(toSelect, nodes[index + 1].node, predicate, options);\n                        }\n                    }\n                    self = parent;\n                }\n\n                /* nothing found, we were the very last node */\n                return undefined;\n            }\n        } else {\n            console.warn('Unknown select direction');\n        }\n        return undefined;\n    }\n\n    // React Components from here\n\n    ExpandIcon: React.FC<RenderExpandIconEnhProps<TreeTableRow<T>>> = React.memo(function ExpandIcon({\n        expanded,\n        onExpand,\n        record,\n        expandable,\n        dataTestId\n    }: any) {\n        const expansionHandler = expandable ? (e: React.MouseEvent) => onExpand(record, e) : undefined;\n        return (\n            <span className='theia-treeTable-ExpansionToggle' onClick={expansionHandler} data-test-id={expansionHandler && dataTestId}>\n                {!expandable ? (\n                    <div className={`${THEIA_EXPANSION_TOGGLE_CLASS} ${codicon('blank')}`}></div>\n                ) : expanded ? (\n                    <div className={`${THEIA_EXPANSION_TOGGLE_CLASS} ${codicon('chevron-down')}`}></div>\n                ) : (\n                    <div className={`${THEIA_EXPANSION_TOGGLE_CLASS} ${codicon('chevron-down')} theia-mod-collapsed`}></div>\n                )}\n            </span>\n        );\n    });\n\n    /* eslint-disable react-hooks/rules-of-hooks */ // The rule thinks we're inside a class body -> inside a class component.\n    TreeTableView: React.FC<TreeTableViewProps<T>> = ({\n        expandedRowsKeys,\n        getRowClassName,\n        onChange,\n        onRender,\n        onToggle,\n        rows,\n        scroll,\n        scrollTo,\n        onScrollTo,\n        indentSize,\n        isExpandable,\n        locale = { emptyText: '' },\n        showHeader,\n        ...props\n    }) => {\n        // typing from antd virtual-list.tsx example\n        // eslint-disable-next-line no-null/no-null\n        const tableRef: Parameters<typeof Table>[0]['ref'] = React.useRef(null);\n        const [inner, setInner] = React.useState<HTMLElement>();\n        const [tableWidth, setTableWidth] = React.useState(scroll?.x === 'dynamic-content' ? 0 : (scroll?.x ?? 0));\n\n        React.useEffect(() => {\n            if (tableRef.current) {\n                // Ant Table doesn't account for the height of the header in laying out virtual table body,\n                // resulting in the body extending under whatever widget is below it. Do this accounting\n                // on its behalf\n                const tableHeader = tableRef.current.nativeElement.querySelector<HTMLElement>('.ant-table-header');\n                const tableBody = tableRef.current.nativeElement.querySelector<HTMLElement>('.ant-table-tbody-virtual');\n                if (tableHeader && tableBody) {\n                    tableBody.style.height = `calc(100% - ${tableHeader.offsetHeight}px)`;\n                }\n            }\n            onRender();\n        });\n\n        React.useEffect(() => {\n            if (scrollTo) {\n                tableRef.current?.scrollTo(scrollTo);\n                onScrollTo?.(scrollTo);\n            }\n        }, [scrollTo, onScrollTo]);\n\n        const onRow = React.useCallback<GetComponentProps<TreeTableRow<T>>>(\n            (row: TreeTableRow<T>, index?: number) => ({\n                className: getRowClassName(row, index),\n                onClick: event => this.handleClickEvent(row.node, event),\n                onDoubleClick: event => this.handleDblClickEvent(row.node, event),\n                onAuxClick: event => this.handleAuxClickEvent(row.node, event),\n                onContextMenu: event => this.handleContextMenuEvent(row.node, event),\n                ...this.getNodeDragHandlers(row.node)\n            }),\n            [getRowClassName]\n        );\n\n        const expandIcon = React.useCallback<NonNullable<ExpandableConfig<TreeTableRow<T>>['expandIcon']>>(\n            ({ expanded, onExpand, record, prefixCls }) => (\n                <this.ExpandIcon\n                    key={`${record.key}-expand-icon`}\n                    expanded={expanded}\n                    onExpand={onExpand}\n                    record={record}\n                    prefixCls={prefixCls}\n                    expandable={isExpandable(record)}\n                    dataTestId={this.getDataTestId(record)}\n                />\n            ),\n            [isExpandable]\n        );\n\n        const expandable = React.useMemo<ExpandableConfig<TreeTableRow<T>>>(\n            () => ({\n                expandedRowKeys: expandedRowsKeys,\n                onExpand: (expanded, row) => onToggle(expanded, row),\n                expandIcon: expandIcon,\n                indentSize\n            }),\n            [expandedRowsKeys, expandIcon, onToggle, indentSize]\n        );\n\n        useEffect(() => {\n            // Retrieve the inner virtual scroll container\n            // We need to use a MutationObserver because it is created/destroyed dynamically\n\n            if (!tableRef.current) {\n                return;\n            }\n\n            const table = tableRef.current.nativeElement;\n\n            const selector = '.ant-table-tbody-virtual-holder-inner';\n\n            const observer = new MutationObserver(() => {\n                if (!inner) {\n                    const element = table.querySelector<HTMLElement>(selector);\n                    if (element) {\n                        // It has been added\n                        setInner(element);\n                    }\n                } else {\n                    const element = table.querySelector<HTMLElement>(selector);\n                    if (!element) {\n                        // It has been removed\n                        setInner(undefined);\n                    }\n                }\n            });\n\n            observer.observe(table, { childList: true, subtree: true });\n\n            return () => {\n                observer.disconnect();\n            };\n        }, [tableRef, inner]);\n\n        useEffect(() => {\n            // Based on the inner element, we can calculate the table width if needed\n            if (!inner) {\n                return;\n            }\n\n            if (scroll?.x !== 'dynamic-content') {\n                setTableWidth(scroll?.x ?? 0);\n                return;\n            }\n\n            setTableWidth(inner.clientWidth);\n\n            const observer = new ResizeObserver(() => {\n                if (inner.isConnected) {\n                    setTableWidth(inner.clientWidth);\n                }\n            });\n            observer.observe(inner);\n            return () => {\n                observer.disconnect();\n            };\n        }, [scroll?.x, inner, rows]);\n\n        const columns = React.useMemo(() => {\n            if (rows.length === 0) {\n                return props.columns.filter(c => !c.className?.includes('tail-column'));\n            }\n\n            return props.columns;\n        }, [props.columns, rows]);\n\n        return (\n            <Table\n                ref={tableRef}\n                virtual\n                dataSource={rows}\n                columns={columns}\n                scroll={{\n                    x: tableWidth,\n                    y: scroll?.y ?? 'max-content'\n                }}\n                showHeader={showHeader}\n                pagination={false}\n                onRow={onRow}\n                expandable={expandable}\n                rowClassName={'sokatoa-TreeTable-row'}\n                tableLayout='fixed'\n                onChange={onChange}\n                sortDirections={['descend', 'ascend']} /* descend before ascend */\n                locale={locale}\n                className={classNamesUtils({ 'sokatoa-dynamic-content': scroll?.x === 'dynamic-content' })}\n            />\n        );\n    };\n    /* eslint-enable react-hooks/rules-of-hooks */\n\n    LazyTreeTableCellView = React.memo(function LazyTreeTableCellView({\n        row,\n        dataKey,\n        formatValue\n    }: {\n        row: LazyTreeTableRow<T>;\n        dataKey: TreeTableDataKey<T>;\n        formatValue: (value: unknown, dataKey: TreeTableDataKey<T>) => React.ReactNode;\n    }) {\n        // eslint-disable-next-line no-null/no-null\n        const [value, setValue] = React.useState<any>(null);\n        const [loading, setLoading] = React.useState<boolean>(!row.isResolved);\n\n        React.useEffect(() => {\n            let isMounted = true;\n\n            const initializeData = async (): Promise<void> => {\n                if (row.isResolved) {\n                    setValue(row.columnData[dataKey]);\n                    setLoading(false);\n                    return;\n                }\n\n                setLoading(true);\n                try {\n                    await row.resolveColumnData();\n                } catch (e) {\n                    console.error(e);\n                }\n                if (isMounted) {\n                    setValue(row.columnData[dataKey]);\n                    setLoading(false);\n                }\n            };\n\n            initializeData().catch(e => console.error(e));\n\n            return () => {\n                isMounted = false;\n            };\n        }, [dataKey, row]);\n        return loading ? <></> : <span key={`${row.key}-${dataKey}`}>{formatValue(value, dataKey)}</span>;\n    });\n\n    /* eslint-disable react-hooks/rules-of-hooks */ // Rule thinks class body -> class component\n    RenameTreeTableCellView: React.FC<{\n        row: TreeTableRow<T>;\n        value: string;\n        validate?: (value: string) => string | undefined;\n        onSubmit: (value: string) => void;\n        onCancel: () => void;\n    }> = ({ row, value, validate = () => undefined, onSubmit, onCancel }) => {\n        // eslint-disable-next-line no-null/no-null\n        const inputRef = React.useRef<HTMLInputElement>(null);\n        const [inputValue, setInputValue] = React.useState<string>(value);\n        const [errorMessage, setErrorMessage] = React.useState<string>('');\n\n        const hasError = React.useMemo(() => errorMessage.length > 0, [errorMessage]);\n\n        const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {\n            const newValue = event.target.value;\n            setInputValue(newValue);\n            setErrorMessage(validate(newValue) ?? '');\n        };\n\n        const submit = (): void => {\n            if (hasError) {\n                onCancel();\n            } else {\n                onSubmit(inputValue);\n            }\n        };\n\n        const handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>): void => {\n            if (event.key === 'Enter') {\n                submit();\n            } else if (event.key === 'Escape') {\n                onCancel();\n            }\n            event.stopPropagation();\n        };\n\n        const handleBlur = (_event: React.FocusEvent<HTMLInputElement>): void => {\n            submit();\n        };\n\n        const handleDragStart = (event: React.DragEvent<HTMLInputElement>): void => {\n            // avoid node dragging, just drag text\n            event.stopPropagation();\n        };\n\n        React.useEffect(() => {\n            inputRef.current?.focus();\n            inputRef.current?.select();\n        }, [inputRef]);\n\n        return (\n            <Tooltip title={errorMessage} open={hasError} arrow={true} rootClassName='validation-error'>\n                <input\n                    ref={inputRef}\n                    key={row.key + '_rename'}\n                    type='text'\n                    className={'theia-input theia-treeTable-Input theia-treeTable-RenameInput' + (hasError ? ' validation-error' : '')}\n                    value={inputValue}\n                    onChange={handleInputChange}\n                    onBlur={handleBlur}\n                    onDragStart={handleDragStart}\n                    onKeyDown={handleKeyDown}\n                    autoFocus\n                />\n            </Tooltip>\n        );\n    };\n    /* eslint-enable react-hooks/rules-of-hooks */\n\n    protected formatValue(value: unknown, dataKey: TreeTableDataKey<T>): React.ReactNode {\n        return value?.toString() ?? '';\n    }\n}\n\n@injectable()\nexport class AnyTreeTableWidget<T extends TreeTableColumnData = TreeTableColumnData> extends TreeTableWidget<T> {\n    protected override getColumnData(_node: TreeNode): T {\n        return {} as T;\n    }\n\n    /** No sorting if no data */\n    protected toValue(): undefined {\n        return undefined;\n    }\n}\n\nexport function getTreeTableRect(node: HTMLElement): DOMRect | undefined {\n    return node.querySelector('.' + TREE_CONTAINER_CLASS)?.getBoundingClientRect() ?? new DOMRect(0, 0, 1, 1);\n}\n\nexport function getTreeTableContainerBounds(node: HTMLElement): DOMRect | undefined {\n    return node.querySelector('.ant-table-container')?.getBoundingClientRect();\n}\n\n/**\n * Calculates the visible bounds of an HTMLElement within the tree table, considering clipping by parent\n * containers starting with the table container.\n * @param node - The HTMLElement to calculate visibility for.\n * @returns A DOMRect representing the visible area or undefined if the element is not visible.\n */\nexport function getTreeTableBodyBounds(node: HTMLElement): DOMRect | undefined {\n    // The container includes the header, which is not part of the body\n    const rect = node.querySelector('.ant-table-tbody')?.getBoundingClientRect();\n    if (!rect || rect.width <= 0 || rect.height <= 0) {\n        // The table body doesn't exist or is invisible\n        return undefined;\n    }\n\n    let visibleLeft = rect.left;\n    let visibleTop = rect.top;\n    let visibleRight = rect.right;\n    let visibleBottom = rect.bottom;\n\n    let currentElement: HTMLElement | null = node;\n\n    while (currentElement) {\n        const parent: HTMLElement | null = currentElement.parentElement;\n        if (!parent) {\n            // Reached the root of the DOM tree\n            break;\n        }\n\n        const parentRect = parent.getBoundingClientRect();\n\n        // Update visible boundaries by intersecting with the parent's bounding rectangle\n        visibleLeft = Math.max(visibleLeft, parentRect.left);\n        visibleTop = Math.max(visibleTop, parentRect.top);\n        visibleRight = Math.min(visibleRight, parentRect.right);\n        visibleBottom = Math.min(visibleBottom, parentRect.bottom);\n\n        // Early exit if the element is completely clipped by the parent\n        if (visibleLeft >= visibleRight || visibleTop >= visibleBottom) {\n            return undefined; // Element is not visible\n        }\n\n        currentElement = parent;\n    }\n\n    const visibleWidth = visibleRight - visibleLeft;\n    const visibleHeight = visibleBottom - visibleTop;\n\n    // If after all intersections, width or height is non-positive, the element is not visible\n    if (visibleWidth <= 0 || visibleHeight <= 0) {\n        return undefined;\n    }\n\n    const visibleRect = new DOMRect(visibleLeft, visibleTop, visibleWidth, visibleHeight);\n\n    return visibleRect;\n}\n\nexport const SearchBoxProps = Symbol('SearchBoxProps');\n\n@injectable()\nexport class TreeTableSearchBox extends SearchBox {\n    @inject(TreeTableContextService)\n    protected readonly contextService: TreeTableContextService;\n\n    constructor(@inject(SearchBoxProps) props: SearchBoxPropsInterface, @inject(SearchBoxDebounce) searchDebounce: SearchBoxDebounce) {\n        super(props, searchDebounce);\n    }\n\n    override handle(event: KeyboardEvent): boolean | void {\n        if (this.contextService.inRenameMode) {\n            return false;\n        }\n        return super.handle(event);\n    }\n}\n"
              }
            }
          ]
        }
      }
    ],
    "responses": [
      {
        "id": "3552d9f0-2dd7-4af5-b43b-d2df88d27031",
        "requestId": "1c88f29c-f44e-4be1-b9a4-c22abe0deca1",
        "isComplete": true,
        "isError": false,
        "promptVariantId": "coder-system-agent-mode-next",
        "isPromptVariantEdited": false,
        "content": [
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01V9Eg5RK4LhjW4diQNpPgeF",
              "name": "getFileContent",
              "arguments": "{\"file\": \"app/packages/capture/src/browser/command-tree/command-tree-model.ts\"}",
              "finished": true,
              "result": "/********************************************************************************\n    Copyright 2024-2026 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\nimport { GFXRQueryBuilderService } from '@sokatoa/gfxr-consumer/lib/';\nimport {\n    DynamicStateEntry,\n    PipelineBindPoint,\n    PipelineBindPointShaderStageFlags,\n    StateType\n} from '@sokatoa/gfxr-consumer/lib/browser/gfxr-data-service';\nimport { PartialRecord } from '@sokatoa/platform/lib';\nimport { BulkTree, BulkTreeModel, ResourceTreeNode, SokatoaLifecycleTreeNode } from '@sokatoa/platform/lib/browser';\nimport { GroupByOptions, MiscPreferences, MiscPrefs } from '@sokatoa/platform/lib/browser/misc-preferences';\nimport { TreeStructureChangeEmitter } from '@sokatoa/platform/lib/browser/tree-table/tree-table-widget';\nimport { ImageAccessorService } from '@sokatoa/platform/lib/common';\nimport { CompressedFileService, usesCompressionExtension } from '@sokatoa/platform/lib/common/compressed-file-service';\nimport { asError } from '@sokatoa/platform/lib/common/error-utils';\nimport { ApiResources, DescriptorResource, DrawApiResult } from '@sokatoa/platform/lib/common/gfxr-apis';\nimport { CancellationToken, Disposable, Emitter, Event, Path, URI } from '@theia/core';\nimport {\n    CompositeTreeNode,\n    DepthFirstTreeIterator,\n    ExpandableTreeNode,\n    SelectableTreeNode,\n    TreeModelImpl,\n    TreeNode\n} from '@theia/core/lib/browser';\nimport { RGBA } from '@theia/core/lib/common/color';\nimport { inject, injectable, postConstruct } from '@theia/core/shared/inversify';\nimport { PNG } from 'pngjs/browser';\nimport { lookupResourceFormat, UncompressedResourceFormat } from '../../common/format-handler';\nimport { extractData } from '../../common/geometry-utils';\nimport { GfxrScreenshotService, requestThumbnails, ScreenshotType, ThumbnailRequestOptions } from '../../common/gfxr-screenshot-service';\nimport { convertDataToImageData } from '../../common/host-side-conversion/vulkan-image';\nimport { FrameRangeSelectionService } from '../capture-widget/frame-range-selection-service';\nimport { placeholderScale } from '../graphics-pipeline-widget/graphics-pipeline-screenshot-requests';\nimport {\n    CaptureDatasetWidgetContext,\n    CaptureDatasetWidgetProfile,\n    CaptureDatasetWidgetReplayContext\n} from '../profile-ui/capture-dataset-widget-types';\nimport { CommandTreePreferenceState } from './command-tree-model-preferences';\nimport {\n    CommandTreeAccelerationStructureBuildInstance,\n    CommandTreeAccelerationStructureCopyInstance,\n    CommandTreeApiEvent,\n    CommandTreeCommandBufferInstance,\n    CommandTreeDataWithFunctionAndDebugNames,\n    CommandTreeDebugLabelGroupInstance,\n    CommandTreeDynamicRenderPassInstance,\n    CommandTreeFrame,\n    CommandTreeQueueDebugLabelGroup,\n    CommandTreeQueueDebugLabelInsert,\n    CommandTreeQueuePresent,\n    CommandTreeQueueSubmit,\n    CommandTreeRenderPassInstance,\n    CommandTreeRenderSubpassInstance,\n    CommandTreeSecondaryCommandBufferInstance,\n    CommandTreeTransferCommandInstance,\n    overrideDynamicState,\n    queryClusterInstanceDynamicState,\n    queryClusterInstanceDynamicStateBatched,\n    queryDispatchInstanceDynamicState,\n    queryDispatchInstanceDynamicStateBatched,\n    queryDrawInstanceDynamicState,\n    queryDrawInstanceDynamicStateBatched,\n    queryMeshTaskInstanceDynamicState,\n    queryMeshTaskInstanceDynamicStateBatched,\n    queryRaytracingInstanceDynamicState,\n    queryRaytracingInstanceDynamicStateBatched,\n    querySecondaryCommandBufferEndDynamicState,\n    QueryTreeDataOptions\n} from './command-tree-service';\nimport { LazyLoadableNode, triggerLazyLoadAndWaitForRemoval } from './lazy-load-utils';\nimport { CommandTreeDataQueriedRootProvider } from './providers/command-tree-root-provider';\n\n// Extension names\nconst VK_NV_COMMAND_BUFFER_INHERITANCE = 'VK_NV_command_buffer_inheritance';\nconst VK_NV_INHERITED_VIEWPORT_SCISSOR = 'VK_NV_inherited_viewport_scissor';\n\n/**\n * Helper type to make TreeNode.parent writable during node construction.\n * TreeNode.parent is readonly, but during tree construction we need to update it.\n */\ninterface MutableParent {\n    parent: CompositeTreeNode | undefined;\n}\n\n/**\n * Check if VK_NV_command_buffer_inheritance extension is enabled for a device.\n * This extension enables full state inheritance between command buffers and leak-back.\n */\nfunction hasCommandBufferInheritance(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_COMMAND_BUFFER_INHERITANCE) ?? false;\n}\n\n/**\n * Check if VK_NV_inherited_viewport_scissor extension is enabled for a device.\n * This extension enables limited viewport/scissor inheritance for secondary command buffers.\n */\nfunction hasInheritedViewportScissor(deviceExtensions: Set<string> | undefined): boolean {\n    return deviceExtensions?.has(VK_NV_INHERITED_VIEWPORT_SCISSOR) ?? false;\n}\n\n/**\n * Filter dynamic state to only viewport and scissor entries.\n * Used for VK_NV_inherited_viewport_scissor extension.\n */\nasync function filterDynamicStateForViewportScissor(statePromise: Promise<DynamicStateEntry[]>): Promise<DynamicStateEntry[]> {\n    const state = await statePromise;\n    return state.filter(entry => entry.stateType === StateType.VIEWPORT || entry.stateType === StateType.SCISSOR);\n}\n\n/**\n * Tracks dynamic state that may be updated as secondary command buffers execute\n * (when VK_NV_command_buffer_inheritance is enabled).\n */\nclass DynamicStateTracker {\n    private currentStatePromise: Promise<DynamicStateEntry[]>;\n\n    constructor(initialState: Promise<DynamicStateEntry[]>) {\n        this.currentStatePromise = initialState;\n    }\n\n    getCurrentState(): Promise<DynamicStateEntry[]> {\n        return this.currentStatePromise;\n    }\n\n    updateState(newState: Promise<DynamicStateEntry[]>): void {\n        this.currentStatePromise = newState;\n    }\n}\n\n/** Internal context for a command tree model.\n *\n * contains all the fixed data needed for the model,\n * e.g. services, etc.\n */\ninterface CommandTreeContext {\n    dbId: number;\n    data: CommandTreeDataWithFunctionAndDebugNames;\n    screenshotService: GfxrScreenshotService;\n    fileService: CompressedFileService;\n    profile: CaptureDatasetWidgetProfile;\n    context: CaptureDatasetWidgetContext;\n    tree: CommandTree;\n    gfxrQueryBuilderService: GFXRQueryBuilderService;\n    imageAccessorService: ImageAccessorService;\n    createDrawOrDispatchChildren: boolean;\n    rootNode: CommandRootNode;\n    deviceExtensions: Map<number, Set<string>>;\n}\n\n/**\n * Helper function to look up the debug name for an object at a specific API event.\n * Finds the most recent debug name that was set at or before the target API event.\n * @param debugNameLookup - Map of objectHandle to array of {apiEvent, name} sorted by apiEvent\n * @param objectHandle - The object handle to look up\n * @param targetApiEvent - The API event at which we want to know the object's name\n * @returns The debug name if found, undefined otherwise\n */\nfunction getDebugNameAtApiEvent(\n    debugNameLookup: Map<number, Array<{ apiEvent: number; name: string }>>,\n    objectHandle: number | null | undefined,\n    targetApiEvent: number\n): string | undefined {\n    if (typeof objectHandle !== 'number') {\n        return undefined;\n    }\n\n    const entries = debugNameLookup.get(objectHandle);\n    if (!entries || entries.length === 0) {\n        return undefined;\n    }\n\n    // Binary search for the most recent name at or before targetApiEvent\n    let left = 0;\n    let right = entries.length - 1;\n    let result: string | undefined = undefined;\n\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (entries[mid].apiEvent <= targetApiEvent) {\n            result = entries[mid].name;\n            left = mid + 1; // Look for a more recent name\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n\nexport interface CommandRootNode extends ResourceTreeNode<CommandTreeDataWithFunctionAndDebugNames>, CompositeTreeNode, ExpandableTreeNode {\n    resourceType: typeof CommandRootNode.RESOURCE_TYPE;\n    children: CommandFrameNode[];\n    dbId: number;\n    profile: CaptureDatasetWidgetProfile;\n    tree?: CommandTree; // Back-reference to the tree that owns this root\n    // Cached maps for queue debug labels to avoid rebuilding for each frame\n    queueDebugLabelGroupsBySubmitId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelGroupsByPresentId: Map<number, CommandTreeQueueDebugLabelGroup>;\n    queueDebugLabelInsertsByApiEvent: Map<number, CommandTreeQueueDebugLabelInsert>;\n}\n\nexport namespace CommandRootNode {\n    export const ID = 'sokatoa-command-tree-widget';\n\n    export const RESOURCE_TYPE = '__root__';\n\n    export function is(node: TreeNode | undefined): node is CommandRootNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRootNode.RESOURCE_TYPE);\n    }\n\n    export function create(\n        dbId: number,\n        data: CommandTreeDataWithFunctionAndDebugNames,\n        screenshotService: GfxrScreenshotService,\n        profile: CaptureDatasetWidgetProfile,\n        context: CaptureDatasetWidgetContext,\n        tree: CommandTree,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        imageAccessorService: ImageAccessorService,\n        fileService: CompressedFileService,\n        createDrawOrDispatchChildren: boolean,\n        deviceExtensions: Map<number, Set<string>>\n    ): CommandRootNode {\n        // Build maps for queue debug labels once for all frames\n        const queueDebugLabelGroupsBySubmitId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelGroupsByPresentId = new Map<number, CommandTreeQueueDebugLabelGroup>();\n        const queueDebugLabelInsertsByApiEvent = new Map<number, CommandTreeQueueDebugLabelInsert>();\n\n        for (const group of Object.values(data.queueDebugLabelGroups)) {\n            if (group) {\n                for (const submitId of group.queueSubmitIds) {\n                    queueDebugLabelGroupsBySubmitId.set(submitId, group);\n                }\n                for (const presentId of group.queuePresentIds) {\n                    queueDebugLabelGroupsByPresentId.set(presentId, group);\n                }\n            }\n        }\n\n        for (const insert of Object.values(data.queueDebugLabelInserts)) {\n            if (insert) {\n                queueDebugLabelInsertsByApiEvent.set(insert.apiEvent, insert);\n            }\n        }\n\n        const rootNode: CommandRootNode = {\n            visible: false,\n            id: CommandRootNode.ID,\n            name: 'ProfileTree',\n            parent: undefined,\n            expanded: true,\n            children: [],\n            resourceType: CommandRootNode.RESOURCE_TYPE,\n            resource: data,\n            dbId,\n            profile,\n            queueDebugLabelGroupsBySubmitId,\n            queueDebugLabelGroupsByPresentId,\n            queueDebugLabelInsertsByApiEvent\n        };\n        const ctx: CommandTreeContext = {\n            dbId,\n            data,\n            screenshotService,\n            fileService,\n            profile,\n            context,\n            tree,\n            gfxrQueryBuilderService,\n            imageAccessorService,\n            createDrawOrDispatchChildren,\n            rootNode,\n            deviceExtensions\n        };\n        const modelBuildStart = Date.now();\n        const frames = Object.values(data.frames);\n        rootNode.children = frames.flatMap(child => (child ? CommandFrameNode.create(ctx, child, rootNode) : []));\n        console.debug(`Model loaded in ${Date.now() - modelBuildStart} ms`);\n        return rootNode;\n    }\n}\n\nexport interface DebugMarker {\n    name: string;\n    color?: RGBA;\n}\n\nexport interface WithDebugMarker {\n    debugMarker?: DebugMarker;\n}\n\nexport namespace WithDebugMarker {\n    /** Type guard for a `node` that is or has a debug marker. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugMarker> {\n        return 'debugMarker' in node && node.debugMarker !== undefined;\n    }\n}\n\nexport interface WithDebugName {\n    debugName?: string;\n}\n\nexport namespace WithDebugName {\n    /** Type guard for a `node` that has a debug name. */\n    export function is(node: TreeNode): node is TreeNode & Required<WithDebugName> {\n        return 'debugName' in node && node.debugName !== undefined;\n    }\n}\n\ninterface LabelData {\n    labelName: string | undefined | null;\n    colorR: number | undefined | null;\n    colorG: number | undefined | null;\n    colorB: number | undefined | null;\n    colorA: number | undefined | null;\n}\n\nfunction setDebugMarkerData(node: WithDebugMarker, labelData: LabelData): void {\n    const name = labelData.labelName ?? 'Debug marker';\n    const color = {\n        r: (labelData.colorR ?? 1) * 255,\n        g: (labelData.colorG ?? 1) * 255,\n        b: (labelData.colorB ?? 1) * 255,\n        a: (labelData.colorA ?? 1) * 255\n    };\n\n    node.debugMarker = { name };\n    if (color.a !== 0 || color.b !== 0 || color.g !== 0 || color.r !== 0) {\n        node.debugMarker.color = color;\n    }\n}\n\nexport interface CommandFrameNode extends ResourceTreeNode<CommandTreeFrame>, ExpandableTreeNode, SelectableTreeNode {\n    label: string;\n    frameIndex: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandFrameNode.RESOURCE_TYPE;\n    thumbnail?: string;\n}\n\nexport namespace CommandFrameNode {\n    export const RESOURCE_TYPE = 'frame';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandFrameNode {\n        return ResourceTreeNode.hasResourceType(node, CommandFrameNode.RESOURCE_TYPE);\n    }\n\n    export function getId(frame: CommandTreeFrame): string {\n        return frame.frameIndex.toString();\n    }\n\n    export function create(ctx: CommandTreeContext, element: CommandTreeFrame, parent: CompositeTreeNode): CommandFrameNode {\n        const node: CommandFrameNode & SokatoaLifecycleTreeNode = {\n            id: getId(element),\n            frameIndex: element.frameIndex,\n            label: `Frame ${element.frameIndex}`,\n            children: [],\n            expanded: false,\n            selected: false,\n            parent,\n            resourceType: CommandFrameNode.RESOURCE_TYPE,\n            resource: element\n        };\n\n        const root = ctx.rootNode;\n\n        const children: CommandTreeNode[] = [];\n        let queueSubmitIndex = 0;\n        let queuePresentIndex = 0;\n        let accelerationStructureBuildIndex = 0;\n        let accelerationStructureCopyIndex = 0;\n\n        // Track current active debug label group and its children\n        let activeDebugLabelGroup: CommandTreeQueueDebugLabelGroup | undefined;\n        let activeGroupChildren: (CommandQueueSubmitNode | CommandQueuePresentNode)[] = [];\n        let queueDebugLabelGroupInstanceIndex = 0;\n\n        // Helper to finalize the active group and add it to children\n        const finalizeActiveGroup = (): void => {\n            if (activeDebugLabelGroup && activeGroupChildren.length > 0) {\n                children.push(\n                    CommandQueueDebugLabelGroupNode.create(\n                        ctx,\n                        activeDebugLabelGroup,\n                        node,\n                        activeGroupChildren,\n                        queueDebugLabelGroupInstanceIndex++\n                    )\n                );\n                activeDebugLabelGroup = undefined;\n                activeGroupChildren = [];\n            }\n        };\n\n        for (let id = element.beginApiEvent; id <= (element.endApiEvent ?? element.beginApiEvent); id++) {\n            // Check for queue debug label insert at this apiEvent\n            const queueDebugLabelInsert = root.queueDebugLabelInsertsByApiEvent.get(id);\n            if (queueDebugLabelInsert) {\n                // Inserts can appear in the middle of groups, so finalize any active group first\n                finalizeActiveGroup();\n                children.push(CommandQueueDebugLabelNode.create(ctx, queueDebugLabelInsert, node));\n            }\n\n            const apiEvent = root.resource.apiEvents[id];\n            if (apiEvent) {\n                if (apiEvent.submissionId && element.queueSubmitIds.includes(apiEvent.submissionId)) {\n                    const queueSubmit = root.resource.queueSubmits[apiEvent.submissionId];\n                    if (queueSubmit) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsBySubmitId.get(apiEvent.submissionId);\n\n                        // Check if this submit is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueueSubmitNode.create(ctx, queueSubmit, node, queueSubmitIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queueSubmit not found for submissionId ${apiEvent.submissionId}`);\n                    }\n                } else if (apiEvent.presentId && element.queuePresentIds.includes(apiEvent.presentId)) {\n                    const queuePresent = root.resource.queuePresents[apiEvent.presentId];\n                    if (queuePresent) {\n                        const debugLabelGroup = root.queueDebugLabelGroupsByPresentId.get(apiEvent.presentId);\n\n                        // Check if this present is within the group's apiEvent range\n                        const isInGroupRange =\n                            debugLabelGroup && id >= debugLabelGroup.beginApiEvent! && id <= debugLabelGroup.endApiEvent!;\n\n                        if (isInGroupRange) {\n                            // If starting a new group or switching groups, finalize the previous one\n                            if (activeDebugLabelGroup && activeDebugLabelGroup.labelId !== debugLabelGroup!.labelId) {\n                                finalizeActiveGroup();\n                            }\n                            // Add to active group\n                            activeDebugLabelGroup = debugLabelGroup;\n                            activeGroupChildren.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        } else {\n                            // Not in a group or outside group range, finalize any active group and add directly\n                            finalizeActiveGroup();\n                            children.push(CommandQueuePresentNode.create(ctx, queuePresent, node, queuePresentIndex++));\n                        }\n                    } else {\n                        console.warn(`CommandFrameNode.create: queuePresent not found for presentId ${apiEvent.presentId}`);\n                    }\n                } else if (\n                    apiEvent.accelerationStructureBuildInstanceId &&\n                    element.accelerationStructureBuildIds.includes(apiEvent.accelerationStructureBuildInstanceId)\n                ) {\n                    // Acceleration structure builds interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureBuild =\n                        root.resource.topLevelAccelerationStructureBuilds[apiEvent.accelerationStructureBuildInstanceId];\n                    if (accelerationStructureBuild) {\n                        children.push(\n                            CommandAccelerationStructureBuildNode.create(\n                                accelerationStructureBuild,\n                                node,\n                                accelerationStructureBuildIndex++\n                            )\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureBuildInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureBuild not found for accelerationStructureBuildInstanceId ${iId}`\n                        );\n                    }\n                } else if (\n                    apiEvent.accelerationStructureCopyInstanceId &&\n                    element.accelerationStructureCopyIds.includes(apiEvent.accelerationStructureCopyInstanceId)\n                ) {\n                    // Acceleration structure copies interrupt debug label groups\n                    finalizeActiveGroup();\n\n                    const accelerationStructureCopy =\n                        root.resource.topLevelAccelerationStructureCopies[apiEvent.accelerationStructureCopyInstanceId];\n                    if (accelerationStructureCopy) {\n                        children.push(\n                            CommandAccelerationStructureCopyNode.create(accelerationStructureCopy, node, accelerationStructureCopyIndex++)\n                        );\n                    } else {\n                        const iId = apiEvent.accelerationStructureCopyInstanceId;\n                        console.warn(\n                            `CommandFrameNode.create: accelerationStructureCopy not found for accelerationStructureCopyInstanceId ${iId}`\n                        );\n                    }\n                }\n            }\n        }\n\n        // Finalize any remaining active debug label group at the end\n        finalizeActiveGroup();\n\n        node.children = children;\n\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        const request: ThumbnailRequestOptions = {\n            profileOrReplay: replay ?? ctx.profile,\n            startFrame: element.frameIndex,\n            endFrame: element.frameIndex,\n            requesterDbgName: `Command tree frame ${element.frameIndex}`,\n            onScreenshotReady: result => {\n                ctx.imageAccessorService\n                    .accessImage(new URL(URI.fromFilePath(result.path).toString()))\n                    .then(url => {\n                        node.thumbnail = url.url.toString();\n                        ctx.tree.addToDispose(url);\n                        void ctx.tree.refresh(node);\n                    })\n                    .catch(reason => {\n                        const error = asError(reason);\n                        console.error(error);\n                    });\n            },\n            onRequestComplete: (success, message) => {\n                if (!success) {\n                    console.error(`Request for frame thumbnails failed: ${message}`);\n                }\n            }\n        };\n        const onWillRender = (): void => {\n            requestThumbnails(ctx.screenshotService, request);\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', onWillRender);\n        };\n        SokatoaLifecycleTreeNode.register(node, 'onWillRender', onWillRender);\n        return node;\n    }\n\n    /**\n     * Retrieve the `CommandFrameNode` that is or contains the given `node`.\n     * Returns `undefined` in the case that the `node` is an ancestor of or\n     * otherwise not contained in an `CommandFrameNode`.\n     */\n    export function getCommandFrameNodeContaining(node: TreeNode): CommandFrameNode | undefined {\n        return CommandFrameNode.is(node) ? node : node.parent ? CommandFrameNode.getCommandFrameNodeContaining(node.parent) : undefined;\n    }\n}\n\nexport interface CommandEmptyNode extends LazyLoadableNode {\n    label: string;\n}\n\nexport namespace CommandEmptyNode {\n    export const GENERALIZED_TYPE = 'empty';\n\n    export function is(node: unknown): node is CommandEmptyNode {\n        return TreeNode.is(node) && node.id.endsWith('_empty');\n    }\n\n    export function getId(parent: CompositeTreeNode): string {\n        return `${parent.id}_empty`;\n    }\n\n    export function create(parent: CompositeTreeNode, load: CommandEmptyNode['load']): CommandEmptyNode {\n        return {\n            id: getId(parent),\n            label: 'Loading...',\n            parent,\n            load\n        };\n    }\n}\n\nexport interface CommandApiEventNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandApiEventNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandApiEventNode {\n    export const RESOURCE_TYPE = 'api-event';\n    export const GENERALIZED_TYPE = RESOURCE_TYPE;\n\n    export function is(node: TreeNode | undefined): node is CommandApiEventNode {\n        return ResourceTreeNode.hasResourceType(node, CommandApiEventNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEventId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex?: number\n    ): CommandApiEventNode {\n        const root = ctx.rootNode;\n        const node: CommandApiEventNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEventId,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex ?? ''}`,\n            parent,\n            resourceType: CommandApiEventNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId,\n            selected: false\n        };\n        // set debug marker data if node is a debug marker\n        if (element.debugLabelId) {\n            const labelData = root.resource.debugLabels[element.debugLabelId];\n            if (labelData) {\n                setDebugMarkerData(node, labelData);\n            }\n        }\n        return node;\n    }\n}\n\nexport interface CommandDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeDebugLabelGroupInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'debug-label-group';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDebugLabelGroupInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDebugLabelGroupInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDebugLabelGroupNode = {\n            id: getId(element, parent),\n            debugLabelInstanceId: element.labelId,\n            label: `${root.resource.functionNameLookup[element.functionNameId ?? -1] ?? '<not defined>'}`,\n            parent,\n            resourceType: CommandDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this debug label range\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this debug label group, add it to array\n            // - not self\n            // - only commands with same command buffer id\n            if (event && event.debugLabelId !== element.labelId && event.commandBufferInstanceId === element.commandBufferInstance) {\n                apiEventCommandArray.push(event);\n            }\n        }\n        // get array of debug label ranges with api event numbers within this debug label range\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this debug label range\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderPassInstance'\n        );\n        // get array of render subpass ranges with api event numbers within this debug label range\n        const renderSubpassInstances = createRangeInstanceArray(\n            element.renderSubpassInstanceIds,\n            root.resource.renderSubpassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'RenderSubpassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this debug label range\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandDebugLabelGroupNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('subpassIndex' in rangeElement) {\n                    const renderSubpassInstanceNode = CommandRenderSubpassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(renderSubpassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        baseDynamicStatePromise\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            renderSubpassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for debug label group:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `debug label group ${element.labelId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelGroupNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelGroup>, SelectableTreeNode, ExpandableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueDebugLabelGroupNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelGroupNode {\n    export const RESOURCE_TYPE = 'queue-debug-label-group';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelGroupNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelGroupNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelGroup, parent: CompositeTreeNode, instanceIndex: number): string {\n        return `${parent.id}_qdl_group_${element.labelId}_${instanceIndex}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelGroup,\n        parent: CompositeTreeNode,\n        children: (CommandQueueSubmitNode | CommandQueuePresentNode)[],\n        instanceIndex: number\n    ): CommandQueueDebugLabelGroupNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelGroupNode = {\n            id: getId(element, parent, instanceIndex),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label Group',\n            queue: element.queue!,\n            parent,\n            resourceType: CommandQueueDebugLabelGroupNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        // Update parent references for children since they were created with a different parent\n        // and are now being reparented to this debug label group node\n        for (const child of children) {\n            // Cast away readonly to update parent during node construction\n            (child as MutableParent).parent = node;\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandQueueDebugLabelNode\n    extends ResourceTreeNode<CommandTreeQueueDebugLabelInsert>, SelectableTreeNode, WithDebugMarker {\n    label: string;\n    debugLabelId: number;\n    queue: number;\n    apiEventId: number;\n    resourceType: typeof CommandQueueDebugLabelNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueDebugLabelNode {\n    export const RESOURCE_TYPE = 'queue-debug-label';\n    export const GENERALIZED_TYPE = 'queue-debug-label';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueDebugLabelNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueDebugLabelNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueDebugLabelInsert, parent: CompositeTreeNode): string {\n        return `${parent.id}_qdl_${element.labelId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueDebugLabelInsert,\n        parent: CompositeTreeNode\n    ): CommandQueueDebugLabelNode {\n        const root = ctx.rootNode;\n\n        const node: CommandQueueDebugLabelNode = {\n            id: getId(element, parent),\n            debugLabelId: element.labelId!,\n            label: element.labelName ?? 'Queue Debug Label',\n            queue: element.queue!,\n            apiEventId: element.apiEvent,\n            parent,\n            resourceType: CommandQueueDebugLabelNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false\n        };\n\n        // set debug marker data in node\n        const labelData = root.resource.debugLabels[element.labelId!];\n        if (labelData) {\n            setDebugMarkerData(node, labelData);\n        }\n\n        return node;\n    }\n}\n\nexport interface CommandCommandBufferInstanceNode\n    extends ResourceTreeNode<CommandTreeCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    commandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandCommandBufferInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandCommandBufferInstanceNode {\n    export const RESOURCE_TYPE = 'command-buffer-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandCommandBufferInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandCommandBufferInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeCommandBufferInstance,\n        parent: CompositeTreeNode,\n        commandBufferIndex: number,\n        baseDynamicStatePromise?: Promise<DynamicStateEntry[]>\n    ): CommandCommandBufferInstanceNode {\n        const node: CommandCommandBufferInstanceNode = {\n            id: getId(element, parent),\n            commandBufferInstanceId: element.instanceId,\n            label: `Command Buffer ${commandBufferIndex}`,\n            parent,\n            resourceType: CommandCommandBufferInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this command buffer\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this command buffer, add it to array\n            // - omit commands that reference render pass id\n            // - if api event is a debug label, check the debug label itself for a render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                event.commandBufferInstanceId === element.instanceId &&\n                event.renderPassInstanceId === undefined &&\n                event.dynamicRenderPassInstanceId === undefined &&\n                (event.debugLabelId === undefined ||\n                    (debugLabel?.beginApiEvent === event.apiEventId &&\n                        debugLabel?.beginRenderPassInstance === undefined &&\n                        debugLabel?.beginDynamicRenderPassInstance === undefined) ||\n                    (debugLabel?.endApiEvent === event.apiEventId &&\n                        debugLabel?.endRenderPassInstance === undefined &&\n                        debugLabel?.endDynamicRenderPassInstance === undefined))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this command buffer\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n        // get array of render pass ranges with api event numbers within this command buffer\n        const renderPassInstances = createRangeInstanceArray(\n            element.renderPassInstanceIds,\n            root.resource.renderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'RenderPassInstance'\n        );\n        // get array of dynamic render pass ranges with api event numbers within this command buffer\n        const dynamicRenderPassInstances = createRangeInstanceArray(\n            element.dynamicRenderPassInstanceIds,\n            root.resource.dynamicRenderPassInstances,\n            'CommandCommandBufferInstanceNode.create',\n            'DynamicRenderSubpassInstance'\n        );\n\n        const emptyDynamicStatePromise = new Promise<DynamicStateEntry[]>(resolve => resolve([]));\n        const effectiveBaseState = baseDynamicStatePromise ?? emptyDynamicStatePromise;\n\n        createChildEventNodesForRange<AllRangeTypes>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            effectiveBaseState,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(debugLabelGroupNode);\n                } else if ('passIndex' in rangeElement) {\n                    const renderPassInstanceNode = CommandRenderPassInstanceNode.create(ctx, rangeElement, parentNode, effectiveBaseState);\n                    parentNode.children.push(renderPassInstanceNode);\n                } else if ('dynamicPassIndex' in rangeElement) {\n                    const dynamicRenderPassInstanceNode = CommandDynamicRenderPassInstanceNode.create(\n                        ctx,\n                        rangeElement,\n                        parentNode,\n                        effectiveBaseState\n                    );\n                    parentNode.children.push(dynamicRenderPassInstanceNode);\n                }\n            },\n            debugLabelGroupInstances,\n            renderPassInstances,\n            dynamicRenderPassInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for command buffer:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, `command buffer ${commandBufferIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandSecondaryCommandBufferExecutionNode\n    extends ResourceTreeNode<CommandTreeSecondaryCommandBufferInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    parentCommandBufferInstanceId: number;\n    secondaryCommandBufferInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n}\n\nexport namespace CommandSecondaryCommandBufferExecutionNode {\n    export const RESOURCE_TYPE = 'secondary-command-buffer-execution';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: unknown): node is CommandSecondaryCommandBufferExecutionNode {\n        return (\n            ExpandableTreeNode.is(node) && SelectableTreeNode.is(node) && ResourceTreeNode.is(node, 'secondary-command-buffer-execution')\n        );\n    }\n\n    export function getId(element: CommandTreeSecondaryCommandBufferInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_secondary_${element.secondaryCommandBufferInstance}_${element.executionId}_${element.executionIndex}`;\n    }\n\n    export async function create(\n        ctx: CommandTreeContext,\n        elements: CommandTreeSecondaryCommandBufferInstance[],\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n        stateTracker?: DynamicStateTracker\n    ): Promise<CommandSecondaryCommandBufferExecutionNode> {\n        if (elements.length === 0) {\n            throw new Error('elements array must not be empty');\n        }\n        // Use the first element for the node's resource (they all share the same executionId and apiEvent)\n        const element = elements[0];\n        const node: CommandSecondaryCommandBufferExecutionNode = {\n            id: getId(element, parent),\n            parentCommandBufferInstanceId: element.parentCommandBufferInstance || 0,\n            secondaryCommandBufferInstanceId: element.secondaryCommandBufferInstance || 0,\n            label: `Secondary Command Buffer Execution ${commandIndex}`,\n            parent,\n            resourceType: 'secondary-command-buffer-execution',\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        createLazyLoadingNode(ctx.tree, node, async () => {\n            // Sort elements by executionIndex to maintain proper order\n            const sortedElements = [...elements].sort((a, b) => (a.executionIndex || 0) - (b.executionIndex || 0));\n\n            // Get device and check extensions\n            const firstSecondary = sortedElements[0]?.secondaryCommandBufferInstance;\n            let deviceExtensions: Set<string> | undefined;\n\n            if (firstSecondary !== undefined) {\n                const commandBufferInstance = root.resource.commandBufferInstances[firstSecondary];\n                const device = commandBufferInstance?.device;\n                if (typeof device === 'number') {\n                    deviceExtensions = ctx.deviceExtensions.get(device);\n                }\n            }\n\n            const hasInheritance = hasCommandBufferInheritance(deviceExtensions);\n            const hasViewportScissorOnly = hasInheritedViewportScissor(deviceExtensions) && !hasInheritance;\n\n            // Calculate effective base state for INHERITANCE INTO secondary\n            let effectiveBaseState: Promise<DynamicStateEntry[]>;\n            if (hasInheritance) {\n                effectiveBaseState = baseDynamicStatePromise;\n            } else if (hasViewportScissorOnly) {\n                effectiveBaseState = filterDynamicStateForViewportScissor(baseDynamicStatePromise);\n            } else {\n                effectiveBaseState = Promise.resolve([]);\n            }\n\n            // Create a CommandCommandBufferInstanceNode for each secondary command buffer in the execution\n            const childNodes: CommandCommandBufferInstanceNode[] = [];\n            sortedElements.forEach((secondaryInstance, index) => {\n                if (secondaryInstance.secondaryCommandBufferInstance) {\n                    const commandBufferInstance = root.resource.commandBufferInstances[secondaryInstance.secondaryCommandBufferInstance];\n                    if (commandBufferInstance) {\n                        const childNode = CommandCommandBufferInstanceNode.create(\n                            ctx,\n                            commandBufferInstance,\n                            node,\n                            index,\n                            effectiveBaseState\n                        );\n                        childNodes.push(childNode);\n                    } else {\n                        console.warn(\n                            `Command buffer instance ${secondaryInstance.secondaryCommandBufferInstance} ` +\n                                'not found in root.resource.commandBufferInstances'\n                        );\n                    }\n                }\n            });\n            CompositeTreeNode.addChildren(node, childNodes);\n\n            // Handle LEAK-BACK: Update parent's state tracker if extension is enabled\n            if (hasInheritance && stateTracker && element.executionId) {\n                const db = ctx.gfxrQueryBuilderService.builderFor(ctx.dbId);\n                const endStatePromise = querySecondaryCommandBufferEndDynamicState(db, [element.executionId]);\n                stateTracker.updateState(endStatePromise);\n            }\n        });\n\n        // Register for thumbnail updates\n        registerThumbnailUpdate(ctx, node, `secondary command buffer execution ${node.resource.executionId}`);\n        return node;\n    }\n}\n\nexport interface CommandQueueSubmitNode\n    extends ResourceTreeNode<CommandTreeQueueSubmit>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    submissionId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandQueueSubmitNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueueSubmitNode {\n    export const RESOURCE_TYPE = 'queue-submit';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueueSubmitNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueueSubmitNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueueSubmit, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.submissionId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueueSubmit,\n        parent: CompositeTreeNode,\n        queueSubmitIndex: number\n    ): CommandQueueSubmitNode {\n        const root = ctx.rootNode;\n        const node: CommandQueueSubmitNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            threadId: element.threadId || 0,\n            submissionId: element.submissionId,\n            label: `Queue Submit ${queueSubmitIndex}`,\n            queue: element.queue,\n            parent,\n            resourceType: CommandQueueSubmitNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            thumbnail: undefined,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        const children =\n            element.queueSubmitBuffers\n                ?.filter(b => b.commandBufferInstance)\n                .flatMap(b => {\n                    const instance = root.resource.commandBufferInstances[b.commandBufferInstance!];\n                    if (!instance) {\n                        console.warn(`CommandQueueSubmitNode.create: commandBufferInstance not found for id ${b.commandBufferInstance}`);\n                        return [];\n                    }\n                    return instance;\n                }) ?? [];\n        let commandBufferIndex = 0;\n        node.children = children.map(child => CommandCommandBufferInstanceNode.create(ctx, child, node, commandBufferIndex++));\n\n        registerThumbnailUpdate(ctx, node, `queue submit ${queueSubmitIndex}`);\n\n        return node;\n    }\n}\n\nexport interface CommandQueuePresentNode extends ResourceTreeNode<CommandTreeQueuePresent>, SelectableTreeNode, WithDebugName {\n    label: string;\n    apiEventId: number;\n    threadId: number;\n    queue: number;\n    resourceType: typeof CommandQueuePresentNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandQueuePresentNode {\n    export const RESOURCE_TYPE = 'queue-present';\n    export const GENERALIZED_TYPE = 'queue';\n\n    export function is(node: TreeNode | undefined): node is CommandQueuePresentNode {\n        return ResourceTreeNode.hasResourceType(node, CommandQueuePresentNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeQueuePresent, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.apiEvent}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeQueuePresent,\n        parent: CompositeTreeNode,\n        queuePresentIndex: number\n    ): CommandQueuePresentNode {\n        const root = ctx.rootNode;\n        const node: CommandQueuePresentNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            apiEventId: element.apiEvent,\n            label: `Queue Present ${queuePresentIndex}`,\n            parent,\n            resourceType: CommandQueuePresentNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            queue: element.queue,\n            selected: false\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.apiEvent);\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureBuildNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureBuildInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    buildInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureBuildNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureBuildNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-build';\n    export const GENERALIZED_TYPE = 'acceleration-structure-build';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureBuildNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureBuildNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureBuildInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.buildApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureBuildInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureBuildNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureBuildNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            buildInstanceId: element.instanceId,\n            apiEventId: element.buildApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureBuildNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandAccelerationStructureCopyNode\n    extends ResourceTreeNode<CommandTreeAccelerationStructureCopyInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    copyInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandAccelerationStructureCopyNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandAccelerationStructureCopyNode {\n    export const RESOURCE_TYPE = 'acceleration-structure-copy';\n    export const GENERALIZED_TYPE = 'acceleration-structure-copy';\n\n    export function is(node: TreeNode | undefined): node is CommandAccelerationStructureCopyNode {\n        return ResourceTreeNode.hasResourceType(node, CommandAccelerationStructureCopyNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeAccelerationStructureCopyInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.copyApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeAccelerationStructureCopyInstance,\n        parent: CompositeTreeNode,\n        buildIndex: number\n    ): CommandAccelerationStructureCopyNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandAccelerationStructureCopyNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            copyInstanceId: element.instanceId,\n            apiEventId: element.copyApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${buildIndex}`,\n            parent,\n            resourceType: CommandAccelerationStructureCopyNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nexport interface CommandTransferCommandNode\n    extends ResourceTreeNode<CommandTreeTransferCommandInstance>, SelectableTreeNode, WithDebugMarker, WithDebugName {\n    label: string;\n    transferCommandInstanceId: number;\n    apiEventId: number;\n    threadId: number;\n    resourceType: typeof CommandTransferCommandNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandTransferCommandNode {\n    export const RESOURCE_TYPE = 'transfer-command';\n    export const GENERALIZED_TYPE = 'transfer-command';\n\n    export function is(node: TreeNode | undefined): node is CommandTransferCommandNode {\n        return ResourceTreeNode.hasResourceType(node, CommandTransferCommandNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeTransferCommandInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.transferApiEvent}`;\n    }\n\n    export function create(\n        element: CommandTreeTransferCommandInstance,\n        parent: CompositeTreeNode,\n        transferCommandIndex: number\n    ): CommandTransferCommandNode {\n        const root = CommandTreeNode.getRoot(parent);\n        if (!root) {\n            throw new Error('Failed to retrieve command tree root node');\n        }\n        const node: CommandTransferCommandNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            transferCommandInstanceId: element.instanceId,\n            apiEventId: element.transferApiEvent,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${transferCommandIndex}`,\n            parent,\n            resourceType: CommandTransferCommandNode.RESOURCE_TYPE,\n            resource: element,\n            threadId: element.threadId || 0,\n            selected: false\n        };\n\n        return node;\n    }\n}\n\nfunction setThumbnailUrl(\n    ctx: CommandTreeContext,\n    resources: ApiResources[],\n    node: TreeNode & { thumbnail?: string },\n    requesterDbgName: string\n): void {\n    if (resources.length > 0) {\n        const replay = CaptureDatasetWidgetReplayContext.getReplay(ctx.profile, ctx.context);\n        ctx.screenshotService.requestScreenshots({\n            profileOrReplay: replay ?? ctx.profile,\n            scale: placeholderScale,\n            screenshotType: ScreenshotType.API_EVENT,\n            requestData: resources,\n            moreRequests: true,\n            requesterDbgName,\n            options: {\n                DumpDepth: true\n            },\n            onScreenshotReady: result => {\n                if (result.resultData.resultType === ScreenshotType.API_EVENT && DrawApiResult.is(result.resultData.apiResult)) {\n                    const images = [...(result.resultData.apiResult.colorAttachments || [])];\n                    if (result.resultData.apiResult.depthAttachment) {\n                        images.push(result.resultData.apiResult.depthAttachment);\n                    }\n                    if (images.length > 0) {\n                        const possibleImage = images[0].subresources?.[0];\n                        if (possibleImage) {\n                            if (usesCompressionExtension(possibleImage.file)) {\n                                // Use VkImageConversionService to get a png\n                                // Do the same as the else case, but with the new png file\n                                const format = lookupResourceFormat(images[0].format);\n                                if (UncompressedResourceFormat.is(format)) {\n                                    ctx.fileService\n                                        .read(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString(), {\n                                            uncompressedSize: possibleImage.size\n                                        })\n                                        .then(async content => {\n                                            const extractedData = await extractData(format, content);\n                                            const dim = {\n                                                width: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[0]\n                                                    : possibleImage.dimensions[0] * placeholderScale,\n                                                height: images[0].scaleFailed\n                                                    ? possibleImage.dimensions[1]\n                                                    : possibleImage.dimensions[1] * placeholderScale\n                                            };\n                                            const conversionResult = await convertDataToImageData(extractedData, format, dim, {\n                                                channelOptions: { alpha: { disabled: true } }\n                                            });\n                                            const png = new PNG({\n                                                width: conversionResult.dimensions.width,\n                                                height: conversionResult.dimensions.height\n                                            });\n                                            png.data = conversionResult.data;\n                                            const pngBuffer = PNG.sync.write(png);\n                                            node.thumbnail = `data:image/png;base64, ${pngBuffer.toString('base64')}`;\n                                            void ctx.tree.refresh(node.parent);\n                                        })\n                                        .catch(reason => {\n                                            const error = asError(reason);\n                                            console.error(error);\n                                        });\n                                }\n                            } else {\n                                ctx.imageAccessorService\n                                    .accessImage(new URL(URI.fromFilePath(result.path + Path.separator + possibleImage.file).toString()))\n                                    .then(url => {\n                                        node.thumbnail = url.url.toString();\n                                        ctx.tree.addToDispose(url);\n                                        void ctx.tree.refresh(node.parent);\n                                    })\n                                    .catch(reason => {\n                                        const error = asError(reason);\n                                        console.error(error);\n                                    });\n                            }\n                        }\n                    }\n                }\n            },\n            onRequestComplete: (result, message) => {\n                if (!result) {\n                    console.error(message);\n                }\n            }\n        });\n    }\n}\n\n/**\n * Registers a thumbnail update callback that triggers on the node's first render.\n * When triggered, finds the last draw instance and requests a screenshot for it.\n *\n * @param ctx - Command tree context\n * @param node - Node to register thumbnail update for\n * @param descriptionContext - Description for the requester debug name (e.g., \"render pass 5\", \"dynamic render pass\")\n */\nfunction registerThumbnailUpdate(\n    ctx: CommandTreeContext,\n    node: CommandTreeNode & { thumbnail?: string },\n    descriptionContext: string\n): void {\n    const updateThumbnail = (): void => {\n        const lastDraw = findLastDrawInstanceNode(node);\n        if (lastDraw) {\n            SokatoaLifecycleTreeNode.unregister(node, 'onWillRender', updateThumbnail);\n            const requesterDbgName = `Command tree ${descriptionContext} last draw: ${lastDraw.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(lastDraw), node, requesterDbgName);\n        }\n    };\n    SokatoaLifecycleTreeNode.register(node, 'onWillRender', updateThumbnail);\n}\n\nexport interface CommandRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    renderPassInstanceId: number;\n    renderPassId?: number;\n    renderSubpassEventIds: number[];\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderPassInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.instanceId,\n            renderPassId: element.renderPass,\n            renderSubpassEventIds: [],\n            label: `Render Pass ${element.passIndex}`,\n            parent,\n            resourceType: CommandRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        // set debug name if node has one\n        node.debugName = getDebugNameAtApiEvent(root.resource.debugNameLookup, element.objectHandle, element.beginApiEvent);\n\n        // A render pass will only contain render subpasses and will always contain at least one subpass\n        const renderSubpassInstances = element.renderSubpassInstanceIds.flatMap(id => {\n            const instance = root.resource.renderSubpassInstances[id];\n            if (!instance) {\n                console.warn(`CommandRenderPassInstanceNode.create: renderSubpassInstance not found for id ${id}`);\n                return [];\n            }\n            return instance;\n        });\n        renderSubpassInstances.forEach(subpass => {\n            if (subpass.beginApiEvent !== node.resource.beginApiEvent) {\n                node.renderSubpassEventIds.push(subpass.beginApiEvent);\n            }\n        });\n        node.children.push(\n            ...renderSubpassInstances.map(instance => {\n                const subpassNode = CommandRenderSubpassInstanceNode.create(ctx, instance, node, baseDynamicStatePromise);\n                return subpassNode;\n            })\n        );\n\n        registerThumbnailUpdate(ctx, node, `render pass ${node.renderPassId}`);\n\n        return node;\n    }\n}\n\nexport interface CommandRenderSubpassInstanceNode\n    extends ResourceTreeNode<CommandTreeRenderSubpassInstance>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    renderPassInstanceId: number;\n    renderSubpassInstanceId: number;\n    renderSubpassIndex: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandRenderSubpassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandRenderSubpassInstanceNode {\n    export const RESOURCE_TYPE = 'render-subpass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandRenderSubpassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRenderSubpassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeRenderSubpassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeRenderSubpassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRenderSubpassInstanceNode {\n        const node: CommandRenderSubpassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            renderPassInstanceId: element.renderPassInstance,\n            renderSubpassInstanceId: element.instanceId,\n            renderSubpassIndex: element.subpassIndex,\n            label: `Subpass ${element.subpassIndex}`,\n            parent,\n            resourceType: CommandRenderSubpassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this render subpass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference render subpass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a render subpass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.renderSubpassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginRenderSubpassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endRenderSubpassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this render subpass\n        const debugLabelGroupInstances = {\n            array: element.debugLabelGroupInstanceIds.flatMap(id => {\n                const result = root.resource.debugLabelGroupInstances[id];\n                if (!result) {\n                    console.warn(`Missing debugLabelGroupInstances for ${id}.`);\n                    return [];\n                }\n                return result;\n            }),\n            getSortNumber: (debugLabelGroupInstance: CommandTreeDebugLabelGroupInstance) => debugLabelGroupInstance.beginApiEvent\n        };\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'render subpass');\n\n        return node;\n    }\n}\n\nexport interface CommandDynamicRenderPassInstanceNode\n    extends ResourceTreeNode<CommandTreeDynamicRenderPassInstance>, SelectableTreeNode, ExpandableTreeNode, WithDebugName {\n    label: string;\n    dynamicRenderPassInstanceId: number;\n    dynamicRenderPassId?: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE;\n}\n\nexport namespace CommandDynamicRenderPassInstanceNode {\n    export const RESOURCE_TYPE = 'dynamic-render-pass-instance';\n    export const GENERALIZED_TYPE = 'range';\n\n    export function is(node: TreeNode | undefined): node is CommandDynamicRenderPassInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeDynamicRenderPassInstance, parent: CompositeTreeNode): string {\n        return `${parent.id}_${element.instanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeDynamicRenderPassInstance,\n        parent: CompositeTreeNode,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDynamicRenderPassInstanceNode {\n        const node: CommandDynamicRenderPassInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dynamicRenderPassInstanceId: element.instanceId,\n            label: `Dynamic Render Pass ${element.dynamicPassIndex}`,\n            parent,\n            resourceType: CommandDynamicRenderPassInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: []\n        };\n\n        const root = ctx.rootNode;\n\n        const end = element.endApiEvent ?? element.beginApiEvent;\n        // get array of commands with api event numbers within this dynamic render pass\n        const apiEventCommandArray: CommandTreeApiEvent[] = [];\n        for (let i = element.beginApiEvent + 1; i < end; i++) {\n            const event = root.resource.apiEvents[i];\n            // if this api event is within this dynamic render pass, add it to array\n            // - draw/dispatch/mesh/cluster/raytracing/tracked commands reference dynamic render pass id in the api event itself\n            // - if api event is a debug label, check the debug label itself for a dynamic render pass id\n            const debugLabel = typeof event?.debugLabelId === 'number' ? root.resource.debugLabels[event.debugLabelId] : undefined;\n            if (\n                event &&\n                (event.dynamicRenderPassInstanceId === element.instanceId ||\n                    (debugLabel?.beginApiEvent === event.apiEventId && debugLabel?.beginDynamicRenderPassInstance === element.instanceId) ||\n                    (debugLabel?.endApiEvent === event.apiEventId && debugLabel?.endDynamicRenderPassInstance === element.instanceId))\n            ) {\n                apiEventCommandArray.push(event);\n            }\n        }\n\n        // get array of debug label ranges with api event numbers within this dynamic render pass\n        const debugLabelGroupInstances = createRangeInstanceArray(\n            element.debugLabelGroupInstanceIds,\n            root.resource.debugLabelGroupInstances,\n            'CommandDynamicRenderPassInstanceNode.create',\n            'DebugLabelGroupInstance'\n        );\n\n        createChildEventNodesForRange<CommandTreeDebugLabelGroupInstance>(\n            ctx,\n            root,\n            node,\n            apiEventCommandArray,\n            0,\n            baseDynamicStatePromise,\n            (rangeElement, parentNode) => {\n                if ('labelId' in rangeElement) {\n                    const debugLabelGroupNode = CommandDebugLabelGroupNode.create(ctx, rangeElement, parentNode, baseDynamicStatePromise);\n                    parentNode.children.push(debugLabelGroupNode);\n                }\n            },\n            debugLabelGroupInstances\n        )\n            .then(() => {\n                // Children populated asynchronously\n            })\n            .catch(error => {\n                console.error('Error creating child event nodes for render pass:', error);\n            });\n\n        registerThumbnailUpdate(ctx, node, 'dynamic render pass');\n\n        return node;\n    }\n}\n\nasync function createChildEventNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    stateTracker: DynamicStateTracker\n): Promise<number> {\n    let endCommandIndex = commandIndex;\n    const baseDynamicStatePromise = stateTracker.getCurrentState();\n\n    if (command.secondaryCommandBufferExecutionId) {\n        // Look up the execution to get the apiEvent, which is the key for secondaryCommandBufferInstances\n        const execution = root.resource.secondaryCommandBufferExecutions[command.secondaryCommandBufferExecutionId];\n        if (execution) {\n            const secondaryInstances = root.resource.secondaryCommandBufferInstances[execution.apiEvent];\n            if (secondaryInstances && secondaryInstances.length > 0) {\n                const node = await CommandSecondaryCommandBufferExecutionNode.create(\n                    ctx,\n                    secondaryInstances,\n                    parentNode,\n                    endCommandIndex++,\n                    baseDynamicStatePromise,\n                    stateTracker\n                );\n                parentNode.children.push(node);\n            }\n        }\n    } else {\n        endCommandIndex = createDrawOrDispatchChildNode(ctx, command, root, parentNode, commandIndex, baseDynamicStatePromise);\n    }\n    return endCommandIndex;\n}\n\nfunction createDrawOrDispatchChildNode(\n    ctx: CommandTreeContext,\n    command: CommandTreeApiEvent,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    commandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n): number {\n    let currentCommandIndex = commandIndex;\n    let accelerationStructureBuildIndex = 0;\n    let accelerationStructureCopyIndex = 0;\n    if (command) {\n        if (command.drawInstanceId && root.resource.drawInstances[command.drawInstanceId]) {\n            parentNode.children.push(\n                CommandDrawInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.dispatchInstanceId && root.resource.dispatchInstances[command.dispatchInstanceId]) {\n            parentNode.children.push(\n                CommandDispatchInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.meshTaskInstanceId && root.resource.meshTaskInstances[command.meshTaskInstanceId]) {\n            parentNode.children.push(\n                CommandMeshTaskInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.clusterInstanceId && root.resource.clusterInstances[command.clusterInstanceId]) {\n            parentNode.children.push(\n                CommandClusterInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (command.raytracingInstanceId && root.resource.raytracingInstances[command.raytracingInstanceId]) {\n            parentNode.children.push(\n                CommandRaytracingInstanceNode.create(ctx, command, parentNode, currentCommandIndex++, baseDynamicStatePromise)\n            );\n        } else if (\n            command.accelerationStructureBuildInstanceId &&\n            root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureBuildNode.create(\n                    root.resource.inlineAccelerationStructureBuilds[command.accelerationStructureBuildInstanceId]!,\n                    parentNode,\n                    accelerationStructureBuildIndex++\n                )\n            );\n        } else if (\n            command.accelerationStructureCopyInstanceId &&\n            root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]\n        ) {\n            parentNode.children.push(\n                CommandAccelerationStructureCopyNode.create(\n                    root.resource.inlineAccelerationStructureCopies[command.accelerationStructureCopyInstanceId]!,\n                    parentNode,\n                    accelerationStructureCopyIndex++\n                )\n            );\n        } else if (command.transferCommandInstanceId && root.resource.transferCommands[command.transferCommandInstanceId]) {\n            parentNode.children.push(\n                CommandTransferCommandNode.create(\n                    root.resource.transferCommands[command.transferCommandInstanceId]!,\n                    parentNode,\n                    currentCommandIndex++\n                )\n            );\n        } else if (command.debugLabelId && root.resource.debugLabels[command.debugLabelId]) {\n            // Only add debug label nodes if this is the BEGIN event (not END event)\n            // The END event has debugLabelId set but should not create a node\n            const debugLabel = root.resource.debugLabels[command.debugLabelId];\n            if (debugLabel && debugLabel.beginApiEvent === command.apiEventId) {\n                // Check if this is a group (has both begin and end and they differ) or just an insert\n                if (debugLabel.endApiEvent && debugLabel.beginApiEvent !== debugLabel.endApiEvent) {\n                    // This is a debug label group - it should be handled by the range processing logic\n                    // Don't create any node here, just skip it\n                    // (The group will be created if it's in debugLabelGroupInstances, or omitted if it crosses boundaries)\n                } else {\n                    // This is a debug label insert - create as simple API event node\n                    parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode));\n                }\n            }\n        } else if (command.commandInstanceId && root.resource.commandInstances[command.commandInstanceId]) {\n            parentNode.children.push(CommandApiEventNode.create(ctx, command, parentNode, currentCommandIndex++));\n        }\n    }\n    return currentCommandIndex;\n}\n\nexport interface CommandDrawInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    drawInstanceId: number;\n    thumbnail?: string;\n    children: CommandTreeNode[];\n    resourceType: typeof CommandDrawInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandDrawInstanceNode {\n    export const RESOURCE_TYPE = 'draw-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDrawInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDrawInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_draw_${element.drawInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDrawInstanceNode {\n        const root = ctx.rootNode;\n\n        const node: CommandDrawInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            drawInstanceId: element.drawInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDrawInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query draw instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n            const requesterDbgName = `Command draw instance ${node.resource.drawInstanceId}`;\n            setThumbnailUrl(ctx, createDrawApiResources(node), node, requesterDbgName);\n        });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDrawInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const drawInstanceDynamicStatePromise = batchQuery\n                ? queryDrawInstanceDynamicStateBatched(db, [node.resource.drawInstanceId || 0])\n                : queryDrawInstanceDynamicState(db, [node.resource.drawInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                drawInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.GRAPHICS\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandDispatchInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    dispatchInstanceId: number;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandDispatchInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n    thumbnail?: string;\n}\n\nexport namespace CommandDispatchInstanceNode {\n    export const RESOURCE_TYPE = 'dispatch-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandDispatchInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandDispatchInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_dispatch_${element.dispatchInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandDispatchInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandDispatchInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            dispatchInstanceId: element.dispatchInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandDispatchInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query dispatch instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for dispatch nodes\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command dispatch instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandDispatchInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const dispatchInstanceDynamicStatePromise = batchQuery\n                ? queryDispatchInstanceDynamicStateBatched(db, [node.resource.dispatchInstanceId || 0])\n                : queryDispatchInstanceDynamicState(db, [node.resource.dispatchInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                dispatchInstanceDynamicStatePromise,\n                PipelineBindPoint.COMPUTE,\n                PipelineBindPointShaderStageFlags.COMPUTE\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandMeshTaskInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    meshTaskInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandMeshTaskInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandMeshTaskInstanceNode {\n    export const RESOURCE_TYPE = 'mesh-task-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandMeshTaskInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandMeshTaskInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_meshtask_${element.meshTaskInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandMeshTaskInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandMeshTaskInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            meshTaskInstanceId: element.meshTaskInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandMeshTaskInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query mesh instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for mesh task dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command mesh instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandMeshTaskInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const meshTaskInstanceDynamicStatePromise = batchQuery\n                ? queryMeshTaskInstanceDynamicStateBatched(db, [node.resource.meshTaskInstanceId || 0])\n                : queryMeshTaskInstanceDynamicState(db, [node.resource.meshTaskInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                meshTaskInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.TASK_MESH\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandClusterInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    clusterInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandClusterInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandClusterInstanceNode {\n    export const RESOURCE_TYPE = 'cluster-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandClusterInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandClusterInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_cluster_${element.clusterInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandClusterInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandClusterInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            clusterInstanceId: element.clusterInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandClusterInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query cluster instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for cluster dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command cluster instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandClusterInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const clusterInstanceDynamicStatePromise = batchQuery\n                ? queryClusterInstanceDynamicStateBatched(db, [node.resource.clusterInstanceId || 0])\n                : queryClusterInstanceDynamicState(db, [node.resource.clusterInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                clusterInstanceDynamicStatePromise,\n                PipelineBindPoint.GRAPHICS,\n                PipelineBindPointShaderStageFlags.CLUSTER\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport interface CommandRaytracingInstanceNode extends ResourceTreeNode<CommandTreeApiEvent>, SelectableTreeNode, ExpandableTreeNode {\n    label: string;\n    raytracingInstanceId: number;\n    thumbnail?: string;\n    children: ReadonlyArray<CommandTreeNode>;\n    resourceType: typeof CommandRaytracingInstanceNode.RESOURCE_TYPE;\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>;\n    mergedDynamicStatePromise?: Promise<DynamicStateEntry[]>;\n}\n\nexport namespace CommandRaytracingInstanceNode {\n    export const RESOURCE_TYPE = 'raytracing-instance';\n    export const GENERALIZED_TYPE = 'draw-or-dispatch';\n\n    export function is(node: TreeNode | undefined): node is CommandRaytracingInstanceNode {\n        return ResourceTreeNode.hasResourceType(node, CommandRaytracingInstanceNode.RESOURCE_TYPE);\n    }\n\n    export function getId(element: CommandTreeApiEvent, parent: CompositeTreeNode): string {\n        return `${parent.id}_raytracing_${element.raytracingInstanceId}`;\n    }\n\n    export function create(\n        ctx: CommandTreeContext,\n        element: CommandTreeApiEvent,\n        parent: CompositeTreeNode,\n        commandIndex: number,\n        baseDynamicStatePromise: Promise<DynamicStateEntry[]>\n    ): CommandRaytracingInstanceNode {\n        const root = ctx.rootNode;\n        const node: CommandRaytracingInstanceNode & SokatoaLifecycleTreeNode = {\n            id: getId(element, parent),\n            raytracingInstanceId: element.raytracingInstanceId || 0,\n            label: `${root.resource.functionNameLookup[element.functionNameId] ?? '<not defined>'} ${commandIndex}`,\n            parent,\n            resourceType: CommandRaytracingInstanceNode.RESOURCE_TYPE,\n            resource: element,\n            selected: false,\n            expanded: false,\n            children: [],\n            onWillRender: [],\n            baseDynamicStatePromise\n        };\n\n        if (ctx.createDrawOrDispatchChildren) {\n            createLazyLoadingNode(ctx.tree, node, async batchQuery => {\n                try {\n                    const result = await getMergedDynamicState(node, ctx.gfxrQueryBuilderService, batchQuery);\n                    const children = getCommandTreeApiEventChildren(result, root);\n                    CompositeTreeNode.addChildren(\n                        node,\n                        children.map(child => CommandApiEventNode.create(ctx, child, node))\n                    );\n                } catch (error) {\n                    console.error(`Failed to query raytracing instance dynamic state: ${asError(error).message}`);\n                }\n            });\n        }\n\n        // TODO thumbnail for raytracing dispatch\n        // SokatoaLifecycleTreeNode.once(node, 'onWillRender', () => {\n        //     const requesterDbgName = `Command raytracing instance ${node.resource.dispatchInstanceId}`;\n        //     setThumbnailUrl(ctx, createComputeApiResources(node), node, requesterDbgName);\n        // });\n        return node;\n    }\n\n    export function getMergedDynamicState(\n        node: CommandRaytracingInstanceNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> {\n        if (node.mergedDynamicStatePromise === undefined) {\n            const db = gfxrQueryBuilderService.builderFor(CommandTreeNode.getDbId(node));\n            const raytracingInstanceDynamicStatePromise = batchQuery\n                ? queryRaytracingInstanceDynamicStateBatched(db, [node.resource.raytracingInstanceId || 0])\n                : queryRaytracingInstanceDynamicState(db, [node.resource.raytracingInstanceId || 0]);\n            node.mergedDynamicStatePromise = overrideDynamicState(\n                node.baseDynamicStatePromise,\n                raytracingInstanceDynamicStatePromise,\n                PipelineBindPoint.RAY_TRACING,\n                PipelineBindPointShaderStageFlags.RAY_TRACING\n            );\n        }\n        return node.mergedDynamicStatePromise;\n    }\n}\n\nexport function getQueueSubmitId(node: CommandTreeNode): number | undefined {\n    let currentNode: CompositeTreeNode | undefined;\n    if (\n        CommandEmptyNode.is(node) ||\n        CommandApiEventNode.is(node) ||\n        CommandTreeDrawOrDispatchNode.is(node) ||\n        CommandAccelerationStructureBuildNode.is(node) ||\n        CommandAccelerationStructureCopyNode.is(node) ||\n        CommandTransferCommandNode.is(node)\n    ) {\n        currentNode = node.parent;\n    } else if (CommandQueuePresentNode.is(node) || CommandQueueDebugLabelNode.is(node)) {\n        return undefined;\n    } else {\n        currentNode = node;\n    }\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(currentNode, CommandQueueSubmitNode.is);\n    return queueSubmitNode ? queueSubmitNode.resource.submissionId : undefined;\n}\n\nexport function findLastDrawInstanceNode(node: CommandTreeNode): CommandDrawInstanceNode | undefined {\n    if (CommandDrawInstanceNode.is(node)) {\n        return node;\n    }\n    let lastDraw: CommandDrawInstanceNode | undefined;\n    if (!CommandDrawInstanceNode.is(node) && ExpandableTreeNode.is(node)) {\n        for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n            lastDraw = findLastDrawInstanceNode(node.children[commandIndex]);\n            if (lastDraw) {\n                break;\n            }\n        }\n    }\n    return lastDraw;\n}\n\nexport function createExecuteCommandsApiResources(\n    node: CommandSecondaryCommandBufferExecutionNode,\n    primaryNode: CommandCommandBufferInstanceNode,\n    queueSubmitNode: CommandQueueSubmitNode,\n    specificSecondaryCommandBufferBeginId?: number // If provided, only include this specific secondary CB\n): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    // findParentNode checks the given node for its type so we have to start looking from this node's parent\n    // otherwise we run into infinite recursion\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node.parent,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n\n    // Collect secondary command buffer begin IDs from the children\n    const commandBufferBeginIds: number[] = [];\n    if (specificSecondaryCommandBufferBeginId !== undefined) {\n        // Only include the specific secondary CB that was requested\n        commandBufferBeginIds.push(specificSecondaryCommandBufferBeginId);\n    } else {\n        // Include all secondary CBs (for when the execution node itself requests a thumbnail)\n        for (const child of node.children) {\n            if (CommandCommandBufferInstanceNode.is(child)) {\n                commandBufferBeginIds.push(child.resource.beginApiEvent);\n            }\n        }\n    }\n\n    const resources: ApiResources[] = [];\n    if (secondaryCommandBufferExecutionNode) {\n        const renderpassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n            renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n            CommandSecondaryCommandBufferExecutionNode.is\n        );\n\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: secondaryCommandBufferExecutionNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n                renderpassSecondaryCommandBufferExecutionNode &&\n                renderpassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n        const executionResources = createExecuteCommandsApiResources(secondaryCommandBufferExecutionNode, primaryNode, queueSubmitNode);\n        if (executionResources.length > 0) {\n            resources.push(...executionResources);\n        }\n    } else {\n        resources.push({\n            primaryCommandBufferBeginId: primaryNode.resource.beginApiEvent,\n            commandBufferBeginId: primaryNode.resource.beginApiEvent,\n            executeCommands: [\n                {\n                    commandBufferBeginIds,\n                    executeCommandsId: node.resource.apiEvent\n                }\n            ],\n            queueSubmitId: queueSubmitNode.resource.apiEvent,\n            drawResources: [],\n            renderPasses:\n                renderPassInstanceNode || dynamicRenderPassInstanceNode\n                    ? [\n                          {\n                              beginId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                              subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                              endId: renderPassInstanceNode\n                                  ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                  : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                    dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                          }\n                      ]\n                    : []\n        });\n    }\n    return resources;\n}\n\nexport function createDrawApiResources(node: CommandDrawInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const renderPassInstanceNode = findParentNode<CommandRenderPassInstanceNode>(node, CommandRenderPassInstanceNode.is);\n    const dynamicRenderPassInstanceNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n        node,\n        CommandDynamicRenderPassInstanceNode.is\n    );\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    // This will find the immediate parent command buffer (secondary if in a secondary CB, primary otherwise)\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n\n    const resources: ApiResources[] = [];\n    if (\n        (renderPassInstanceNode || dynamicRenderPassInstanceNode) &&\n        queueSubmitNode &&\n        commandBufferInstanceNode &&\n        primaryCommandBufferInstanceNode\n    ) {\n        if (secondaryCommandBufferExecutionNode) {\n            const renderPassSecondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                renderPassInstanceNode ? renderPassInstanceNode : dynamicRenderPassInstanceNode,\n                CommandSecondaryCommandBufferExecutionNode.is\n            );\n\n            // Add draw resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses:\n                    renderPassSecondaryCommandBufferExecutionNode &&\n                    renderPassSecondaryCommandBufferExecutionNode === secondaryCommandBufferExecutionNode\n                        ? [\n                              {\n                                  beginId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                                  subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                                  endId: renderPassInstanceNode\n                                      ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                                      : dynamicRenderPassInstanceNode!.resource.endApiEvent ||\n                                        dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                              }\n                          ]\n                        : []\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                drawResources: [{ index: node.resource.apiEventId, descriptors: descResources }],\n                renderPasses: [\n                    {\n                        beginId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.beginApiEvent,\n                        subpassIds: renderPassInstanceNode ? renderPassInstanceNode.renderSubpassEventIds : [],\n                        endId: renderPassInstanceNode\n                            ? renderPassInstanceNode.resource.endApiEvent || renderPassInstanceNode.resource.beginApiEvent\n                            : dynamicRenderPassInstanceNode!.resource.endApiEvent || dynamicRenderPassInstanceNode!.resource.beginApiEvent\n                    }\n                ]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createComputeApiResources(node: CommandDispatchInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add dispatch resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                dispatchResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport function createTraceRaysApiResources(node: CommandRaytracingInstanceNode, descResources?: DescriptorResource[]): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                traceRaysResources: [{ index: node.resource.apiEventId, descriptors: descResources }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTransferNode = CommandAccelerationStructureBuildNode | CommandAccelerationStructureCopyNode | CommandTransferCommandNode;\n\nexport function createTransferApiResources(node: CommandTransferNode): ApiResources[] {\n    const secondaryCommandBufferExecutionNode = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n        node,\n        CommandSecondaryCommandBufferExecutionNode.is\n    );\n    const commandBufferInstanceNode = findParentNode<CommandCommandBufferInstanceNode>(node, CommandCommandBufferInstanceNode.is);\n    const primaryCommandBufferInstanceNode = findPrimaryCommandBufferInstanceNode(\n        commandBufferInstanceNode,\n        secondaryCommandBufferExecutionNode\n    );\n    const queueSubmitNode = findParentNode<CommandQueueSubmitNode>(primaryCommandBufferInstanceNode, CommandQueueSubmitNode.is);\n    let transferEvent: number = 0;\n    if (CommandAccelerationStructureBuildNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureBuildNode).resource.buildApiEvent;\n    } else if (CommandAccelerationStructureCopyNode.is(node)) {\n        transferEvent = (node as CommandAccelerationStructureCopyNode).resource.copyApiEvent;\n    } else if (CommandTransferCommandNode.is(node)) {\n        transferEvent = (node as CommandTransferCommandNode).resource.transferApiEvent;\n    }\n\n    const resources: ApiResources[] = [];\n    if (queueSubmitNode && commandBufferInstanceNode && primaryCommandBufferInstanceNode) {\n        if (secondaryCommandBufferExecutionNode) {\n            // Add trace rays resources FIRST (for secondary CB)\n            resources.push({\n                primaryCommandBufferBeginId: primaryCommandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                executeCommands: undefined,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n            // Then add execution resources (for primary CB)\n            const executionResources = createExecuteCommandsApiResources(\n                secondaryCommandBufferExecutionNode,\n                primaryCommandBufferInstanceNode,\n                queueSubmitNode,\n                commandBufferInstanceNode.resource.beginApiEvent\n            );\n            if (executionResources.length > 0) {\n                resources.push(...executionResources);\n            }\n        } else {\n            resources.push({\n                primaryCommandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                commandBufferBeginId: commandBufferInstanceNode.resource.beginApiEvent,\n                queueSubmitId: queueSubmitNode.resource.apiEvent,\n                transferResources: [{ index: transferEvent }]\n            });\n        }\n    }\n    return resources;\n}\n\nexport type CommandTreeNode =\n    | CommandFrameNode\n    | CommandEmptyNode\n    | CommandApiEventNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandQueuePresentNode\n    | CommandQueueDebugLabelGroupNode\n    | CommandQueueDebugLabelNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandEmptyNode.is(node) ||\n            CommandApiEventNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandQueuePresentNode.is(node) ||\n            CommandQueueDebugLabelGroupNode.is(node) ||\n            CommandQueueDebugLabelNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n\n    export function findApiEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandSecondaryCommandBufferExecutionNode.is(current)) {\n            // For secondary command buffer execution nodes, return the VkCmdExecuteCommands apiEvent\n            // rather than the VkCommandBufferBegin apiEvent\n            return current.resource.apiEvent;\n        } else if (CommandTreeRangeNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (\n            CommandApiEventNode.is(current) ||\n            CommandQueueSubmitNode.is(current) ||\n            CommandQueuePresentNode.is(current) ||\n            CommandQueueDebugLabelNode.is(current)\n        ) {\n            return current.apiEventId;\n        } else if (CommandQueueDebugLabelGroupNode.is(current)) {\n            return current.resource.beginApiEvent;\n        } else if (CommandAccelerationStructureBuildNode.is(current)) {\n            return current.resource.buildApiEvent;\n        } else if (CommandAccelerationStructureCopyNode.is(current)) {\n            return current.resource.copyApiEvent;\n        } else if (CommandTransferCommandNode.is(current)) {\n            return current.apiEventId;\n        } else if (CommandTreeDrawOrDispatchNode.is(current)) {\n            return current.resource.apiEventId;\n        }\n        return undefined;\n    }\n\n    export function findFilterEventId(current?: CommandTreeNode): number | undefined {\n        if (current === undefined) {\n            return undefined;\n        }\n        if (CommandFrameNode.is(current)) {\n            return current.resource.beginApiEvent;\n        }\n        let maybeQueueSubmitOrPresent: TreeNode | undefined = current;\n        while (\n            maybeQueueSubmitOrPresent !== undefined &&\n            !(\n                CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueuePresentNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent) ||\n                CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)\n            )\n        ) {\n            maybeQueueSubmitOrPresent = maybeQueueSubmitOrPresent.parent;\n        }\n        let queueSubmitEventId: number | undefined;\n        if (maybeQueueSubmitOrPresent !== undefined) {\n            if (CommandQueueSubmitNode.is(maybeQueueSubmitOrPresent) || CommandQueuePresentNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            } else if (CommandQueueDebugLabelGroupNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.resource.beginApiEvent;\n            } else if (CommandQueueDebugLabelNode.is(maybeQueueSubmitOrPresent)) {\n                queueSubmitEventId = maybeQueueSubmitOrPresent.apiEventId;\n            }\n        }\n        return queueSubmitEventId;\n    }\n\n    export function findRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const renderPassNode = findParentNode<CommandRenderPassInstanceNode>(current, CommandRenderPassInstanceNode.is);\n        return renderPassNode ? renderPassNode.renderPassInstanceId : undefined;\n    }\n\n    export function findDynamicRenderPassInstanceId(current?: CommandTreeNode): number | undefined {\n        const dynamicRenderPassNode = findParentNode<CommandDynamicRenderPassInstanceNode>(\n            current,\n            CommandDynamicRenderPassInstanceNode.is\n        );\n        return dynamicRenderPassNode ? dynamicRenderPassNode.dynamicRenderPassInstanceId : undefined;\n    }\n\n    export function findDrawInstanceId(current?: CommandTreeNode): number | undefined {\n        const drawInstanceNode = findParentNode<CommandDrawInstanceNode>(current, CommandDrawInstanceNode.is);\n        return drawInstanceNode ? drawInstanceNode.drawInstanceId : undefined;\n    }\n\n    export function findDispatchInstanceId(current?: CommandTreeNode): number | undefined {\n        const dispatchInstanceNode = findParentNode<CommandDispatchInstanceNode>(current, CommandDispatchInstanceNode.is);\n        return dispatchInstanceNode ? dispatchInstanceNode.dispatchInstanceId : undefined;\n    }\n\n    export function findMeshTaskInstanceId(current?: CommandTreeNode): number | undefined {\n        const meshTaskInstanceNode = findParentNode<CommandMeshTaskInstanceNode>(current, CommandMeshTaskInstanceNode.is);\n        return meshTaskInstanceNode ? meshTaskInstanceNode.meshTaskInstanceId : undefined;\n    }\n\n    export function findClusterInstanceId(current?: CommandTreeNode): number | undefined {\n        const clusterInstanceNode = findParentNode<CommandClusterInstanceNode>(current, CommandClusterInstanceNode.is);\n        return clusterInstanceNode ? clusterInstanceNode.clusterInstanceId : undefined;\n    }\n\n    export function findRaytracingInstanceId(current?: CommandTreeNode): number | undefined {\n        const raytracingInstanceNode = findParentNode<CommandRaytracingInstanceNode>(current, CommandRaytracingInstanceNode.is);\n        return raytracingInstanceNode ? raytracingInstanceNode.raytracingInstanceId : undefined;\n    }\n\n    export function findAccelerationBuildInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelBuildNode = findParentNode<CommandAccelerationStructureBuildNode>(current, CommandAccelerationStructureBuildNode.is);\n        return accelBuildNode ? accelBuildNode.buildInstanceId : undefined;\n    }\n\n    export function findAccelerationCopyInstanceId(current?: CommandTreeNode): number | undefined {\n        const accelCopyNode = findParentNode<CommandAccelerationStructureCopyNode>(current, CommandAccelerationStructureCopyNode.is);\n        return accelCopyNode ? accelCopyNode.copyInstanceId : undefined;\n    }\n\n    export function findTransferCommandInstanceId(current?: CommandTreeNode): number | undefined {\n        const transferCommandNode = findParentNode<CommandTransferCommandNode>(current, CommandTransferCommandNode.is);\n        return transferCommandNode ? transferCommandNode.transferCommandInstanceId : undefined;\n    }\n\n    export function findMergedDynamicStatePromise(\n        current: CommandTreeNode,\n        gfxrQueryBuilderService: GFXRQueryBuilderService,\n        batchQuery?: boolean\n    ): Promise<DynamicStateEntry[]> | undefined {\n        let maybeDrawOrDispatchInstance: TreeNode | undefined = current;\n        while (maybeDrawOrDispatchInstance !== undefined && !CommandTreeDrawOrDispatchNode.is(maybeDrawOrDispatchInstance)) {\n            maybeDrawOrDispatchInstance = maybeDrawOrDispatchInstance.parent;\n        }\n        let mergedDynamicStatePromise: Promise<DynamicStateEntry[]> | undefined;\n        if (maybeDrawOrDispatchInstance !== undefined && CommandDrawInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDrawInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandDispatchInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandDispatchInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandMeshTaskInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandMeshTaskInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandClusterInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandClusterInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        } else if (maybeDrawOrDispatchInstance !== undefined && CommandRaytracingInstanceNode.is(maybeDrawOrDispatchInstance)) {\n            mergedDynamicStatePromise = CommandRaytracingInstanceNode.getMergedDynamicState(\n                maybeDrawOrDispatchInstance,\n                gfxrQueryBuilderService,\n                batchQuery\n            );\n        }\n        return mergedDynamicStatePromise;\n    }\n\n    export function getRoot(node?: CompositeTreeNode | CommandRootNode | CommandTreeNode): CommandRootNode | undefined {\n        return findParentNode<CommandRootNode>(node, CommandRootNode.is);\n    }\n\n    export function getDbId(node: CommandRootNode | CommandTreeNode): number {\n        return getRoot(node)?.dbId ?? -1;\n    }\n\n    type GeneralizableNodes =\n        | typeof CommandApiEventNode\n        | typeof CommandClusterInstanceNode\n        | typeof CommandCommandBufferInstanceNode\n        | typeof CommandDispatchInstanceNode\n        | typeof CommandDrawInstanceNode\n        | typeof CommandEmptyNode\n        | typeof CommandFrameNode\n        | typeof CommandMeshTaskInstanceNode\n        | typeof CommandQueuePresentNode\n        | typeof CommandQueueSubmitNode\n        | typeof CommandQueueDebugLabelGroupNode\n        | typeof CommandQueueDebugLabelNode\n        | typeof CommandAccelerationStructureBuildNode\n        | typeof CommandAccelerationStructureCopyNode\n        | typeof CommandTransferCommandNode\n        | typeof CommandRaytracingInstanceNode\n        | typeof CommandRenderPassInstanceNode\n        | typeof CommandRenderSubpassInstanceNode\n        | typeof CommandDynamicRenderPassInstanceNode\n        | typeof CommandDebugLabelGroupNode;\n\n    /**\n     * An aggregate type label for command-tree nodes, roughly corresponding to some of the union\n     * types defined in this module.\n     */\n    export type GeneralizedType = GeneralizableNodes['GENERALIZED_TYPE'];\n\n    /**\n     * Query the generalized type of a given node, if it is a Command Tree node.\n     *\n     * @param node a tree node that may or may not be a `CommandTreeNode`\n     * @return its generalized type, or `undefined` if it isn't a `CommandTreeNode`\n     */\n    export function getGeneralizedNodeType(node: TreeNode): GeneralizedType | undefined {\n        const resourceType = 'resourceType' in node ? node.resourceType : undefined;\n        if (!resourceType) {\n            return CommandEmptyNode.is(node) ? 'empty' : undefined;\n        }\n\n        switch (resourceType) {\n            case 'frame':\n            case 'command-buffer-instance':\n            case 'render-pass-instance':\n            case 'render-subpass-instance':\n            case 'secondary-command-buffer-execution':\n            case 'debug-label-group':\n                return 'range';\n            case 'queue-submit':\n            case 'queue-present':\n                return 'queue';\n            case 'acceleration-structure-build':\n                return 'acceleration-structure-build';\n            case 'acceleration-structure-copy':\n                return 'acceleration-structure-copy';\n            case 'transfer-command':\n                return 'transfer-command';\n            case 'draw-instance':\n            case 'dispatch-instance':\n            case 'mesh-task-instance':\n            case 'cluster-instance':\n            case 'raytracing-instance':\n                return 'draw-or-dispatch';\n            case 'api-event':\n                return 'api-event';\n            default:\n                return undefined;\n        }\n    }\n\n    /** Type assertion for a range-type node. */\n    export function generalize(node: TreeNode, type: 'range'): asserts node is CommandTreeRangeNode;\n    /** Type assertion for a queue-type node. */\n    export function generalize(node: TreeNode, type: 'queue'): asserts node is CommandQueueSubmitNode | CommandQueuePresentNode;\n    /** Type assertion for a queue-debug-label-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'queue-debug-label'\n    ): asserts node is CommandQueueDebugLabelGroupNode | CommandQueueDebugLabelNode;\n    /** Type assertion for a acceleration-structure-build-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-build'): asserts node is CommandAccelerationStructureBuildNode;\n    /** Type assertion for a acceleration-structure-copy-type node. */\n    export function generalize(node: TreeNode, type: 'acceleration-structure-copy'): asserts node is CommandAccelerationStructureCopyNode;\n    /** Type assertion for a transfer-command-type node. */\n    export function generalize(node: TreeNode, type: 'transfer-command'): asserts node is CommandTransferCommandNode;\n    /** Type assertion for a draw-or-dispatch-type node. */\n    export function generalize(node: TreeNode, type: 'draw-or-dispatch'): asserts node is CommandTreeDrawOrDispatchNode;\n    /** Type assertion for an api-event-type node. */\n    export function generalize(node: TreeNode, type: 'api-event'): asserts node is CommandApiEventNode;\n    /** Type assertion for a draw-or-dispatch- or api-event-type node. */\n    export function generalize(\n        node: TreeNode,\n        type: 'draw-or-dispatch' | 'api-event'\n    ): asserts node is CommandTreeDrawOrDispatchNode | CommandApiEventNode;\n    /** Type assertion for an empty-type node. */\n    export function generalize(node: TreeNode, type: 'empty'): asserts node is CommandEmptyNode;\n    export function generalize(node: TreeNode, _type: GeneralizedType): asserts node is CommandTreeNode {\n        // Pass\n    }\n}\n\nexport type CommandTreeRangeNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandDebugLabelGroupNode;\n\nexport namespace CommandTreeRangeNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeRangeNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node)\n        );\n    }\n}\n\nexport type CommandTreeDrawOrDispatchNode =\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandMeshTaskInstanceNode\n    | CommandClusterInstanceNode\n    | CommandRaytracingInstanceNode;\n\nexport namespace CommandTreeDrawOrDispatchNode {\n    export function is(node: TreeNode | undefined): node is CommandTreeDrawOrDispatchNode {\n        return (\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandMeshTaskInstanceNode.is(node) ||\n            CommandClusterInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node)\n        );\n    }\n}\n\ninterface ArrayWithSortNumber<RangeType> {\n    array: RangeType[];\n    getSortNumber(element: RangeType): number;\n}\n\ntype AllRangeTypes =\n    | CommandTreeDebugLabelGroupInstance\n    | CommandTreeRenderPassInstance\n    | CommandTreeRenderSubpassInstance\n    | CommandTreeDynamicRenderPassInstance;\n\ntype CommandTreeRangeParentNode =\n    | CommandRenderPassInstanceNode\n    | CommandCommandBufferInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandDebugLabelGroupNode;\n\nfunction findNextRangeElementToProcess<RangeType>(...arrays: ArrayWithSortNumber<RangeType>[]): RangeType | undefined {\n    // designate which array is the api event array vs a range array\n    // when processing a range, shift off any api events that are within the range\n    // so they aren't processed (because they actually reside within a sub-group)\n\n    const arraysToProcess: ArrayWithSortNumber<RangeType>[] = [];\n    arrays.forEach(arr => {\n        if (arr.array.length) {\n            arraysToProcess.push(arr);\n        }\n    });\n\n    if (!arraysToProcess.length) {\n        return undefined;\n    }\n\n    // get the sort number of the first element of each array and sort them\n    const sortedElements = arraysToProcess\n        .map(array => ({ subarray: array.array, sortNumber: array.getSortNumber(array.array[0]) }))\n        .sort((a, b) => a.sortNumber - b.sortNumber);\n\n    return sortedElements[0].subarray.shift();\n}\n\n/**\n * Process commands and ranges together in API event order.\n * For each range element, creates child nodes for commands that come before it,\n * skips commands that fall within the range, and creates a node for the range itself.\n * After processing all ranges, any remaining commands are processed.\n *\n * @param ctx - Command tree context\n * @param root - Root node\n * @param parentNode - Parent node to add children to\n * @param apiEventCommandArray - Array of commands sorted by API event ID (will be mutated)\n * @param childCommandIndex - Starting index for child commands\n * @param baseDynamicStatePromise - Promise for dynamic state\n * @param createRangeNode - Callback to create a node for each range element\n * @param rangeArrays - Variable number of range arrays to process together\n * @returns The final child command index\n */\nasync function createChildEventNodesForRange<RangeType extends { beginApiEvent: number; endApiEvent?: number }>(\n    ctx: CommandTreeContext,\n    root: CommandRootNode,\n    parentNode: CommandTreeRangeParentNode,\n    apiEventCommandArray: CommandTreeApiEvent[],\n    childCommandIndex: number,\n    baseDynamicStatePromise: Promise<DynamicStateEntry[]>,\n    createRangeNode: (rangeElement: RangeType, parentNode: CommandTreeRangeParentNode) => void,\n    ...rangeArrays: ArrayWithSortNumber<RangeType>[]\n): Promise<number> {\n    const stateTracker = new DynamicStateTracker(baseDynamicStatePromise);\n    let nextRangeElement: RangeType | undefined;\n    let priorRangeEndApiEvent: number | undefined;\n\n    while ((nextRangeElement = findNextRangeElementToProcess<RangeType>(...rangeArrays))) {\n        // create a node for any command that comes BEFORE the next range element\n        while (apiEventCommandArray.length && apiEventCommandArray[0].apiEventId < nextRangeElement.beginApiEvent) {\n            const command = apiEventCommandArray.shift();\n            childCommandIndex = await createChildEventNode(ctx, command!, root, parentNode, childCommandIndex, stateTracker);\n        }\n\n        // shift off any command that falls WITHIN next range since it will be processed when creating next range node\n        while (\n            apiEventCommandArray.length &&\n            nextRangeElement.endApiEvent !== undefined &&\n            apiEventCommandArray[0].apiEventId >= nextRangeElement.beginApiEvent &&\n            apiEventCommandArray[0].apiEventId <= nextRangeElement.endApiEvent\n        ) {\n            apiEventCommandArray.shift();\n        }\n\n        // skip next range if it falls within the prior range since it will be processed when creating prior range node\n        if (\n            priorRangeEndApiEvent !== undefined &&\n            nextRangeElement.endApiEvent !== undefined &&\n            nextRangeElement.endApiEvent <= priorRangeEndApiEvent\n        ) {\n            continue;\n        }\n        priorRangeEndApiEvent = nextRangeElement.endApiEvent;\n\n        // create a node for the next range element\n        createRangeNode(nextRangeElement, parentNode);\n    }\n\n    // process any remaining command elements after all range elements have been processed\n    for (const command of apiEventCommandArray) {\n        childCommandIndex = await createChildEventNode(ctx, command, root, parentNode, childCommandIndex, stateTracker);\n    }\n\n    return childCommandIndex;\n}\n\n/**\n * Find node from descendent node for which isNode is true\n */\nexport const findParentNode = <T extends TreeNode>(\n    node: TreeNode | undefined,\n    isNode: (node: TreeNode | undefined) => node is T\n): T | undefined => {\n    let targetNode: TreeNode | undefined = node;\n    while (targetNode && targetNode.parent && !isNode(targetNode)) {\n        targetNode = targetNode.parent;\n    }\n\n    return targetNode && isNode(targetNode) ? targetNode : undefined;\n};\n\n/**\n * Find the primary command buffer instance node from a given command buffer instance node.\n * If the given node is in a secondary command buffer, traverses up through nested secondary\n * command buffers until finding the primary command buffer (one with no parent execution node).\n * If the given node is already in a primary command buffer, returns it as-is.\n */\nexport const findPrimaryCommandBufferInstanceNode = (\n    commandBufferInstanceNode: CommandCommandBufferInstanceNode | undefined,\n    secondaryCommandBufferExecutionNode: CommandSecondaryCommandBufferExecutionNode | undefined\n): CommandCommandBufferInstanceNode | undefined => {\n    let primaryCommandBufferInstanceNode = commandBufferInstanceNode;\n    if (secondaryCommandBufferExecutionNode) {\n        let currentExecution: CommandSecondaryCommandBufferExecutionNode | undefined = secondaryCommandBufferExecutionNode;\n        while (currentExecution) {\n            const parentCB: CommandCommandBufferInstanceNode | undefined = findParentNode<CommandCommandBufferInstanceNode>(\n                currentExecution,\n                CommandCommandBufferInstanceNode.is\n            );\n            if (parentCB) {\n                primaryCommandBufferInstanceNode = parentCB;\n                // Check if this CB is also inside another secondary execution (nested case)\n                currentExecution = findParentNode<CommandSecondaryCommandBufferExecutionNode>(\n                    parentCB.parent,\n                    CommandSecondaryCommandBufferExecutionNode.is\n                );\n            } else {\n                break;\n            }\n        }\n    }\n    return primaryCommandBufferInstanceNode;\n};\n\n/**\n * find a frame node from descendent node or self\n */\nexport const findFrameNode = (node: TreeNode): CommandFrameNode | undefined => findParentNode<CommandFrameNode>(node, CommandFrameNode.is);\n\n@injectable()\nexport class CommandTree extends BulkTree implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTree {\n        return tree instanceof CommandTree;\n    }\n\n    @inject(CaptureDatasetWidgetProfile)\n    protected readonly profile: CaptureDatasetWidgetProfile;\n    @inject(CaptureDatasetWidgetContext)\n    protected readonly context: CaptureDatasetWidgetContext;\n\n    @inject(CommandTreeDataQueriedRootProvider)\n    protected readonly rootProvider: CommandTreeDataQueriedRootProvider;\n    @inject(GFXRQueryBuilderService)\n    protected readonly gfxrQueryBuilderService: GFXRQueryBuilderService;\n\n    protected override _root: CommandRootNode | undefined;\n\n    // Back-reference to the model that manages this tree\n    model?: CommandTreeModel;\n\n    protected readonly onStructureChangedEmitter = new Emitter<TreeNode | undefined>();\n    readonly onStructureChanged = this.onStructureChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this._root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        super.root = root;\n        // Set back-reference from root to tree\n        if (root) {\n            root.tree = this;\n        }\n    }\n\n    async initTree(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        this.root = await this.rootProvider.provide(dbId, { tree: this }, options, createDrawOrDispatchChildren);\n\n        // tree structure is fully built at this point, report structure change\n        this.onStructureChangedEmitter.fire(undefined);\n    }\n\n    async refreshStructure(node?: CompositeTreeNode, cancellationToken?: CancellationToken): Promise<void> {\n        console.log('JF: CommandTree.refreshStructure START', { nodeId: node?.id });\n        await this.refresh(node, cancellationToken);\n        console.log('JF: CommandTree.refreshStructure - calling fireStructureChanged');\n        this.fireStructureChanged(node);\n        console.log('JF: CommandTree.refreshStructure END');\n    }\n\n    fireStructureChanged(node?: TreeNode): void {\n        console.log('JF: CommandTree.fireStructureChanged', { nodeId: node?.id });\n        this.onStructureChangedEmitter.fire(node);\n    }\n\n    addToDispose(disposable: Disposable): void {\n        this.toDispose.push(disposable);\n    }\n\n    override dispose(): void {\n        this.rootProvider.dispose();\n        super.dispose();\n    }\n}\n\n@injectable()\nexport class CommandTreeModelPreferenceStateAccessImpl implements CommandTreePreferenceState.Access {\n    private readonly models = new Map<CommandTree, CommandTreeModel>();\n\n    private readonly commandTreeStateChangedEmitter = new Emitter<{ tree: CommandTree; state: CommandTreePreferenceState }>();\n    readonly onCommandTreeStateChanged = this.commandTreeStateChangedEmitter.event;\n\n    getCommandTreeState(tree: CommandTree): CommandTreePreferenceState {\n        return this.models.get(tree)?.getPreferenceState() ?? {};\n    }\n\n    fireCommandTreeStateChanged(tree: CommandTree): void {\n        this.commandTreeStateChangedEmitter.fire({ tree, state: this.getCommandTreeState(tree) });\n    }\n\n    registerCommandTreeModel(tree: CommandTree, model: CommandTreeModel): void {\n        this.models.set(tree, model);\n        this.fireCommandTreeStateChanged(tree);\n    }\n}\n\n@injectable()\nexport class CommandTreeModel extends BulkTreeModel implements TreeStructureChangeEmitter {\n    static is(tree: unknown): tree is CommandTreeModel {\n        return tree instanceof CommandTreeModel;\n    }\n\n    @inject(MiscPreferences)\n    protected readonly miscPreferences: MiscPreferences;\n    @inject(CommandTree) override readonly tree: CommandTree;\n    protected _groupBy: GroupByOptions = GroupByOptions.Frame;\n    private groupByChangedEmitter = new Emitter<GroupByOptions>();\n    readonly onGroupByChanged = this.groupByChangedEmitter.event;\n    protected _isThumbnailEnabled = true;\n    protected _isApiEventIdsEnabled = true;\n    protected _isShowingEmptyRows = false;\n    protected _isVulkanEnabled = true;\n    protected _isDebugNamesEnabled = true;\n    protected _isDebugLabelsEnabled = true;\n    protected _isLinksEnabled = true;\n    protected _isThreadsEnabled = true;\n\n    @inject(FrameRangeSelectionService)\n    protected readonly frameRangeSelectionService: FrameRangeSelectionService;\n\n    @inject(CommandTreeModelPreferenceStateAccessImpl)\n    private readonly preferenceStateAccess: CommandTreeModelPreferenceStateAccessImpl;\n\n    protected isCollapsingSubTree = false;\n\n    // Proxies to prevent calls on sub tree expansion\n    protected readonly onExpansionChangedEmitterProxy = new Emitter<ExpandableTreeNode>();\n    protected readonly onChangedEmitterProxy = new Emitter<void>();\n\n    protected readonly onSubTreeExpansionChangedEmitter = new Emitter<ExpandableTreeNode>();\n    readonly onSubTreeExpansionChanged = this.onSubTreeExpansionChangedEmitter.event;\n\n    override get root(): CommandRootNode | undefined {\n        return this.tree.root;\n    }\n\n    override set root(root: CommandRootNode | undefined) {\n        this.tree.root = root;\n    }\n\n    override get onChanged(): Event<void> {\n        return this.onChangedEmitterProxy.event;\n    }\n\n    override get onExpansionChanged(): Event<ExpandableTreeNode> {\n        return this.onExpansionChangedEmitterProxy.event;\n    }\n\n    get onStructureChanged(): Event<TreeNode | undefined> {\n        return this.tree.onStructureChanged;\n    }\n\n    async initModel(dbId: number, createDrawOrDispatchChildren: boolean, options?: QueryTreeDataOptions): Promise<void> {\n        await this.tree.initTree(dbId, createDrawOrDispatchChildren, options);\n    }\n\n    set groupBy(value: GroupByOptions) {\n        if (this._groupBy !== value) {\n            this._groupBy = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n            this.groupByChangedEmitter.fire(value);\n        }\n    }\n\n    get groupBy(): GroupByOptions {\n        return this._groupBy;\n    }\n\n    /**\n     * Obtain the tree nodes that are the top-level groups according to\n     * the current {@link groupBy} mode.\n     */\n    *groupNodes(): IterableIterator<CompositeTreeNode> {\n        if (!this.root) {\n            return;\n        }\n\n        const group = this.groupBy;\n        const treeIterator = new (class extends DepthFirstTreeIterator {\n            protected override children(node: TreeNode): TreeNode[] | undefined {\n                // Prune group nodes because we needn't look in them for more groups\n                return CommandTreeModel.isOfGroup(node, group) ? undefined : super.children(node);\n            }\n        })(this.root);\n\n        for (const next of treeIterator) {\n            if (CommandTreeModel.isOfGroup(next, group)) {\n                yield next;\n            }\n        }\n    }\n\n    set isApiEventIdsEnabled(value: boolean) {\n        if (this._isApiEventIdsEnabled !== value) {\n            this._isApiEventIdsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isApiEventIdsEnabled(): boolean {\n        return this._isApiEventIdsEnabled;\n    }\n\n    set isShowingEmptyRows(value: boolean) {\n        if (this._isShowingEmptyRows !== value) {\n            this._isShowingEmptyRows = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isShowingEmptyRows(): boolean {\n        return this._isShowingEmptyRows;\n    }\n\n    set isThumbnailEnabled(value: boolean) {\n        if (this._isThumbnailEnabled !== value) {\n            this._isThumbnailEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThumbnailEnabled(): boolean {\n        return this._isThumbnailEnabled;\n    }\n\n    set isVulkanEnabled(value: boolean) {\n        if (this._isVulkanEnabled !== value) {\n            this._isVulkanEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isVulkanEnabled(): boolean {\n        return this._isVulkanEnabled;\n    }\n\n    set isDebugNamesEnabled(value: boolean) {\n        if (this._isDebugNamesEnabled !== value) {\n            this._isDebugNamesEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugNamesEnabled(): boolean {\n        return this._isDebugNamesEnabled;\n    }\n\n    set isDebugLabelsEnabled(value: boolean) {\n        if (this._isDebugLabelsEnabled !== value) {\n            this._isDebugLabelsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isDebugLabelsEnabled(): boolean {\n        return this._isDebugLabelsEnabled;\n    }\n\n    set isLinksEnabled(value: boolean) {\n        if (this._isLinksEnabled !== value) {\n            this._isLinksEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isLinksEnabled(): boolean {\n        return this._isLinksEnabled;\n    }\n\n    set isThreadsEnabled(value: boolean) {\n        if (this._isThreadsEnabled !== value) {\n            this._isThreadsEnabled = value;\n            this.preferenceStateAccess.fireCommandTreeStateChanged(this.tree);\n        }\n    }\n\n    get isThreadsEnabled(): boolean {\n        return this._isThreadsEnabled;\n    }\n\n    getPreferenceState(nonDefaultOnly = false): CommandTreePreferenceState {\n        const result: CommandTreePreferenceState = {};\n\n        if (!nonDefaultOnly || this.groupBy !== this.miscPreferences[MiscPrefs.GroupBy]) {\n            result.groupBy = this.groupBy;\n        }\n        if (!nonDefaultOnly || this.isApiEventIdsEnabled !== this.miscPreferences[MiscPrefs.ShowApiEventIds]) {\n            result.isApiEventIdsEnabled = this.isApiEventIdsEnabled;\n        }\n        if (!nonDefaultOnly || this.isShowingEmptyRows !== this.miscPreferences[MiscPrefs.ShowEmptyRows]) {\n            result.isShowingEmptyRows = this.isShowingEmptyRows;\n        }\n        if (!nonDefaultOnly || this.isThumbnailEnabled !== this.miscPreferences[MiscPrefs.ShowThumbnails]) {\n            result.isThumbnailEnabled = this.isThumbnailEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugNamesEnabled !== true) {\n            result.isDebugNamesEnabled = this.isDebugNamesEnabled;\n        }\n        if (!nonDefaultOnly || this.isDebugLabelsEnabled !== true) {\n            result.isDebugLabelsEnabled = this.isDebugLabelsEnabled;\n        }\n        if (!nonDefaultOnly || this.isLinksEnabled !== true) {\n            result.isLinksEnabled = this.isLinksEnabled;\n        }\n        if (!nonDefaultOnly || this.isThreadsEnabled !== true) {\n            result.isThreadsEnabled = this.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (!nonDefaultOnly || this.isVulkanEnabled !== this.miscPreferences[MiscPrefs.ShowVulkanCalls]) {\n        //     result.isVulkanEnabled = this.isVulkanEnabled;\n        // }\n\n        return result;\n    }\n\n    override restoreState(state: CommandTreeModel.State): void {\n        if (state.groupBy !== undefined) {\n            this.groupBy = state.groupBy;\n        }\n        if (state.isApiEventIdsEnabled !== undefined) {\n            this.isApiEventIdsEnabled = state.isApiEventIdsEnabled;\n        }\n        if (state.isShowingEmptyRows !== undefined) {\n            this.isShowingEmptyRows = state.isShowingEmptyRows;\n        }\n        if (state.isThumbnailEnabled !== undefined) {\n            this.isThumbnailEnabled = state.isThumbnailEnabled;\n        }\n        if (state.isDebugNamesEnabled !== undefined) {\n            this.isDebugNamesEnabled = state.isDebugNamesEnabled;\n        }\n        if (state.isDebugLabelsEnabled !== undefined) {\n            this.isDebugLabelsEnabled = state.isDebugLabelsEnabled;\n        }\n        if (state.isLinksEnabled !== undefined) {\n            this.isLinksEnabled = state.isLinksEnabled;\n        }\n        if (state.isThreadsEnabled !== undefined) {\n            this.isThreadsEnabled = state.isThreadsEnabled;\n        }\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // if (state.isVulkanEnabled !== undefined) {\n        //     this.isVulkanEnabled = state.isVulkanEnabled;\n        // }\n    }\n    override storeState(): CommandTreeModel.State {\n        return {\n            ...super.storeState(),\n            ...this.getPreferenceState(true)\n        };\n    }\n\n    @postConstruct()\n    protected override init(): void {\n        super.init();\n\n        // Set back-reference from tree to model\n        this.tree.model = this;\n\n        this.toDispose.pushAll([\n            this.onChangedEmitterProxy,\n            this.onExpansionChangedEmitterProxy,\n            this.onSubTreeExpansionChangedEmitter,\n\n            super.onChanged(() => {\n                if (!this.isCollapsingSubTree) {\n                    this.onChangedEmitterProxy.fire();\n                }\n            }),\n            super.onExpansionChanged(node => {\n                if (!this.isCollapsingSubTree) {\n                    this.onExpansionChangedEmitterProxy.fire(node);\n                }\n            })\n        ]);\n\n        this._isApiEventIdsEnabled = this.miscPreferences[MiscPrefs.ShowApiEventIds];\n        this._isShowingEmptyRows = this.miscPreferences[MiscPrefs.ShowEmptyRows];\n        this.isThumbnailEnabled = this.miscPreferences[MiscPrefs.ShowThumbnails];\n        this.groupBy = this.miscPreferences[MiscPrefs.GroupBy];\n        // Is not shown at the current time, but can be uncommented if decided to show again\n        // this.isVulkanEnabled = this.miscPreferences[MiscPrefs.ShowVulkanCalls];\n\n        this.preferenceStateAccess.registerCommandTreeModel(this.tree, this);\n    }\n\n    /**\n     * Collapses the entire tree.\n     */\n    async collapseTree(): Promise<void> {\n        const root = this.root;\n\n        if (CompositeTreeNode.is(root) && root.children.length > 0) {\n            await Promise.all(\n                root.children.filter(CompositeTreeNode.is).map((child: CompositeTreeNode) => this.expansionService.collapseAll(child))\n            );\n        }\n    }\n\n    /**\n     * Expands the given node and all its children recursively.\n     */\n    async expandSubTree(node?: Readonly<TreeNode>, includeDrawOrDispatchNodes = false): Promise<void> {\n        node ??= this.root;\n        if (!ExpandableTreeNode.is(node)) {\n            return;\n        }\n\n        try {\n            this.isCollapsingSubTree = true;\n            await this.doExpandSubTree(node, includeDrawOrDispatchNodes);\n            this.onSubTreeExpansionChangedEmitter.fire(node);\n        } finally {\n            this.isCollapsingSubTree = false;\n        }\n    }\n\n    protected async doExpandSubTree(node: TreeNode, includeDrawOrDispatchNodes: boolean): Promise<void> {\n        console.log('JF: doExpandSubTree START', { nodeId: node.id, includeDrawOrDispatchNodes });\n        const YIELD_AFTER_MS = 200;\n\n        const processedNodes = new Set<TreeNode>();\n        const pendingNodes: TreeNode[] = [node];\n        let lastYieldTime = performance.now();\n\n        while (pendingNodes.length > 0) {\n            const currentLevelNodes: ExpandableTreeNode[] = [];\n            const nextLevelNodes: TreeNode[] = [];\n\n            while (pendingNodes.length > 0) {\n                const currentNode = pendingNodes.shift()!;\n                if (processedNodes.has(currentNode)) {\n                    continue;\n                }\n                processedNodes.add(currentNode);\n\n                // stop expansion at draw and dispatch nodes to avoid creation of low-utility nodes\n                // if this logic gets changed please also update enablement of ExpandSubtreeCommand accordingly\n                if (ExpandableTreeNode.is(currentNode) && (includeDrawOrDispatchNodes || !CommandTreeDrawOrDispatchNode.is(currentNode))) {\n                    currentLevelNodes.push(currentNode);\n                }\n            }\n\n            console.log('JF: doExpandSubTree - processing level', {\n                currentLevelNodesCount: currentLevelNodes.length,\n                nodeIds: currentLevelNodes.map(n => n.id)\n            });\n\n            if (currentLevelNodes.length > 0) {\n                const expandedNodes = await this.expansionService.bulkExpandNodes(currentLevelNodes[Symbol.iterator]());\n                console.log('JF: doExpandSubTree - after bulkExpandNodes', {\n                    expandedNodesCount: expandedNodes.length,\n                    expandedNodeIds: expandedNodes.map(n => n.id)\n                });\n                for (const expandedNode of expandedNodes) {\n                    console.log('JF: doExpandSubTree - calling ensureLazyChildrenLoaded for', {\n                        nodeId: expandedNode.id,\n                        childrenCount: expandedNode.children.length,\n                        childrenIds: expandedNode.children.map(c => c.id)\n                    });\n                    await this.ensureLazyChildrenLoaded(expandedNode);\n                    console.log('JF: doExpandSubTree - after ensureLazyChildrenLoaded', {\n                        nodeId: expandedNode.id,\n                        childrenCountAfter: expandedNode.children.length,\n                        childrenIdsAfter: expandedNode.children.map(c => c.id)\n                    });\n                    nextLevelNodes.push(...expandedNode.children);\n                    // For draw/dispatch nodes that won't be expanded, still trigger their lazy loading\n                    if (!includeDrawOrDispatchNodes) {\n                        for (const child of expandedNode.children) {\n                            if (CommandTreeDrawOrDispatchNode.is(child) && ExpandableTreeNode.is(child)) {\n                                await this.ensureLazyChildrenLoaded(child);\n                            }\n                        }\n                    }\n                }\n                // Also process children of nodes that were already expanded\n                for (const currentNode of currentLevelNodes) {\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\n                        console.log('JF: doExpandSubTree - processing already expanded node', { nodeId: currentNode.id });\n                        await this.ensureLazyChildrenLoaded(currentNode);\n                        nextLevelNodes.push(...currentNode.children);\n                        // For draw/dispatch nodes that won't be expanded, still trigger their lazy loading\n                        if (!includeDrawOrDispatchNodes) {\n                            for (const child of currentNode.children) {\n                                if (CommandTreeDrawOrDispatchNode.is(child) && ExpandableTreeNode.is(child)) {\n                                    await this.ensureLazyChildrenLoaded(child);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            pendingNodes.push(...nextLevelNodes);\n            console.log('JF: doExpandSubTree - next level', { nextLevelNodesCount: nextLevelNodes.length });\n\n            // Yield control back to the event loop periodically based on time\n            const currentTime = performance.now();\n            if (currentTime - lastYieldTime >= YIELD_AFTER_MS) {\n                await new Promise(resolve => setTimeout(resolve, 0));\n                lastYieldTime = performance.now();\n            }\n        }\n        console.log('JF: doExpandSubTree END', { nodeId: node.id, totalProcessed: processedNodes.size });\n    }\n\n    protected async ensureLazyChildrenLoaded(node: ExpandableTreeNode): Promise<void> {\n        console.log('JF: ensureLazyChildrenLoaded START', {\n            nodeId: node.id,\n            childrenCount: node.children.length,\n            childrenIds: node.children.map(c => c.id)\n        });\n        // Find all loading nodes among children\n        const loadingNodes = node.children.filter(CommandEmptyNode.is);\n        console.log('JF: ensureLazyChildrenLoaded - found loading nodes', {\n            loadingNodesCount: loadingNodes.length,\n            loadingNodeIds: loadingNodes.map(n => n.id)\n        });\n\n        if (loadingNodes.length === 0) {\n            console.log('JF: ensureLazyChildrenLoaded - no loading nodes, returning');\n            return;\n        }\n\n        // Trigger load for all loading nodes and wait for them to complete\n        console.log('JF: ensureLazyChildrenLoaded - triggering loads');\n        await Promise.all(loadingNodes.map(loadingNode => triggerLazyLoadAndWaitForRemoval(loadingNode)));\n        console.log('JF: ensureLazyChildrenLoaded END', {\n            nodeId: node.id,\n            childrenCountAfter: node.children.length,\n            childrenIdsAfter: node.children.map(c => c.id)\n        });\n    }\n\n    hasTrailingSuffixes(node: TreeNode): boolean {\n        if (CommandQueueSubmitNode.is(node)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    protected override isVisibleSelectableNode(node: TreeNode): node is SelectableTreeNode {\n        return super.isVisibleSelectableNode(node) && this.isInFrameRange(node);\n    }\n\n    protected isInFrameRange(node: TreeNode): boolean {\n        const frameNode = CommandFrameNode.getCommandFrameNodeContaining(node);\n        if (frameNode === undefined) {\n            return true; // Assume it's good\n        }\n        const range = this.frameRangeSelectionService.frameSpan;\n        if (range === undefined) {\n            return true; // No constraint\n        }\n        return frameNode.frameIndex >= range.startFrame && frameNode.frameIndex <= range.endFrame;\n    }\n}\n\nexport namespace CommandTreeModel {\n    export interface State extends TreeModelImpl.State, CommandTreePreferenceState {}\n\n    /**\n     * Test whether a `node` is of the kind that implements the given `group` mode.\n     * As groups are _a priori_ composite nodes, this additionally infers that type\n     * for the `node` if successful.\n     */\n    export function isOfGroup(node: TreeNode, group: GroupByOptions): node is CompositeTreeNode {\n        switch (group) {\n            case GroupByOptions.Frame:\n                return CommandFrameNode.is(node);\n            case GroupByOptions.RenderPass:\n                return CommandRenderPassInstanceNode.is(node) || CommandDynamicRenderPassInstanceNode.is(node);\n            case GroupByOptions.RenderSubpass:\n                return CommandRenderSubpassInstanceNode.is(node);\n            case GroupByOptions.CommandBuffer:\n                return CommandCommandBufferInstanceNode.is(node);\n            case GroupByOptions.QueueSubmission:\n                return CommandQueueSubmitNode.is(node);\n        }\n    }\n}\n\ntype TextureSupportingNode =\n    | CommandFrameNode\n    | CommandDrawInstanceNode\n    | CommandDispatchInstanceNode\n    | CommandRaytracingInstanceNode\n    | CommandAccelerationStructureBuildNode\n    | CommandAccelerationStructureCopyNode\n    | CommandTransferCommandNode;\n\nexport namespace TextureSupportingNode {\n    export function is(node: CommandTreeNode): node is TextureSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandDrawInstanceNode.is(node) ||\n            CommandDispatchInstanceNode.is(node) ||\n            CommandRaytracingInstanceNode.is(node) ||\n            CommandAccelerationStructureBuildNode.is(node) ||\n            CommandAccelerationStructureCopyNode.is(node) ||\n            CommandTransferCommandNode.is(node)\n        );\n    }\n    export function getLast(node: CommandTreeNode): TextureSupportingNode | undefined {\n        if (TextureSupportingNode.is(node)) {\n            return node;\n        }\n        let lastSupportingNode: TextureSupportingNode | undefined;\n        if (CompositeTreeNode.is(node)) {\n            for (let commandIndex = node.children.length - 1; commandIndex >= 0; --commandIndex) {\n                lastSupportingNode = TextureSupportingNode.getLast(node.children[commandIndex]);\n                if (lastSupportingNode) {\n                    break;\n                }\n            }\n        }\n        return lastSupportingNode;\n    }\n}\n\n/**\n * Union type of all command tree nodes that support thumbnails.\n * Nodes with heavy thumbnail costs are commented out.\n */\ntype ThumbnailSupportingNode =\n    | CommandFrameNode\n    | CommandCommandBufferInstanceNode\n    | CommandSecondaryCommandBufferExecutionNode\n    | CommandQueueSubmitNode\n    | CommandDebugLabelGroupNode\n    | CommandRenderPassInstanceNode\n    | CommandDynamicRenderPassInstanceNode\n    | CommandRenderSubpassInstanceNode\n    | CommandDrawInstanceNode;\n// Below currently have a possibly heavy cost to getting thumbnails\n// | CommandDispatchInstanceNode\n// | CommandMeshTaskInstanceNode\n// | CommandClusterInstanceNode\n// | CommandRaytracingInstanceNode;\n\nexport namespace ThumbnailSupportingNode {\n    export function is(node: CommandTreeNode): node is ThumbnailSupportingNode {\n        return (\n            CommandFrameNode.is(node) ||\n            CommandCommandBufferInstanceNode.is(node) ||\n            CommandSecondaryCommandBufferExecutionNode.is(node) ||\n            CommandQueueSubmitNode.is(node) ||\n            CommandDebugLabelGroupNode.is(node) ||\n            CommandRenderPassInstanceNode.is(node) ||\n            CommandDynamicRenderPassInstanceNode.is(node) ||\n            CommandRenderSubpassInstanceNode.is(node) ||\n            CommandDrawInstanceNode.is(node)\n        );\n    }\n}\n\nfunction getCommandTreeApiEventChildren(eventIds: Array<{ apiEvent: number }>, root: CommandRootNode): CommandTreeApiEvent[] {\n    return eventIds.reduce<CommandTreeApiEvent[]>((collected, id) => {\n        const event = root.resource.apiEvents[id.apiEvent];\n        if (event) {\n            collected.push(event);\n        } else {\n            console.warn(`No event found for ${id.apiEvent}`);\n        }\n        return collected;\n    }, []);\n}\n\nfunction getInstancesByIds<T>(ids: number[], container: PartialRecord<number, T>, source?: string, target?: string): T[] {\n    return ids.flatMap(id => {\n        const instance = container[id];\n        if (!instance) {\n            if (target) {\n                console.warn(`${source ? `${source} expected` : 'Expected'} ${target} with ${id} but found none.`);\n            }\n            return [];\n        }\n        return instance;\n    });\n}\n\n/**\n * Creates an ArrayWithSortNumber for range instances, used by createChildEventNodesForRange.\n * Fetches instances by IDs and provides sorting by beginApiEvent.\n *\n * @param ids - Array of instance IDs to fetch\n * @param container - Container object mapping IDs to instances\n * @param sourceContext - Context string for error messages (e.g., \"CommandRenderPassInstanceNode.create\")\n * @param targetName - Target instance type name for error messages (e.g., \"DebugLabelGroupInstance\")\n * @returns ArrayWithSortNumber object ready for use with getNextRangeElementToProcess\n */\nfunction createRangeInstanceArray<T extends { beginApiEvent: number }>(\n    ids: number[],\n    container: PartialRecord<number, T>,\n    sourceContext: string,\n    targetName: string\n): ArrayWithSortNumber<T> {\n    return {\n        array: getInstancesByIds(ids, container, sourceContext, targetName),\n        getSortNumber: (element: T) => element.beginApiEvent\n    };\n}\n\nexport function createLazyLoadingNode(\n    tree: CommandTree,\n    parent: ExpandableTreeNode,\n    load: (batchQuery?: boolean) => Promise<void>\n): CommandEmptyNode {\n    let loaded = false;\n    let loadingInProgress = false;\n\n    const lazyLoad: (batchQuery?: boolean) => Promise<boolean> = async (batchQuery = true) => {\n        console.log('JF: lazyLoad START', { parentId: parent.id, batchQuery, loaded, loadingInProgress });\n        if (loadingInProgress) {\n            console.log('JF: lazyLoad - already in progress, returning false');\n            return false;\n        }\n\n        if (!loaded) {\n            loaded = true;\n            loadingInProgress = true;\n            loadOnExpanded.dispose();\n            try {\n                console.log('JF: lazyLoad - calling load function');\n                await load(batchQuery);\n                console.log('JF: lazyLoad - load function completed');\n            } catch (error) {\n                console.error(`LazyLoad failed for node ${parent.id}:`, error);\n            } finally {\n                loadingInProgress = false;\n            }\n            console.log('JF: lazyLoad - removing loading node and refreshing structure');\n            CompositeTreeNode.removeChild(parent, loadingNode);\n            await tree.refreshStructure(parent);\n            console.log('JF: lazyLoad - refreshStructure completed', {\n                parentChildrenCount: parent.children.length,\n                parentChildrenIds: parent.children.map(c => c.id)\n            });\n            return true;\n        }\n        console.log('JF: lazyLoad - already loaded, returning false');\n        return false;\n    };\n\n    // create lazy loading node\n    const loadingNode: CommandEmptyNode = CommandEmptyNode.create(parent, lazyLoad);\n    CompositeTreeNode.addChild(parent, loadingNode);\n\n    // register for lazy loading when the node is expanded\n    const loadOnExpanded = SokatoaLifecycleTreeNode.register(parent, 'onWillRender', async () => {\n        if (parent.expanded) {\n            // do not batch queries for expansion manually\n            await lazyLoad(false);\n        }\n    });\n    return loadingNode;\n}\n"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01FksiHTQYFoNDKu1Q97H1BD",
              "name": "getFileContent",
              "arguments": "{\"file\": \"app/packages/capture/src/browser/command-tree/lazy-load-utils.ts\"}",
              "finished": true,
              "result": "/********************************************************************************\n    Copyright 2026 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\n\nimport { CompositeTreeNode, TreeNode } from '@theia/core/lib/browser';\nimport { wait } from '@theia/core/lib/common/promise-util';\n\nexport interface LazyLoadWaitOptions {\n    /** Maximum time to wait in milliseconds. */\n    timeoutMs?: number;\n    /** Interval between checks in milliseconds. */\n    checkIntervalMs?: number;\n}\n\nconst DEFAULT_LAZY_LOAD_WAIT_OPTIONS: Required<LazyLoadWaitOptions> = {\n    timeoutMs: 60000,\n    checkIntervalMs: 100\n};\n\n/**\n * Waits until a loading node is removed from its parent's children list.\n * @returns Promise that resolves when the loading node is removed, or logs a warning on timeout\n */\nexport async function waitForLoadingNodeRemoval(\n    loadingNodeId: string,\n    parent: CompositeTreeNode | undefined,\n    options?: LazyLoadWaitOptions\n): Promise<void> {\n    const opts = { ...DEFAULT_LAZY_LOAD_WAIT_OPTIONS, ...options };\n    const parentId = parent?.id ?? 'unknown';\n    console.log('JF: waitForLoadingNodeRemoval START', { loadingNodeId, parentId, timeoutMs: opts.timeoutMs });\n\n    const maxTries = Math.ceil(opts.timeoutMs / opts.checkIntervalMs);\n    for (let i = 0; i < maxTries; i++) {\n        await wait(opts.checkIntervalMs);\n        const children = parent ? parent.children : [];\n        const loadingNodeStillPresent = children.some(child => child.id === loadingNodeId);\n        if (!loadingNodeStillPresent) {\n            console.log('JF: waitForLoadingNodeRemoval - node removed after', { tries: i + 1 });\n            return;\n        }\n        if (i % 10 === 0) {\n            console.log('JF: waitForLoadingNodeRemoval - still waiting', { tries: i + 1, loadingNodeId });\n        }\n    }\n    console.warn(`JF: Loading node still not removed after ${opts.timeoutMs}ms for parent: ${parentId}`);\n}\n\nexport interface LazyLoadableNode extends TreeNode {\n    load(batchQuery?: boolean): Promise<boolean>;\n    parent: CompositeTreeNode | undefined;\n}\n\nexport async function triggerLazyLoadAndWaitForRemoval(node: LazyLoadableNode, options?: LazyLoadWaitOptions): Promise<void> {\n    const loadingNodeId = node.id;\n    console.log('JF: triggerLazyLoadAndWaitForRemoval START', { loadingNodeId, parentId: node.parent?.id });\n\n    // Directly call the load function - this triggers the lazy loading\n    // without requiring the node to be rendered\n    console.log('JF: triggerLazyLoadAndWaitForRemoval - calling node.load()');\n    await node.load();\n    console.log('JF: triggerLazyLoadAndWaitForRemoval - node.load() completed');\n\n    // Wait until the loading node is removed from children list\n    await waitForLoadingNodeRemoval(loadingNodeId, node.parent, options);\n    console.log('JF: triggerLazyLoadAndWaitForRemoval END', { loadingNodeId });\n}\n"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_0127v6xGBBS5vtssYBLZuxhG",
              "name": "getFileContent",
              "arguments": "{\"file\": \"app/packages/platform/src/browser/tree-table/tree-table-widget.tsx\"}",
              "finished": true,
              "result": "/********************************************************************************\n    Copyright 2024-2025 The Sokatoa Project Authors\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n ********************************************************************************/\n\n// This is a fork of Theia's tree-widget.tsx implementation with the aim of\n// reusing as much common models and services as possible\n// Below is the original copyright header\n\n// *****************************************************************************\n// Copyright (C) 2018 TypeFox and others.\n//\n// This program and the accompanying materials are made available under the\n// terms of the Eclipse Public License v. 2.0 which is available at\n// http://www.eclipse.org/legal/epl-2.0.\n//\n// This Source Code may also be made available under the following Secondary\n// Licenses when the conditions for such availability set forth in the Eclipse\n// Public License v. 2.0 are satisfied: GNU General Public License, version 2\n// with the GNU Classpath Exception which is available at\n// https://www.gnu.org/software/classpath/license.html.\n//\n// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n// *****************************************************************************\n\nimport {\n    CancellationError,\n    CancellationToken,\n    CancellationTokenSource,\n    CorePreferences,\n    Disposable,\n    DisposableCollection,\n    Emitter,\n    Event,\n    isOSX,\n    MenuPath,\n    Mutable,\n    notEmpty,\n    PreferenceChange,\n    PreferenceService,\n    Progress,\n    ProgressService,\n    SelectionService,\n    unreachable\n} from '@theia/core';\nimport {\n    animationFrame,\n    codicon,\n    CompositeTreeNode,\n    ContextMenuRenderer,\n    DecoratedTreeNode,\n    defaultTreeProps,\n    ExpandableTreeNode,\n    Key,\n    KeyCode,\n    KeyModifier,\n    LabelProvider,\n    Message,\n    SelectableTreeNode,\n    StatefulWidget,\n    Tree,\n    TreeDecoratorService,\n    TreeModel,\n    TreeNode,\n    TreeProps,\n    TreeSearch,\n    TreeSelection,\n    TreeWidget,\n    UnsafeWidgetUtilities,\n    Widget\n} from '@theia/core/lib/browser';\nimport { SearchBox, SearchBoxFactory, SearchBoxProps as SearchBoxPropsInterface } from '@theia/core/lib/browser/tree/search-box';\nimport { SearchBoxDebounce } from '@theia/core/lib/browser/tree/search-box-debounce';\nimport { TreeFocusService } from '@theia/core/lib/browser/tree/tree-focus-service';\nimport { WidgetDecoration as TreeDecoration } from '@theia/core/lib/browser/widget-decoration';\nimport { Deferred } from '@theia/core/lib/common/promise-util';\nimport { PREFERENCE_NAME_TREE_INDENT } from '@theia/core/lib/common/tree-preference';\nimport { inject, injectable, postConstruct } from '@theia/core/shared/inversify';\nimport debounce from '@theia/core/shared/lodash.debounce';\nimport React, { CSSProperties, useEffect } from '@theia/core/shared/react';\nimport { GetProp, Table, Tooltip } from 'antd';\nimport { ColumnsType, ColumnType } from 'antd/es/table';\nimport {\n    ExpandableConfig,\n    FilterValue,\n    SorterResult,\n    SortOrder,\n    TableCurrentDataSource,\n    TablePaginationConfig\n} from 'antd/es/table/interface';\nimport { classNames as classNamesUtils } from 'primereact/utils';\nimport { AlignType, GetComponentProps, RenderExpandIconProps, ScrollConfig, SpecialString } from 'rc-table/lib/interface';\nimport { type DotPathOf, hasObjectProperty, Iterators, Objects } from '../../common/utils';\nimport { ContextMenuHelper } from '../context-menu-helper';\nimport { waitForElement } from '../core';\nimport { SearchPreferenceHelper } from '../search-preferences';\nimport { SokatoaCachingTreeDecoratorService } from '../widgets';\nimport { SokatoaReactWidget } from '../widgets/sokatoa-base-widget';\nimport { VisibilityGateFactory } from '../widgets/visibility-gate';\nimport { TreeTableContextService } from './tree-table-context-service';\nimport { TreeTableWidgetSelection } from './tree-table-widget-selection';\n\nexport const TREE_TABLE_CLASS = 'sokatoa-TreeTable';\nexport const TREE_CONTAINER_CLASS = 'sokatoa-TreeTableContainer';\nexport const TREE_TABLE_NODE_CLASS = 'sokatoa-TreeTableNode';\nexport const TREE_TABLE_NODE_CONTENT_CLASS = 'sokatoa-TreeTableNodeContent';\nexport const TREE_TABLE_NODE_TAIL_CLASS = 'sokatoa-TreeTableNodeTail';\nexport const TREE_TABLE_NODE_SEGMENT_CLASS = 'sokatoa-TreeTableNodeSegment';\nexport const TREE_TABLE_NODE_SEGMENT_GROW_CLASS = 'sokatoa-TreeTableNodeSegmentGrow';\nexport const TREE_TABLE_NON_HIGHLIGHT = 'sokatoa-non-highlight';\n\nexport const TreeTableProps = Symbol('TreeTableProps');\n\n/**\n * Allows to separate UI updates and model (structure) updates.\n *\n * This is useful when updating the structure is more expensive than rendering.\n * A single update is triggered for the whole subtree.\n */\nexport interface TreeStructureChangeEmitter {\n    readonly onStructureChanged: Event<TreeNode | undefined>;\n}\n\nexport function isTreeStructureChangeEmitter(toCheck: any): toCheck is TreeStructureChangeEmitter {\n    return typeof toCheck === 'object' && 'onStructureChanged' in toCheck;\n}\n\n/**\n * Representation of tree table properties.\n */\nexport type TreeTableProps = Omit<TreeProps, 'virtualized'>;\n\n/**\n * The default tree table properties.\n */\nexport const defaultTreeTableProps: TreeTableProps = {\n    ...defaultTreeProps\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface TreeTableColumnData {}\n\nexport interface TreeTableColumnHeaderProps {\n    title?: string;\n    sortable?: boolean;\n    description?: string;\n    align?: AlignType;\n}\n\nexport interface TreeTableRoot<T extends TreeTableColumnData = any> {\n    children: TreeTableRow<T>[];\n}\n\nexport type TreeTableRowParent<T extends TreeTableColumnData = any> = TreeTableRow<T> | TreeTableRoot<T>;\n\nexport interface TreeTableRow<T extends TreeTableColumnData = any> {\n    /** The identifier of this row. */\n    key: string;\n    /** The Theia tree node on which this row is based. */\n    node: Mutable<TreeNode>;\n    /** The column data associated with this row. */\n    columnData: T;\n    /** The parent node. */\n    parent: TreeTableRowParent<T>;\n    /** The children of this row. The property name must match with the 'expandable.childrenColumnName' in the table rendering. */\n    children?: TreeTableRow<T>[];\n}\n\nexport function isTreeTableRow<T extends TreeTableColumnData = any>(toCheck: any): toCheck is TreeTableRow<T> {\n    return hasObjectProperty<TreeTableRow>(toCheck, 'key', 'node', 'columnData', 'parent');\n}\n\nexport interface LazyTreeTableRow<T extends TreeTableColumnData = any> extends TreeTableRow<T> {\n    isResolved: boolean;\n    isResolving: boolean;\n    onResolved: Event<T>;\n    resolveColumnData(): Promise<T>;\n}\n\nexport namespace LazyTreeTableRow {\n    export function is<T extends TreeTableColumnData = any>(toCheck: any): toCheck is LazyTreeTableRow<T> {\n        return isTreeTableRow(toCheck) && hasObjectProperty<LazyTreeTableRow>(toCheck, 'isResolved', 'resolveColumnData');\n    }\n\n    export function resolve<T extends TreeTableColumnData = any>(toCheck: any): Promise<T> {\n        return is(toCheck) ? toCheck.resolveColumnData() : Promise.resolve(toCheck.columnData);\n    }\n\n    export function isUnresolved<T extends TreeTableColumnData = any>(toCheck: any): toCheck is LazyTreeTableRow<T> {\n        return is(toCheck) && !toCheck.isResolved;\n    }\n\n    export function isResolving<T extends TreeTableColumnData = any>(toCheck: any): toCheck is LazyTreeTableRow<T> {\n        return is(toCheck) && toCheck.isResolving;\n    }\n}\n\nexport interface TreeTableStructuralChange {\n    regenerateTreeTableRows?: boolean;\n    sortTreeTableRows?: boolean;\n    updateExpandedRowKeys?: boolean;\n    updateFilteredRows?: boolean;\n    affectedNodes?: TreeNode[];\n}\n\nexport type TreeTableDataKey<T extends TreeTableColumnData> = DotPathOf<T>;\n\nexport interface TreeTableColumn<D extends TreeTableColumnData, T = TreeTableRow<D>> extends ColumnType<T> {\n    key: 'node' | TreeTableDataKey<D> | string;\n    dataIndex: SpecialString<T> | number | (SpecialString<T> | number)[];\n}\n\nexport interface TreeTableRepresentationModel<T extends TreeTableColumnData = any> {\n    tree: TreeTableRow<T>[];\n    size: number;\n}\n\nexport interface TreeTableRowRepresentationModel<T extends TreeTableColumnData = any> {\n    node: TreeNode;\n    treeRow: TreeTableRow<T>;\n}\n\n/** Properties for the internal tree table view rendering. */\nexport interface TreeTableViewProps<T extends TreeTableColumnData> {\n    // data model\n    rows: TreeTableRow<T>[];\n    columns: ColumnsType<TreeTableRow<T>>;\n\n    // state\n    expandedRowsKeys: React.Key[];\n\n    onToggle(expanded: boolean, data: TreeTableRow<T>): void;\n    getRowClassName(row: TreeTableRow<T>, index?: number): string | undefined;\n    onChange: (\n        pagination: TablePaginationConfig,\n        filters: Record<string, FilterValue | null>,\n        sorter: SorterResult<TreeTableRow<T>> | SorterResult<TreeTableRow<T>>[],\n        extra: TableCurrentDataSource<TreeTableRow<T>>\n    ) => void;\n    showHeader: boolean;\n    onRender(): void;\n\n    scroll?: {\n        x: number | 'max-content' | 'dynamic-content';\n        y: number | 'max-content';\n    };\n    scrollTo?: TreeTableScrollToConfig;\n    onScrollTo?: (scrolledTo: TreeTableScrollToConfig) => void;\n    indentSize?: number;\n    getExpanderDataTestId(row: TreeTableRow<T>): string | undefined;\n    locale?: GetProp<typeof Table, 'locale'>;\n    isExpandable: (candidate: TreeTableRow<T>) => boolean;\n}\n\ninterface TreeTableScrollToConfig extends ScrollConfig {\n    /** number of pixels the scrollbar is moved from the left */\n    left?: number;\n}\n\n/**\n * Enhanced Expand Icon Props\n * @dataTestId string for the data-test-id attribute\n */\nexport interface RenderExpandIconEnhProps<RecordType> extends RenderExpandIconProps<RecordType> {\n    dataTestId: string | undefined;\n}\n\nexport type DropOperation = 'insert-before' | 'insert-after' | 'insert-into';\n\nexport interface Unsorted {\n    type: 'none';\n}\n\nexport type SortMode = 'ascending' | 'descending' | 'none';\n\nexport type ColumnKey = React.Key;\nexport interface SingleColumnSort {\n    type: 'single-column';\n    columnKey: ColumnKey;\n    mode: Exclude<SortMode, 'none'>;\n}\n\nexport type SortDescriptor = Unsorted | SingleColumnSort;\nexport namespace SortDescriptor {\n    export function equals(sort1: SortDescriptor, sort2: SortDescriptor): boolean {\n        if (sort1.type !== sort2.type) {\n            return false;\n        }\n        // Check both to let TypeScript infer the remaining type\n        if (sort1.type === 'none' || sort2.type === 'none') {\n            return true;\n        }\n        return sort2.columnKey === sort1.columnKey && sort2.mode === sort1.mode;\n    }\n}\n\nexport interface RowUpdateConfig {\n    regenerateRowModel?: boolean;\n    sortTreeTableRows?: boolean;\n    updateFilteredRows?: boolean;\n    updateExpandedRowKeys?: boolean;\n    decorationsPotentiallyIncomplete?: boolean;\n}\n\nexport namespace RowUpdateConfig {\n    export function allTrue(...except: Array<keyof RowUpdateConfig>): RowUpdateConfig {\n        const res = {\n            regenerateRowModel: true,\n            sortTreeTableRows: true,\n            updateFilteredRows: true,\n            updateExpandedRowKeys: true,\n            decorationsPotentiallyIncomplete: true\n        };\n        for (const notTrue of except) {\n            res[notTrue] = false;\n        }\n        return res;\n    }\n\n    export function allFalse(...except: Array<keyof RowUpdateConfig>): RowUpdateConfig {\n        const res = {\n            regenerateRowModel: false,\n            sortTreeTableRows: false,\n            updateFilteredRows: false,\n            updateExpandedRowKeys: false,\n            decorationsPotentiallyIncomplete: false\n        };\n        for (const notFalse of except) {\n            res[notFalse] = true;\n        }\n        return res;\n    }\n}\n\nconst MIN_TABLE_SIZE_PX = 10;\n\nconst THEIA_EXPANSION_TOGGLE_CLASS = 'theia-ExpansionToggle';\n\nexport const BASIC_SCROLL_HYSTERESIS_MS = 50;\nexport const EXPANSION_SCROLL_HYSTERESIS_MS = BASIC_SCROLL_HYSTERESIS_MS * 4;\n\ntype UpdateDecorationsParams = TreeNode | TreeNode[];\n\nconst FETCHING_DATA_CLASS = 'fetching-data';\n/**\n * A tree table widget that can be used as an in-place replacement for the Theia tree widget.\n */\n@injectable()\nexport abstract class TreeTableWidget<T extends TreeTableColumnData> extends SokatoaReactWidget implements StatefulWidget {\n    protected searchBox: SearchBox;\n    protected searchHighlights?: Map<string, TreeDecoration.CaptionHighlight>;\n\n    @inject(TreeDecoratorService)\n    protected readonly decoratorService: TreeDecoratorService;\n\n    @inject(Tree)\n    protected readonly tree: Tree;\n\n    @inject(TreeSearch)\n    protected readonly treeSearch: TreeSearch;\n\n    @inject(SearchBoxFactory)\n    protected readonly searchBoxFactory: SearchBoxFactory;\n\n    @inject(TreeFocusService)\n    protected readonly focusService: TreeFocusService;\n\n    protected decorations: Map<string, TreeDecoration.Data[]> = new Map();\n\n    @inject(SelectionService)\n    protected readonly selectionService: SelectionService;\n\n    @inject(PreferenceService)\n    protected readonly preferenceService: PreferenceService;\n\n    @inject(LabelProvider)\n    protected readonly labelProvider: LabelProvider;\n\n    @inject(CorePreferences)\n    protected readonly corePreferences: CorePreferences;\n\n    @inject(ProgressService)\n    protected readonly progressService: ProgressService;\n\n    @inject(TreeTableContextService)\n    protected readonly contextService: TreeTableContextService;\n\n    @inject(SearchPreferenceHelper)\n    protected searchPreferenceHelper: SearchPreferenceHelper;\n\n    @inject(VisibilityGateFactory)\n    protected readonly visibilityGateFactory: VisibilityGateFactory;\n\n    protected readonly contextMenuHelper: ContextMenuHelper;\n\n    protected treeIndent: number;\n    protected shouldCalcScroll = true;\n    protected scroll: NonNullable<TreeTableViewProps<T>['scroll']> = { x: -1, y: -1 };\n    protected focused = false;\n    protected styleChildrenOfSelection = false;\n\n    constructor(\n        @inject(TreeTableProps) readonly props: TreeTableProps,\n        @inject(TreeModel) readonly model: TreeModel,\n        @inject(ContextMenuRenderer)\n        protected readonly contextMenuRenderer: ContextMenuRenderer\n    ) {\n        super();\n        this.contextMenuHelper = ContextMenuHelper.for(contextMenuRenderer);\n        this.scrollOptions = {\n            suppressScrollX: true,\n            minScrollbarLength: 35\n        };\n        this.addClass(TREE_TABLE_CLASS);\n        this.addClass('sokatoa-tree');\n        this.node.tabIndex = 0;\n\n        // add focus listeners to update styling based on focus\n        const focusIn = (): void => {\n            this.focused = true;\n            this.update();\n        };\n        const focusOut = (): void => {\n            this.focused = false;\n            this.update();\n        };\n        this.node.addEventListener('focusin', focusIn);\n        this.node.addEventListener('focusout', focusOut);\n        this.toDispose.pushAll([\n            Disposable.create(() => this.node.removeEventListener('focusin', focusIn)),\n            Disposable.create(() => this.node.removeEventListener('focusout', focusOut))\n        ]);\n    }\n\n    @postConstruct()\n    protected init(): void {\n        this.contextService.init(this.node);\n        this.treeIndent = this.preferenceService.get(PREFERENCE_NAME_TREE_INDENT, this.treeIndent);\n        if (this.props.search) {\n            this.searchBox = this.searchBoxFactory({\n                ...SearchBoxPropsInterface.DEFAULT,\n                showButtons: true,\n                showFilter: true\n            });\n            this.searchBox.node.addEventListener('focus', () => {\n                this.node.focus();\n            });\n            const applyFilter = this.searchPreferenceHelper.debounce(this.doHandleFilterChange.bind(this));\n            this.toDispose.pushAll([\n                this.searchBox,\n                applyFilter,\n                this.searchBox.onTextChange(applyFilter),\n                this.searchBox.onClose(data => this.treeSearch.filter(undefined)),\n                this.searchBox.onNext(() => {\n                    // Enable next selection if there are currently highlights.\n                    if (this.searchHighlights && this.searchHighlights.size > 1) {\n                        this.model.selectNextNode();\n                    }\n                }),\n                this.searchBox.onPrevious(() => {\n                    // Enable previous selection if there are currently highlights.\n                    if (this.searchHighlights && this.searchHighlights.size > 1) {\n                        this.model.selectPrevNode();\n                    }\n                }),\n                this.searchBox.onFilterToggled(e => {\n                    this.updateRows({\n                        regenerateTreeTableRows: true\n                    });\n                }),\n                this.treeSearch,\n                this.treeSearch.onFilteredNodesChanged(nodes => {\n                    if (this.searchBox.isFiltering) {\n                        this.updateRows({\n                            regenerateTreeTableRows: true\n                        });\n                    }\n                    this.updateFilteredNodesSelection(nodes, this.treeSearch);\n                })\n            ]);\n        }\n\n        // as of now no special handling of middle click event as in theia table\n\n        this.toDispose.pushAll([\n            this.model,\n            this.setupOnChangedListener(),\n            this.model.onSelectionChanged(nodes => {\n                if (nodes.length > 0) {\n                    this.scheduleUpdateScrollToRow(nodes[0].id);\n                }\n            }),\n            this.focusService.onDidChangeFocus(node => {\n                if (node !== undefined) {\n                    this.scheduleUpdateScrollToRow(node.id);\n                }\n            }),\n            this.model.onDidChangeBusy(() => this.update()),\n            this.model.onDidUpdate(() => this.update()),\n            this.model.onNodeRefreshed(node => this.doUpdateDecorations(node)),\n            this.model.onExpansionChanged(node => this.doUpdateDecorations(node)),\n            this.decoratorService,\n            this.decoratorService.onDidChangeDecorations(() => this.updateDecorations()),\n            this.labelProvider.onDidChange(e => {\n                for (const row of this.asList()) {\n                    if (e.affects(row.node)) {\n                        this.update();\n                        return;\n                    }\n                }\n            }),\n            this.preferenceService.onPreferenceChanged((event: PreferenceChange) => {\n                if (event.preferenceName === PREFERENCE_NAME_TREE_INDENT) {\n                    this.treeIndent = Number(event.newValue ?? 0);\n                    this.update();\n                }\n            }),\n            this.dragOverExpansion\n        ]);\n        setTimeout(() => {\n            this.updateRows({\n                regenerateTreeTableRows: true\n            });\n            this.updateDecorations();\n        });\n\n        // update selection in tree table framework + styling\n        this.toDispose.push(this.model.onSelectionChanged(() => this.updateSelection()));\n\n        if (this.props.globalSelection) {\n            this.toDispose.pushAll([\n                this.model.onSelectionChanged(() => {\n                    if (this.shouldUpdateGlobalSelection()) {\n                        this.updateGlobalSelection();\n                    }\n                }),\n                this.focusService.onDidChangeFocus(focus => {\n                    if (\n                        focus &&\n                        this.shouldUpdateGlobalSelection() &&\n                        this.model.selectedNodes[0] !== focus &&\n                        this.model.selectedNodes.includes(focus)\n                    ) {\n                        this.updateGlobalSelection();\n                    }\n                }),\n                Disposable.create(() => {\n                    const selection = this.selectionService.selection;\n                    if (TreeTableWidgetSelection.isSource(selection, this)) {\n                        this.selectionService.selection = undefined;\n                    }\n                })\n            ]);\n\n            this.node.addEventListener('focusin', e => {\n                if (\n                    this.model.selectedNodes.length &&\n                    (!this.selectionService.selection || !TreeTableWidgetSelection.isSource(this.selectionService.selection, this))\n                ) {\n                    this.updateGlobalSelection();\n                }\n            });\n        }\n        this.toDispose.push(\n            this.corePreferences.onPreferenceChanged(preference => {\n                if (preference.preferenceName === 'workbench.tree.renderIndentGuides') {\n                    this.update();\n                }\n            })\n        );\n        this.toDispose.push(\n            Disposable.create(() => {\n                // reset internal model on dispose to help with GC\n                this.rowModel.tree.length = 0;\n                this.rows.length = 0;\n                this.expandedRowKeys.length = 0;\n                this.sorter = undefined;\n                this.scrollTo = undefined;\n                this.rowCache.clear();\n            })\n        );\n\n        // Trigger initial scroll constraint calculation after the view is ready.\n        const cancellationToken = new CancellationTokenSource();\n\n        void waitForElement(this.node, '.ant-table-tbody-virtual-holder', cancellationToken.token)\n            .then(() => {\n                this.updateScrollConstraints();\n            })\n            .catch(e => {\n                if (e instanceof CancellationError) {\n                    return;\n                }\n\n                console.error(e);\n            });\n        this.toDispose.push(cancellationToken);\n    }\n\n    protected updateFilteredNodesSelection(newFilteredNodes: readonly Readonly<TreeNode>[], treeSearch: TreeSearch): void {\n        if (\n            this.model.selectedNodes.length > 0 &&\n            (newFilteredNodes.length === 0 || treeSearch.passesFilters(this.model.selectedNodes[0]))\n        ) {\n            // If there is an existing selection and either:\n            // - no filters are applied (i.e. all nodes are shown), or\n            // - the current selection (including its parent nodes) passes the active filters,\n            // then we want to ensure that this selection is visible.\n            // We delay scrolling slightly because the number of shown nodes may grow drastically\n            this.scheduleUpdateScrollToRow(this.model.selectedNodes[0].id, true)?.catch(e => console.error(e));\n        } else {\n            // Otherwise, if the current selection doesn't pass the filters,\n            // select the first node from the filtered list that is selectable\n            // and scroll to it.\n            const node = newFilteredNodes.find(SelectableTreeNode.is);\n            if (node) {\n                this.model.selectNode(node);\n                this.scheduleUpdateScrollToRow(node.id)?.catch(e => console.error(e));\n            }\n        }\n    }\n\n    protected async doHandleFilterChange(data?: string): Promise<void> {\n        await this.treeSearch.filter(data);\n        this.searchHighlights = this.treeSearch.getHighlights();\n        this.searchBox.updateHighlightInfo({\n            filterText: data,\n            total: this.rowModel.size,\n            matched: this.searchHighlights.size\n        });\n        this.update();\n    }\n\n    protected shouldUpdateGlobalSelection(): boolean {\n        return this.node.contains(document.activeElement) || TreeTableWidgetSelection.isSource(this.selectionService.selection, this);\n    }\n\n    protected setupOnChangedListener(): Disposable {\n        if (isTreeStructureChangeEmitter(this.model)) {\n            const structureChange = this.model.onStructureChanged(node => {\n                console.log('JF: TreeTableWidget.onStructureChanged received', { nodeId: node?.id });\n                // FIXME(GH-2093): Performance Issues (don't recreate all rows, support partial update)\n                this.updateRows({\n                    regenerateTreeTableRows: true\n                });\n            });\n            const expansionChange = this.model.onExpansionChanged(() => {\n                console.log('JF: TreeTableWidget.onExpansionChanged received');\n                this.updateRows({\n                    updateExpandedRowKeys: true\n                });\n            });\n            const modelChange = this.model.onChanged(() => {\n                console.log('JF: TreeTableWidget.onChanged received');\n                this.update();\n            });\n            return Disposable.create(() => {\n                structureChange.dispose();\n                expansionChange.dispose();\n                modelChange.dispose();\n            });\n        } else {\n            /* we only have the regular information from Theia -> assume all structure changes */\n            return this.model.onChanged(() => {\n                console.log('JF: TreeTableWidget.onChanged (fallback) received');\n                this.updateRows({\n                    regenerateTreeTableRows: true\n                });\n            });\n        }\n    }\n\n    /**\n     * Update the global selection for the tree.\n     */\n    protected updateGlobalSelection(): void {\n        this.selectionService.selection = TreeTableWidgetSelection.create(this);\n    }\n\n    protected rowModel: TreeTableRepresentationModel<T> = { tree: [], size: 0 };\n    protected rowCache: Map<string, TreeTableRow<T>> = new Map();\n    /** The actually used row model depending on the configuration. */\n    protected rows: TreeTableRow<T>[] = this.rowModel.tree;\n\n    protected asList(): IterableIterator<TreeTableRow<T>> {\n        return Iterators.childrenFromArray(this.rowModel.tree);\n    }\n\n    protected expandedRowKeys: React.Key[] = [];\n    protected sorter?: SorterResult<TreeTableRow<T>> = undefined;\n    protected scrollTo?: TreeTableScrollToConfig;\n\n    private updateRowsCancellation?: CancellationTokenSource;\n    protected updateRows(change: TreeTableStructuralChange = {}): void {\n        console.log('JF: TreeTableWidget.updateRows called', { change });\n        this.doSetUpdateRowsConfig(change);\n        this.updateRowsCancellation?.dispose();\n        const localCancellation = (this.updateRowsCancellation = new CancellationTokenSource());\n        this.debouncedDoUpdateRows(localCancellation.token);\n    }\n\n    protected rowUpdateConfig: RowUpdateConfig = {\n        regenerateRowModel: true,\n        sortTreeTableRows: true,\n        updateFilteredRows: true,\n        updateExpandedRowKeys: true,\n        decorationsPotentiallyIncomplete: true\n    };\n\n    protected doSetUpdateRowsConfig(change: TreeTableStructuralChange = {}): void {\n        const { regenerateTreeTableRows, sortTreeTableRows, updateExpandedRowKeys, updateFilteredRows } = change;\n        // with this method we can tell the update rows method to update certain aspects if true is passed\n        // when false is passed, this does not override/prevent an update requested by a different caller\n        // update rows will reset the config once consumed\n        if (!this.rowUpdateConfig.regenerateRowModel && regenerateTreeTableRows) {\n            // if we have a structural change, everything should be recomputed\n            this.rowUpdateConfig = RowUpdateConfig.allTrue();\n        }\n        this.rowUpdateConfig.sortTreeTableRows ||= sortTreeTableRows;\n        this.rowUpdateConfig.updateExpandedRowKeys ||= updateExpandedRowKeys;\n        this.rowUpdateConfig.updateFilteredRows ||= updateFilteredRows;\n    }\n    protected toDisposeOnUpdateRows = new DisposableCollection();\n    // execute immediately, if further calls within 100ms execute only last one after 100ms\n    protected debouncedDoUpdateRows = debounce(this.doUpdateRows, 100, {\n        leading: true,\n        trailing: true\n    });\n    protected async doUpdateRows(token: CancellationToken): Promise<void> {\n        if (token.isCancellationRequested) {\n            return;\n        }\n        const config = { ...this.rowUpdateConfig };\n        if (config.regenerateRowModel) {\n            const root = this.model.root;\n            const visitedKeys = new Set<string>();\n            const model = CompositeTreeNode.is(root)\n                ? this.createRowModel(root.children, token, { children: [] }, visitedKeys, undefined)\n                : undefined;\n            await this.setRowModel(model, token, visitedKeys);\n        }\n        if (token.isCancellationRequested) {\n            return;\n        }\n        await this.setRows(config);\n        if (token.isCancellationRequested) {\n            return;\n        }\n        this.update();\n        await animationFrame(1);\n        if (token.isCancellationRequested) {\n            return;\n        }\n        this.toDisposeOnUpdateRows.dispose();\n        this.update();\n        if (Objects.partialEqual(config, this.rowUpdateConfig)) {\n            this.rowUpdateConfig = RowUpdateConfig.allFalse();\n        }\n    }\n\n    protected async setRowModel(\n        model: TreeTableRepresentationModel<T> = { tree: [], size: 0 },\n        cancellationToken: CancellationToken,\n        visitedKeys: Set<string>\n    ): Promise<void> {\n        if (cancellationToken.isCancellationRequested) {\n            return;\n        }\n        if (model.size === 0) {\n            this.rowCache.clear();\n        } else if (visitedKeys) {\n            this.pruneRowCache(visitedKeys);\n        }\n        this.rowModel = model;\n    }\n\n    protected async setRows(config: RowUpdateConfig): Promise<void> {\n        if (config.sortTreeTableRows) {\n            // if we have sorting enabled, we need to use the sorted list\n            if (this.requiresSorting()) {\n                // the decorations may rely on the tree node structure for lazy initialization\n                // on sort we are using a flat list of all the tree nodes though\n                // make sure the decorations are fully initialized\n                if (config.decorationsPotentiallyIncomplete) {\n                    this.doUpdateDecorations(Array.from(this.asList()).map(row => row.node)).catch(e => console.error(e));\n                }\n                this.rows = this.rowModel.tree;\n                await this.sort();\n            }\n        }\n        if (config.updateFilteredRows) {\n            if (this.shouldResolveLazyTreeNodesOnFilter()) {\n                await this.resolveLazyTreeNodes();\n            }\n            this.rows = this.filterRows();\n        }\n        if (config.updateExpandedRowKeys) {\n            this.expandedRowKeys = Array.from(\n                Iterators.filter(this.asList(), row => ExpandableTreeNode.isExpanded(row.node)),\n                row => row.key\n            );\n        }\n    }\n\n    protected filterRows(): TreeTableRow<T>[] {\n        // no op by default\n        return this.rowModel.tree;\n    }\n\n    requiresSorting(): boolean {\n        return !!this.sorter?.order && !!this.sorter.columnKey;\n    }\n\n    protected onScrollTo = (scrolledTo: TreeTableScrollToConfig): void => {\n        // Clear only if execution and current request are identical.\n        if (\n            this.scrollTo &&\n            scrolledTo.index === this.scrollTo.index &&\n            scrolledTo.key === this.scrollTo.key &&\n            scrolledTo.top === this.scrollTo.top &&\n            scrolledTo.left === this.scrollTo.left\n        ) {\n            this.scrollTo = undefined;\n        }\n    };\n\n    protected shouldResolveLazyTreeNodesOnFilter(): boolean {\n        return false;\n    }\n\n    protected getUnresolvedData(rows: Iterable<TreeTableRow<T>>): Promise<T>[] {\n        return Array.from(Iterators.filter(rows, LazyTreeTableRow.isUnresolved<T>), row => row.resolveColumnData());\n    }\n\n    protected async showProgressWhileResolving(sorting: boolean): Promise<Progress> {\n        return this.progressService.showProgress({\n            text: sorting ? 'Fetching data to sort...' : 'Fetching data...',\n            options: { cancelable: false, location: 'notification' }\n        });\n    }\n\n    protected async resolveLazyTreeNodes(): Promise<void> {\n        let fetchingDataAdded = false;\n        let rows = this.rowModel.tree.slice();\n        let progress: Progress | undefined = undefined;\n        const startTime = Date.now();\n\n        try {\n            while (rows.length > 0) {\n                const unresolvedData = this.getUnresolvedData(rows);\n                if (unresolvedData.length > 0) {\n                    if (!fetchingDataAdded) {\n                        this.node.classList.add(FETCHING_DATA_CLASS);\n                        fetchingDataAdded = true;\n                    }\n\n                    await Promise.all(unresolvedData);\n\n                    // also show progress if resolution seems to be taking longer\n                    if (progress === undefined && Date.now() - startTime > 200) {\n                        progress = await this.showProgressWhileResolving(false);\n                    }\n                }\n\n                const newRows: TreeTableRow<T>[] = [];\n                for (const row of rows) {\n                    if (row.children && row.children.length > 0) {\n                        newRows.push(...row.children);\n                    }\n                }\n                rows = newRows;\n            }\n        } finally {\n            this.node.classList.remove(FETCHING_DATA_CLASS);\n            progress?.cancel();\n        }\n    }\n\n    protected requestId = 0;\n    protected currentSortOperationId: number | undefined;\n    protected currentSortOperationProgress: Promise<Progress> | undefined;\n    protected async sort(): Promise<void> {\n        const sortOperationId = this.requestId++;\n        this.currentSortOperationId = sortOperationId;\n\n        // get all data before updating rows so that sorting will work\n        const unresolvedData = this.getUnresolvedData(this.asList());\n        const cancelProgress = (): void => {\n            if (this.currentSortOperationProgress !== undefined) {\n                this.currentSortOperationProgress.then(progress => progress.cancel()).catch(e => console.error(e));\n                this.currentSortOperationProgress = undefined;\n            }\n        };\n        if (unresolvedData.length > 0) {\n            this.node.classList.add(FETCHING_DATA_CLASS);\n            if (this.currentSortOperationProgress === undefined) {\n                this.currentSortOperationProgress = this.showProgressWhileResolving(true);\n                this.toDispose.push(Disposable.create(cancelProgress));\n            }\n            try {\n                await Promise.all(unresolvedData);\n            } catch (e) {\n                console.error(e);\n            }\n        }\n        if (this.currentSortOperationId === sortOperationId) {\n            cancelProgress();\n            this.node.classList.remove('fetching-data');\n            this.sortRecursively(this.rowModel.tree);\n            this.currentSortOperationId = undefined;\n        }\n    }\n\n    protected sortRecursively(siblings: TreeTableRow<T>[]): void {\n        siblings.sort((l, r) => this.sortRows(l, r));\n        siblings.forEach(current => {\n            if (Array.isArray(current.children)) {\n                this.sortRecursively(current.children);\n            }\n        });\n    }\n\n    get sortDescriptor(): SortDescriptor {\n        if (!this.sorter?.columnKey) {\n            return { type: 'none' };\n        }\n\n        const mode = this.sorter.order === 'descend' ? 'descending' : 'ascending';\n        return {\n            type: 'single-column',\n            columnKey: this.sorter.columnKey,\n            mode\n        };\n    }\n\n    set sortDescriptor(sortDescriptor: SortDescriptor) {\n        const sortColumnKey = this.sorter?.columnKey;\n        const sortOrder = this.sorter?.order;\n        const sortColumn = sortColumnKey && sortOrder ? this.getColumns().find(column => column.key === sortColumnKey) : undefined;\n\n        const updateForSortChange = (): void => {\n            this.update();\n            this.updateRowsToSort().catch(e => console.error(e));\n        };\n\n        switch (sortDescriptor.type) {\n            case 'none':\n                if (sortColumn) {\n                    sortColumn.sortOrder = undefined;\n                    this.sorter = undefined;\n                }\n                updateForSortChange();\n                break;\n            case 'single-column': {\n                const newSortOrder = sortDescriptor.mode === 'descending' ? 'descend' : 'ascend';\n                if (sortColumn?.key === sortDescriptor.columnKey && sortColumn?.sortOrder === newSortOrder) {\n                    // No change\n                    return;\n                }\n\n                if (sortColumn) {\n                    sortColumn.sortOrder = undefined;\n                }\n\n                const newSortColumn = this.getColumns().find(column => column.key === sortDescriptor.columnKey);\n                if (newSortColumn && newSortColumn.sorter) {\n                    newSortColumn.sortOrder = newSortOrder;\n                    this.sorter = {\n                        column: newSortColumn,\n                        columnKey: sortDescriptor.columnKey,\n                        order: newSortOrder\n                    };\n                }\n                updateForSortChange();\n                break;\n            }\n            default:\n                unreachable(sortDescriptor);\n        }\n    }\n\n    /**\n     * Transforms the Theia TreeModel into a TreeTableModel.\n     */\n    protected createRowModel(\n        nodes: readonly TreeNode[],\n        cancellationToken: CancellationToken,\n        treeParent: TreeTableRowParent<T> = { children: [] },\n        visitedKeys: Set<string>,\n        props?: any\n    ): TreeTableRepresentationModel<T> {\n        const tree: TreeTableRow<T>[] = [];\n        let size = 0;\n        for (const node of nodes) {\n            if (cancellationToken.isCancellationRequested) {\n                return { tree, size };\n            }\n            if (!this.shouldDisplayNode(node)) {\n                continue;\n            }\n            visitedKeys.add(node.id);\n            const row = this.toRow(node, treeParent, props);\n            tree.push(row.treeRow);\n            size++;\n\n            if (CompositeTreeNode.is(node)) {\n                const subModel = this.createRowModel(node.children, cancellationToken, row.treeRow, visitedKeys, props);\n                row.treeRow.children = subModel.tree;\n                size += subModel.size;\n            }\n        }\n        return { tree, size };\n    }\n\n    protected toRow(node: TreeNode, treeParent: TreeTableRowParent<T>, props?: any): TreeTableRowRepresentationModel<T> {\n        const cachedRow = this.rowCache.get(node.id);\n\n        if (cachedRow && cachedRow.node === node) {\n            cachedRow.parent = treeParent;\n            cachedRow.children = undefined;\n            treeParent.children?.push(cachedRow);\n            return { node, treeRow: cachedRow };\n        }\n\n        const columnData = this.getColumnData(node);\n        const treeRow: TreeTableRow<T> = {\n            key: node.id,\n            node,\n            columnData,\n            parent: treeParent\n        };\n        treeParent.children?.push(treeRow);\n\n        this.rowCache.set(node.id, treeRow);\n\n        const model = { node, treeRow };\n        return this.decorateLazyRow(model);\n    }\n\n    protected pruneRowCache(visitedKeys: Set<string>): void {\n        if (this.rowCache.size === 0) {\n            return;\n        }\n        for (const cachedKey of this.rowCache.keys()) {\n            if (!visitedKeys.has(cachedKey)) {\n                this.rowCache.delete(cachedKey);\n            }\n        }\n    }\n\n    protected isLazyNode(node: TreeNode): boolean {\n        return false;\n    }\n\n    protected decorateLazyRow(model: TreeTableRowRepresentationModel<T>): TreeTableRowRepresentationModel<T> {\n        return !this.isLazyNode(model.node) || LazyTreeTableRow.is(model.treeRow) ? model : this.doDecorateLazyRow(model);\n    }\n\n    protected doDecorateLazyRow(model: TreeTableRowRepresentationModel<T>): TreeTableRowRepresentationModel<T> {\n        const listAndTreeRow = [model.treeRow as LazyTreeTableRow<T>];\n\n        // decorate the row with lazy loading capabilities\n        const resolution = new Deferred<T>();\n        const onResolvedEmitter = new Emitter<T>();\n        const resolveColumnData = async (): Promise<T> => {\n            // only resolve data once\n            if (listAndTreeRow.every(row => !row.isResolving && !row.isResolved)) {\n                listAndTreeRow.forEach(row => (row.isResolving = true));\n                this.resolveColumnData(model.node).then(data => {\n                    listAndTreeRow.forEach(row => {\n                        row.isResolving = false;\n                        row.columnData = data;\n                        row.isResolved = true;\n                        onResolvedEmitter.fire(data);\n                    });\n                    resolution.resolve(data);\n                }, resolution.reject);\n            }\n            return resolution.promise;\n        };\n        listAndTreeRow.forEach(row => {\n            row.isResolving = false;\n            row.isResolved = false;\n            row.onResolved = onResolvedEmitter.event;\n            row.resolveColumnData = resolveColumnData;\n        });\n        return model;\n    }\n\n    protected shouldDisplayNode(node: TreeNode): boolean {\n        return TreeNode.isVisible(node) && !this.isNodeFiltered(node);\n    }\n\n    protected isNodeFiltered(node: TreeNode): boolean {\n        return this.isFiltering && !this.treeSearch.passesFilters(node);\n    }\n\n    /**\n     * Schedules scrolling to a node and prepares the Tree accordingly (e.g. expanding parents)\n     *\n     * @param id the node's id to scroll to\n     * @param delayedScroll whether scrolling should be delayed. This might be required after expensive\n     *                      updates to give the ui time to render all nodes\n     * @returns\n     */\n    protected async scrollToNode(id: string, delayedScroll = false): Promise<void> {\n        const node = this.model.getNode(id);\n\n        if (node === undefined) {\n            return;\n        }\n\n        // expand all parents\n        let expandRequired = false;\n        let parent = node.parent;\n        while (parent !== undefined) {\n            if (ExpandableTreeNode.is(parent) && !parent.expanded) {\n                expandRequired = true;\n                await this.model.toggleNodeExpansion(parent);\n            }\n            parent = parent.parent;\n        }\n\n        if (expandRequired || delayedScroll) {\n            // give extra time to expand before scrolling\n            this.updateScrollToOnExpand({ key: id });\n        } else {\n            // we are using virtual rendering, give some time before scrolling\n            // usually this is only needed with rapid keyboard navigation\n            this.updateScrollToRegular({ key: id });\n        }\n    }\n    scheduleUpdateScrollToRow = debounce(this.scrollToNode);\n    protected updateScrollToOnExpand = debounce(this.updateScrollTo, EXPANSION_SCROLL_HYSTERESIS_MS);\n    protected updateScrollToRegular = debounce(this.updateScrollTo, BASIC_SCROLL_HYSTERESIS_MS);\n    protected async updateScrollTo(opts: TreeTableScrollToConfig): Promise<void> {\n        this.scrollTo = opts;\n        this.update();\n        await animationFrame(1);\n        this.update();\n    }\n\n    /**\n     * Update tree decorations.\n     * - Updating decorations are debounced in order to limit the number of expensive updates.\n     */\n    protected readonly updateDecorations = debounce((nodes?: UpdateDecorationsParams) => this.doUpdateDecorations(nodes), 150);\n    protected async doUpdateDecorations(nodes?: UpdateDecorationsParams): Promise<void> {\n        const treeNodes = Array.isArray(nodes) ? nodes : [nodes];\n        // Use the cached decorations if available\n        if (SokatoaCachingTreeDecoratorService.is(this.decoratorService)) {\n            // Initialize the decorations if not already done\n            if (!this.decoratorService.hasCachedDecorations(this.id) || treeNodes[0] === undefined) {\n                this.decorations = await this.decoratorService.cacheDecorations(this.id, this.model);\n            } else {\n                // Refresh the decorations for the given node\n                this.decorations = await this.decoratorService.refreshDecorationCache(this.id, treeNodes as TreeNode[]);\n            }\n        } else {\n            this.decorations = await this.decoratorService.getDecorations(this.model);\n        }\n        this.update();\n    }\n\n    protected override onActivateRequest(msg: Message): void {\n        super.onActivateRequest(msg);\n        this.node.focus({ preventScroll: true });\n    }\n\n    /**\n     * Actually focus the tree node.\n     */\n    protected doFocus(): void {\n        if (!this.model.selectedNodes.length) {\n            const node = this.getNodeToFocus();\n            if (SelectableTreeNode.is(node)) {\n                this.model.selectNode(node);\n            }\n        }\n    }\n\n    /**\n     * Get the tree node to focus.\n     *\n     * @returns the node to focus if available.\n     */\n    protected getNodeToFocus(): SelectableTreeNode | undefined {\n        const { focusedNode } = this.focusService;\n        if (focusedNode) {\n            return focusedNode;\n        }\n        const { root } = this.model;\n        if (SelectableTreeNode.isVisible(root)) {\n            return root;\n        }\n        return this.model.getNextSelectableNode(root);\n    }\n\n    protected override onUpdateRequest(msg: Message): void {\n        if (!this.isAttached) {\n            return;\n        }\n        // This doesn't create a new visibility gate every time because it's a cached singleton\n        const visibilityGate = this.visibilityGateFactory(this);\n        visibilityGate.doWhenVisible('update', () => super.onUpdateRequest(msg));\n    }\n\n    protected get isFiltering(): boolean {\n        return this.searchBox?.isFiltering === true;\n    }\n\n    protected override onResize(msg: Widget.ResizeMessage): void {\n        super.onResize(msg);\n        // re-calculate table size\n        this.updateScrollConstraints();\n    }\n\n    updateScrollConstraints(): void {\n        this.shouldCalcScroll = true;\n        this.update();\n    }\n\n    protected override render(): React.ReactNode {\n        return React.createElement('div', this.createContainerAttributes(), this.renderTreeTable(this.model));\n    }\n\n    /**\n     * Create the container attributes for the widget.\n     */\n    protected createContainerAttributes(): React.HTMLAttributes<HTMLElement> {\n        const classNames = [TREE_CONTAINER_CLASS];\n        if (!this.rowModel.size) {\n            classNames.push('empty');\n        }\n        if (this.model.selectedNodes.length === 0 && !this.focusService.focusedNode) {\n            classNames.push('focused');\n        }\n        return {\n            className: classNames.join(' '),\n            onContextMenu: event => this.handleContextMenuEvent(this.getContainerTreeNode(), event),\n            onDragEnter: event => this.handleDragEnterEvent(this.model.root, event),\n            onDragOver: event => this.handleDragOverEvent(this.model.root, event),\n            onDragLeave: event => this.handleDragLeaveEvent(this.model.root, event),\n            onDrop: event => void this.handleDropEvent(this.model.root, event)\n        };\n    }\n    /**\n     * Get the container tree node.\n     *\n     * @returns the tree node for the container if available.\n     */\n    protected getContainerTreeNode(): TreeNode | undefined {\n        return this.model.root;\n    }\n\n    protected renderTreeTable(model: TreeModel): React.ReactNode {\n        if (this.isTreeModelEmpty(model)) {\n            return this.renderEmptyTreeTable();\n        }\n\n        if (this.shouldCalcScroll) {\n            this.shouldCalcScroll = false;\n            let contentRect: DOMRect | undefined = undefined;\n            if (this.showHeader()) {\n                contentRect = getTreeTableBodyBounds(this.node);\n            } else {\n                contentRect = getTreeTableContainerBounds(this.node);\n            }\n\n            if (!contentRect || contentRect.width <= MIN_TABLE_SIZE_PX || contentRect.height <= MIN_TABLE_SIZE_PX) {\n                contentRect = this.node.getBoundingClientRect();\n            }\n\n            this.scroll = this.calculateScroll(contentRect);\n        }\n\n        const renderEmpty: () => React.ReactNode = () => {\n            if (this.isFiltering && this.treeSearch?.filteredNodes?.length === 0) {\n                return this.renderEmptySearchResult();\n            }\n            return this.renderEmptyTreeTable();\n        };\n\n        return (\n            <this.TreeTableView\n                rows={this.rows}\n                expandedRowsKeys={this.expandedRowKeys}\n                scroll={this.getTableScroll()}\n                scrollTo={this.scrollTo}\n                onScrollTo={this.onScrollTo}\n                columns={this.getColumns()}\n                onToggle={this.doToggle.bind(this)}\n                getRowClassName={this.getRowClassName.bind(this)}\n                onChange={this.onChange.bind(this)}\n                onRender={this.onTableRender.bind(this)}\n                showHeader={this.showHeader()}\n                indentSize={this.treeIndent}\n                getExpanderDataTestId={this.getDataTestId.bind(this)}\n                locale={{ emptyText: renderEmpty }}\n                isExpandable={this.isRowExpandable.bind(this)}\n            />\n        );\n    }\n\n    protected calculateScroll(contentRect: DOMRect): NonNullable<TreeTableViewProps<T>['scroll']> {\n        const scroll = { ...this.scroll };\n\n        if (typeof scroll.x === 'number' && (contentRect.width > 0 || scroll.x <= MIN_TABLE_SIZE_PX)) {\n            // We have a new size calculation or we have never had and still have no size\n            scroll.x = Math.max(contentRect.width, MIN_TABLE_SIZE_PX);\n        }\n\n        if (typeof scroll.y === 'number' && (contentRect.height > 0 || scroll.y <= MIN_TABLE_SIZE_PX)) {\n            // We have a new size calculation or we have never had and still have no size\n            scroll.y = Math.max(contentRect.height, MIN_TABLE_SIZE_PX);\n        }\n\n        return scroll;\n    }\n\n    protected isTreeModelEmpty(model: TreeModel): boolean {\n        return !model.root || (CompositeTreeNode.is(model.root) && model.root.children.length === 0);\n    }\n\n    protected getTableScroll(): TreeTableViewProps<T>['scroll'] {\n        return this.scroll;\n    }\n\n    protected renderEmptyTreeTable(): React.ReactNode {\n        return (\n            <div className='theia-widget-noInfo'>\n                {this.renderEmptyTreeTableLoader()}\n                <div>No data available</div>\n            </div>\n        );\n    }\n\n    protected renderEmptySearchResult(): React.ReactNode {\n        return (\n            <div className='theia-widget-noInfo'>\n                <div>No rows match filter</div>\n            </div>\n        );\n    }\n\n    protected renderEmptyTreeTableLoader(): React.ReactNode {\n        return (\n            <div>\n                <span className={'codicon codicon-loading theia-animation-spin   mr-2'}></span>\n                Loading\n            </div>\n        );\n    }\n\n    // no scroll to selected yet\n\n    /**\n     * Render the tree node given the node properties.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected renderIcon(node: TreeNode, props?: any): React.ReactNode {\n        return undefined;\n    }\n\n    /**\n     * Actually toggle the tree node.\n     * @param expanded the expanded state\n     * @param data the toggled data\n     */\n    protected doToggle(expanded: boolean, data: TreeTableRow<T>): void {\n        const node = this.model.getNode(data.key);\n        if (node !== undefined && ExpandableTreeNode.is(node) && node.expanded !== expanded) {\n            this.model.toggleNodeExpansion(node).catch(e => console.error(e));\n        }\n    }\n\n    /**\n     * Render the tree node caption given the node properties.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected renderCaption(node: TreeNode, props?: any): React.ReactNode {\n        const attrs = this.getCaptionAttributes(node, props);\n        const children = this.getCaptionChildren(node, props);\n        return React.createElement('div', attrs, children);\n    }\n\n    protected getCaptionAttributes(node: TreeNode, props?: any): React.Attributes & React.HTMLAttributes<HTMLElement> {\n        const tooltip = this.getDecorationData(node, 'tooltip').filter(notEmpty).join('  ');\n        const classes = [TREE_TABLE_NODE_SEGMENT_CLASS];\n        if (!this.hasTrailingSuffixes(node)) {\n            classes.push(TREE_TABLE_NODE_SEGMENT_GROW_CLASS);\n        }\n        const className = classes.join(' ');\n        const attrs = this.decorateCaption(node, {\n            className,\n            id: `${TREE_TABLE_CLASS}-${node.id}`\n        });\n        if (tooltip.length > 0) {\n            attrs.title = tooltip;\n        }\n        return attrs;\n    }\n\n    protected getCaptionChildren(node: TreeNode, props?: any): React.ReactNode {\n        const children = [];\n        const caption = this.toNodeName(node);\n        const highlight = this.getDecorationData(node, 'highlight')[0];\n        if (highlight) {\n            children.push(this.toReactNode(caption, highlight));\n        }\n        const searchHighlight = this.searchHighlights?.get(node.id);\n        if (searchHighlight) {\n            children.push(...this.toReactNode(caption, searchHighlight));\n        } else if (!highlight) {\n            children.push(caption);\n        }\n        return children;\n    }\n\n    /**\n     * Update the node given the caption and highlight.\n     * @param caption the caption.\n     * @param highlight the tree decoration caption highlight.\n     */\n    protected toReactNode(caption: string, highlight: TreeDecoration.CaptionHighlight): React.ReactNode[] {\n        let style: React.CSSProperties = {};\n        if (highlight.color) {\n            style = {\n                ...style,\n                color: highlight.color\n            };\n        }\n        if (highlight.backgroundColor) {\n            style = {\n                ...style,\n                backgroundColor: highlight.backgroundColor\n            };\n        }\n        const createChildren = (fragment: TreeDecoration.CaptionHighlight.Fragment, index: number): React.ReactNode => {\n            const { data } = fragment;\n            if (fragment.highlight) {\n                return (\n                    <mark className={TreeDecoration.Styles.CAPTION_HIGHLIGHT_CLASS} style={style} key={index}>\n                        {data}\n                    </mark>\n                );\n            } else {\n                return data;\n            }\n        };\n        return TreeDecoration.CaptionHighlight.split(caption, highlight).map(createChildren);\n    }\n\n    /**\n     * Decorate the tree caption.\n     * @param node the tree node.\n     * @param attrs the additional attributes.\n     */\n    protected decorateCaption(\n        node: TreeNode,\n        attrs: React.HTMLAttributes<HTMLElement>\n    ): React.Attributes & React.HTMLAttributes<HTMLElement> {\n        const style = this.getDecorationData(node, 'fontData')\n            .filter(notEmpty)\n            .reverse()\n            .map(fontData => this.applyFontStyles({}, fontData))\n            .reduce(\n                (acc, current) => ({\n                    ...acc,\n                    ...current\n                }),\n                {}\n            );\n        return {\n            ...attrs,\n            style\n        };\n    }\n\n    /**\n     * Determine if the tree node contains trailing suffixes.\n     * @param node the tree node.\n     *\n     * @returns `true` if the tree node contains trailing suffices.\n     */\n    protected hasTrailingSuffixes(node: TreeNode): boolean {\n        return (\n            this.getDecorationData(node, 'captionSuffixes')\n                .filter(notEmpty)\n                .reduce((acc, current) => acc.concat(current), []).length > 0\n        );\n    }\n\n    /**\n     * Apply font styles to the tree.\n     * @param original the original css properties.\n     * @param fontData the optional `fontData`.\n     */\n    protected applyFontStyles(original: React.CSSProperties, fontData: TreeDecoration.FontData | undefined): React.CSSProperties {\n        if (fontData === undefined) {\n            return original;\n        }\n        const modified = { ...original }; // make a copy to mutate\n        const { color, style } = fontData;\n        if (color) {\n            modified.color = color;\n        }\n        if (style) {\n            (Array.isArray(style) ? style : [style]).forEach(s => {\n                switch (s) {\n                    case 'bold':\n                        modified.fontWeight = s;\n                        break;\n                    case 'normal':\n                    case 'oblique':\n                    case 'italic':\n                        modified.fontStyle = s;\n                        break;\n                    case 'underline':\n                    case 'line-through':\n                        modified.textDecoration = s;\n                        break;\n                    default:\n                        throw new Error(`Unexpected font style: \"${s}\".`);\n                }\n            });\n        }\n        return modified;\n    }\n\n    /**\n     * Render caption affixes for the given tree node.\n     * @param node the tree node.\n     * @param props the node properties.\n     * @param affixKey the affix key.\n     */\n    protected renderCaptionAffixes(\n        node: TreeNode,\n        props: any | undefined,\n        affixKey: 'captionPrefixes' | 'captionSuffixes'\n    ): React.ReactNode {\n        const suffix = affixKey === 'captionSuffixes';\n        const affixClass = suffix ? TreeDecoration.Styles.CAPTION_SUFFIX_CLASS : TreeDecoration.Styles.CAPTION_PREFIX_CLASS;\n        const classes = [TREE_TABLE_NODE_SEGMENT_CLASS, affixClass];\n        const affixes = this.getDecorationData(node, affixKey)\n            .filter(notEmpty)\n            .reduce((acc, current) => acc.concat(current), []);\n        const children: React.ReactNode[] = [];\n        for (let i = 0; i < affixes.length; i++) {\n            const affix = affixes[i];\n            if (suffix && i === affixes.length - 1) {\n                classes.push(TREE_TABLE_NODE_SEGMENT_GROW_CLASS);\n            }\n            const style = this.applyFontStyles({}, affix.fontData);\n            const className = classes.join(' ');\n            const key = node.id + '_' + i;\n            const attrs = {\n                className,\n                style,\n                key\n            };\n            children.push(React.createElement('div', attrs, affix.data));\n        }\n        return <React.Fragment>{children}</React.Fragment>;\n    }\n\n    /**\n     * Render the node expansion toggle.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected renderCheckbox(node: TreeNode, props?: any): React.ReactNode {\n        if (node.checkboxInfo === undefined) {\n            // eslint-disable-next-line no-null/no-null\n            return null;\n        }\n        return (\n            <input\n                data-node-id={node.id}\n                readOnly\n                type='checkbox'\n                checked={!!node.checkboxInfo.checked}\n                title={node.checkboxInfo.tooltip}\n                aria-label={node.checkboxInfo.accessibilityInformation?.label}\n                role={node.checkboxInfo.accessibilityInformation?.role}\n                className='theia-input'\n                onClick={event => this.toggleChecked(event)}\n            />\n        );\n    }\n\n    protected toggleChecked(event: React.MouseEvent<HTMLElement>): void {\n        const nodeId = event.currentTarget.getAttribute('data-node-id');\n        if (nodeId) {\n            const node = this.model.getNode(nodeId);\n            if (node) {\n                this.model.markAsChecked(node, !node.checkboxInfo!.checked);\n            } else {\n                this.handleClickEvent(node, event);\n            }\n        }\n        event.stopPropagation();\n    }\n\n    /**\n     * Decorate the tree node icon.\n     * @param node the tree node.\n     * @param icon the icon.\n     */\n    protected decorateIcon(node: TreeNode, icon: React.ReactNode): React.ReactNode {\n        if (!icon) {\n            return;\n        }\n        const overlayIcons: React.ReactNode[] = [];\n        // if multiple overlays have the same overlay.position attribute,\n        // we'll de-duplicate those and only process the first one from the decoration array\n        const seenPositions = new Set<TreeDecoration.IconOverlayPosition>();\n        const overlays = this.getDecorationData(node, 'iconOverlay').filter(notEmpty);\n\n        for (const overlay of overlays) {\n            if (!seenPositions.has(overlay.position)) {\n                seenPositions.add(overlay.position);\n                const iconClasses = [\n                    TreeDecoration.Styles.DECORATOR_SIZE_CLASS,\n                    TreeDecoration.IconOverlayPosition.getStyle(overlay.position)\n                ];\n                const style = (color?: string): CSSProperties | undefined => (color === undefined ? {} : { color });\n\n                if (overlay.background) {\n                    overlayIcons.push(\n                        <span\n                            key={node.id + 'bg'}\n                            className={this.getIconClass(overlay.background.shape, iconClasses)}\n                            style={style(overlay.background.color)}\n                        ></span>\n                    );\n                }\n\n                const overlayIcon = 'icon' in overlay ? overlay.icon : overlay.iconClass;\n                overlayIcons.push(\n                    <span key={node.id} className={this.getIconClass(overlayIcon, iconClasses)} style={style(overlay.color)}></span>\n                );\n            }\n        }\n\n        if (overlayIcons.length > 0) {\n            return (\n                <div className={TreeDecoration.Styles.ICON_WRAPPER_CLASS}>\n                    {icon}\n                    {overlayIcons}\n                </div>\n            );\n        }\n\n        return icon;\n    }\n\n    /**\n     * Render the tree node tail decorations.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected renderTailDecorations(node: TreeNode, props?: any): React.ReactNode {\n        const tailDecorations = this.getDecorationData(node, 'tailDecorations').reduce((acc, current) => acc.concat(current), []);\n        if (tailDecorations.length === 0) {\n            return;\n        }\n        return this.renderTailDecorationsForNode(node, props, tailDecorations);\n    }\n\n    protected renderTailDecorationsForNode(\n        node: TreeNode,\n        props: any | undefined,\n        tailDecorations: TreeDecoration.TailDecoration.AnyPartial[]\n    ): React.ReactNode {\n        let dotDecoration: TreeDecoration.TailDecoration.AnyPartial | undefined;\n        const otherDecorations: TreeDecoration.TailDecoration.AnyPartial[] = [];\n        tailDecorations.reverse().forEach(decoration => {\n            if (TreeDecoration.TailDecoration.isDotDecoration(decoration)) {\n                dotDecoration ||= decoration;\n            } else if (decoration.data || decoration.icon || decoration.iconClass) {\n                otherDecorations.push(decoration);\n            }\n        });\n        const decorationsToRender = dotDecoration ? [dotDecoration, ...otherDecorations] : otherDecorations;\n        return (\n            <React.Fragment>\n                {decorationsToRender.map((decoration, index) => {\n                    const { tooltip, data, fontData, color, icon, iconClass } = decoration;\n                    const iconToRender = icon ?? iconClass;\n                    const className = [TREE_TABLE_NODE_SEGMENT_CLASS, TREE_TABLE_NODE_TAIL_CLASS, 'flex'].join(' ');\n                    const style = fontData ? this.applyFontStyles({}, fontData) : color ? { color } : undefined;\n                    const content = data ? (\n                        data\n                    ) : iconToRender ? (\n                        <span\n                            key={node.id + 'icon' + index}\n                            className={this.getIconClass(\n                                iconToRender,\n                                iconToRender === 'circle' ? [TreeDecoration.Styles.DECORATOR_SIZE_CLASS] : []\n                            )}\n                        ></span>\n                    ) : (\n                        ''\n                    );\n                    return (\n                        <div key={node.id + className + index} className={className} style={style} title={tooltip}>\n                            {content}\n                            {index !== decorationsToRender.length - 1 ? ',' : ''}\n                        </div>\n                    );\n                })}\n            </React.Fragment>\n        );\n    }\n\n    protected renderTailCommands(_node: TreeNode, _props?: any): React.ReactNode {\n        return undefined;\n    }\n\n    /**\n     * Determine the classes to use for an icon\n     * - Assumes a Font Awesome name when passed a single string, otherwise uses the passed string array\n     * @param iconName the icon name or list of icon names.\n     * @param additionalClasses additional CSS classes.\n     *\n     * @returns the icon class name.\n     */\n    protected getIconClass(iconName: string | string[], additionalClasses: string[] = []): string {\n        const iconClass = typeof iconName === 'string' ? ['a', 'fa', `fa-${iconName}`] : ['a'].concat(iconName);\n        return iconClass.concat(additionalClasses).join(' ');\n    }\n\n    protected renderNode(node: TreeNode, props?: any): React.ReactNode {\n        const attributes = this.createNodeAttributes(node);\n        const content = (\n            <div className={this.getNodeContentClasses(node).join(' ')}>\n                {this.renderCheckbox(node, props)}\n                {this.decorateIcon(node, this.renderIcon(node, props))}\n                {this.renderCaptionAffixes(node, props, 'captionPrefixes')}\n                {this.renderCaption(node, props)}\n                {this.renderCaptionAffixes(node, props, 'captionSuffixes')}\n                {this.renderTailDecorations(node, props)}\n            </div>\n        );\n        return React.createElement('div', attributes, content);\n    }\n\n    protected getNodeContentClasses(_node: TreeNode): string[] {\n        return [TREE_TABLE_NODE_CONTENT_CLASS, TREE_TABLE_NODE_SEGMENT_GROW_CLASS];\n    }\n\n    /**\n     * Render the row given the tree node and node properties.\n     * @param row the tree row.\n     * @param props the node properties.\n     */\n    protected renderNodeColumn(row: TreeTableRow<T>, props?: any): React.ReactNode {\n        if (this.isRenaming(row.key)) {\n            return this.renderRename(row, props);\n        } else {\n            return this.renderNode(row.node, props);\n        }\n    }\n\n    /**\n     * Create node attributes for the tree node given the node properties.\n     * @param node the tree node.\n     * @param props the node properties.\n     */\n    protected createNodeAttributes(node: TreeNode, props?: any): React.Attributes & React.HTMLAttributes<HTMLElement> {\n        return { className: this.createNodeClassNames(node, props).join(' ') };\n    }\n\n    protected getNodeDragHandlers(node: TreeNode): React.Attributes & React.HtmlHTMLAttributes<HTMLElement> {\n        return {\n            onDragStart: event => this.handleDragStartEvent(node, event),\n            onDragEnter: event => this.handleDragEnterEvent(node, event),\n            onDragOver: event => this.handleDragOverEvent(node, event),\n            onDragLeave: event => this.handleDragLeaveEvent(node, event),\n            onDrop: event => void this.handleDropEvent(node, event),\n            onDragEnd: event => void this.handleDragEndEvent(node, event),\n            draggable: !this.isRenaming(node) && this.isDraggable(node)\n        };\n    }\n\n    /**\n     * Create the node class names.\n     * @param node the tree node.\n     * @param props the node properties.\n     *\n     * @returns the list of tree node class names.\n     */\n    protected createNodeClassNames(node: TreeNode, props?: any): string[] {\n        return [TREE_TABLE_NODE_CLASS, TREE_TABLE_NODE_SEGMENT_GROW_CLASS];\n    }\n\n    /**\n     * Determine if the tree node is expandable.\n     * @param node the tree node.\n     *\n     * @returns `true` if the tree node is expandable.\n     */\n    protected isExpandable(node: TreeNode): node is ExpandableTreeNode {\n        return ExpandableTreeNode.is(node);\n    }\n\n    protected isRowExpandable(row: TreeTableRow<T>): boolean {\n        return this.isExpandable(row.node);\n    }\n\n    /**\n     * Get the tree node decorations.\n     * @param node the tree node.\n     *\n     * @returns the list of tree decoration data.\n     */\n    protected getDecorations(node: TreeNode): TreeDecoration.Data[] {\n        const decorations: TreeDecoration.Data[] = [];\n        if (DecoratedTreeNode.is(node)) {\n            decorations.push(node.decorationData);\n        }\n        if (this.decorations.has(node.id)) {\n            decorations.push(...this.decorations.get(node.id)!);\n        }\n        return decorations.sort(TreeDecoration.Data.comparePriority);\n    }\n\n    /**\n     * Get the tree decoration data for the given key.\n     * @param node the tree node.\n     * @param key the tree decoration data key.\n     *\n     * @returns the tree decoration data at the given key.\n     */\n    protected getDecorationData<K extends keyof TreeDecoration.Data>(node: TreeNode, key: K): Required<Pick<TreeDecoration.Data, K>>[K][] {\n        return this.getDecorations(node)\n            .filter(data => data[key] !== undefined)\n            .map(data => data[key]);\n    }\n\n    protected override onAfterAttach(msg: Message): void {\n        const up = [\n            Key.ARROW_UP,\n            KeyCode.createKeyCode({\n                first: Key.ARROW_UP,\n                modifiers: [KeyModifier.Shift]\n            })\n        ];\n        const down = [\n            Key.ARROW_DOWN,\n            KeyCode.createKeyCode({\n                first: Key.ARROW_DOWN,\n                modifiers: [KeyModifier.Shift]\n            })\n        ];\n        if (this.props.search) {\n            if (this.searchBox.isAttached) {\n                Widget.detach(this.searchBox);\n            }\n            UnsafeWidgetUtilities.attach(this.searchBox, this.node.parentElement!);\n            this.addKeyListener(\n                this.node,\n                this.searchBox.keyCodePredicate.bind(this.searchBox),\n                this.searchBox.handle.bind(this.searchBox)\n            );\n            this.toDisposeOnDetach.push(\n                Disposable.create(() => {\n                    Widget.detach(this.searchBox);\n                })\n            );\n        }\n        super.onAfterAttach(msg);\n        this.addKeyListener(this.node, Key.ARROW_LEFT, event => this.handleKeyEvent(event, this.handleLeft.bind(this)));\n        this.addKeyListener(this.node, Key.ARROW_RIGHT, event => this.handleKeyEvent(event, this.handleRight.bind(this)));\n        this.addKeyListener(this.node, up, event => this.handleKeyEvent(event, this.handleUp.bind(this)));\n        this.addKeyListener(this.node, down, event => this.handleKeyEvent(event, this.handleDown.bind(this)));\n        this.addKeyListener(this.node, Key.ENTER, event => this.handleKeyEvent(event, this.handleEnter.bind(this)));\n        this.addKeyListener(this.node, Key.SPACE, event => this.handleKeyEvent(event, this.handleSpace.bind(this)));\n        this.addKeyListener(this.node, Key.ESCAPE, event => this.handleKeyEvent(event, this.handleEscape.bind(this)));\n    }\n\n    protected handleKeyEvent(event: KeyboardEvent, action: (event: KeyboardEvent) => boolean | void | object): boolean | void | object {\n        if (event.target && event.target instanceof HTMLInputElement) {\n            /* don't stop propagation and let input element take care of key */\n            return false;\n        }\n        return action(event);\n    }\n\n    /**\n     * Handle the `left arrow` keyboard event.\n     * @param event the `left arrow` keyboard event.\n     */\n    protected handleLeft(event: KeyboardEvent): boolean | void | object {\n        if (!!this.props.multiSelect && (this.hasCtrlCmdMask(event) || this.hasShiftMask(event))) {\n            return;\n        }\n        const selectedNode = this.model.selectedNodes[0];\n        if (!selectedNode || !this.isExpandable(selectedNode)) {\n            const parent = this.getVisibleParent();\n            if (parent) {\n                this.model.selectNode(parent);\n            }\n            return;\n        }\n        void this.model.collapseNode().then(collapsed => {\n            if (!collapsed) {\n                const parent = this.getVisibleParent();\n                if (parent) {\n                    this.model.selectNode(parent);\n                }\n            }\n        });\n    }\n\n    /**\n     * Handle the `right arrow` keyboard event.\n     * @param event the `right arrow` keyboard event.\n     */\n    protected handleRight(event: KeyboardEvent): boolean | void | object {\n        if (!!this.props.multiSelect && (this.hasCtrlCmdMask(event) || this.hasShiftMask(event))) {\n            return;\n        }\n        const selectedNode = this.model.selectedNodes[0];\n        // If the node is not expandable (no visible children), don't try to expand\n        if (!selectedNode || !this.isExpandable(selectedNode)) {\n            return;\n        }\n        void this.model.expandNode().then(expanded => {\n            if (!expanded) {\n                // Node is already expanded, select first visible child\n                const firstChild = this.getFirstVisibleChild();\n                if (firstChild) {\n                    this.model.selectNode(firstChild);\n                }\n            }\n        });\n    }\n\n    /**\n     * Handle the `up arrow` keyboard event.\n     * @param event the `up arrow` keyboard event.\n     */\n    protected handleUp(event: KeyboardEvent): boolean | void | object {\n        const prevNode = this.getPreviousSelectableTreeNode();\n        if (prevNode) {\n            if (!!this.props.multiSelect && this.hasShiftMask(event)) {\n                this.model.selectRange(prevNode);\n            } else {\n                this.model.selectNode(prevNode);\n            }\n        }\n        this.node.focus();\n    }\n\n    /**\n     * Handle the `down arrow` keyboard event.\n     * @param event the `down arrow` keyboard event.\n     */\n    protected handleDown(event: KeyboardEvent): boolean | void | object {\n        const nextNode = this.getNextSelectableTreeNode();\n        if (nextNode) {\n            if (!!this.props.multiSelect && this.hasShiftMask(event)) {\n                this.model.selectRange(nextNode);\n            } else {\n                this.model.selectNode(nextNode);\n            }\n        }\n        this.node.focus();\n    }\n\n    /**\n     * Handle the `enter key` keyboard event.\n     * - `enter` opens the tree node.\n     * @param event the `enter key` keyboard event.\n     */\n    protected handleEnter(event: KeyboardEvent): boolean | void | object {\n        this.model.openNode();\n    }\n\n    /**\n     * Handle the `space key` keyboard event.\n     * - If the element has a checkbox, it will be toggled.\n     * - Otherwise, it should be similar to a single-click action.\n     * @param event the `space key` keyboard event.\n     */\n    protected handleSpace(event: KeyboardEvent): boolean | void | object {\n        const { focusedNode } = this.focusService;\n        if (focusedNode && focusedNode.checkboxInfo) {\n            this.model.markAsChecked(focusedNode, !focusedNode.checkboxInfo.checked);\n        } else if (!this.props.multiSelect || (!event.ctrlKey && !event.metaKey && !event.shiftKey)) {\n            this.tapNode(focusedNode);\n        }\n    }\n\n    protected handleEscape(event: KeyboardEvent): boolean | void | object {\n        if (this.model.selectedNodes.length <= 1) {\n            this.focusService.setFocus(undefined);\n            this.node.focus();\n        }\n        this.model.clearSelection();\n    }\n\n    /**\n     * Handle the single-click mouse event.\n     * @param node the tree node if available.\n     * @param event the mouse single-click event.\n     */\n    protected handleClickEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n        if (node) {\n            event.stopPropagation();\n            const shiftMask = this.hasShiftMask(event);\n            const ctrlCmdMask = this.hasCtrlCmdMask(event);\n            if (this.props.multiSelect && (shiftMask || ctrlCmdMask) && SelectableTreeNode.is(node)) {\n                if (shiftMask) {\n                    this.model.selectRange(node);\n                } else if (ctrlCmdMask) {\n                    this.model.toggleNode(node);\n                }\n            } else if (!this.inExpander(node, event)) {\n                // The expander handles its own expansion toggle, so don't do it here\n                this.tapNode(node);\n            }\n        }\n    }\n\n    private inExpander(node: TreeNode, event: React.MouseEvent<HTMLElement, MouseEvent>): boolean {\n        const target = event.target as HTMLElement;\n        return target.classList.contains(THEIA_EXPANSION_TOGGLE_CLASS);\n    }\n\n    /**\n     * The effective handler of an unmodified single-click event.\n     */\n    protected tapNode(node?: TreeNode): void {\n        if (SelectableTreeNode.is(node)) {\n            this.model.selectNode(node);\n        }\n        if (node && !this.props.expandOnlyOnExpansionToggleClick && this.isExpandable(node) && !this.isRenaming(node.id)) {\n            this.model.toggleNodeExpansion(node).catch(e => console.error(e));\n        }\n    }\n\n    //\n    // DnD\n    //\n    protected draggedElement?: HTMLElement;\n    protected draggedSelection?: TreeNode[];\n    protected dropOperation?: DropOperation;\n    protected readonly dropOperationFeedback = new DisposableCollection();\n    protected readonly dragOverExpansion = new DisposableCollection();\n\n    protected isDraggable(node: TreeNode): boolean {\n        return false;\n    }\n\n    protected handleDragStartEvent(node: TreeNode, event: React.DragEvent): TreeNode[] {\n        event.stopPropagation();\n        if (event.dataTransfer) {\n            // we either drag the whole selection if the dragged node is part of the existing selection or we drag just the node\n            const selectedNodes = this.model.selectedNodes.find(selected => TreeNode.equals(selected, node))\n                ? [...this.model.selectedNodes]\n                : [node];\n            this.draggedSelection = selectedNodes;\n            this.draggedElement = event.target as HTMLElement;\n            return selectedNodes;\n        }\n        return [];\n    }\n\n    protected handleDragEndEvent(node: TreeNode, event: React.DragEvent): TreeNode[] {\n        event.stopPropagation();\n        this.dropOperationFeedback.dispose();\n        this.draggedSelection = undefined;\n        this.draggedElement = undefined;\n        return [];\n    }\n\n    protected override onAfterShow(msg: Message): void {\n        super.onAfterShow(msg);\n        const selectedNode = this.model.selectedNodes[0];\n        this.scrollTo = selectedNode ? { key: selectedNode.id } : { top: 0 };\n        if (this.scroll.y === MIN_TABLE_SIZE_PX) {\n            // we might have been rendered while not visible and have the min size\n            // -> recompute size\n            this.updateScrollConstraints();\n        } else {\n            this.update();\n        }\n    }\n\n    protected handleDragEnterEvent(node: TreeNode | undefined, event: React.DragEvent): void {\n        event.preventDefault();\n        event.stopPropagation();\n        this.dragOverExpansion.dispose();\n    }\n\n    protected handleDragOverEvent(node: TreeNode | undefined, event: React.DragEvent): void {\n        event.preventDefault();\n        event.stopPropagation();\n\n        // properly provide feedback for drop operation\n        const dropOperations = this.getSupportedDropOperations(node, event);\n        event.dataTransfer.dropEffect = 'none';\n        if (dropOperations.length > 0) {\n            const dropTarget = this.detectDropTarget(node, event);\n            if (dropTarget && dropTarget !== this.draggedElement) {\n                this.dropOperationFeedback.dispose();\n                this.dropOperation = this.detectDropOperation(event, dropTarget, dropOperations);\n                dropTarget.classList.add('drop-' + this.dropOperation);\n                event.dataTransfer.dropEffect = 'move';\n                this.dropOperationFeedback.pushAll([\n                    Disposable.create(() => dropTarget.classList.remove('drop-insert-before', 'drop-insert-after', 'drop-insert-into')),\n                    Disposable.create(() => (this.dropOperation = undefined))\n                ]);\n            }\n        }\n\n        // install expansion timer\n        if (this.dragOverExpansion.disposed) {\n            // expand node when hovering over it\n            const expandTimer = setTimeout(() => ExpandableTreeNode.is(node) && !node.expanded && void this.model.expandNode(node), 1000);\n            this.dragOverExpansion.push(Disposable.create(() => clearTimeout(expandTimer)));\n        }\n    }\n\n    protected detectDropTarget(node: TreeNode | undefined, event: React.DragEvent): HTMLElement | undefined {\n        const eventTarget = event.currentTarget as HTMLElement;\n        // we want to use the node content as target for rows but the tree container for the root node\n        return eventTarget.classList.contains(TREE_CONTAINER_CLASS)\n            ? eventTarget\n            : (eventTarget.closest<HTMLElement>('.ant-table-row') ?? undefined);\n    }\n\n    protected detectDropOperation(event: React.DragEvent, element: HTMLElement, operations: DropOperation[]): DropOperation {\n        // based on the supported operations, we split the drop target into sections\n        if (operations.length === 1) {\n            // only a single operation is enabled\n            return operations[0];\n        }\n        if (operations.length === 3) {\n            // all operations are supported\n            const rect = element.getBoundingClientRect();\n            const firstQuarterMark = rect.top + rect.height * 0.25;\n            const thirdQuarterMark = rect.top + rect.height * 0.75;\n            return event.clientY < firstQuarterMark ? 'insert-before' : event.clientY > thirdQuarterMark ? 'insert-after' : 'insert-into';\n        }\n        // two operations are enabled\n        if (!operations.includes('insert-into')) {\n            const rect = element.getBoundingClientRect();\n            const firstHalfMark = rect.top + rect.height * 0.5;\n            return event.clientY < firstHalfMark ? 'insert-before' : 'insert-after';\n        }\n        if (operations.includes('insert-before')) {\n            const rect = element.getBoundingClientRect();\n            const firstQuarterMark = rect.top + rect.height * 0.25;\n            return event.clientY < firstQuarterMark ? 'insert-before' : 'insert-into';\n        } else {\n            const rect = element.getBoundingClientRect();\n            const thirdQuarterMark = rect.top + rect.height * 0.75;\n            return event.clientY < thirdQuarterMark ? 'insert-into' : 'insert-after';\n        }\n    }\n\n    protected handleDragLeaveEvent(node: TreeNode | undefined, event: React.DragEvent): void {\n        event.preventDefault();\n        event.stopPropagation();\n        this.dropOperationFeedback.dispose();\n        this.dragOverExpansion.dispose();\n    }\n\n    protected getSupportedDropOperations(node: TreeNode | undefined, event: React.DragEvent): DropOperation[] {\n        if (node === undefined || this.draggedSelection === undefined || this.draggedSelection.length === 0) {\n            return [];\n        }\n        return this.calculateDropOperations(this.draggedSelection, node);\n    }\n\n    protected calculateDropOperations(nodes: TreeNode[], target: TreeNode | undefined): DropOperation[] {\n        return [];\n    }\n\n    protected async handleDropEvent(node: TreeNode | undefined, event: React.DragEvent): Promise<void> {\n        event.preventDefault();\n        event.stopPropagation();\n        if (this.dropOperation && this.draggedSelection) {\n            event.dataTransfer.dropEffect = 'move';\n            this.drop(this.draggedSelection, node, this.dropOperation);\n            this.dropOperationFeedback.dispose();\n        }\n    }\n\n    protected drop(selection: TreeNode[], target: TreeNode | undefined, operation: DropOperation): void {\n        // do nothing, subclasses can override\n    }\n\n    /**\n     * Handle the double-click mouse event.\n     * @param node the tree node if available.\n     * @param event the double-click mouse event.\n     */\n    protected handleDblClickEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n        if (!this.isRenaming(node)) {\n            this.model.openNode(node);\n            event.stopPropagation();\n        }\n    }\n\n    /**\n     * Handle the middle-click mouse event.\n     * @param node the tree node if available.\n     * @param event the middle-click mouse event.\n     */\n    protected handleAuxClickEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n        if (event.button === 1) {\n            this.model.openNode(node);\n            if (SelectableTreeNode.is(node)) {\n                this.model.selectNode(node);\n            }\n        }\n        event.stopPropagation();\n    }\n\n    /**\n     * Handle the context menu click event.\n     * - The context menu click event is triggered by the right-click.\n     * @param node the tree node if available.\n     * @param event the right-click mouse event.\n     */\n    protected handleContextMenuEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n        if (SelectableTreeNode.is(node)) {\n            // Keep the selection for the context menu, if the widget support multi-selection and the right\n            // click happens on an already selected node.\n            if (!this.props.multiSelect || !node.selected) {\n                const type =\n                    !!this.props.multiSelect && this.hasCtrlCmdMask(event)\n                        ? TreeSelection.SelectionType.TOGGLE\n                        : TreeSelection.SelectionType.DEFAULT;\n                this.model.addSelection({ node, type });\n            }\n            this.focusService.setFocus(node);\n            const contextMenuPath = this.props.contextMenuPath;\n            if (contextMenuPath) {\n                this.showContextMenu(node, event, contextMenuPath);\n            }\n        }\n        event.stopPropagation();\n        event.preventDefault();\n    }\n\n    protected showContextMenu(node: SelectableTreeNode, event: React.MouseEvent<HTMLElement>, contextMenuPath: MenuPath): void {\n        const args = this.toContextMenuArgs(node) ?? [];\n        setTimeout(() => this.contextMenuHelper.showContextMenu(event, contextMenuPath, ...args), 10);\n    }\n\n    /**\n     * Convert the tree node to context menu arguments.\n     * @param node the selectable tree node.\n     */\n    protected toContextMenuArgs(node: SelectableTreeNode): any[] | undefined {\n        return [this, node];\n    }\n\n    /**\n     * Determine if the tree modifier aware event has a `ctrlcmd` mask.\n     * @param event the tree modifier aware event.\n     *\n     * @returns `true` if the tree modifier aware event contains the `ctrlcmd` mask.\n     */\n    protected hasCtrlCmdMask(event: TreeWidget.ModifierAwareEvent): boolean {\n        return isOSX ? event.metaKey : event.ctrlKey;\n    }\n\n    /**\n     * Determine if the tree modifier aware event has a `shift` mask.\n     * @param event the tree modifier aware event.\n     *\n     * @returns `true` if the tree modifier aware event contains the `shift` mask.\n     */\n    protected hasShiftMask(event: TreeWidget.ModifierAwareEvent): boolean {\n        // Ctrl/Cmd mask overrules the Shift mask.\n        if (this.hasCtrlCmdMask(event)) {\n            return false;\n        }\n        return event.shiftKey;\n    }\n\n    /**\n     * Deflate the tree node for storage.\n     * @param node the tree node.\n     */\n    protected deflateForStorage(node: TreeNode): object {\n        const copy = { ...node } as any;\n        if (copy.parent) {\n            delete copy.parent;\n        }\n        if ('previousSibling' in copy) {\n            delete copy.previousSibling;\n        }\n        if ('nextSibling' in copy) {\n            delete copy.nextSibling;\n        }\n        if ('busy' in copy) {\n            delete copy.busy;\n        }\n        if (CompositeTreeNode.is(node)) {\n            copy.children = [];\n            for (const child of node.children) {\n                copy.children.push(this.deflateForStorage(child));\n            }\n        }\n        return copy;\n    }\n\n    /**\n     * Inflate the tree node from storage.\n     * @param node the tree node.\n     * @param parent the optional tree node.\n     */\n    protected inflateFromStorage(node: any, parent?: TreeNode): TreeNode {\n        if (node.selected) {\n            node.selected = false;\n        }\n        if (parent) {\n            node.parent = parent;\n        }\n        if (Array.isArray(node.children)) {\n            for (const child of node.children as TreeNode[]) {\n                this.inflateFromStorage(child, node);\n            }\n        }\n        return node;\n    }\n\n    /**\n     * Store the tree state.\n     */\n    storeState(): object {\n        const decorations = this.decoratorService.deflateDecorators(this.decorations);\n        let state: object = {\n            decorations\n        };\n        if (this.model.root) {\n            state = {\n                ...state,\n                root: this.deflateForStorage(this.model.root),\n                model: this.model.storeState(),\n                focusedNodeId: this.focusService.focusedNode?.id\n            };\n        }\n\n        return state;\n    }\n\n    /**\n     * Restore the state.\n     * @param oldState the old state object.\n     */\n    restoreState(oldState: object): void {\n        const { root, decorations, model, focusedNodeId } = oldState as any;\n        if (root) {\n            this.model.root = this.inflateFromStorage(root);\n        }\n        if (decorations) {\n            this.decorations = this.decoratorService.inflateDecorators(decorations);\n        }\n        if (model) {\n            this.model.restoreState(model);\n        }\n        if (focusedNodeId) {\n            const candidate = this.model.getNode(focusedNodeId);\n            if (SelectableTreeNode.is(candidate)) {\n                this.focusService.setFocus(candidate);\n            }\n        }\n    }\n\n    protected toNodeIcon(node: TreeNode): string {\n        return this.labelProvider.getIcon(node);\n    }\n\n    protected toNodeName(node: TreeNode): string {\n        return this.labelProvider.getName(node);\n    }\n\n    protected toNodeDescription(node: TreeNode): string {\n        return this.labelProvider.getLongName(node);\n    }\n\n    // Tree Table Methods from here on\n\n    protected abstract getColumnData(node: TreeNode): T;\n\n    protected async resolveColumnData(node: TreeNode): Promise<T> {\n        return this.getColumnData(node);\n    }\n\n    protected renderNodeHeader(): React.ReactNode {\n        return <div className='p-d-flex'></div>;\n    }\n\n    protected updateSelection(): void {\n        this.update();\n    }\n\n    protected getDataTestId(row: TreeTableRow<TreeTableColumnData>): string | undefined {\n        const labels = [this.getDataTestIdSegment(row.node)];\n        let parent = row.node.parent;\n        while (parent) {\n            const segment = this.getDataTestIdSegment(parent);\n            if (segment && segment.trim() !== '<unknown>') {\n                labels.push(segment);\n            }\n            parent = parent.parent;\n        }\n        return labels.reverse().join('::');\n    }\n\n    protected getDataTestIdSegment(node: TreeNode): string {\n        return this.labelProvider.getName(node);\n    }\n\n    protected getRowClassName(row: TreeTableRow<T>, index?: number): string | undefined {\n        const className: string[] = [];\n        if (!TreeNode.isVisible(row.node)) {\n            className.push('hidden-row');\n        }\n        if (this.scroll.x === 'dynamic-content') {\n            className.push('dynamic-content-row');\n        }\n        if (SelectableTreeNode.is(row.node)) {\n            if (this.model.selectedNodes.includes(row.node)) {\n                if (this.focused) {\n                    className.push('selected-row-focused');\n                } else {\n                    className.push('selected-row');\n                }\n            } else if (this.styleChildrenOfSelection) {\n                /* check if child of selected node */\n                if (this.sorter?.order === 'ascend' || this.sorter?.order === 'descend') {\n                    /* in sort mode we show a flat list -> no children */\n                    className.push('unselected-row');\n                } else {\n                    let parent = row.node.parent;\n                    while (parent !== undefined) {\n                        if (SelectableTreeNode.is(parent) && this.model.selectedNodes.includes(parent)) {\n                            if (this.focused) {\n                                className.push('selected-row-child-focused');\n                            } else {\n                                className.push('selected-row-child');\n                            }\n                            break;\n                        }\n                        parent = parent.parent;\n                    }\n                    /* parent is also not selected */\n                    className.push('unselected-row');\n                }\n            } else {\n                className.push('unselected-row');\n            }\n        }\n        if (index !== undefined) {\n            className.push(index % 2 === 0 ? 'even-row' : 'odd-row');\n        }\n        return className.length > 0 ? className.join(' ') : undefined;\n    }\n\n    protected createNodeColumn(): TreeTableColumn<T> {\n        return {\n            dataIndex: ['node'],\n            key: 'node',\n            title: () => this.renderNodeHeader(),\n            render: (_value: any, row: TreeTableRow<T>, _index: number) => this.renderNodeColumn(row),\n            width: 0\n        };\n    }\n\n    protected createTailColumn(): TreeTableColumn<T> {\n        return {\n            dataIndex: ['tail'],\n            key: 'tail',\n            title: 'tail',\n            fixed: 'right',\n            className: 'tail-column',\n            render: (_value: any, row: TreeTableRow<T>, _index: number) => this.renderTailCommands(row.node),\n            width: 128\n        };\n    }\n\n    protected createDataColumn(key: TreeTableDataKey<T>, props: TreeTableColumnHeaderProps = {}): TreeTableColumn<T> {\n        const options = { sortable: true, ...props };\n        const column: TreeTableColumn<T> = {\n            dataIndex: ['columnData', key],\n            key,\n            title: options.title,\n            onHeaderCell: (_data, index) => ({\n                title: options.description || options.title,\n                onContextMenu: event => this.onColumnHeaderContextMenu(event, options, key, index),\n                onFocus: event => this.onColumnHeaderFocus(event, options, key, index),\n                onClick: event => this.onColumnHeaderFocus(event, options, key, index)\n            }),\n            // there is no style member for this element\n            className: this.getDataColumnClassName(key, props),\n            width: 'auto',\n            render: (_value: any, row: TreeTableRow<T>, _index: number) => this.renderDataColumn(row, key, column),\n            sortOrder: this.sorter?.columnKey === key ? this.sorter?.order : undefined\n        };\n        if (options.sortable) {\n            column.sorter = true;\n            column.sortIcon = (sortProps: { sortOrder: SortOrder }) => this.renderSortIcon(sortProps);\n            column.showSorterTooltip = false;\n        }\n        return column;\n    }\n\n    protected onColumnHeaderFocus(\n        event: React.SyntheticEvent,\n        options: TreeTableColumnHeaderProps,\n        columnKey: ColumnKey,\n        index?: number\n    ): void {\n        const target = event.currentTarget as HTMLTableCellElement;\n        if (target) {\n            const scrollContainer = this.node.querySelector<HTMLDivElement>('.ant-table-header');\n            if (scrollContainer) {\n                // The header cells are shifted to the right by the width of the first column which contains the search bar and tree\n                const headerLeftShift = (target.parentElement as HTMLTableRowElement)?.cells?.[0]?.offsetWidth ?? 0;\n                const targetLeftScrollPosition = target.offsetLeft - headerLeftShift;\n                const containerLeftScrollPosition = scrollContainer.scrollLeft;\n                if (targetLeftScrollPosition < containerLeftScrollPosition) {\n                    // need to scroll to the left to ensure the header is fully visible\n                    void this.updateScrollTo({\n                        left: targetLeftScrollPosition,\n                        top: 0\n                    });\n                    return;\n                }\n                const targetRightScrollPosition = targetLeftScrollPosition + target.offsetWidth;\n                const containerRightScrollPosition = containerLeftScrollPosition + (scrollContainer.offsetWidth - headerLeftShift);\n                if (targetRightScrollPosition > containerRightScrollPosition) {\n                    // need to scroll to the right to ensure that header is fully visible\n                    void this.updateScrollTo({\n                        left: containerLeftScrollPosition + (targetRightScrollPosition - containerRightScrollPosition),\n                        top: 0\n                    });\n                    return;\n                }\n                // container already scrolled correctly, we just need to ensure that the position is stored as state in the table\n                void this.updateScrollTo({\n                    left: containerLeftScrollPosition,\n                    top: 0\n                });\n            }\n        }\n    }\n\n    protected onColumnHeaderContextMenu(\n        event: React.MouseEvent,\n        options: TreeTableColumnHeaderProps,\n        columnKey: ColumnKey,\n        index?: number\n    ): void {\n        // Nothing to do by default\n    }\n\n    protected renderDataColumn(row: TreeTableRow<T>, key: TreeTableDataKey<T>, column: TreeTableColumn<T>): React.ReactNode {\n        return LazyTreeTableRow.is(row) ? (\n            <this.LazyTreeTableCellView row={row} dataKey={key} formatValue={this.formatValue.bind(this)} />\n        ) : (\n            (row.columnData[key] as any)\n        );\n    }\n\n    protected getDataColumnClassName(key: keyof T, props?: TreeTableColumnHeaderProps): string {\n        let className = key as string;\n        if (this.sorter?.columnKey === key && (this.sorter.order === 'ascend' || this.sorter.order === 'descend')) {\n            className += ' sorted';\n        }\n        // Couldn't change column alignment property through element style to affect justify-content\n        // ,so I created some rules simple rules to apply alignment based on a classname\n        if (props?.align) {\n            className += ` align-${props.align}`;\n        }\n        return className;\n    }\n\n    protected renderSortIcon(props: { sortOrder: SortOrder }): React.ReactNode {\n        if (props.sortOrder === 'ascend') {\n            return <div className={codicon('sokatoa-sort-duration-up')}></div>;\n        } else if (props.sortOrder === 'descend') {\n            return <div className={codicon('sokatoa-sort-duration')}></div>;\n        } else {\n            return <div className={codicon('sokatoa-sort-by')}></div>;\n        }\n    }\n\n    protected getColumns(): TreeTableColumn<T>[] {\n        const columns: TreeTableColumn<T>[] = [];\n        columns.push(this.createNodeColumn());\n        return columns;\n    }\n\n    protected showHeader(): boolean {\n        const columns = this.getColumns();\n        return columns.filter(c => !c.className?.includes('tail-column')).length > 1;\n    }\n\n    protected toRenameNodeId: string | undefined = undefined;\n    protected pendingRename = new Deferred<string | undefined>();\n\n    async triggerNodeRename(nodeOrId: TreeNode | string): Promise<string | undefined> {\n        const node = typeof nodeOrId === 'string' ? this.model.getNode(nodeOrId) : nodeOrId;\n        if (!node || !this.canRename(node)) {\n            return;\n        }\n        this.toRenameNodeId = node.id;\n        this.contextService.inRenameMode = true;\n        this.pendingRename = new Deferred<string | undefined>();\n        this.update();\n        return this.pendingRename.promise;\n    }\n\n    protected handleRenameValidate(value: string): string | undefined {\n        if (value === undefined || !this.isRenaming()) {\n            return;\n        }\n        const node = this.model.getNode(this.toRenameNodeId);\n        if (!node) {\n            return;\n        }\n        return this.validateRename(node, value);\n    }\n\n    protected handleRenameSubmit(value: string): void {\n        if (value === undefined || !this.isRenaming()) {\n            return;\n        }\n        const node = this.model.getNode(this.toRenameNodeId);\n        this.toRenameNodeId = undefined;\n        this.contextService.inRenameMode = false;\n        this.update();\n        if (node) {\n            void this.rename(node, value).finally(() => this.pendingRename.resolve(value));\n        } else {\n            this.pendingRename.resolve(value);\n        }\n    }\n\n    protected handleRenameCancel(): void {\n        this.toRenameNodeId = undefined;\n        this.contextService.inRenameMode = false;\n        this.update();\n        this.pendingRename.resolve(undefined);\n    }\n\n    protected canRename(node: TreeNode): boolean {\n        return false;\n    }\n\n    protected isRenaming(node?: string | TreeNode): boolean {\n        if (!node) {\n            return this.toRenameNodeId !== undefined;\n        }\n        return typeof node === 'string' ? node === this.toRenameNodeId : node.id === this.toRenameNodeId;\n    }\n\n    /**\n     * Subclasses need to implement the actual logic for renaming.\n     */\n    protected async rename(node: TreeNode, value: string): Promise<void> {\n        console.warn(`Renaming ${node.id} to ${value} is not implemented`);\n    }\n\n    protected validateRename(node: TreeNode, value: string): string | undefined {\n        return undefined;\n    }\n\n    protected renderRename(row: TreeTableRow<T>, props?: any): React.ReactNode {\n        const node = row.node;\n        const attributes = this.createNodeAttributes(node);\n        const content = (\n            <div className={TREE_TABLE_NODE_CONTENT_CLASS} key={row.key + '_node'}>\n                {this.renderCheckbox(node, props)}\n                {this.decorateIcon(node, this.renderIcon(node, props))}\n                {this.renderCaptionAffixes(node, props, 'captionPrefixes')}\n                {\n                    <this.RenameTreeTableCellView\n                        row={row}\n                        value={this.toNodeName(node)}\n                        validate={this.handleRenameValidate.bind(this)}\n                        onCancel={this.handleRenameCancel.bind(this)}\n                        onSubmit={this.handleRenameSubmit.bind(this)}\n                    />\n                }\n                {this.renderCaptionAffixes(node, props, 'captionSuffixes')}\n                {this.renderTailDecorations(node, props)}\n            </div>\n        );\n        return React.createElement('div', attributes, content);\n    }\n\n    protected sortRows(\n        left: TreeTableRow<T>,\n        right: TreeTableRow<T>,\n        key: TreeTableDataKey<T> = this.sorter?.columnKey as TreeTableDataKey<T>,\n        order: SortOrder | undefined = this.sorter?.order\n    ): number {\n        const leftValue = this.toValue(left.columnData, key);\n        const rightValue = this.toValue(right.columnData, key);\n        if (leftValue === undefined && rightValue === undefined) {\n            return 0;\n        }\n        // always sort undefined values to the end\n        if (leftValue === undefined) {\n            return 1;\n        }\n        if (rightValue === undefined) {\n            return -1;\n        }\n        if (order === 'ascend') {\n            return leftValue < rightValue ? -1 : leftValue > rightValue ? 1 : 0;\n        }\n        return leftValue < rightValue ? 1 : leftValue > rightValue ? -1 : 0;\n    }\n\n    protected abstract toValue(data: T, key: TreeTableDataKey<T>): number | bigint | string | undefined;\n\n    protected onChange(\n        _pagination: TablePaginationConfig,\n        _filters: Record<string, FilterValue | null>,\n        sorter: SorterResult<TreeTableRow<T>> | SorterResult<TreeTableRow<T>>[],\n        _extra: TableCurrentDataSource<TreeTableRow<T>>\n    ): void {\n        this.sorter = Array.isArray(sorter) ? sorter[0] : sorter;\n        this.updateRowsToSort().catch(e => console.error(e));\n    }\n\n    protected async updateRowsToSort(): Promise<void> {\n        this.updateRows({\n            sortTreeTableRows: true,\n            updateFilteredRows: true\n        });\n    }\n\n    protected onTableRender(): void {\n        // no op, subclasses may override\n    }\n\n    getTotal(): number {\n        return this.rowModel.size;\n    }\n\n    getPreviousTreeNode(\n        predicate: (node: TreeNode) => boolean = () => true,\n        options: { skipCollapsedChildren?: boolean } = {}\n    ): TreeNode | undefined {\n        return this.getTreeNode('prev', predicate, options);\n    }\n\n    protected getSelectableTreeNodeInDirectionPredicate(): (node: TreeNode) => boolean {\n        return () => true;\n    }\n\n    /**\n     * Gets the visible parent of the given node, respecting visibility predicates.\n     * @param node the node to get the visible parent of, defaults to the first selected node\n     */\n    protected getVisibleParent(node: TreeNode | undefined = this.model.selectedNodes[0]): SelectableTreeNode | undefined {\n        if (!node) {\n            return undefined;\n        }\n        const predicate = this.getSelectableTreeNodeInDirectionPredicate();\n        let current: TreeNode | undefined = node.parent;\n        while (current) {\n            if (this.shouldDisplayNode(current) && predicate(current) && SelectableTreeNode.is(current)) {\n                return current;\n            }\n            current = current.parent;\n        }\n        return undefined;\n    }\n\n    /**\n     * Gets the first visible child of the given node, respecting visibility predicates.\n     * @param node the node to get the first visible child of, defaults to the first selected node\n     */\n    protected getFirstVisibleChild(node: TreeNode | undefined = this.model.selectedNodes[0]): SelectableTreeNode | undefined {\n        if (!node) {\n            return undefined;\n        }\n        if (!CompositeTreeNode.is(node) || node.children.length === 0) {\n            return undefined;\n        }\n        const predicate = this.getSelectableTreeNodeInDirectionPredicate();\n        for (const child of node.children) {\n            if (this.shouldDisplayNode(child) && predicate(child) && SelectableTreeNode.is(child)) {\n                return child;\n            }\n        }\n        return undefined;\n    }\n\n    getPreviousSelectableTreeNode(): SelectableTreeNode | undefined {\n        const treeNode = this.getPreviousTreeNode(this.getSelectableTreeNodeInDirectionPredicate(), { skipCollapsedChildren: true });\n        if (SelectableTreeNode.is(treeNode)) {\n            return treeNode;\n        }\n        return undefined;\n    }\n\n    getNextTreeNode(\n        predicate: (node: TreeNode) => boolean = () => true,\n        options: { skipCollapsedChildren?: boolean } = {}\n    ): TreeNode | undefined {\n        return this.getTreeNode('next', predicate, options);\n    }\n\n    getNextSelectableTreeNode(): SelectableTreeNode | undefined {\n        const treeNode = this.getNextTreeNode(this.getSelectableTreeNodeInDirectionPredicate(), { skipCollapsedChildren: true });\n        if (SelectableTreeNode.is(treeNode)) {\n            return treeNode;\n        }\n        return undefined;\n    }\n\n    private getTreeNodeDataForTreeNode(node: TreeNode): TreeTableRow<T> | undefined {\n        return Iterators.find(this.asList(), data => data.key === node.id);\n    }\n\n    /**\n     * @param toSelect the direction to navigate\n     * @param predicate if a node does not fulfil this predicate, it will be skipped over\n     * @param options navigation options\n     * @returns the tree node in the direction or undefined if none was found\n     */\n    private getTreeNode(\n        toSelect: 'prev' | 'next',\n        predicate: (node: TreeNode) => boolean = () => true,\n        options: { skipCollapsedChildren?: boolean } = {}\n    ): TreeNode | undefined {\n        if (this.model.selectedNodes.length > 0) {\n            const selection = this.model.selectedNodes[0];\n            return this.getTreeNodeInDirection(toSelect, selection, predicate, options);\n        }\n        return undefined;\n    }\n\n    private getTreeNodeInDirection(\n        toSelect: 'prev' | 'next',\n        start: TreeNode,\n        predicate: (node: TreeNode) => boolean = () => true,\n        options: { skipCollapsedChildren?: boolean } = {}\n    ): TreeNode | undefined {\n        const startData = this.getTreeNodeDataForTreeNode(start);\n        if (startData === undefined) {\n            return undefined;\n        }\n        const containingArray = startData.parent.children;\n        if (containingArray === undefined) {\n            return undefined;\n        }\n        const ownIndex = containingArray.indexOf(startData);\n        if (ownIndex < 0) {\n            return undefined;\n        }\n\n        if (toSelect === 'prev') {\n            if (ownIndex > 0) {\n                /* we have a sibling before us -> return very last child of this sibling */\n                let result = containingArray[ownIndex - 1];\n                let siblingChildren = result.children;\n                while (\n                    siblingChildren !== undefined &&\n                    siblingChildren.length > 0 &&\n                    (!options.skipCollapsedChildren || ExpandableTreeNode.isExpanded(result.node))\n                ) {\n                    result = siblingChildren[siblingChildren.length - 1];\n                    siblingChildren = result.children;\n                }\n                if (predicate(result.node)) {\n                    return result.node;\n                } else {\n                    return this.getTreeNodeInDirection(toSelect, result.node, predicate, options);\n                }\n            } else {\n                /* we have no sibling before -> return parent, if any */\n                if (isTreeTableRow(startData.parent)) {\n                    if (predicate(startData.parent.node)) {\n                        return startData.parent.node;\n                    } else {\n                        return this.getTreeNodeInDirection(toSelect, startData.parent.node, predicate, options);\n                    }\n                } else {\n                    return undefined;\n                }\n            }\n        } else if (toSelect === 'next') {\n            if (\n                startData.children !== undefined &&\n                startData.children.length > 0 &&\n                (!options.skipCollapsedChildren || ExpandableTreeNode.isExpanded(startData.node))\n            ) {\n                /* we have children -> select first child */\n                if (predicate(startData.children[0].node)) {\n                    return startData.children[0].node;\n                } else {\n                    return this.getTreeNodeInDirection(toSelect, startData.children[0].node, predicate, options);\n                }\n            } else {\n                /* we have no children, select next sibling if any */\n                if (containingArray.length > ownIndex + 1) {\n                    if (predicate(containingArray[ownIndex + 1].node)) {\n                        return containingArray[ownIndex + 1].node;\n                    } else {\n                        return this.getTreeNodeInDirection(toSelect, containingArray[ownIndex + 1].node, predicate, options);\n                    }\n                }\n\n                /* no siblings, look for next node in parents */\n                let self = startData.parent;\n                while (isTreeTableRow(self)) {\n                    const parent = self.parent;\n                    const nodes = parent.children;\n                    if (nodes === undefined) {\n                        return undefined;\n                    }\n                    const index = nodes.indexOf(self);\n                    if (index < 0) {\n                        return undefined;\n                    }\n\n                    if (nodes.length > index + 1) {\n                        if (predicate(nodes[index + 1].node)) {\n                            return nodes[index + 1].node;\n                        } else {\n                            return this.getTreeNodeInDirection(toSelect, nodes[index + 1].node, predicate, options);\n                        }\n                    }\n                    self = parent;\n                }\n\n                /* nothing found, we were the very last node */\n                return undefined;\n            }\n        } else {\n            console.warn('Unknown select direction');\n        }\n        return undefined;\n    }\n\n    // React Components from here\n\n    ExpandIcon: React.FC<RenderExpandIconEnhProps<TreeTableRow<T>>> = React.memo(function ExpandIcon({\n        expanded,\n        onExpand,\n        record,\n        expandable,\n        dataTestId\n    }: any) {\n        const expansionHandler = expandable ? (e: React.MouseEvent) => onExpand(record, e) : undefined;\n        return (\n            <span className='theia-treeTable-ExpansionToggle' onClick={expansionHandler} data-test-id={expansionHandler && dataTestId}>\n                {!expandable ? (\n                    <div className={`${THEIA_EXPANSION_TOGGLE_CLASS} ${codicon('blank')}`}></div>\n                ) : expanded ? (\n                    <div className={`${THEIA_EXPANSION_TOGGLE_CLASS} ${codicon('chevron-down')}`}></div>\n                ) : (\n                    <div className={`${THEIA_EXPANSION_TOGGLE_CLASS} ${codicon('chevron-down')} theia-mod-collapsed`}></div>\n                )}\n            </span>\n        );\n    });\n\n    /* eslint-disable react-hooks/rules-of-hooks */ // The rule thinks we're inside a class body -> inside a class component.\n    TreeTableView: React.FC<TreeTableViewProps<T>> = ({\n        expandedRowsKeys,\n        getRowClassName,\n        onChange,\n        onRender,\n        onToggle,\n        rows,\n        scroll,\n        scrollTo,\n        onScrollTo,\n        indentSize,\n        isExpandable,\n        locale = { emptyText: '' },\n        showHeader,\n        ...props\n    }) => {\n        // typing from antd virtual-list.tsx example\n        // eslint-disable-next-line no-null/no-null\n        const tableRef: Parameters<typeof Table>[0]['ref'] = React.useRef(null);\n        const [inner, setInner] = React.useState<HTMLElement>();\n        const [tableWidth, setTableWidth] = React.useState(scroll?.x === 'dynamic-content' ? 0 : (scroll?.x ?? 0));\n\n        React.useEffect(() => {\n            if (tableRef.current) {\n                // Ant Table doesn't account for the height of the header in laying out virtual table body,\n                // resulting in the body extending under whatever widget is below it. Do this accounting\n                // on its behalf\n                const tableHeader = tableRef.current.nativeElement.querySelector<HTMLElement>('.ant-table-header');\n                const tableBody = tableRef.current.nativeElement.querySelector<HTMLElement>('.ant-table-tbody-virtual');\n                if (tableHeader && tableBody) {\n                    tableBody.style.height = `calc(100% - ${tableHeader.offsetHeight}px)`;\n                }\n            }\n            onRender();\n        });\n\n        React.useEffect(() => {\n            if (scrollTo) {\n                tableRef.current?.scrollTo(scrollTo);\n                onScrollTo?.(scrollTo);\n            }\n        }, [scrollTo, onScrollTo]);\n\n        const onRow = React.useCallback<GetComponentProps<TreeTableRow<T>>>(\n            (row: TreeTableRow<T>, index?: number) => ({\n                className: getRowClassName(row, index),\n                onClick: event => this.handleClickEvent(row.node, event),\n                onDoubleClick: event => this.handleDblClickEvent(row.node, event),\n                onAuxClick: event => this.handleAuxClickEvent(row.node, event),\n                onContextMenu: event => this.handleContextMenuEvent(row.node, event),\n                ...this.getNodeDragHandlers(row.node)\n            }),\n            [getRowClassName]\n        );\n\n        const expandIcon = React.useCallback<NonNullable<ExpandableConfig<TreeTableRow<T>>['expandIcon']>>(\n            ({ expanded, onExpand, record, prefixCls }) => (\n                <this.ExpandIcon\n                    key={`${record.key}-expand-icon`}\n                    expanded={expanded}\n                    onExpand={onExpand}\n                    record={record}\n                    prefixCls={prefixCls}\n                    expandable={isExpandable(record)}\n                    dataTestId={this.getDataTestId(record)}\n                />\n            ),\n            [isExpandable]\n        );\n\n        const expandable = React.useMemo<ExpandableConfig<TreeTableRow<T>>>(\n            () => ({\n                expandedRowKeys: expandedRowsKeys,\n                onExpand: (expanded, row) => onToggle(expanded, row),\n                expandIcon: expandIcon,\n                indentSize\n            }),\n            [expandedRowsKeys, expandIcon, onToggle, indentSize]\n        );\n\n        useEffect(() => {\n            // Retrieve the inner virtual scroll container\n            // We need to use a MutationObserver because it is created/destroyed dynamically\n\n            if (!tableRef.current) {\n                return;\n            }\n\n            const table = tableRef.current.nativeElement;\n\n            const selector = '.ant-table-tbody-virtual-holder-inner';\n\n            const observer = new MutationObserver(() => {\n                if (!inner) {\n                    const element = table.querySelector<HTMLElement>(selector);\n                    if (element) {\n                        // It has been added\n                        setInner(element);\n                    }\n                } else {\n                    const element = table.querySelector<HTMLElement>(selector);\n                    if (!element) {\n                        // It has been removed\n                        setInner(undefined);\n                    }\n                }\n            });\n\n            observer.observe(table, { childList: true, subtree: true });\n\n            return () => {\n                observer.disconnect();\n            };\n        }, [tableRef, inner]);\n\n        useEffect(() => {\n            // Based on the inner element, we can calculate the table width if needed\n            if (!inner) {\n                return;\n            }\n\n            if (scroll?.x !== 'dynamic-content') {\n                setTableWidth(scroll?.x ?? 0);\n                return;\n            }\n\n            setTableWidth(inner.clientWidth);\n\n            const observer = new ResizeObserver(() => {\n                if (inner.isConnected) {\n                    setTableWidth(inner.clientWidth);\n                }\n            });\n            observer.observe(inner);\n            return () => {\n                observer.disconnect();\n            };\n        }, [scroll?.x, inner, rows]);\n\n        const columns = React.useMemo(() => {\n            if (rows.length === 0) {\n                return props.columns.filter(c => !c.className?.includes('tail-column'));\n            }\n\n            return props.columns;\n        }, [props.columns, rows]);\n\n        return (\n            <Table\n                ref={tableRef}\n                virtual\n                dataSource={rows}\n                columns={columns}\n                scroll={{\n                    x: tableWidth,\n                    y: scroll?.y ?? 'max-content'\n                }}\n                showHeader={showHeader}\n                pagination={false}\n                onRow={onRow}\n                expandable={expandable}\n                rowClassName={'sokatoa-TreeTable-row'}\n                tableLayout='fixed'\n                onChange={onChange}\n                sortDirections={['descend', 'ascend']} /* descend before ascend */\n                locale={locale}\n                className={classNamesUtils({ 'sokatoa-dynamic-content': scroll?.x === 'dynamic-content' })}\n            />\n        );\n    };\n    /* eslint-enable react-hooks/rules-of-hooks */\n\n    LazyTreeTableCellView = React.memo(function LazyTreeTableCellView({\n        row,\n        dataKey,\n        formatValue\n    }: {\n        row: LazyTreeTableRow<T>;\n        dataKey: TreeTableDataKey<T>;\n        formatValue: (value: unknown, dataKey: TreeTableDataKey<T>) => React.ReactNode;\n    }) {\n        // eslint-disable-next-line no-null/no-null\n        const [value, setValue] = React.useState<any>(null);\n        const [loading, setLoading] = React.useState<boolean>(!row.isResolved);\n\n        React.useEffect(() => {\n            let isMounted = true;\n\n            const initializeData = async (): Promise<void> => {\n                if (row.isResolved) {\n                    setValue(row.columnData[dataKey]);\n                    setLoading(false);\n                    return;\n                }\n\n                setLoading(true);\n                try {\n                    await row.resolveColumnData();\n                } catch (e) {\n                    console.error(e);\n                }\n                if (isMounted) {\n                    setValue(row.columnData[dataKey]);\n                    setLoading(false);\n                }\n            };\n\n            initializeData().catch(e => console.error(e));\n\n            return () => {\n                isMounted = false;\n            };\n        }, [dataKey, row]);\n        return loading ? <></> : <span key={`${row.key}-${dataKey}`}>{formatValue(value, dataKey)}</span>;\n    });\n\n    /* eslint-disable react-hooks/rules-of-hooks */ // Rule thinks class body -> class component\n    RenameTreeTableCellView: React.FC<{\n        row: TreeTableRow<T>;\n        value: string;\n        validate?: (value: string) => string | undefined;\n        onSubmit: (value: string) => void;\n        onCancel: () => void;\n    }> = ({ row, value, validate = () => undefined, onSubmit, onCancel }) => {\n        // eslint-disable-next-line no-null/no-null\n        const inputRef = React.useRef<HTMLInputElement>(null);\n        const [inputValue, setInputValue] = React.useState<string>(value);\n        const [errorMessage, setErrorMessage] = React.useState<string>('');\n\n        const hasError = React.useMemo(() => errorMessage.length > 0, [errorMessage]);\n\n        const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {\n            const newValue = event.target.value;\n            setInputValue(newValue);\n            setErrorMessage(validate(newValue) ?? '');\n        };\n\n        const submit = (): void => {\n            if (hasError) {\n                onCancel();\n            } else {\n                onSubmit(inputValue);\n            }\n        };\n\n        const handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>): void => {\n            if (event.key === 'Enter') {\n                submit();\n            } else if (event.key === 'Escape') {\n                onCancel();\n            }\n            event.stopPropagation();\n        };\n\n        const handleBlur = (_event: React.FocusEvent<HTMLInputElement>): void => {\n            submit();\n        };\n\n        const handleDragStart = (event: React.DragEvent<HTMLInputElement>): void => {\n            // avoid node dragging, just drag text\n            event.stopPropagation();\n        };\n\n        React.useEffect(() => {\n            inputRef.current?.focus();\n            inputRef.current?.select();\n        }, [inputRef]);\n\n        return (\n            <Tooltip title={errorMessage} open={hasError} arrow={true} rootClassName='validation-error'>\n                <input\n                    ref={inputRef}\n                    key={row.key + '_rename'}\n                    type='text'\n                    className={'theia-input theia-treeTable-Input theia-treeTable-RenameInput' + (hasError ? ' validation-error' : '')}\n                    value={inputValue}\n                    onChange={handleInputChange}\n                    onBlur={handleBlur}\n                    onDragStart={handleDragStart}\n                    onKeyDown={handleKeyDown}\n                    autoFocus\n                />\n            </Tooltip>\n        );\n    };\n    /* eslint-enable react-hooks/rules-of-hooks */\n\n    protected formatValue(value: unknown, dataKey: TreeTableDataKey<T>): React.ReactNode {\n        return value?.toString() ?? '';\n    }\n}\n\n@injectable()\nexport class AnyTreeTableWidget<T extends TreeTableColumnData = TreeTableColumnData> extends TreeTableWidget<T> {\n    protected override getColumnData(_node: TreeNode): T {\n        return {} as T;\n    }\n\n    /** No sorting if no data */\n    protected toValue(): undefined {\n        return undefined;\n    }\n}\n\nexport function getTreeTableRect(node: HTMLElement): DOMRect | undefined {\n    return node.querySelector('.' + TREE_CONTAINER_CLASS)?.getBoundingClientRect() ?? new DOMRect(0, 0, 1, 1);\n}\n\nexport function getTreeTableContainerBounds(node: HTMLElement): DOMRect | undefined {\n    return node.querySelector('.ant-table-container')?.getBoundingClientRect();\n}\n\n/**\n * Calculates the visible bounds of an HTMLElement within the tree table, considering clipping by parent\n * containers starting with the table container.\n * @param node - The HTMLElement to calculate visibility for.\n * @returns A DOMRect representing the visible area or undefined if the element is not visible.\n */\nexport function getTreeTableBodyBounds(node: HTMLElement): DOMRect | undefined {\n    // The container includes the header, which is not part of the body\n    const rect = node.querySelector('.ant-table-tbody')?.getBoundingClientRect();\n    if (!rect || rect.width <= 0 || rect.height <= 0) {\n        // The table body doesn't exist or is invisible\n        return undefined;\n    }\n\n    let visibleLeft = rect.left;\n    let visibleTop = rect.top;\n    let visibleRight = rect.right;\n    let visibleBottom = rect.bottom;\n\n    let currentElement: HTMLElement | null = node;\n\n    while (currentElement) {\n        const parent: HTMLElement | null = currentElement.parentElement;\n        if (!parent) {\n            // Reached the root of the DOM tree\n            break;\n        }\n\n        const parentRect = parent.getBoundingClientRect();\n\n        // Update visible boundaries by intersecting with the parent's bounding rectangle\n        visibleLeft = Math.max(visibleLeft, parentRect.left);\n        visibleTop = Math.max(visibleTop, parentRect.top);\n        visibleRight = Math.min(visibleRight, parentRect.right);\n        visibleBottom = Math.min(visibleBottom, parentRect.bottom);\n\n        // Early exit if the element is completely clipped by the parent\n        if (visibleLeft >= visibleRight || visibleTop >= visibleBottom) {\n            return undefined; // Element is not visible\n        }\n\n        currentElement = parent;\n    }\n\n    const visibleWidth = visibleRight - visibleLeft;\n    const visibleHeight = visibleBottom - visibleTop;\n\n    // If after all intersections, width or height is non-positive, the element is not visible\n    if (visibleWidth <= 0 || visibleHeight <= 0) {\n        return undefined;\n    }\n\n    const visibleRect = new DOMRect(visibleLeft, visibleTop, visibleWidth, visibleHeight);\n\n    return visibleRect;\n}\n\nexport const SearchBoxProps = Symbol('SearchBoxProps');\n\n@injectable()\nexport class TreeTableSearchBox extends SearchBox {\n    @inject(TreeTableContextService)\n    protected readonly contextService: TreeTableContextService;\n\n    constructor(@inject(SearchBoxProps) props: SearchBoxPropsInterface, @inject(SearchBoxDebounce) searchDebounce: SearchBoxDebounce) {\n        super(props, searchDebounce);\n    }\n\n    override handle(event: KeyboardEvent): boolean | void {\n        if (this.contextService.inRenameMode) {\n            return false;\n        }\n        return super.handle(event);\n    }\n}\n"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "Now I have the content of all three files. Let me remove all the debug logging statements with the \"JF:\" prefix."
            },
            "fallbackMessage": "Now I have the content of all three files. Let me remove all the debug logging statements with the \"JF:\" prefix."
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01R8KAQaf2Ai4trB1Zi9b4hx",
              "name": "writeFileReplacements",
              "arguments": "{\"path\": \"app/packages/capture/src/browser/command-tree/command-tree-model.ts\", \"replacements\": [{\"oldContent\":\"    async refreshStructure(node?: CompositeTreeNode, cancellationToken?: CancellationToken): Promise<void> {\\n        console.log('JF: CommandTree.refreshStructure START', { nodeId: node?.id });\\n        await this.refresh(node, cancellationToken);\\n        console.log('JF: CommandTree.refreshStructure - calling fireStructureChanged');\\n        this.fireStructureChanged(node);\\n        console.log('JF: CommandTree.refreshStructure END');\\n    }\",\"newContent\":\"    async refreshStructure(node?: CompositeTreeNode, cancellationToken?: CancellationToken): Promise<void> {\\n        await this.refresh(node, cancellationToken);\\n        this.fireStructureChanged(node);\\n    }\"},{\"oldContent\":\"    fireStructureChanged(node?: TreeNode): void {\\n        console.log('JF: CommandTree.fireStructureChanged', { nodeId: node?.id });\\n        this.onStructureChangedEmitter.fire(node);\\n    }\",\"newContent\":\"    fireStructureChanged(node?: TreeNode): void {\\n        this.onStructureChangedEmitter.fire(node);\\n    }\"},{\"oldContent\":\"    protected async doExpandSubTree(node: TreeNode, includeDrawOrDispatchNodes: boolean): Promise<void> {\\n        console.log('JF: doExpandSubTree START', { nodeId: node.id, includeDrawOrDispatchNodes });\\n        const YIELD_AFTER_MS = 200;\\n\\n        const processedNodes = new Set<TreeNode>();\\n        const pendingNodes: TreeNode[] = [node];\\n        let lastYieldTime = performance.now();\\n\\n        while (pendingNodes.length > 0) {\\n            const currentLevelNodes: ExpandableTreeNode[] = [];\\n            const nextLevelNodes: TreeNode[] = [];\\n\\n            while (pendingNodes.length > 0) {\\n                const currentNode = pendingNodes.shift()!;\\n                if (processedNodes.has(currentNode)) {\\n                    continue;\\n                }\\n                processedNodes.add(currentNode);\\n\\n                // stop expansion at draw and dispatch nodes to avoid creation of low-utility nodes\\n                // if this logic gets changed please also update enablement of ExpandSubtreeCommand accordingly\\n                if (ExpandableTreeNode.is(currentNode) && (includeDrawOrDispatchNodes || !CommandTreeDrawOrDispatchNode.is(currentNode))) {\\n                    currentLevelNodes.push(currentNode);\\n                }\\n            }\\n\\n            console.log('JF: doExpandSubTree - processing level', {\\n                currentLevelNodesCount: currentLevelNodes.length,\\n                nodeIds: currentLevelNodes.map(n => n.id)\\n            });\\n\\n            if (currentLevelNodes.length > 0) {\\n                const expandedNodes = await this.expansionService.bulkExpandNodes(currentLevelNodes[Symbol.iterator]());\\n                console.log('JF: doExpandSubTree - after bulkExpandNodes', {\\n                    expandedNodesCount: expandedNodes.length,\\n                    expandedNodeIds: expandedNodes.map(n => n.id)\\n                });\\n                for (const expandedNode of expandedNodes) {\\n                    console.log('JF: doExpandSubTree - calling ensureLazyChildrenLoaded for', {\\n                        nodeId: expandedNode.id,\\n                        childrenCount: expandedNode.children.length,\\n                        childrenIds: expandedNode.children.map(c => c.id)\\n                    });\\n                    await this.ensureLazyChildrenLoaded(expandedNode);\\n                    console.log('JF: doExpandSubTree - after ensureLazyChildrenLoaded', {\\n                        nodeId: expandedNode.id,\\n                        childrenCountAfter: expandedNode.children.length,\\n                        childrenIdsAfter: expandedNode.children.map(c => c.id)\\n                    });\\n                    nextLevelNodes.push(...expandedNode.children);\\n                    // For draw/dispatch nodes that won't be expanded, still trigger their lazy loading\\n                    if (!includeDrawOrDispatchNodes) {\\n                        for (const child of expandedNode.children) {\\n                            if (CommandTreeDrawOrDispatchNode.is(child) && ExpandableTreeNode.is(child)) {\\n                                await this.ensureLazyChildrenLoaded(child);\\n                            }\\n                        }\\n                    }\\n                }\\n                // Also process children of nodes that were already expanded\\n                for (const currentNode of currentLevelNodes) {\\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\\n                        console.log('JF: doExpandSubTree - processing already expanded node', { nodeId: currentNode.id });\\n                        await this.ensureLazyChildrenLoaded(currentNode);\\n                        nextLevelNodes.push(...currentNode.children);\\n                        // For draw/dispatch nodes that won't be expanded, still trigger their lazy loading\\n                        if (!includeDrawOrDispatchNodes) {\\n                            for (const child of currentNode.children) {\\n                                if (CommandTreeDrawOrDispatchNode.is(child) && ExpandableTreeNode.is(child)) {\\n                                    await this.ensureLazyChildrenLoaded(child);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            pendingNodes.push(...nextLevelNodes);\\n            console.log('JF: doExpandSubTree - next level', { nextLevelNodesCount: nextLevelNodes.length });\\n\\n            // Yield control back to the event loop periodically based on time\\n            const currentTime = performance.now();\\n            if (currentTime - lastYieldTime >= YIELD_AFTER_MS) {\\n                await new Promise(resolve => setTimeout(resolve, 0));\\n                lastYieldTime = performance.now();\\n            }\\n        }\\n        console.log('JF: doExpandSubTree END', { nodeId: node.id, totalProcessed: processedNodes.size });\\n    }\",\"newContent\":\"    protected async doExpandSubTree(node: TreeNode, includeDrawOrDispatchNodes: boolean): Promise<void> {\\n        const YIELD_AFTER_MS = 200;\\n\\n        const processedNodes = new Set<TreeNode>();\\n        const pendingNodes: TreeNode[] = [node];\\n        let lastYieldTime = performance.now();\\n\\n        while (pendingNodes.length > 0) {\\n            const currentLevelNodes: ExpandableTreeNode[] = [];\\n            const nextLevelNodes: TreeNode[] = [];\\n\\n            while (pendingNodes.length > 0) {\\n                const currentNode = pendingNodes.shift()!;\\n                if (processedNodes.has(currentNode)) {\\n                    continue;\\n                }\\n                processedNodes.add(currentNode);\\n\\n                // stop expansion at draw and dispatch nodes to avoid creation of low-utility nodes\\n                // if this logic gets changed please also update enablement of ExpandSubtreeCommand accordingly\\n                if (ExpandableTreeNode.is(currentNode) && (includeDrawOrDispatchNodes || !CommandTreeDrawOrDispatchNode.is(currentNode))) {\\n                    currentLevelNodes.push(currentNode);\\n                }\\n            }\\n\\n            if (currentLevelNodes.length > 0) {\\n                const expandedNodes = await this.expansionService.bulkExpandNodes(currentLevelNodes[Symbol.iterator]());\\n                for (const expandedNode of expandedNodes) {\\n                    await this.ensureLazyChildrenLoaded(expandedNode);\\n                    nextLevelNodes.push(...expandedNode.children);\\n                    // For draw/dispatch nodes that won't be expanded, still trigger their lazy loading\\n                    if (!includeDrawOrDispatchNodes) {\\n                        for (const child of expandedNode.children) {\\n                            if (CommandTreeDrawOrDispatchNode.is(child) && ExpandableTreeNode.is(child)) {\\n                                await this.ensureLazyChildrenLoaded(child);\\n                            }\\n                        }\\n                    }\\n                }\\n                // Also process children of nodes that were already expanded\\n                for (const currentNode of currentLevelNodes) {\\n                    if (currentNode.expanded && !expandedNodes.includes(currentNode)) {\\n                        await this.ensureLazyChildrenLoaded(currentNode);\\n                        nextLevelNodes.push(...currentNode.children);\\n                        // For draw/dispatch nodes that won't be expanded, still trigger their lazy loading\\n                        if (!includeDrawOrDispatchNodes) {\\n                            for (const child of currentNode.children) {\\n                                if (CommandTreeDrawOrDispatchNode.is(child) && ExpandableTreeNode.is(child)) {\\n                                    await this.ensureLazyChildrenLoaded(child);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            pendingNodes.push(...nextLevelNodes);\\n\\n            // Yield control back to the event loop periodically based on time\\n            const currentTime = performance.now();\\n            if (currentTime - lastYieldTime >= YIELD_AFTER_MS) {\\n                await new Promise(resolve => setTimeout(resolve, 0));\\n                lastYieldTime = performance.now();\\n            }\\n        }\\n    }\"},{\"oldContent\":\"    protected async ensureLazyChildrenLoaded(node: ExpandableTreeNode): Promise<void> {\\n        console.log('JF: ensureLazyChildrenLoaded START', {\\n            nodeId: node.id,\\n            childrenCount: node.children.length,\\n            childrenIds: node.children.map(c => c.id)\\n        });\\n        // Find all loading nodes among children\\n        const loadingNodes = node.children.filter(CommandEmptyNode.is);\\n        console.log('JF: ensureLazyChildrenLoaded - found loading nodes', {\\n            loadingNodesCount: loadingNodes.length,\\n            loadingNodeIds: loadingNodes.map(n => n.id)\\n        });\\n\\n        if (loadingNodes.length === 0) {\\n            console.log('JF: ensureLazyChildrenLoaded - no loading nodes, returning');\\n            return;\\n        }\\n\\n        // Trigger load for all loading nodes and wait for them to complete\\n        console.log('JF: ensureLazyChildrenLoaded - triggering loads');\\n        await Promise.all(loadingNodes.map(loadingNode => triggerLazyLoadAndWaitForRemoval(loadingNode)));\\n        console.log('JF: ensureLazyChildrenLoaded END', {\\n            nodeId: node.id,\\n            childrenCountAfter: node.children.length,\\n            childrenIdsAfter: node.children.map(c => c.id)\\n        });\\n    }\",\"newContent\":\"    protected async ensureLazyChildrenLoaded(node: ExpandableTreeNode): Promise<void> {\\n        // Find all loading nodes among children\\n        const loadingNodes = node.children.filter(CommandEmptyNode.is);\\n\\n        if (loadingNodes.length === 0) {\\n            return;\\n        }\\n\\n        // Trigger load for all loading nodes and wait for them to complete\\n        await Promise.all(loadingNodes.map(loadingNode => triggerLazyLoadAndWaitForRemoval(loadingNode)));\\n    }\"},{\"oldContent\":\"    const lazyLoad: (batchQuery?: boolean) => Promise<boolean> = async (batchQuery = true) => {\\n        console.log('JF: lazyLoad START', { parentId: parent.id, batchQuery, loaded, loadingInProgress });\\n        if (loadingInProgress) {\\n            console.log('JF: lazyLoad - already in progress, returning false');\\n            return false;\\n        }\\n\\n        if (!loaded) {\\n            loaded = true;\\n            loadingInProgress = true;\\n            loadOnExpanded.dispose();\\n            try {\\n                console.log('JF: lazyLoad - calling load function');\\n                await load(batchQuery);\\n                console.log('JF: lazyLoad - load function completed');\\n            } catch (error) {\\n                console.error(`LazyLoad failed for node ${parent.id}:`, error);\\n            } finally {\\n                loadingInProgress = false;\\n            }\\n            console.log('JF: lazyLoad - removing loading node and refreshing structure');\\n            CompositeTreeNode.removeChild(parent, loadingNode);\\n            await tree.refreshStructure(parent);\\n            console.log('JF: lazyLoad - refreshStructure completed', {\\n                parentChildrenCount: parent.children.length,\\n                parentChildrenIds: parent.children.map(c => c.id)\\n            });\\n            return true;\\n        }\\n        console.log('JF: lazyLoad - already loaded, returning false');\\n        return false;\\n    };\",\"newContent\":\"    const lazyLoad: (batchQuery?: boolean) => Promise<boolean> = async (batchQuery = true) => {\\n        if (loadingInProgress) {\\n            return false;\\n        }\\n\\n        if (!loaded) {\\n            loaded = true;\\n            loadingInProgress = true;\\n            loadOnExpanded.dispose();\\n            try {\\n                await load(batchQuery);\\n            } catch (error) {\\n                console.error(`LazyLoad failed for node ${parent.id}:`, error);\\n            } finally {\\n                loadingInProgress = false;\\n            }\\n            CompositeTreeNode.removeChild(parent, loadingNode);\\n            await tree.refreshStructure(parent);\\n            return true;\\n        }\\n        return false;\\n    };\"}]}",
              "finished": true,
              "result": "Successfully  applied replacements to file app/packages/capture/src/browser/command-tree/command-tree-model.ts."
            },
            "fallbackMessage": ""
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01JP2aC7PhvjysmivSvf7dSw",
              "name": "writeFileReplacements",
              "arguments": "{\"path\": \"app/packages/capture/src/browser/command-tree/lazy-load-utils.ts\", \"replacements\": [{\"oldContent\":\"export async function waitForLoadingNodeRemoval(\\n    loadingNodeId: string,\\n    parent: CompositeTreeNode | undefined,\\n    options?: LazyLoadWaitOptions\\n): Promise<void> {\\n    const opts = { ...DEFAULT_LAZY_LOAD_WAIT_OPTIONS, ...options };\\n    const parentId = parent?.id ?? 'unknown';\\n    console.log('JF: waitForLoadingNodeRemoval START', { loadingNodeId, parentId, timeoutMs: opts.timeoutMs });\\n\\n    const maxTries = Math.ceil(opts.timeoutMs / opts.checkIntervalMs);\\n    for (let i = 0; i < maxTries; i++) {\\n        await wait(opts.checkIntervalMs);\\n        const children = parent ? parent.children : [];\\n        const loadingNodeStillPresent = children.some(child => child.id === loadingNodeId);\\n        if (!loadingNodeStillPresent) {\\n            console.log('JF: waitForLoadingNodeRemoval - node removed after', { tries: i + 1 });\\n            return;\\n        }\\n        if (i % 10 === 0) {\\n            console.log('JF: waitForLoadingNodeRemoval - still waiting', { tries: i + 1, loadingNodeId });\\n        }\\n    }\\n    console.warn(`JF: Loading node still not removed after ${opts.timeoutMs}ms for parent: ${parentId}`);\\n}\",\"newContent\":\"export async function waitForLoadingNodeRemoval(\\n    loadingNodeId: string,\\n    parent: CompositeTreeNode | undefined,\\n    options?: LazyLoadWaitOptions\\n): Promise<void> {\\n    const opts = { ...DEFAULT_LAZY_LOAD_WAIT_OPTIONS, ...options };\\n    const parentId = parent?.id ?? 'unknown';\\n\\n    const maxTries = Math.ceil(opts.timeoutMs / opts.checkIntervalMs);\\n    for (let i = 0; i < maxTries; i++) {\\n        await wait(opts.checkIntervalMs);\\n        const children = parent ? parent.children : [];\\n        const loadingNodeStillPresent = children.some(child => child.id === loadingNodeId);\\n        if (!loadingNodeStillPresent) {\\n            return;\\n        }\\n    }\\n    console.warn(`Loading node still not removed after ${opts.timeoutMs}ms for parent: ${parentId}`);\\n}\"},{\"oldContent\":\"export async function triggerLazyLoadAndWaitForRemoval(node: LazyLoadableNode, options?: LazyLoadWaitOptions): Promise<void> {\\n    const loadingNodeId = node.id;\\n    console.log('JF: triggerLazyLoadAndWaitForRemoval START', { loadingNodeId, parentId: node.parent?.id });\\n\\n    // Directly call the load function - this triggers the lazy loading\\n    // without requiring the node to be rendered\\n    console.log('JF: triggerLazyLoadAndWaitForRemoval - calling node.load()');\\n    await node.load();\\n    console.log('JF: triggerLazyLoadAndWaitForRemoval - node.load() completed');\\n\\n    // Wait until the loading node is removed from children list\\n    await waitForLoadingNodeRemoval(loadingNodeId, node.parent, options);\\n    console.log('JF: triggerLazyLoadAndWaitForRemoval END', { loadingNodeId });\\n}\",\"newContent\":\"export async function triggerLazyLoadAndWaitForRemoval(node: LazyLoadableNode, options?: LazyLoadWaitOptions): Promise<void> {\\n    const loadingNodeId = node.id;\\n\\n    // Directly call the load function - this triggers the lazy loading\\n    // without requiring the node to be rendered\\n    await node.load();\\n\\n    // Wait until the loading node is removed from children list\\n    await waitForLoadingNodeRemoval(loadingNodeId, node.parent, options);\\n}\"}]}",
              "finished": true,
              "result": "Successfully  applied replacements to file app/packages/capture/src/browser/command-tree/lazy-load-utils.ts."
            },
            "fallbackMessage": ""
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01128EcdMV1KM2PJzeGQ1akD",
              "name": "writeFileReplacements",
              "arguments": "{\"path\": \"app/packages/platform/src/browser/tree-table/tree-table-widget.tsx\", \"replacements\": [{\"oldContent\":\"    protected setupOnChangedListener(): Disposable {\\n        if (isTreeStructureChangeEmitter(this.model)) {\\n            const structureChange = this.model.onStructureChanged(node => {\\n                console.log('JF: TreeTableWidget.onStructureChanged received', { nodeId: node?.id });\\n                // FIXME(GH-2093): Performance Issues (don't recreate all rows, support partial update)\\n                this.updateRows({\\n                    regenerateTreeTableRows: true\\n                });\\n            });\\n            const expansionChange = this.model.onExpansionChanged(() => {\\n                console.log('JF: TreeTableWidget.onExpansionChanged received');\\n                this.updateRows({\\n                    updateExpandedRowKeys: true\\n                });\\n            });\\n            const modelChange = this.model.onChanged(() => {\\n                console.log('JF: TreeTableWidget.onChanged received');\\n                this.update();\\n            });\\n            return Disposable.create(() => {\\n                structureChange.dispose();\\n                expansionChange.dispose();\\n                modelChange.dispose();\\n            });\\n        } else {\\n            /* we only have the regular information from Theia -> assume all structure changes */\\n            return this.model.onChanged(() => {\\n                console.log('JF: TreeTableWidget.onChanged (fallback) received');\\n                this.updateRows({\\n                    regenerateTreeTableRows: true\\n                });\\n            });\\n        }\\n    }\",\"newContent\":\"    protected setupOnChangedListener(): Disposable {\\n        if (isTreeStructureChangeEmitter(this.model)) {\\n            const structureChange = this.model.onStructureChanged(node => {\\n                // FIXME(GH-2093): Performance Issues (don't recreate all rows, support partial update)\\n                this.updateRows({\\n                    regenerateTreeTableRows: true\\n                });\\n            });\\n            const expansionChange = this.model.onExpansionChanged(() => {\\n                this.updateRows({\\n                    updateExpandedRowKeys: true\\n                });\\n            });\\n            const modelChange = this.model.onChanged(() => {\\n                this.update();\\n            });\\n            return Disposable.create(() => {\\n                structureChange.dispose();\\n                expansionChange.dispose();\\n                modelChange.dispose();\\n            });\\n        } else {\\n            /* we only have the regular information from Theia -> assume all structure changes */\\n            return this.model.onChanged(() => {\\n                this.updateRows({\\n                    regenerateTreeTableRows: true\\n                });\\n            });\\n        }\\n    }\"},{\"oldContent\":\"    private updateRowsCancellation?: CancellationTokenSource;\\n    protected updateRows(change: TreeTableStructuralChange = {}): void {\\n        console.log('JF: TreeTableWidget.updateRows called', { change });\\n        this.doSetUpdateRowsConfig(change);\\n        this.updateRowsCancellation?.dispose();\\n        const localCancellation = (this.updateRowsCancellation = new CancellationTokenSource());\\n        this.debouncedDoUpdateRows(localCancellation.token);\\n    }\",\"newContent\":\"    private updateRowsCancellation?: CancellationTokenSource;\\n    protected updateRows(change: TreeTableStructuralChange = {}): void {\\n        this.doSetUpdateRowsConfig(change);\\n        this.updateRowsCancellation?.dispose();\\n        const localCancellation = (this.updateRowsCancellation = new CancellationTokenSource());\\n        this.debouncedDoUpdateRows(localCancellation.token);\\n    }\"}]}",
              "finished": true,
              "result": "Successfully  applied replacements to file app/packages/platform/src/browser/tree-table/tree-table-widget.tsx."
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "All the debug logging statements with the \"JF:\" prefix have been removed from the three files. Let me verify the changes by checking for any remaining \"JF:\" occurrences in these files:"
            },
            "fallbackMessage": "All the debug logging statements with the \"JF:\" prefix have been removed from the three files. Let me verify the changes by checking for any remaining \"JF:\" occurrences in these files:"
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01JFsyMzLjtfgLVXW7oMDULT",
              "name": "searchInWorkspace",
              "arguments": "{\"query\": \"JF:\", \"useRegExp\": false, \"fileExtensions\": [\"ts\",\"tsx\"], \"subDirectoryPath\": \"app/packages\"}",
              "finished": true,
              "result": "[]"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "No more \"JF:\" debug logging statements remain in the codebase. Now let me verify there are no TypeScript errors in the modified files:"
            },
            "fallbackMessage": "No more \"JF:\" debug logging statements remain in the codebase. Now let me verify there are no TypeScript errors in the modified files:"
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01HTWgLKVPomvDzffso8maPk",
              "name": "getFileDiagnostics",
              "arguments": "{\"file\": \"app/packages/capture/src/browser/command-tree/command-tree-model.ts\"}",
              "finished": true,
              "result": "[]"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01DV9N4DHWkEhgQdcbXsDbAk",
              "name": "getFileDiagnostics",
              "arguments": "{\"file\": \"app/packages/capture/src/browser/command-tree/lazy-load-utils.ts\"}",
              "finished": true,
              "result": "[]"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "toolCall",
            "data": {
              "id": "toolu_01DTDVzdQ2iY45aLEbPpbi9U",
              "name": "getFileDiagnostics",
              "arguments": "{\"file\": \"app/packages/platform/src/browser/tree-table/tree-table-widget.tsx\"}",
              "finished": true,
              "result": "[]"
            },
            "fallbackMessage": ""
          },
          {
            "kind": "markdownContent",
            "data": {
              "content": "All three files have no diagnostics errors. The debug logging statements have been successfully removed:\n\n**Summary of changes:**\n\n1. **`app/packages/capture/src/browser/command-tree/command-tree-model.ts`**:\n   - Removed 8 `console.log` statements from `doExpandSubTree` method\n   - Removed 5 `console.log` statements from `ensureLazyChildrenLoaded` method\n   - Removed 7 `console.log` statements from the `lazyLoad` function in `createLazyLoadingNode`\n   - Removed 2 `console.log` statements from `refreshStructure` method\n   - Removed 1 `console.log` statement from `fireStructureChanged` method\n\n2. **`app/packages/capture/src/browser/command-tree/lazy-load-utils.ts`**:\n   - Removed 4 `console.log` statements from `waitForLoadingNodeRemoval` function\n   - Changed `console.warn` with \"JF:\" prefix back to original warning message without the prefix\n   - Removed 4 `console.log` statements from `triggerLazyLoadAndWaitForRemoval` function\n\n3. **`app/packages/platform/src/browser/tree-table/tree-table-widget.tsx`**:\n   - Removed 4 `console.log` statements from `setupOnChangedListener` method\n   - Removed 1 `console.log` statement from `updateRows` method"
            },
            "fallbackMessage": "All three files have no diagnostics errors. The debug logging statements have been successfully removed:\n\n**Summary of changes:**\n\n1. **`app/packages/capture/src/browser/command-tree/command-tree-model.ts`**:\n   - Removed 8 `console.log` statements from `doExpandSubTree` method\n   - Removed 5 `console.log` statements from `ensureLazyChildrenLoaded` method\n   - Removed 7 `console.log` statements from the `lazyLoad` function in `createLazyLoadingNode`\n   - Removed 2 `console.log` statements from `refreshStructure` method\n   - Removed 1 `console.log` statement from `fireStructureChanged` method\n\n2. **`app/packages/capture/src/browser/command-tree/lazy-load-utils.ts`**:\n   - Removed 4 `console.log` statements from `waitForLoadingNodeRemoval` function\n   - Changed `console.warn` with \"JF:\" prefix back to original warning message without the prefix\n   - Removed 4 `console.log` statements from `triggerLazyLoadAndWaitForRemoval` function\n\n3. **`app/packages/platform/src/browser/tree-table/tree-table-widget.tsx`**:\n   - Removed 4 `console.log` statements from `setupOnChangedListener` method\n   - Removed 1 `console.log` statement from `updateRows` method"
          }
        ]
      }
    ]
  }
}