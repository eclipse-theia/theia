{
  "ai-chat-ui.show-settings": "Показать настройки ИИ",
  "ai.executePlanWithCoder": "Выполнить текущий план с помощью Coder",
  "aiConfiguration:open": "Открыть окно «Настройки AI»",
  "aiHistory:clear": "История AI: очистить историю",
  "aiHistory:open": "Открыть окно «История AI»",
  "aiHistory:sortChronologically": "История ИИ: сортировать по хронологии",
  "aiHistory:sortReverseChronologically": "История ИИ: сортировка в обратном хронологическом порядке",
  "aiHistory:toggleCompact": "История ИИ: переключить компактный вид",
  "aiHistory:toggleHideNewlines": "История ИИ: прекратить интерпретацию новых строк",
  "aiHistory:toggleRaw": "История ИИ: переключить необработанный вид",
  "aiHistory:toggleRenderNewlines": "История ИИ: интерпретация новых строк",
  "debug.breakpoint.editCondition": "Редактировать условие...",
  "debug.breakpoint.removeSelected": "Удалить выбранные точки останова",
  "debug.breakpoint.toggleEnabled": "Включить/выключить точки останова",
  "notebook.cell.changeToCode": "Изменить ячейку на код",
  "notebook.cell.changeToMarkdown": "Изменить ячейку на Markdown",
  "notebook.cell.insertMarkdownCellAbove": "Вставить ячейку Markdown выше",
  "notebook.cell.insertMarkdownCellBelow": "Вставить ячейку Markdown ниже",
  "terminal:new:profile": "Создать новый интегрированный терминал из профиля",
  "terminal:profile:default": "Выберите профиль терминала по умолчанию",
  "theia": {
    "ai": {
      "agents": {
        "completionNotification": {
          "mdDescription": "Поведение уведомлений, когда этот агент завершает задачу. Если не установлено, будет использоваться глобальная настройка уведомлений по умолчанию.\n- `os-notification`: показывать уведомления ОС/системы\n- `message`: показывать уведомления в строке состояния/области сообщений\n- `blink`: мигать или выделять пользовательский интерфейс\n- `off`: отключить уведомления для этого агента",
          "title": "Уведомление о завершении"
        },
        "enable": {
          "mdDescription": "Указывает, должен ли агент быть включен (true) или отключен (false).",
          "title": "Включить агент"
        },
        "languageModelRequirements": {
          "identifier": {
            "mdDescription": "Идентификатор языковой модели, которая будет использоваться."
          },
          "mdDescription": "Указывает языковые модели, используемые для этого агента.",
          "purpose": {
            "mdDescription": "Цель, для которой используется эта языковая модель.",
            "title": "Назначение"
          },
          "title": "Требования к языковой модели"
        },
        "mdDescription": "Настройте параметры агента, такие как включение или отключение определенных агентов, настройка подсказок и выбор LLM.",
        "selectedVariants": {
          "mdDescription": "Указывает выбранные в данный момент варианты подсказок для этого агента.",
          "title": "Выбранные варианты"
        },
        "showInChat": {
          "mdDescription": "Указывает, следует ли отображать агент в интерфейсе чата (true) или скрыть (false).",
          "title": "Показать в чате"
        },
        "title": "Настройки агента"
      },
      "anthropic": {
        "apiKey": {
          "description": "Введите ключ API вашей официальной учетной записи Anthropic. **Обратите внимание:** при использовании этого параметра ключ API Anthropic будет храниться в виде открытого текста на компьютере, на котором запущена Theia. Используйте переменную среды `ANTHROPIC_API_KEY`, чтобы безопасно установить ключ."
        },
        "customEndpoints": {
          "apiKey": {
            "title": "Либо ключ для доступа к API, обслуживаемому по указанному URL-адресу, либо `true` для использования глобального ключа API Anthropic."
          },
          "enableStreaming": {
            "title": "Указывает, следует ли использовать потоковый API. По умолчанию `true`."
          },
          "id": {
            "title": "Уникальный идентификатор, который используется в пользовательском интерфейсе для идентификации настраиваемой модели."
          },
          "maxRetries": {
            "title": "Максимальное количество попыток при сбое запроса. По умолчанию — 3."
          },
          "mdDescription": "Интегрируйте пользовательские модели, совместимые с Anthropic API. Требуемые атрибуты: `model` и `url`.            \n            Опционально вы можете            \n            - указать уникальный `id` для идентификации пользовательской модели в пользовательском интерфейсе. Если он не указан, в качестве `id` будет использоваться `model`.            \n            - предоставить `apiKey` для доступа к API, обслуживаемому по указанному URL. Используйте `true`, чтобы указать использование глобального ключа API Anthropic.            \n            - указать `enableStreaming: false`, чтобы указать, что потоковая передача не должна использоваться.            \n            - Указать `useCaching: false`, чтобы указать, что кэширование подсказок не будет использоваться. \n- Указать `maxRetries: <number>`, чтобы указать максимальное количество повторных попыток при сбое запроса. По умолчанию — 3.",
          "modelId": {
            "title": "Идентификатор модели"
          },
          "url": {
            "title": "Конечная точка, совместимая с Anthropic API, на которой размещена модель."
          },
          "useCaching": {
            "title": "Указывает, поддерживает ли модель кэширование подсказок. По умолчанию `true`."
          }
        },
        "models": {
          "description": "Официальные модели Anthropic для использования"
        }
      },
      "chat": {
        "agent": {
          "architect": "Архитектор",
          "coder": "Coder",
          "universal": "Универсальный"
        },
        "app-tester": {
          "description": "Этот агент тестирует пользовательский интерфейс вашего приложения, чтобы проверить заданные пользователем тестовые сценарии с помощью автоматизации браузера. Он может автоматизировать рабочие процессы тестирования и предоставлять подробную обратную связь о функциональности приложения."
        },
        "applySuggestion": "Применить предложение",
        "bypassModelRequirement": {
          "description": "Обход проверки требований к языковой модели. Включите эту опцию, если вы используете внешние агенты (например, Claude Code), которые не требуют языковых моделей Theia."
        },
        "changeSetDefaultTitle": "Предлагаемые изменения",
        "changeSetFileDiffUriLabel": "Изменения в искусственном интеллекте: {0}",
        "chatAgentsVariable": {
          "description": "Возвращает список доступных в системе агентов чата."
        },
        "chatSessionNamingAgent": {
          "description": "Агент для генерации имен сеансов чата",
          "vars": {
            "conversation": {
              "description": "Содержимое чата."
            },
            "listOfSessionNames": {
              "description": "Список существующих имен сеансов."
            }
          }
        },
        "chatSessionSummaryAgent": {
          "description": "Агент для генерации сводок сеансов чата."
        },
        "clipboardSeparator": "буфер обмена",
        "confirmApplySuggestion": "Файл {0} изменился с момента создания этого предложения. Вы уверены, что хотите применить изменения?",
        "confirmRevertSuggestion": "Файл {0} изменился с момента создания этого предложения. Вы уверены, что хотите отменить изменение?",
        "couldNotFindMatchingLM": "Не удалось найти подходящую языковую модель. Проверьте настройки!",
        "couldNotFindReadyLMforAgent": "Не удалось найти готовую языковую модель для агента {0}. Проверьте настройки!",
        "defaultAgent": {
          "description": "Необязательно: <имя-агента> чат-агента, который должен быть вызван, если в запросе пользователя явно не указан агент с помощью @<имя-агента>.         Если агент по умолчанию не настроен, будут применены настройки Theia по умолчанию."
        },
        "fromClipboard": "$(clippy) Из буфера обмена",
        "fromClipboardDescription": "Вставить изображение из буфера обмена",
        "imageContextVariable": {
          "args": {
            "data": {
              "description": "Данные изображения в base64."
            },
            "mimeType": {
              "description": "Тип MIME изображения."
            },
            "name": {
              "description": "Имя файла изображения, если доступно."
            },
            "wsRelativePath": {
              "description": "Относительный путь к файлу изображения, если он доступен."
            }
          },
          "description": "Предоставляет контекстную информацию для изображения.",
          "label": "Файл изображения"
        },
        "imagePickerPlaceholder": "Выберите файл изображения или выполните поиск по имени",
        "orchestrator": {
          "description": "Этот агент анализирует запрос пользователя на основе описания всех доступных чат-агентов и выбирает наиболее подходящего агента для ответа на запрос (с помощью ИИ). Запрос пользователя будет напрямую передан выбранному агенту без дополнительного подтверждения.",
          "vars": {
            "availableChatAgents": {
              "description": "Список агентов чата, которым оркестратор может делегировать задачи, за исключением агентов, указанных в настройках списка исключений."
            }
          }
        },
        "pendingImage": {
          "file": "Ожидаемое изображение: {0}",
          "pasted": "Ожидающее изображение (вставлено)"
        },
        "persistedSessionLimit": {
          "description": "Максимальное количество сеансов чата, которые будут сохранены. Используйте -1 для неограниченного количества сеансов, 0 для отключения сохранения сеансов. Когда ограничение уменьшается, самые старые сеансы, превышающие новое ограничение, автоматически удаляются при следующем сохранении."
        },
        "pinChatAgent": {
          "description": "Включите фиксацию агента, чтобы автоматически поддерживать активность упомянутого чат-агента во всех подсказках, что снизит необходимость в повторных упоминаниях. Вы можете вручную открепить или переключить агентов в любое время."
        },
        "revertSuggestion": "Вернуть предложение",
        "sessionStorageScope": {
          "description": "Выберите, следует ли сохранять сеансы чата в отдельных хранилищах для каждого рабочего пространства или в одном глобальном хранилище. Если рабочее пространство не открыто, сеансы будут сохраняться в глобальном хранилище.",
          "global": "Хранение сеансов чата в едином хранилище, общем для всех рабочих пространств.",
          "workspace": "Хранение сеансов чата в хранилище метаданных, специфичном для рабочей области. Сеансы связаны с рабочей областью, но хранятся вне каталога рабочей области."
        },
        "taskContextService": {
          "summarizeProgressMessage": "Резюме: {0}"
        },
        "taskContextStorageDirectory": {
          "description": "Относительный путь рабочей области, в которой будут сохраняться и из которой будут извлекаться описания контекста задач. Если значение не указано, сгенерированные контексты задач будут храниться в памяти, а не на диске."
        },
        "toolConfirmation": {
          "confirm": {
            "description": "Запрашивать подтверждение перед запуском инструментов"
          },
          "description": "Настройте поведение подтверждения для различных инструментов. Ключ — это идентификатор инструмента, значение — режим подтверждения. Используйте «*» в качестве ключа, чтобы установить глобальное значение по умолчанию для всех инструментов.",
          "disabled": {
            "description": "Отключить выполнение инструмента"
          },
          "yolo": {
            "description": "Автоматическое выполнение инструментов без подтверждения"
          }
        },
        "universal": {
          "description": "Этот агент предназначен для помощи разработчикам программного обеспечения, предоставляя краткие и точные ответы на общие вопросы по программированию и разработке программного обеспечения. Он также является запасным вариантом для любых общих вопросов, которые может задать пользователь. Универсальный агент в настоящее время по умолчанию не имеет контекста, т. е. он не может получить доступ к текущему контексту пользователя или рабочему пространству."
        },
        "view": {
          "label": "AI Chat"
        },
        "welcomeScreenSessions": {
          "description": "Количество строк недавних сеансов чата, которые будут отображаться на экране приветствия. Количество видимых сеансов зависит от доступной ширины. Установите значение 0, чтобы скрыть раздел недавних чатов."
        }
      },
      "chat-ui": {
        "addContextVariable": "Добавить контекстную переменную",
        "agent": "Агент",
        "agentDelegationDescription": "Другие ИИ-агенты, которым можно делегировать полномочия",
        "aiDisabled": "Функции искусственного интеллекта отключены.",
        "applyAll": "Применить все",
        "applyAllTitle": "Применить все ожидающие изменения",
        "askQuestion": "Задать вопрос",
        "attachToContext": "Прикрепить элементы к контексту",
        "cancel": "Отмена (Esc)",
        "chat-view-tree-widget": {
          "ai": "ИИ",
          "generating": "Генерация",
          "noRenderer": "Ошибка: не найден рендер",
          "scrollToBottom": "Перейти к последнему сообщению",
          "waitingForInput": "Ожидание ввода",
          "you": "Вы"
        },
        "chatInput": {
          "clearHistory": "Очистить историю запросов ввода",
          "cycleMode": "Цикл Режим чата",
          "nextPrompt": "Следующий запрос",
          "previousPrompt": "Предыдущий запрос",
          "toggleCapabilities": "Конфигурация переключаемых возможностей"
        },
        "chatInputAriaLabel": "Введите здесь свое сообщение",
        "chatResponses": "Ответы в чате",
        "clearAllSelections": "Очистить строку поиска и выбор возможностей",
        "code-part-renderer": {
          "copied": "Скопировано",
          "generatedCode": "Сгенерированный код"
        },
        "collapseAll": "Свернуть все",
        "collapseChangeSet": "Свернуть набор изменений",
        "command-part-renderer": {
          "commandNotExecutable": "Команда имеет идентификатор «{0}», но не может быть выполнена из окна чата."
        },
        "confirmDeleteChatMsg": "Вы уверены, что хотите удалить этот чат?",
        "copyCodeBlock": "Копировать блок кода",
        "couldNotSendRequestToSession": "Не удалось отправить запрос «{0}» в сессию {1}",
        "delegation-response-renderer": {
          "prompt": {
            "label": "Делегированный запрос:"
          },
          "response": {
            "label": "Ответ:"
          },
          "starting": "Начало делегирования...",
          "status": {
            "canceled": "отменен",
            "error": "ошибка",
            "generating": "генерирование...",
            "starting": "запуск..."
          }
        },
        "deleteChangeSet": "Удалить набор изменений",
        "deleteChat": "Удалить чат",
        "editRequest": "Редактировать",
        "edited": "отредактировано",
        "editedTooltipHint": "Этот вариант подсказки был отредактирован. Вы можете сбросить его в окне «Конфигурация ИИ».",
        "enterChatName": "Введите имя чата",
        "errorChatInvocation": "Во время вызова службы чата произошла ошибка.",
        "expandChangeSet": "Развернуть набор изменений",
        "failedToDeleteSession": "Не удалось удалить сеанс чата",
        "failedToLoadChats": "Не удалось загрузить сеансы чата",
        "failedToRestoreSession": "Не удалось восстановить сеанс чата",
        "failedToRetry": "Сообщение об ошибке повторной попытки",
        "focusInput": "Фокус ввода в чате",
        "focusResponse": "Фокус Чат Ответ",
        "functions": "Функции",
        "functionsDescription": "Встроенные функции, предоставляемые расширениями Theia",
        "genericCapabilities": "Общие возможности",
        "mcpFunctions": "MCP",
        "mcpFunctionsDescription": "Функции протокола контекста модели (MCP) от подключенных серверов",
        "noChatAgentsAvailable": "Нет доступных чат-агентов.",
        "noMatchingCapabilities": "Нет соответствующих возможностей",
        "openDiff": "Открыть Diff",
        "openImage": "Открыть изображение",
        "openOriginalFile": "Открыть исходный файл",
        "performThisTask": "Выполните это задание.",
        "persistedSession": "Сохраненная сессия (щелкните, чтобы восстановить)",
        "promptFragments": "Подсказки",
        "promptFragmentsDescription": "Пользовательские фрагменты подсказок для включения в разговор",
        "removeChat": "Удалить чат",
        "renameChat": "Переименовать чат",
        "requestNotFoundForRetry": "Запрос не найден для повторной попытки",
        "responseFrom": "Ответ от {0}",
        "searchCapabilities": "Возможности поиска",
        "selectAgentQuickPickPlaceholder": "Выберите агент для новой сессии",
        "selectAllInCategory": "Выбрать все в этой категории",
        "selectChat": "Выбрать чат",
        "selectContextVariableQuickPickPlaceholder": "Выберите контекстную переменную, которая будет привязана к сообщению.",
        "selectTaskContextQuickPickItem": {
          "currentlyOpen": "в настоящее время открыто"
        },
        "selectTaskContextQuickPickPlaceholder": "Выберите контекст задачи для прикрепления",
        "selectVariableArguments": "Выбрать переменные аргументы",
        "send": "Отправить (Enter)",
        "sessionNotFoundForRetry": "Сессия не найдена для повторной попытки",
        "skillsDescription": "Многоразовые инструкции по навыкам, которые можно добавлять в разговор",
        "switchAgentMode": "Переключить режим агента",
        "text-part-renderer": {
          "cantDisplay": "Не удается отобразить ответ, проверьте ChatResponsePartRenderers!"
        },
        "toggleCapabilitiesConfig": "Конфигурация переключаемых возможностей",
        "toolcall-part-renderer": {
          "denied": "Выполнение запрещено",
          "finished": "Запустить",
          "rejected": "Выполнение отменено"
        },
        "toolconfirmation": {
          "allow-options-dropdown-tooltip": "Дополнительные параметры",
          "allow-session": "Разрешить этот чат",
          "allowed": "Разрешено выполнение инструмента",
          "alwaysAllowConfirm": "Я понимаю, включить автоматическое одобрение",
          "alwaysAllowGenericWarning": "Этот инструмент требует подтверждения, прежде чем можно будет включить автоматическое одобрение. После включения все будущие вызовы будут выполняться без подтверждения. Включайте эту функцию только в том случае, если вы доверяете этому инструменту и понимаете потенциальные риски.",
          "alwaysAllowTitle": "Включить автоматическое одобрение для «{0}»?",
          "canceled": "Выполнение инструмента отменено",
          "denied": "Выполнение инструмента запрещено",
          "deny-forever": "Всегда отклонять",
          "deny-options-dropdown-tooltip": "Дополнительные параметры отказа",
          "deny-reason-placeholder": "Введите причину отказа...",
          "deny-session": "Запретить для этого чата",
          "deny-with-reason": "Отклонить с обоснованием...",
          "executionDenied": "Выполнение инструмента запрещено",
          "header": "Подтвердить выполнение инструмента"
        },
        "unableToSummarizeCurrentSession": "Невозможно подвести итоги текущей сессии. Убедитесь, что агент подведения итогов не отключен.",
        "unknown-part-renderer": {
          "contentNotRestoreable": "Этот контент (тип «{0}») не удалось полностью восстановить. Возможно, он принадлежит расширению, которое больше не доступно."
        },
        "unpinAgent": "Открепить агент",
        "unselectAllInCategory": "Отменить выбор всех элементов в этой категории",
        "variablesDescription": "Динамические переменные, предоставляющие контекстную информацию",
        "variantTooltip": "Вариант запроса: {0}",
        "yourMessage": "Ваше сообщение"
      },
      "claude-code": {
        "agentDescription": "Агент кодирования Anthropic",
        "allowSession": "Разрешить для этой сессии",
        "apiKey": {
          "description": "Введите ключ API для Claude Code. **Обратите внимание:** при использовании этого параметра ключ API будет храниться в виде открытого текста на компьютере, на котором работает Theia. Используйте переменную среды `ANTHROPIC_API_KEY`, чтобы безопасно установить ключ."
        },
        "askBeforeEdit": "Спросите перед редактированием",
        "changeSetTitle": "Изменения внесены Claude Code",
        "clearCommand": {
          "description": "Создать новую сессию"
        },
        "compactCommand": {
          "description": "Компактный диалог с дополнительными инструкциями по фокусировке"
        },
        "completedCount": "{0} / {1} завершено",
        "configCommand": {
          "description": "Открыть конфигурацию Claude Code"
        },
        "currentDirectory": "текущий каталог",
        "differentAgentRequestWarning": "Предыдущий запрос в чате был обработан другим агентом. Claude Code не видит эти другие сообщения.",
        "directory": "Каталог",
        "domain": "Домен",
        "editAutomatically": "Автоматическое редактирование",
        "editNumber": "Редактировать {0}",
        "editing": "Редактирование",
        "editsCount": "{0} редактирует",
        "emptyTodoList": "Нет доступных",
        "entireFile": "Весь файл",
        "excludingOnePattern": " (исключая 1 шаблон)",
        "excludingPatterns": " (за исключением шаблонов {0})",
        "executablePath": {
          "description": "Путь к исполняемому файлу Claude Code (cli.js) из `@anthropic-ai/claude-agent-sdk`. Если путь не указан, система попытается автоматически определить его из глобальной установки npm."
        },
        "executedCommand": "Выполнено: {0}",
        "failedToParseBashToolData": "Не удалось проанализировать данные инструмента Bash",
        "failedToParseEditToolData": "Не удалось проанализировать данные инструмента редактирования",
        "failedToParseGlobToolData": "Не удалось проанализировать данные инструмента Glob",
        "failedToParseGrepToolData": "Не удалось проанализировать данные инструмента Grep",
        "failedToParseLSToolData": "Не удалось проанализировать данные инструмента LS",
        "failedToParseMultiEditToolData": "Не удалось проанализировать данные инструмента MultiEdit",
        "failedToParseReadToolData": "Не удалось проанализировать данные инструмента чтения",
        "failedToParseTodoListData": "Не удалось проанализировать данные списка задач",
        "failedToParseWebFetchToolData": "Не удалось проанализировать данные инструмента WebFetch",
        "failedToParseWriteToolData": "Не удалось проанализировать данные инструмента записи",
        "fetching": "Извлечение",
        "fileFilter": "Фильтр файлов",
        "filePath": "Путь к файлу",
        "fileType": "Тип файла",
        "findMatchingFiles": "Найти файлы, соответствующие шаблону «{0}» в текущем каталоге",
        "findMatchingFilesWithPath": "Найти файлы, соответствующие шаблону «{0}» в {1}",
        "finding": "Поиск",
        "from": "Из",
        "globPattern": "шаблон glob",
        "grepOptions": {
          "caseInsensitive": "нечувствительный к регистру",
          "glob": "glob: {0}",
          "headLimit": "ограничение: {0}",
          "lineNumbers": "номера строк",
          "linesAfter": "+{0} после",
          "linesBefore": "+{0} до",
          "linesContext": "± Контекст {0}",
          "multiLine": "многострочный",
          "type": "тип:{0}"
        },
        "grepOutputModes": {
          "content": "содержимое",
          "count": "счет",
          "filesWithMatches": "файлы с совпадениями"
        },
        "ignoredPatterns": "Игнорируемые шаблоны",
        "ignoringPatterns": "Игнорирование шаблонов «{0}»",
        "initCommand": {
          "description": "Инициализируйте проект с помощью руководства CLAUDE.md."
        },
        "itemCount": "{0} элементы",
        "lineLimit": "Ограничение по количеству строк",
        "lines": "Строки",
        "listDirectoryContents": "Список содержимого каталога",
        "listing": "Листинг",
        "memoryCommand": {
          "description": "Отредактируйте файл памяти CLAUDE.md"
        },
        "multiEditing": "Мультиредактирование",
        "oneEdit": "1 редактировать",
        "oneItem": "1 элемент",
        "oneOption": "1 вариант",
        "openDirectoryTooltip": "Щелкните, чтобы открыть каталог",
        "openFileTooltip": "Щелкните, чтобы открыть файл в редакторе",
        "optionsCount": "{0} опции",
        "partial": "Частично",
        "pattern": "Шаблон",
        "plan": "План режима",
        "project": "проект",
        "projectRoot": "корень проекта",
        "readMode": "Режим чтения",
        "reading": "Чтение",
        "replaceAllCount": "{0} replace-all",
        "replaceAllOccurrences": "Заменить все вхождения",
        "resumeCommand": {
          "description": "Возобновить сеанс"
        },
        "reviewCommand": {
          "description": "Запросить проверку кода"
        },
        "searchPath": "Путь поиска",
        "searching": "Поиск",
        "startingLine": "Стартовые линии",
        "timeout": "Таймаут",
        "timeoutInMs": "Таймаут: {0} мс",
        "to": "К",
        "todoList": "Список всего",
        "todoPriority": {
          "high": "высокий",
          "low": "низкий",
          "medium": "средний"
        },
        "toolApprovalRequest": "Claude Code хочет использовать инструмент «{0}». Разрешить?",
        "totalEdits": "Общее количество правок",
        "vars": {
          "activeEditor": {
            "description": "URI текущего активного редактора."
          }
        },
        "webFetch": "Web Fetch",
        "writing": "Письмо"
      },
      "code-completion": {
        "progressText": "Вычисление автозавершения кода ИИ..."
      },
      "codex": {
        "agentDescription": "Помощник по программированию OpenAI на базе Codex",
        "apiKey": {
          "description": "Ключ API OpenAI для Codex. Если не установлен, используется общий ключ API OpenAI (`ai-features.openAiOfficial.openAiApiKey`). Также может быть установлен через переменную среды `OPENAI_API_KEY`."
        },
        "completedCount": "{0} / {1} завершено",
        "exitCode": "Код завершения: {0}",
        "fileChangeFailed": "Codex не смог применить изменения для: {0}",
        "fileChangeFailedGeneric": "Codex не смог применить изменения файла.",
        "itemCount": "{0} элементы",
        "noItems": "Нет элементов",
        "oneItem": "1 элемент",
        "searched": "Поиск",
        "searching": "Поиск",
        "todoList": "Список всего",
        "webSearch": "Поиск в Интернете"
      },
      "completion": {
        "agent": {
          "description": "Этот агент обеспечивает встроенное автодополнение кода в редакторе кода в IDE Theia.",
          "vars": {
            "file": {
              "description": "URI редактируемого файла"
            },
            "language": {
              "description": "Языковой идентификатор редактируемого файла"
            },
            "prefix": {
              "description": "Код перед текущей позицией курсора"
            },
            "suffix": {
              "description": "Код после текущей позиции курсора"
            }
          }
        },
        "automaticEnable": {
          "description": "Автоматически запускайте автодополнение AI в любом редакторе (Monaco) во время редактирования.            \n            В качестве альтернативы вы можете вручную запустить код с помощью команды «Trigger Inline Suggestion» (Запустить встроенное предложение) или стандартного сочетания клавиш «Ctrl+Alt+Space»."
        },
        "cacheCapacity": {
          "description": "Максимальное количество завершений кода, которое можно сохранить в кэше. Более высокое число может улучшить производительность, но будет потреблять больше памяти. Минимальное значение — 10, рекомендуемый диапазон — от 50 до 200.",
          "title": "Емкость кэша автодополнения кода"
        },
        "debounceDelay": {
          "description": "Управляет задержкой в миллисекундах перед запуском автозаполнения AI после обнаружения изменений в редакторе. Требует включения функции «Автоматическое автозаполнение кода». Введите 0, чтобы отключить задержку дебаунса.",
          "title": "Задержка отскока"
        },
        "excludedFileExts": {
          "description": "Укажите расширения файлов (например, .md, .txt), для которых следует отключить автозаполнение с помощью ИИ.",
          "title": "Исключенные расширения файлов"
        },
        "fileVariable": {
          "description": "URI редактируемого файла. Доступно только в контексте автодополнения кода."
        },
        "languageVariable": {
          "description": "Языковой идентификатор редактируемого файла. Доступно только в контексте автодополнения кода."
        },
        "maxContextLines": {
          "description": "Максимальное количество строк, используемых в качестве контекста, распределенных между строками перед и после позиции курсора (префикс и суффикс). Установите значение -1, чтобы использовать весь файл в качестве контекста без ограничения количества строк, и 0, чтобы использовать только текущую строку.",
          "title": "Максимальное количество строк контекста"
        },
        "prefixVariable": {
          "description": "Код перед текущей позицией курсора. Доступно только в контексте автодополнения кода."
        },
        "stripBackticks": {
          "description": "Удалите обратные кавычки из кода, возвращаемого некоторыми LLM. Если обнаружена обратная кавычка, все содержимое после закрывающей обратной кавычки также удаляется. Эта настройка помогает обеспечить возврат простого кода, когда языковые модели используют форматирование, похожее на Markdown.",
          "title": "Удаление обратных кавычек из встроенных автодополнений"
        },
        "suffixVariable": {
          "description": "Код после текущей позиции курсора. Доступно только в контексте автодополнения кода."
        }
      },
      "configuration": {
        "selectItem": "Выберите элемент."
      },
      "copilot": {
        "auth": {
          "aiConfiguration": "Конфигурация ИИ",
          "authorize": "Я дал разрешение",
          "copied": "Скопировано!",
          "copyCode": "Копировать код",
          "expired": "Срок действия авторизации истек или был отклонен. Повторите попытку.",
          "hint": "После ввода кода и авторизации нажмите «Я авторизовался» ниже.",
          "initiating": "Инициирование аутентификации...",
          "instructions": "Чтобы разрешить Theia использовать GitHub Copilot, перейдите по указанному ниже URL-адресу и введите код:",
          "openGitHub": "Открыть GitHub",
          "privacy": "Theia — это проект с открытым исходным кодом. Мы запрашиваем доступ к вашему имени пользователя GitHub только для подключения к службам GitHub Copilot — никакие другие данные не доступны и не хранятся.",
          "success": "Успешно вошли в GitHub Copilot!",
          "successHint": "Если ваша учетная запись GitHub имеет доступ к Copilot, теперь вы можете настроить языковые модели Copilot в ",
          "tos": "Входя в систему, вы соглашаетесь с ",
          "tosLink": "Условия предоставления услуг GitHub",
          "verifying": "Проверка авторизации..."
        },
        "category": "Copilot",
        "commands": {
          "signIn": "Войдите в GitHub Copilot",
          "signOut": "Выйти из GitHub Copilot"
        },
        "enterpriseUrl": {
          "mdDescription": "Домен GitHub Enterprise для Copilot API (например, `github.mycompany.com`). Оставьте поле пустым для GitHub.com."
        },
        "models": {
          "description": "Модели GitHub Copilot для использования. Доступные модели зависят от вашей подписки Copilot."
        },
        "signOut": {
          "confirmMessage": "Вы уверены, что хотите выйти из GitHub Copilot?"
        },
        "statusBar": {
          "signedIn": "Вошли в GitHub Copilot как {0}. Нажмите, чтобы выйти.",
          "signedOut": "Вы не вошли в GitHub Copilot. Нажмите, чтобы войти."
        }
      },
      "core": {
        "agentConfiguration": {
          "addCustomAgent": "Добавить пользовательский агент",
          "availableCapabilities": "Доступные возможности",
          "completionNotificationDescriptionPrefix": "Выберите, как вы хотите получать уведомления, когда этот агент завершит свою задачу. «По умолчанию» использует ",
          "defaultNotificationDescription": "Использует глобальную настройку уведомлений ИИ.",
          "enableAgent": "Включить агент",
          "llmRequirements": "Требования к LLM",
          "notUsedInPrompt": "Не используется в командной строке.",
          "notUsedInPromptTooltip": "Эта переменная объявляется агентом, но не упоминается в текущем шаблоне запроса.",
          "notificationSettings": "Настройки уведомлений",
          "notificationSettingsLink": "Настройка уведомлений ИИ",
          "promptTemplates": "Шаблоны подсказок",
          "selectAgentMessage": "Сначала выберите агента!",
          "showInChat": "Показать в чате",
          "templateName": "Шаблон",
          "undeclared": "Незадекларированный",
          "undeclaredTooltip": "Эта переменная используется в командной строке, но не имеет описания, объявленного агентом.",
          "usedAgentSpecificVariables": "Используемые переменные, специфичные для агента",
          "usedFunctions": "Используемые функции",
          "usedGlobalVariables": "Используемые глобальные переменные",
          "variant": "Вариант"
        },
        "agentsVariable": {
          "description": "Возвращает список агентов, доступных в системе."
        },
        "aiConfiguration": {
          "label": "Конфигурация ИИ [Бета]"
        },
        "blinkTitle": {
          "agentCompleted": "Theia — агент завершил работу",
          "namedAgentCompleted": "Theia — агент «{0}» Завершено"
        },
        "capabilityVariable": {
          "argDescription": "Идентификатор фрагмента командной строки, за которым может следовать «default on» (по умолчанию включено) или «default off» (по умолчанию выключено) (по умолчанию выключено).",
          "completions": {
            "detail": {
              "off": "Функция отключена по умолчанию",
              "on": "Функция включена по умолчанию."
            }
          },
          "description": "Условно разрешает фрагменты подсказок на основе настроек включения/выключения по умолчанию."
        },
        "changeSetSummaryVariable": {
          "description": "Предоставляет сводку файлов в наборе изменений и их содержимое."
        },
        "contextDetailsVariable": {
          "description": "Предоставляет полные текстовые значения и описания для всех элементов контекста."
        },
        "contextSummaryVariable": {
          "description": "Описывает файлы в контексте данной сессии."
        },
        "customAgentTemplate": {
          "description": "Это пример агента. Пожалуйста, адаптируйте свойства в соответствии с вашими потребностями."
        },
        "defaultModelAliases": {
          "code": {
            "description": "Оптимизировано для задач понимания и генерации кода."
          },
          "code-completion": {
            "description": "Наилучшим образом подходит для сценариев автозаполнения кода."
          },
          "summarize": {
            "description": "Модели, приоритетные для обобщения и сжатия контента."
          },
          "universal": {
            "description": "Хорошо сбалансирован как для использования в коде, так и для общего использования языка."
          }
        },
        "defaultNotification": {
          "mdDescription": "Метод уведомления, используемый по умолчанию, когда агент ИИ завершает задачу. Отдельные агенты могут переопределить эту настройку.\n- `os-notification`: показывать уведомления ОС/системы\n- `message`: показывать уведомления в строке состояния/области сообщений\n- `blink`: мигать или выделять пользовательский интерфейс\n- `off`: отключить все уведомления",
          "title": "Тип уведомления по умолчанию"
        },
        "discard": {
          "label": "Шаблон подсказки «Отклонить ИИ»"
        },
        "discardCustomPrompt": {
          "tooltip": "Отменить настройки"
        },
        "fileVariable": {
          "description": "Разрешает содержимое файла",
          "uri": {
            "description": "URI запрашиваемого файла."
          }
        },
        "languageModelRenderer": {
          "alias": "[псевдоним] {0}",
          "languageModel": "Языковая модель",
          "purpose": "Назначение"
        },
        "maxRetries": {
          "mdDescription": "Максимальное количество попыток повторного выполнения, когда запрос к поставщику ИИ завершается сбоем. Значение 0 означает, что повторные попытки не выполняются.",
          "title": "Максимальное количество попыток"
        },
        "modelAliasesConfiguration": {
          "agents": "Агенты, использующие этот псевдоним",
          "defaultList": "[Список по умолчанию]",
          "evaluatesTo": "Оценивается как",
          "label": "Псевдонимы моделей",
          "modelNotReadyTooltip": "Не готов",
          "modelReadyTooltip": "Готов",
          "noAgents": "Ни один агент не использует этот псевдоним.",
          "noModelReadyTooltip": "Модель не готова",
          "noResolvedModel": "Для этого псевдонима нет готовой модели.",
          "priorityList": "Список приоритетов",
          "selectAlias": "Выберите псевдоним модели.",
          "selectedModelId": "Выбранная модель",
          "unavailableModel": "Выбранная модель больше не доступна"
        },
        "noVariableFoundForOpenRequest": "Не найдена переменная для открытого запроса.",
        "notification": {
          "message": {
            "description": "Показать уведомление внутри приложения"
          },
          "off": {
            "description": "Отключить все уведомления"
          },
          "osNotification": "Уведомление ОС",
          "windowBlink": "Мигание окна"
        },
        "openEditorsShortVariable": {
          "description": "Краткая справка по всем открытым в данный момент файлам (относительные пути, разделенные запятыми)"
        },
        "openEditorsVariable": {
          "description": "Разделенный запятыми список всех открытых в данный момент файлов относительно корня рабочей области."
        },
        "preference": {
          "languageModelAliases": {
            "description": "Настройте модели для каждого псевдонима языковой модели в [окне настройки ИИ]({0}). В качестве альтернативы вы можете вручную задать настройки в файле settings.json: \n```\n\"default/code\": {\n  \"selectedModel\": \"anthropic/claude-opus-4-20250514\"\n}\n```",
            "selectedModel": "Выбранная пользователем модель для этого псевдонима.",
            "title": "Псевдонимы языковой модели"
          }
        },
        "promptFragmentsConfiguration": {
          "activeCustomizationTitle": "Активная настройка",
          "createCustomizationTitle": "Создать настройку",
          "customization": "настройка",
          "customizationLabel": "Настройка",
          "defaultVariantTitle": "Вариант по умолчанию",
          "deleteCustomizationTitle": "Удалить настройки",
          "editTemplateTitle": "Редактировать шаблон",
          "headerTitle": "Фрагменты подсказок",
          "label": "Фрагменты подсказок",
          "noFragmentsAvailable": "Фрагменты подсказок отсутствуют.",
          "otherPromptFragmentsHeader": "Другие фрагменты подсказок",
          "promptTemplateText": "Текст шаблона подсказки",
          "promptVariantsHeader": "Наборы вариантов подсказок",
          "removeCustomizationDialogMsg": "Вы уверены, что хотите удалить настройку {0} для фрагмента запроса «{1}»?",
          "removeCustomizationDialogTitle": "Удалить настройки",
          "removeCustomizationWithDescDialogMsg": "Вы уверены, что хотите удалить настройку {0} для фрагмента запроса «{1}» ({2})?",
          "resetAllButton": "Сбросить все",
          "resetAllCustomizationsDialogMsg": "Вы уверены, что хотите сбросить все фрагменты подсказок до их встроенных версий? Это удалит все настройки.",
          "resetAllCustomizationsDialogTitle": "Сбросить все настройки",
          "resetAllCustomizationsTitle": "Сбросить все настройки",
          "resetAllPromptFragments": "Сбросить все фрагменты подсказок",
          "resetToBuiltInDialogMsg": "Вы уверены, что хотите сбросить фрагмент командной строки «{0}» до его встроенной версии? Это удалит все настройки.",
          "resetToBuiltInDialogTitle": "Сброс до встроенных настроек",
          "resetToBuiltInTitle": "Сбросить до этого встроенного",
          "resetToCustomizationDialogMsg": "Вы уверены, что хотите сбросить фрагмент подсказки «{0}» для использования настройки {1}? Это удалит все настройки с более высоким приоритетом.",
          "resetToCustomizationDialogTitle": "Сброс настроек",
          "resetToCustomizationTitle": "Сбросить настройки",
          "selectedVariantLabel": "Выбранные",
          "selectedVariantTitle": "Выбранный вариант",
          "usedByAgentTitle": "Используется агентом: {0}",
          "variantSetError": "Выбранный вариант не существует, и не удалось найти значение по умолчанию. Проверьте свою конфигурацию.",
          "variantSetWarning": "Выбранный вариант не существует. Вместо него используется вариант по умолчанию.",
          "variantsOfSystemPrompt": "Варианты этого набора вариантов подсказок:"
        },
        "promptTemplates": {
          "description": "Папка для хранения настраиваемых шаблонов командной строки. Если настройка не выполнена, используется каталог конфигурации пользователя. Для управления вариантами шаблонов командной строки рекомендуется использовать папку, которая находится под контролем версий.",
          "openLabel": "Выбрать папку"
        },
        "promptVariable": {
          "argDescription": "Идентификатор шаблона подсказки для разрешения",
          "completions": {
            "detail": {
              "builtin": "Встроенный фрагмент командной строки",
              "custom": "Настраиваемый фрагмент подсказки"
            }
          },
          "description": "Решает шаблоны запросов через службу запросов."
        },
        "prompts": {
          "category": "Шаблоны запросов для ИИ"
        },
        "requestSettings": {
          "clientSettings": {
            "description": "Настройки клиента для обработки сообщений, которые отправляются обратно в llm.",
            "keepThinking": {
              "description": "Если установлено значение false, все результаты обработки будут отфильтрованы перед отправкой следующего запроса пользователя в многоходовом диалоге."
            },
            "keepToolCalls": {
              "description": "Если установлено значение false, все запросы и ответы инструментов будут фильтроваться перед отправкой следующего запроса пользователя в многоходовом диалоге."
            }
          },
          "mdDescription": "Позволяет задавать настраиваемые параметры запроса для нескольких моделей.\nКаждый параметр состоит из:\n- `scope`: определяет, когда применяется настройка:\n- `modelId` (необязательно): идентификатор модели для сопоставления\n- `providerId` (необязательно): Идентификатор провайдера для сопоставления (например, huggingface, openai, ollama, llamafile)\n- `agentId` (необязательно): Идентификатор агента для сопоставления\n- `requestSettings`: Настройки для конкретной модели в виде пар «ключ-значение»\n- `clientSettings`: Настройки обработки сообщений на стороне клиента:\n- `keepToolCalls` (булево значение): Сохранять ли вызовы инструментов в контексте\n              - `keepThinking` (булево значение): Сохранять ли сообщения о размышлениях\nНастройки сопоставляются на основе специфичности (агент: 100, модель: 10, провайдер: 1 балл).\n            Дополнительную информацию см. в [нашей документации](https://theia-ide.org/docs/user_ai/#custom-request-settings).",
          "modelSpecificSettings": {
            "description": "Настройки для конкретного идентификатора модели."
          },
          "scope": {
            "agentId": {
              "description": "(Необязательный) идентификатор агента, к которому будут применены настройки."
            },
            "modelId": {
              "description": "Идентификатор модели (необязательно)"
            },
            "providerId": {
              "description": "(Необязательный) идентификатор поставщика, к которому будут применены настройки."
            }
          },
          "title": "Настройки пользовательского запроса"
        },
        "skillDirectories": {
          "description": "Дополнительные каталоги, содержащие определения навыков (файлы SKILL.md). Навыки предоставляют повторно используемые инструкции, на которые могут ссылаться агенты ИИ. Каталог .prompts/skills в рабочей области и каталог skills в папке конфигурации продукта всегда включены."
        },
        "skillsVariable": {
          "description": "Возвращает список доступных навыков, которые могут использоваться агентами ИИ."
        },
        "taskContextSummary": {
          "description": "Разрешает все элементы контекста задачи, присутствующие в контексте сеанса."
        },
        "templateSettings": {
          "edited": "отредактировано",
          "unavailableVariant": "Недоступно"
        },
        "thinkingMode": {
          "mdDescription": "Позволяет задавать настройки режима мышления для моделей, поддерживающих расширенные возможности мышления.\nКаждая настройка состоит из:\n- `scope`: определяет, когда применяется настройка:\n- `modelId` (необязательно): идентификатор модели для сопоставления\n- `providerId` (необязательно): идентификатор поставщика для сопоставления\n- `agentId` (необязательно): Идентификатор агента для сопоставления\n- `thinkingMode`: Конфигурация режима мышления:\n- `enabled` (булево значение): Включен ли режим мышления\n- `budgetTokens` (число, необязательно): Максимальное количество токенов для мышления (если поддерживается моделью)\nНастройки сопоставляются на основе специфичности (агент: 100, модель: 10, поставщик: 1 балл).",
          "scope": {
            "agentId": {
              "description": "(Необязательный) идентификатор агента, к которому будут применены настройки."
            },
            "modelId": {
              "description": "Идентификатор модели (необязательно)"
            },
            "providerId": {
              "description": "(Необязательный) идентификатор поставщика, к которому будут применены настройки."
            }
          },
          "thinkingMode": {
            "budgetTokens": {
              "description": "Максимальное количество токенов, которые можно использовать для мышления. Применимо только в том случае, если модель поддерживает бюджет мышления."
            },
            "description": "Настройка режима мышления.",
            "enabled": {
              "description": "Включен ли режим размышления."
            }
          },
          "title": "Настройки режима мышления"
        },
        "todayVariable": {
          "description": "Сделать что-то на сегодня",
          "format": {
            "description": "Формат даты"
          }
        },
        "unableToDisplayVariableValue": "Невозможно отобразить значение переменной.",
        "unableToResolveVariable": "Невозможно разрешить переменную.",
        "variable-contribution": {
          "builtInVariable": "Встроенная переменная Theia",
          "currentAbsoluteFilePath": "Абсолютный путь к                 текущему открытому файлу. Обратите внимание, что большинство агентов ожидают относительный путь к файлу (относительно текущего рабочего пространства).",
          "currentFileContent": "Обычное содержимое                 текущего открытого файла. Это исключает информацию о том, откуда взято содержимое. Обратите внимание, что большинство агентов будут работать лучше с относительным путем к файлу                 (относительно текущего рабочего пространства).",
          "currentRelativeDirPath": "Относительный путь к каталогу, содержащему открытый в данный момент файл.",
          "currentRelativeFilePath": "Относительный путь к                 текущему открытому файлу.",
          "currentSelectedText": "Обычный текст, который в данный момент выбран в открытом файле. Это исключает информацию о том, откуда взято содержимое. Обратите внимание, что большинство агентов будут работать лучше с относительным путем к файлу (относительно текущего рабочего пространства).",
          "dotRelativePath": "Краткая ссылка на относительный путь к текущему открытому файлу («currentRelativeFilePath»)."
        }
      },
      "editor": {
        "editorContextVariable": {
          "description": "Разрешает контекстную информацию, специфичную для редактора.",
          "label": "EditorContext"
        },
        "explainWithAI": {
          "prompt": "Объясните эту ошибку",
          "title": "Объясните с помощью ИИ"
        },
        "fixWithAI": {
          "prompt": "Помощь в устранении этой ошибки"
        }
      },
      "google": {
        "apiKey": {
          "description": "Введите ключ API вашей официальной учетной записи Google AI (Gemini). **Обратите внимание:** при использовании этого параметра ключ API GOOGLE AI будет храниться в виде открытого текста на компьютере, на котором работает Theia. Используйте переменную среды `GOOGLE_API_KEY`, чтобы безопасно установить ключ."
        },
        "maxRetriesOnErrors": {
          "description": "Максимальное количество попыток повтора в случае ошибок. Если значение меньше 1, то логика повторных попыток отключена."
        },
        "models": {
          "description": "Официальные модели Google Gemini для использования"
        },
        "retryDelayOnOtherErrors": {
          "description": "Задержка в секундах между повторными попытками в случае других ошибок (иногда Google GenAI сообщает об ошибках, таких как неполный синтаксис JSON, возвращенный из модели, или 500 Internal Server Error). Установка этого параметра в -1 предотвращает повторные попытки в этих случаях. В противном случае повторная попытка происходит либо немедленно (если установлено значение 0), либо после этой задержки в секундах (если установлено положительное число)."
        },
        "retryDelayOnRateLimitError": {
          "description": "Задержка в секундах между повторными попытками в случае ошибок ограничения скорости. См. https://ai.google.dev/gemini-api/docs/rate-limits"
        }
      },
      "history": {
        "clear": {
          "tooltip": "Очистить историю всех агентов"
        },
        "edited": "отредактировано",
        "exchange-card": {
          "agentId": "Агент",
          "timestamp": "Запущено"
        },
        "open-history-tooltip": "Открыть историю AI...",
        "request-card": {
          "agent": "Агент",
          "model": "Модель",
          "promptVariant": "Вариант подсказки",
          "request": "Запрос",
          "response": "Ответ",
          "timestamp": "Временная метка",
          "title": "Запрос"
        },
        "sortChronologically": {
          "tooltip": "Сортировать по дате"
        },
        "sortReverseChronologically": {
          "tooltip": "Сортировать в обратном хронологическом порядке"
        },
        "toggleCompact": {
          "tooltip": "Показать компактный вид"
        },
        "toggleHideNewlines": {
          "tooltip": "Прекратить интерпретацию новых строк"
        },
        "toggleRaw": {
          "tooltip": "Показать исходный вид"
        },
        "toggleRenderNewlines": {
          "tooltip": "Интерпретировать новые строки"
        },
        "view": {
          "label": "История AI-агента [бета-версия]",
          "noAgent": "Агент недоступен.",
          "noAgentSelected": "Агент не выбран.",
          "noHistoryForAgent": "История для выбранного агента «{0}» отсутствует."
        }
      },
      "huggingFace": {
        "apiKey": {
          "mdDescription": "Введите ключ API для вашей учетной записи Hugging Face. **Обратите внимание:** при использовании этого параметра ключ API Hugging Face будет храниться в виде открытого текста на компьютере, на котором работает Theia. Используйте переменную среды `HUGGINGFACE_API_KEY`, чтобы безопасно установить ключ."
        },
        "models": {
          "mdDescription": "Модели Hugging Face для использования. **Обратите внимание:** в настоящее время поддерживаются только модели, поддерживающие API автозаполнения чата (модели, настроенные на инструкции, такие как `*-Instruct`). Для некоторых моделей может потребоваться принятие условий лицензии на веб-сайте Hugging Face."
        }
      },
      "ide": {
        "agent-description": "Настройте параметры AI-агента, включая включение, выбор LLM, настройку шаблона подсказок и создание пользовательского агента в [ oknove AI Configuration View]({0}).",
        "agentConfiguration": {
          "capabilityOn": "На",
          "customAgentLocationQuickPick": {
            "createNewFile": "Создать новый файл",
            "openExistingFile": "Открыть существующий файл",
            "placeholder": "Выберите, где создать или открыть файл пользовательских агентов",
            "title": "Выберите местоположение для файла пользовательских агентов"
          },
          "enabledByDefault": "Включено по умолчанию",
          "noDescription": "Описание отсутствует."
        },
        "app-tester": {
          "errorCheckingDevToolsServerStatus": "Проверка ошибок Статус сервера DevTools MCP: {0}",
          "errorCheckingPlaywrightServerStatus": "Проверка ошибок Статус сервера Playwright MCP: {0}",
          "startChromeDevToolsMcpServers": {
            "canceled": "Пожалуйста, настройте сервер Chrome DevTools MCP.",
            "error": "Не удалось запустить сервер Chrome DevTools MCP: {0}",
            "progress": "Запуск сервера Chrome DevTools MCP.",
            "question": "Сервер Chrome DevTools MCP не запущен. Хотите запустить его сейчас? Это может привести к установке сервера Chrome DevTools MCP."
          },
          "startMcpServers": {
            "no": "Нет, отменить",
            "yes": "Да, запустите серверы."
          },
          "startPlaywrightServers": {
            "canceled": "Пожалуйста, настройте серверы Playwright MCP.",
            "error": "Не удалось запустить серверы Playwright MCP: {0}",
            "progress": "Запуск серверов Playwright MCP.",
            "question": "Серверы Playwright MCP не запущены. Хотите запустить их сейчас? Это может привести к установке серверов Playwright MCP."
          }
        },
        "appTester": {
          "description": "Позволяет агенту тестировать браузерные приложения от начала до конца. Для этого агент может делегировать задачу агенту AppTester, который автоматизирует взаимодействие с браузером для проверки реализации.",
          "name": "Тестировщик приложений"
        },
        "architectAgent": {
          "mode": {
            "plan": "План Режим",
            "simple": "Простой режим"
          },
          "suggestion": {
            "executePlanWithCoder": "Выполнить «{0}» с помощью Coder"
          }
        },
        "browseAllChats": "Просмотреть все чаты...",
        "bypassHint": "Некоторые агенты, такие как Claude Code, не требуют языковых моделей Theia.",
        "chatDisabledMessage": {
          "title": "Функции искусственного интеллекта отключены"
        },
        "coderAgent": {
          "mode": {
            "agentNext": "Режим агента (Далее)",
            "edit": "Режим редактирования"
          },
          "suggestion": {
            "fixProblems": {
              "content": "[Исправьте проблемы]({0}) в текущем файле.",
              "prompt": "Пожалуйста, посмотрите {1} и исправьте все проблемы."
            },
            "startNewChat": "Сообщения в чате должны быть краткими и по существу. [Начните новый чат]({0}) для новой задачи или [начните новый чат с кратким изложением этого]({1})."
          }
        },
        "commandAgent": {
          "commandCallback": {
            "confirmAction": "Понятно",
            "label": "Команда AI",
            "message": "Выполнение обратного вызова с аргументами {0}. Первый аргумент — это идентификатор команды, зарегистрированный для динамически зарегистрированной команды. Остальные аргументы — это фактические аргументы для обработчика."
          },
          "description": "Этот агент знает все команды, которые пользователь может выполнить в IDE Theia, инструменте, с которым пользователь работает в данный момент. На основе запроса пользователя он может найти нужную команду и позволить пользователю ее выполнить.",
          "response": {
            "customHandler": "Попробуйте выполнить следующее:",
            "noCommand": "К сожалению, я не могу найти такую команду.",
            "theiaCommand": "Я нашел эту команду, которая может вам помочь:"
          },
          "vars": {
            "commandIds": {
              "description": "Список доступных команд в Theia."
            }
          }
        },
        "configurationState": "Проблемы с конфигурацией",
        "configureAgent": {
          "header": "Настройка агента по умолчанию"
        },
        "continueAnyway": "Продолжить все равно",
        "createSkillAgent": {
          "mode": {
            "edit": "Режим по умолчанию"
          }
        },
        "deleteChat": "Удалить чат",
        "enableAI": {
          "mdDescription": "Эта настройка позволяет вам получить доступ к новейшим возможностям искусственного интеллекта (бета-версия).            \n            Обратите внимание, что эти функции находятся в бета-фазе, что означает, что они могут             подвергаться изменениям и будут дальнейшему усовершенствованию. Важно помнить, что эти функции могут генерировать            непрерывные запросы к языковым моделям (LLM), к которым вы предоставляете доступ. Это может повлечь за собой расходы, которые вам            необходимо тщательно контролировать. Включая эту опцию, вы признаете эти риски.            \n            **Обратите внимание! Настройки, приведенные ниже в этом разделе, вступят в силу\n            только после включения основной настройки функции. После включения функции вам необходимо настроить хотя бы одного            поставщика LLM ниже. См. также [документацию](https://theia-ide.org/docs/user_ai/)**."
        },
        "github": {
          "configureGitHubServer": {
            "canceled": "Конфигурация сервера GitHub отменена. Настройте сервер GitHub MCP для использования этого агента.",
            "followup": "Файл настроек открыт. Добавьте свой личный токен доступа GitHub в свойство `serverAuthToken` в конфигурации сервера GitHub, затем  сохраните и попробуйте снова.\n\nВы можете создать личный токен доступа по адресу: https://github.com/settings/tokens",
            "no": "Нет, отменить",
            "question": "Сервер GitHub MCP не настроен. Хотите настроить его сейчас? Откроется файл settings.json, в который можно добавить токен доступа GitHub.",
            "yes": "Да, настройте сервер GitHub"
          },
          "description": "Этот агент помогает вам взаимодействовать с репозиториями GitHub, проблемами, запросами на извлечение и другими функциями GitHub через сервер GitHub MCP. Он может помочь вам управлять репозиториями, создавать проблемы, обрабатывать запросы на извлечение и выполнять различные операции GitHub.",
          "errorCheckingGitHubServerStatus": "Проверка ошибок Статус сервера GitHub MCP: {0}",
          "startGitHubServer": {
            "canceled": "Запустите сервер GitHub MCP, чтобы использовать этот агент.",
            "error": "Не удалось запустить сервер GitHub MCP: {0}",
            "no": "Нет, отменить",
            "progress": "Запуск сервера GitHub MCP.",
            "question": "Сервер GitHub MCP настроен, но не запущен. Хотите запустить его сейчас?",
            "yes": "Да, запустите сервер"
          }
        },
        "githubCapability": {
          "description": "Позволяет агенту взаимодействовать с GitHub. Для этого агент может делегировать полномочия агенту GitHub, который может читать и записывать проблемы, запросы на извлечение, комментарии и содержимое репозитория.",
          "name": "GitHub"
        },
        "githubRepoName": {
          "description": "Название текущего репозитория GitHub (например, «eclipse-theia/theia»)."
        },
        "howToGetStarted": "Как начать работу",
        "model-selection-description": "Выберите, какие большие языковые модели (LLM) будут использоваться каждым агентом ИИ в [окне настроек ИИ]({0}).",
        "moreAgentsAvailable": {
          "header": "Доступно больше агентов"
        },
        "noRecommendedAgents": "Рекомендуемых агентов нет.",
        "openSettings": "Открыть настройки AI",
        "orchestrator": {
          "error": {
            "noAgents": "Нет доступных чат-агентов для обработки запроса. Проверьте настройки, чтобы убедиться, что они включены."
          },
          "excludedAgents": {
            "mdDescription": "Список идентификаторов агентов, которым оркестратор не может делегировать задачи. Эти агенты не будут видны оркестратору при выборе агента для обработки запроса."
          },
          "progressMessage": "Определение наиболее подходящего агента",
          "response": {
            "delegatingToAgent": "Делегирование `@{0}`"
          }
        },
        "prompt-template-description": "Выберите варианты запросов и настройте шаблоны запросов для агентов ИИ в [окне настройки ИИ]({0}).",
        "recentChats": "Последние чаты",
        "renameChat": "Переименовать чат",
        "shellAllowlist": {
          "placeholder": "Например, «git log» (точно) или «git log *» (с аргументами)."
        },
        "shellDenylist": {
          "placeholder": "Например, «git push *» или «rm -rf /»."
        },
        "shellExecutionCapability": {
          "description": "Позволяет агенту запускать произвольные команды оболочки в системе хоста. Затем агент может делегировать выполнение скриптов, которые недоступны в качестве задач, запрашивать системную информацию и выполнять операции, для которых не существует специальных инструментов.",
          "name": "Выполнение оболочки"
        },
        "skillsConfiguration": {
          "location": {
            "label": "Местоположение"
          },
          "noSkills": "Навыки отсутствуют",
          "noSlashCommands": "Скосы команды недоступны",
          "slashCommand": {
            "allAgents": "Все агенты"
          },
          "slashCommandsSectionHeader": "Команды со слэшем"
        },
        "toolsConfiguration": {
          "confirmAlwaysAllow": {
            "confirm": "Я понимаю, включить автоматическое одобрение",
            "genericWarning": "Этот инструмент требует подтверждения, прежде чем можно будет включить автоматическое одобрение. После включения все будущие вызовы будут выполняться без подтверждения. Включайте эту функцию только в том случае, если вы доверяете этому инструменту и понимаете потенциальные риски.",
            "title": "Включить автоматическое одобрение для «{0}»?"
          },
          "confirmationMode": {
            "label": "Режим подтверждения"
          },
          "default": {
            "label": "Режим подтверждения по умолчанию:"
          },
          "resetAll": "Сбросить все",
          "resetAllConfirmDialog": {
            "msg": "Вы уверены, что хотите сбросить все режимы подтверждения инструментов до значений по умолчанию? Это приведет к удалению всех настроек пользователя.",
            "title": "Сброс всех режимов подтверждения инструмента"
          },
          "resetAllTooltip": "Сбросить все инструменты до значений по умолчанию",
          "shellAllowlist": {
            "description": "Команды, соответствующие этим шаблонам, будут автоматически разрешены без подтверждения. Используйте * в качестве подстановочного знака: «git log» (точное совпадение), «git log *» (с любыми аргументами). Перед подстановочным знаком должно быть пробел.",
            "empty": "Шаблоны не настроены. Все команды оболочки будут требовать подтверждения.",
            "title": "Список разрешенных команд оболочки"
          },
          "shellDenylist": {
            "description": "Команды, соответствующие этим шаблонам, будут автоматически отклоняться без подтверждения. Используйте эту функцию для блокировки опасных команд, таких как «git push *» или «rm -rf /».",
            "empty": "Шаблоны не настроены. Никакие команды оболочки не будут автоматически запрещены.",
            "title": "Shell Execute Denylist"
          },
          "toolOptions": {
            "confirm": {
              "label": "Подтвердить"
            }
          }
        },
        "tooltip": {
          "agent": "Агент",
          "lastActivity": "Последняя активность",
          "lastMessage": "Последнее сообщение",
          "messages": "Сообщения",
          "multipleExchanges": "{0} обмены",
          "oneExchange": "1 обмен",
          "unread": "Непрочитанные"
        },
        "variableConfiguration": {
          "selectVariable": "Выберите переменную.",
          "usedByAgents": "Используется агентами",
          "variableArgs": "Аргументы"
        }
      },
      "llamaFile": {
        "prefs": {
          "mdDescription": "Эта настройка позволяет настраивать и управлять моделями LlamaFile в Theia IDE.            \n            Каждая запись требует удобного для пользователя `имени`, файла `uri`, указывающего на ваш LlamaFile, и `порта`, на котором он будет работать.            \n            Чтобы запустить LlamaFile, используйте команду «Запустить LlamaFile», которая позволяет выбрать нужную модель.            \n            Если вы редактируете запись (например, меняете порт), все запущенные экземпляры остановятся, и вам нужно будет запустить их снова вручную.            \n            [Узнайте больше о настройке и управлении LlamaFiles в документации Theia IDE](https://theia-ide.org/docs/user_ai/#llamafile-models).",
          "name": {
            "description": "Название модели, которое следует использовать для этого файла Llamafile."
          },
          "port": {
            "description": "Порт, который необходимо использовать для запуска сервера."
          },
          "title": "AI LlamaFile",
          "uri": {
            "description": "URI файла Llamafile."
          }
        },
        "start": "Запустить Llamafile",
        "stop": "Stop Llamafile"
      },
      "llamafile": {
        "error": {
          "noConfigured": "Llamafiles не настроен.",
          "noRunning": "Llamafiles не запущено.",
          "startFailed": "Во время запуска llamafile произошла ошибка: {0}.\nДополнительную информацию см. в консоли.",
          "stopFailed": "Во время остановки llamafile произошла ошибка: {0}.\nДополнительные сведения см. в консоли."
        }
      },
      "mcp": {
        "error": {
          "allServersRunning": "Все серверы MCP уже запущены.",
          "noRunningServers": "Серверы MCP не работают.",
          "noServersConfigured": "Серверы MCP не настроены.",
          "startFailed": "При запуске сервера MCP произошла ошибка."
        },
        "info": {
          "serverStarted": "Сервер MCP «{0}» успешно запущен. Зарегистрированные инструменты: {1}"
        },
        "servers": {
          "args": {
            "mdDescription": "Массив аргументов, которые необходимо передать команде.",
            "title": "Аргументы для команды"
          },
          "autostart": {
            "mdDescription": "Автоматически запускать этот сервер при запуске интерфейса. Вновь добавленные серверы не запускаются автоматически сразу, а при перезапуске.",
            "title": "Автозапуск"
          },
          "command": {
            "mdDescription": "Команда, используемая для запуска сервера MCP, например «uvx» или «npx».",
            "title": "Команда для запуска сервера MCP"
          },
          "env": {
            "mdDescription": "Дополнительные переменные среды, которые необходимо установить для сервера, например ключ API.",
            "title": "Переменные среды"
          },
          "headers": {
            "mdDescription": "Дополнительные заголовки, включаемые в каждый запрос к серверу.",
            "title": "Заголовки"
          },
          "mdDescription": "Настройте серверы MCP либо локально с помощью команд, аргументов и, опционально, переменных среды, либо удаленно с помощью URL-адреса сервера, токена аутентификации и, опционально, имени заголовка аутентификации. Кроме того, можно настроить автозапуск (по умолчанию true). Каждый сервер идентифицируется уникальным ключом, таким как «brave-search» или «filesystem». Чтобы запустить сервер, используйте команду «MCP: Start MCP Server», которая позволяет выбрать нужный сервер. Чтобы остановить сервер, используйте команду «MCP: Stop MCP Server». Обратите внимание, что автозапуск вступит в силу только после перезапуска, поэтому вам необходимо запустить сервер вручную в первый раз.\nПример конфигурации:\n```{\n  \"brave-search\": {\n    \"command\": \"npx\",\n    \"args\": [\n      \"-y\",\n      \"@modelcontextprotocol/server-brave-search\"\n    ],\n    \"env\": {\n      \"BRAVE_API_KEY\": \"YOUR_API_KEY\"\n    },\n  },\n  \"filesystem\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/Users/YOUR_USERNAME/Desktop\"],\n    \"env\": {\n      \"CUSTOM_ENV_VAR\": \"custom-value\"\n    },\n    \"autostart\": false\n  },\n  \"jira\": {\n    \"serverUrl\": \"YOUR_JIRA_MCP_SERVER_URL\",\n    \"serverAuthToken\": \"YOUR_JIRA_MCP_SERVER_TOKEN\"\n  }\n}\n```",
          "serverAuthToken": {
            "mdDescription": "Токен аутентификации для сервера, если требуется. Используется для аутентификации на удаленном сервере.",
            "title": "Токен аутентификации"
          },
          "serverAuthTokenHeader": {
            "mdDescription": "Имя заголовка, которое будет использоваться для токена аутентификации сервера. Если оно не указано, будет использоваться «Authorization» с «Bearer».",
            "title": "Имя заголовка аутентификации"
          },
          "serverUrl": {
            "mdDescription": "URL удаленного сервера MCP. Если он указан, сервер подключится к этому URL вместо запуска локального процесса.",
            "title": "URL-адрес сервера"
          },
          "title": "Конфигурация сервера MCP"
        },
        "start": {
          "label": "MCP: Запустить сервер MCP"
        },
        "stop": {
          "label": "MCP: Остановить сервер MCP"
        },
        "useWorkspaceAsRoot": {
          "mdDescription": "Корни определяют границы, в которых серверы могут работать в файловой системе. Если эта опция включена, папки рабочего пространства будут использоваться в качестве корней, в противном случае серверы MCP будут иметь доступ ко всей файловой системе. Изменение этого параметра приведет к перезапуску всех запущенных серверов MCP для применения новой конфигурации корней.",
          "title": "Использовать рабочую область в качестве корня"
        }
      },
      "mcpConfiguration": {
        "arguments": "Аргументы",
        "autostart": "Автозапуск",
        "connectServer": "Подключить",
        "connectingServer": "Подключение...",
        "copiedAllList": "Скопировал все инструменты в буфер обмена (список всех инструментов)",
        "copiedAllSingle": "Скопировал все инструменты в буфер обмена (один фрагмент командной строки со всеми инструментами)",
        "copiedForPromptTemplate": "Скопировал все инструменты в буфер обмена для шаблона подсказки (один фрагмент подсказки со всеми инструментами)",
        "copyAllList": "Копировать все (список всех инструментов)",
        "copyAllSingle": "Копировать все для чата (один фрагмент подсказки со всеми инструментами)",
        "copyForPrompt": "Инструмент копирования (для чата или шаблона командной строки)",
        "copyForPromptTemplate": "Копировать все для шаблона запроса (один фрагмент запроса со всеми инструментами)",
        "deleteServer": "Удалить сервер",
        "deleteServerDialogMsg": "Вы уверены, что хотите удалить сервер «{0}»?",
        "deleteServerDialogTitle": "Удалить сервер MCP",
        "deleteServerError": "Не удалось удалить сервер MCP: {0}",
        "editServer": "Редактировать сервер",
        "editServerTitle": "Редактировать сервер MCP",
        "environmentVariables": "Переменные среды",
        "form": {
          "argsPlaceholder": "Разделены пробелами, например, -y @modelcontextprotocol/server-brave-search",
          "authHeaderPlaceholder": "По умолчанию: авторизация с помощью Bearer",
          "authTokenPlaceholder": "Дополнительный токен аутентификации",
          "autostart": "Автозапуск",
          "commandPlaceholder": "Например, npx или uvx.",
          "commandRequired": "Команда требуется для локальных серверов.",
          "envPlaceholder": "KEY=значение (по одному на строку)",
          "headersPlaceholder": "Заголовок-Имя=значение (по одному на строку)",
          "localServer": "Локальный (командный)",
          "nameExists": "Сервер с таким именем уже существует.",
          "nameRequired": "Имя сервера является обязательным",
          "remoteServer": "Удаленный (URL)",
          "saveChanges": "Сохранить изменения",
          "serverName": "Имя сервера",
          "serverNamePlaceholder": "Например, my-mcp-server",
          "serverType": "Тип сервера",
          "serverUrlPlaceholder": "Например, https://mcp.example.com",
          "serverUrlRequired": "URL-адрес сервера требуется для удаленных серверов."
        },
        "headers": "Заголовки",
        "noServers": "Серверы MCP не настроены",
        "saveServerError": "Не удалось сохранить конфигурацию сервера MCP: {0}",
        "serverAuthToken": "Токен авторизации",
        "serverAuthTokenHeader": "Имя заголовка аутентификации",
        "serverUrl": "URL-адрес сервера",
        "tools": "Инструменты: "
      },
      "openai": {
        "apiKey": {
          "mdDescription": "Введите ключ API вашей официальной учетной записи OpenAI. **Обратите внимание:** при использовании этого параметра ключ API Open AI будет храниться в виде открытого текста на компьютере, на котором запущена Theia. Используйте переменную среды `OPENAI_API_KEY`, чтобы безопасно установить ключ."
        },
        "customEndpoints": {
          "apiKey": {
            "title": "Либо ключ для доступа к API, обслуживаемому по указанному URL-адресу, либо `true` для использования глобального ключа API OpenAI."
          },
          "apiVersion": {
            "title": "Версия для доступа к API, обслуживаемому по указанному URL-адресу в Azure, или `true` для использования глобальной версии OpenAI API."
          },
          "deployment": {
            "title": "Имя развертывания для доступа к API, обслуживаемому по указанному URL-адресу в Azure."
          },
          "developerMessageSettings": {
            "title": "Управляет обработкой системных сообщений: `user`, `system` и `developer` будут использоваться в качестве роли, `mergeWithFollowingUserMessage` будет добавлять префикс к следующему пользовательскому сообщению с системным сообщением или преобразовывать системное сообщение в пользовательское сообщение, если следующее сообщение не является пользовательским сообщением. `skip` просто удалит системное сообщение), по умолчанию используется `developer`."
          },
          "enableStreaming": {
            "title": "Указывает, следует ли использовать потоковый API. По умолчанию `true`."
          },
          "id": {
            "title": "Уникальный идентификатор, который используется в пользовательском интерфейсе для идентификации настраиваемой модели."
          },
          "mdDescription": "Интегрируйте пользовательские модели, совместимые с API OpenAI, например, через `vllm`. Требуемые атрибуты: `model` и `url`.            \n            Опционально вы можете            \n            - указать уникальный `id` для идентификации пользовательской модели в пользовательском интерфейсе. Если он не указан, в качестве `id` будет использоваться `model`.            \n            - предоставить `apiKey` для доступа к API, обслуживаемому по указанному URL. Используйте `true`, чтобы указать использование глобального ключа API OpenAI.            \n            - предоставить `apiVersion` для доступа к API, обслуживаемому по указанному URL в Azure. Используйте `true`, чтобы указать использование глобальной версии API OpenAI.            \n- предоставить имя `deployment` для вашего развертывания Azure.            \n- установить `developerMessageSettings` в одно из значений `user`, `system`, `developer`, `mergeWithFollowingUserMessage` или `skip`, чтобы контролировать, как сообщение разработчика будет включено (где `user`, `system` и `developer` будут использоваться в качестве роли, `mergeWithFollowingUserMessage` будет добавлять префикс к следующему сообщению пользователя с системным сообщением или преобразовывать системное сообщение в сообщение пользователя, если следующее сообщение не является сообщением пользователя. `skip` просто удалит системное сообщение). По умолчанию используется `developer`.            \n            - Укажите `supportsStructuredOutput: false`, чтобы указать, что структурированный вывод не должен использоваться.\n- Укажите `enableStreaming: false`, чтобы указать, что потоковая передача не должна использоваться.\n- Укажите `useResponseApi: true`, чтобы использовать новую OpenAI Response API вместо Chat Completion API (требуется совместимая конечная точка).            \n            Дополнительную информацию см. в [нашей документации](https://theia-ide.org/docs/user_ai/#openai-compatible-models-eg-via-vllm).",
          "modelId": {
            "title": "Идентификатор модели"
          },
          "supportsStructuredOutput": {
            "title": "Указывает, поддерживает ли модель структурированный вывод. По умолчанию `true`."
          },
          "url": {
            "title": "Конечная точка, совместимая с Open AI API, на которой размещена модель."
          },
          "useResponseApi": {
            "title": "Используйте новую OpenAI Response API вместо Chat Completion API. По умолчанию для пользовательских провайдеров установлено значение `false`. Примечание: при использовании инструментов автоматически переключается на Chat Completions API."
          }
        },
        "models": {
          "description": "Официальные модели OpenAI для использования"
        },
        "useResponseApi": {
          "mdDescription": "Используйте новую API OpenAI Response вместо API Chat Completion для официальных моделей OpenAI.Эта настройка применима только к официальным моделям OpenAI — пользовательские провайдеры должны настраивать ее индивидуально. Обратите внимание, что для API ответа определения вызовов инструментов должны соответствовать [строгому определению схемы](https://platform.openai.com/docs/guides/function-calling#strict-mode) Open AI. Мы прилагаем все усилия для преобразования несоответствующих схем, но ошибки все же возможны."
        }
      },
      "promptTemplates": {
        "directories": {
          "description": "Список относительных путей, указывающих папки в текущем рабочем пространстве, которые необходимо просканировать на наличие шаблонов командной строки, специфичных для WORKSPACE. Если шаблоны с одинаковым ID (именем файла) существуют в нескольких местах, конфликты разрешаются по приоритету: специфические файлы шаблонов (наивысший) > каталоги рабочего пространства > глобальные каталоги (наинизший).",
          "title": "Каталоги шаблонов командных строк для конкретных рабочих пространств"
        },
        "extensions": {
          "description": "Список дополнительных расширений файлов в местах расположения подсказок, которые считаются шаблонами подсказок. «.prompttemplate» всегда считается шаблоном по умолчанию.",
          "title": "Дополнительные расширения файлов шаблонов подсказок"
        },
        "files": {
          "description": "Список относительных путей к конкретным файлам в текущей рабочей области, которые будут использоваться в качестве шаблонов командной строки. Если шаблоны с одинаковым ID (именем файла) существуют в нескольких местах, конфликты разрешаются по приоритету: конкретные файлы шаблонов (наивысший приоритет) > каталоги рабочей области > глобальные каталоги (наименьший приоритет).",
          "title": "Файлы шаблонов подсказок для конкретной рабочей среды"
        }
      },
      "scanoss": {
        "changeSet": {
          "clean": "Нет совпадений",
          "error": "Ошибка: Повторить",
          "error-notification": "Возникла ошибка ScanOSS: {0}.",
          "match": "Просмотреть совпадения",
          "scan": "Сканирование",
          "scanning": "Сканирование..."
        },
        "mode": {
          "automatic": {
            "description": "Включить автоматическое сканирование фрагментов кода в окнах чата."
          },
          "description": "Настройте функцию SCANOSS для анализа фрагментов кода в окнах чата. Это позволит отправлять хэш предлагаемых фрагментов кода в службу SCANOSS,\n размещенную на [Software Transparency foundation](https://www.softwaretransparency.org/osskb) для анализа.",
          "manual": {
            "description": "Пользователь может вручную запустить сканирование, нажав на элемент SCANOSS в окне чата."
          },
          "off": {
            "description": "Функция полностью отключена."
          }
        },
        "snippet": {
          "dialog-header": "Результаты ScanOSS",
          "errored": "SCANOSS — Ошибка — {0}",
          "file-name-heading": "Соответствие найдено в {0}",
          "in-progress": "SCANOSS — Выполняется сканирование...",
          "match-count": "Найдено {0} совпадений",
          "matched": "SCANOSS — найдено совпадение с {0}",
          "no-match": "SCANOSS — нет совпадений",
          "summary": "Резюме"
        }
      },
      "session-settings-dialog": {
        "advancedSettings": "Расширенные настройки (JSON)",
        "budgetTokens": "Бюджетные токены:",
        "enableThinking": "Включить расширенное мышление",
        "thinkingMode": "Режим мышления",
        "thinkingModeNote": "Некоторые модели могут игнорировать эту настройку.",
        "title": "Установить настройки сеанса",
        "tooltip": "Установить настройки сеанса"
      },
      "terminal": {
        "agent": {
          "description": "Этот агент помогает писать и выполнять произвольные команды терминала.         На основе запроса пользователя он предлагает команды и позволяет пользователю напрямую вставлять и выполнять их в терминале.         Он получает доступ к текущему каталогу, среде и последним выводам терминала, чтобы предоставить контекстную помощь.",
          "vars": {
            "cwd": {
              "description": "Текущий рабочий каталог."
            },
            "recentTerminalContents": {
              "description": "Последние 0–50 строк, отображаемых в терминале."
            },
            "shell": {
              "description": "Используемая оболочка, например, /usr/bin/zsh."
            },
            "userRequest": {
              "description": "Вопрос или запрос пользователя."
            }
          }
        },
        "askAi": "Спросить ИИ",
        "askTerminalCommand": "Спросите о команде терминала...",
        "hitEnterConfirm": "Нажмите Enter для подтверждения.",
        "howCanIHelp": "Чем могу помочь?",
        "loading": "Загрузка",
        "tryAgain": "Попробуйте еще раз...",
        "useArrowsAlternatives": " или используйте ⇅, чтобы показать альтернативы..."
      },
      "tokenUsage": {
        "cachedInputTokens": "Входные токены, записанные в кэш",
        "cachedInputTokensTooltip": "Отслеживается дополнительно к «входным токенам». Обычно стоит дороже, чем токены без кэширования.",
        "failedToGetTokenUsageData": "Не удалось получить данные об использовании токена: {0}",
        "inputTokens": "Входные токены",
        "label": "Использование токенов",
        "lastUsed": "Последнее использование",
        "model": "Модель",
        "noData": "Данные об использовании токена пока недоступны.",
        "note": "Использование токенов отслеживается с момента запуска приложения и не сохраняется.",
        "outputTokens": "Выходные токены",
        "readCachedInputTokens": "Входные токены, считываемые из кэша",
        "readCachedInputTokensTooltip": "Отслеживается дополнительно к «Input Token». Обычно значительно дешевле, чем без кэширования. Обычно не учитывается в ограничениях по скорости.",
        "total": "Всего",
        "totalTokens": "Общее количество токенов",
        "totalTokensTooltip": "«Входные токены» + «Выходные токены»"
      },
      "vercelai": {
        "anthropicApiKey": {
          "mdDescription": "Введите ключ API для моделей Anthropic, используемых Vercel AI SDK. **Обратите внимание:** при использовании этого параметра ключ API будет храниться в виде открытого текста на компьютере, на котором работает Theia. Используйте переменную среды `ANTHROPIC_API_KEY`, чтобы безопасно установить ключ."
        },
        "customEndpoints": {
          "apiKey": {
            "title": "Либо ключ для доступа к API, обслуживаемому по указанному URL-адресу, либо `true` для использования глобального ключа API."
          },
          "enableStreaming": {
            "title": "Указывает, следует ли использовать потоковый API. По умолчанию `true`."
          },
          "id": {
            "title": "Уникальный идентификатор, который используется в пользовательском интерфейсе для идентификации настраиваемой модели."
          },
          "mdDescription": "Интегрируйте пользовательские модели, совместимые с Vercel AI SDK. Требуемые атрибуты: `model` и `url`.            \n            По желанию вы можете            \n            - указать уникальный `id` для идентификации пользовательской модели в пользовательском интерфейсе. Если он не указан, в качестве `id` будет использоваться `model`.            \n            - предоставить `apiKey` для доступа к API, обслуживаемому по указанному URL. Используйте `true`, чтобы указать использование глобального ключа API.            \n            - укажите `supportsStructuredOutput: false`, чтобы указать, что структурированный вывод не должен использоваться.            \n            - укажите `enableStreaming: false`, чтобы указать, что потоковая передача не должна использоваться.            \n            - укажите `provider`, чтобы указать, от какого поставщика взята модель (openai, anthropic).",
          "modelId": {
            "title": "Идентификатор модели"
          },
          "supportsStructuredOutput": {
            "title": "Указывает, поддерживает ли модель структурированный вывод. По умолчанию `true`."
          },
          "url": {
            "title": "Конечная точка API, где размещена модель"
          }
        },
        "models": {
          "description": "Официальные модели для использования с Vercel AI SDK",
          "id": {
            "title": "Идентификатор модели"
          },
          "model": {
            "title": "Название модели"
          }
        },
        "openaiApiKey": {
          "mdDescription": "Введите ключ API для моделей OpenAI, используемых Vercel AI SDK. **Обратите внимание:** при использовании этого параметра ключ API будет храниться в виде открытого текста на компьютере, на котором работает Theia. Используйте переменную среды `OPENAI_API_KEY`, чтобы безопасно установить ключ."
        }
      },
      "workspace": {
        "coderAgent": {
          "description": "Искусственный интеллект, интегрированный в IDE Theia, предназначенный для помощи разработчикам программного обеспечения. Этот агент может получить доступ к рабочему пространству пользователя, получить список всех доступных файлов и папок и извлечь их содержимое. Кроме того, он может предлагать пользователю изменения файлов. Таким образом, он может помогать пользователю в задачах кодирования или других задачах, связанных с изменениями файлов."
        },
        "considerGitignore": {
          "description": "Если включено, исключает файлы/папки, указанные в глобальном файле .gitignore (ожидаемое расположение — корень рабочей области).",
          "title": "Рассмотрим .gitignore"
        },
        "createSkillAgent": {
          "description": "ИИ-помощник для создания новых навыков. Навыки предоставляют ИИ-агентам повторно используемые инструкции и знания в определенной области. Этот агент помогает создавать хорошо структурированные навыки в каталоге .prompts/skills с правильным YAML-фронтматтером и контентом в формате Markdown."
        },
        "excludedPattern": {
          "description": "Список шаблонов (glob или regex) для исключаемых файлов/папок.",
          "title": "Шаблоны исключенных файлов"
        },
        "projectInfoAgent": {
          "description": "ИИ-помощник для управления шаблонами информации о проекте. Этот агент помогает создавать, обновлять и просматривать файл .prompts/project-info.prompttemplate, который предоставляет другим ИИ-агентам контекстную информацию о вашем проекте. Он может анализировать ваше рабочее пространство, чтобы предлагать информацию о проекте или обновлять существующие шаблоны в соответствии с вашими требованиями."
        },
        "searchMaxResults": {
          "description": "Максимальное количество результатов поиска, возвращаемых функцией поиска в рабочей области.",
          "title": "Максимальное количество результатов поиска"
        },
        "workspaceAgent": {
          "description": "Искусственный интеллект, интегрированный в IDE Theia, предназначенный для помощи разработчикам программного обеспечения. Этот агент может получить доступ к рабочему пространству пользователя, получить список всех доступных файлов и папок и извлечь их содержимое. Он не может изменять файлы. Таким образом, он может отвечать на вопросы о текущем проекте, файлах проекта и исходном коде в рабочем пространстве, например, как построить проект, где разместить исходный код, где найти конкретный код или конфигурации и т. д."
        }
      }
    },
    "ai-chat": {
      "fileChangeSetTitle": "Предлагаемые изменения"
    },
    "ai-chat-ui": {
      "deleteChat": "Удалить чат",
      "initiate-session-task-context": "Контекст задачи: инициировать сессию",
      "navigate-back": "Вернуться назад",
      "navigate-forward": "Перейти вперед",
      "open-current-session-summary": "Открыть сводку текущей сессии",
      "open-settings-tooltip": "Открыть настройки AI...",
      "renameChat": "Переименовать чат",
      "scroll-lock": "Блокировка прокрутки",
      "scroll-unlock": "Разблокировать прокрутку",
      "session-settings": "Установить настройки сеанса",
      "showChats": "Показать чаты...",
      "summarize-current-session": "Обобщить текущую сессию"
    },
    "ai-claude-code": {
      "open-config": "Открыть конфигурацию Claude Code",
      "open-memory": "Открыть Claude Code Memory (CLAUDE.MD)"
    },
    "ai-core": {
      "agentCompletionMessage": "Агент «{0}» завершил свою задачу.",
      "agentCompletionMessageWithSession": "Агент «{0}» завершил свою задачу в «{1}».",
      "agentCompletionTitle": "Задача агента «{0}» выполнена",
      "preferences": {
        "title": "Функции искусственного интеллекта"
      },
      "showChat": "Показать чат"
    },
    "ai-editor": {
      "contextMenu": "Спросить ИИ",
      "sendToChat": "Отправить в чат с ИИ"
    },
    "ai-ide": {
      "addressGhReviewCommand": {
        "argumentHint": "<pr-number>",
        "description": "Комментарии по проверке адреса в запросе на извлечение GitHub"
      },
      "fixGhTicketCommand": {
        "argumentHint": "<номер билета>",
        "description": "Проанализируйте заявку GitHub и реализуйте решение."
      },
      "open-agent-settings-tooltip": "Открыть настройки агента...",
      "rememberCommand": {
        "argumentHint": "[подсказка по теме]",
        "description": "Извлечение тем из разговора и обновление информации о проекте"
      },
      "ticketCommand": {
        "argumentHint": "<номер билета>",
        "description": "Проанализируйте заявку GitHub и создайте план реализации."
      },
      "todoTool": {
        "noTasks": "Нет задач"
      }
    },
    "ai-mcp": {
      "blockedServersLabel": "Серверы MCP (автозапуск заблокирован)"
    },
    "ai-terminal": {
      "allowAllConfirm": "Я понимаю, разрешить все",
      "allowAllForever": "Всегда разрешать все команды оболочки...",
      "allowAllSession": "Разрешить все команды оболочки для этого чата...",
      "allowAllSessionConfirm": "Я понимаю, разрешить все для этого чата",
      "allowAllSessionTitle": "Разрешить ВСЕ команды оболочки для этого чата?",
      "allowAllSessionWarning": "Это позволит ИИ выполнять любые команды оболочки без подтверждения до конца данной сессии чата. Команды оболочки имеют полный доступ к системе и могут выполнять любые команды, изменять файлы за пределами рабочего пространства и получать доступ к сетевым ресурсам. Команды из списка запрещенных по-прежнему будут блокироваться.",
      "allowAllTitle": "Разрешить ВСЕ команды оболочки?",
      "allowAllWarning": "Это позволит ИИ выполнять любые команды оболочки без подтверждения. Команды оболочки имеют полный доступ к системе и могут выполнять любые команды, изменять файлы за пределами рабочего пространства и получать доступ к сетевым ресурсам. Команды из списка запрещенных по-прежнему будут блокироваться.",
      "alwaysAllowPattern": "Всегда разрешать {0}",
      "alwaysAllowPatterns": "Всегда разрешать {0} и {1}",
      "alwaysAllowPatternsList": "Всегда разрешать {0}",
      "alwaysDenyPattern": "Всегда отклонять {0}",
      "alwaysDenyPatterns": "Всегда отклонять {0} и {1}",
      "alwaysDenyPatternsList": "Всегда отклонять {0}",
      "cancelExecution": "Отмена выполнения команды",
      "canceling": "Отмена...",
      "configurePermissions": "Настройка разрешений команд оболочки",
      "confirmExecution": "Подтвердить команду оболочки",
      "denialReason": "Причина",
      "executionCanceled": "Отменено",
      "executionDenied": "Отклонено",
      "executionDeniedWithReason": "Отклонено с обоснованием",
      "noOutput": "Нет вывода",
      "partialOutput": "Частичный вывод",
      "shellCommandAllowlist": {
        "description": "Список шаблонов команд оболочки. Используйте * в качестве подстановочного знака: «git log» (точное совпадение), «git log *» (с дополнительными аргументами), «* --version» (любая команда, заканчивающаяся на --version). Перед подстановочным знаком должен стоять пробел. Команды с опасными шаблонами ($, обратные кавычки) никогда не разрешаются автоматически."
      },
      "shellCommandDenylist": {
        "description": "Список шаблонов команд оболочки, которые всегда должны быть запрещены. Команды, соответствующие этим шаблонам, будут автоматически отклоняться без подтверждения. Использует синтаксис шаблонов: «git push» (точное совпадение) или «git push *» (с любыми аргументами). Поставляется с шаблонами по умолчанию для опасных команд (eval, exec, sudo, rm -rf и т. д.)."
      },
      "timeout": "Таймаут",
      "workingDirectory": "Рабочий каталог"
    },
    "callhierarchy": {
      "noCallers": "Вызывающие устройства не обнаружены.",
      "open": "Открыть иерархию вызовов"
    },
    "chat": {
      "taskContextVariable": {
        "args": {
          "contextId": {
            "description": "Идентификатор контекста задачи, который необходимо извлечь, или сеанса чата, который необходимо обобщить."
          }
        },
        "description": "Предоставляет контекстную информацию для задачи, например план выполнения задачи или сводку предыдущих сеансов.",
        "label": "Контекст задачи"
      }
    },
    "collaboration": {
      "collaborate": "Совместная работа",
      "collaboration": "Совместная работа",
      "collaborationWorkspace": "Рабочая область для совместной работы",
      "connected": "Подключено",
      "connectedSession": "Подключено к сеансу совместной работы",
      "copiedInvitation": "Код приглашения скопирован в буфер обмена.",
      "copyAgain": "Скопировать еще раз",
      "createRoom": "Создать новую сессию совместной работы",
      "creatingRoom": "Создание сеанса",
      "end": "Завершить сеанс совместной работы",
      "endDetail": "Завершите сеанс, прекратите обмен контентом и отмените доступ для других пользователей.",
      "enterCode": "Введите код сеанса совместной работы",
      "failedCreate": "Не удалось создать комнату: {0}",
      "failedJoin": "Не удалось присоединиться к комнате: {0}",
      "fieldRequired": "Поле «{0}» (Имя пользователя) является обязательным для заполнения. Вход прерван.",
      "invite": "Пригласить других",
      "inviteDetail": "Скопируйте код приглашения, чтобы поделиться им с другими участниками сессии.",
      "joinRoom": "Присоединиться к сеансу совместной работы",
      "joiningRoom": "Присоединение к сеансу",
      "leave": "Выйти из сеанса совместной работы",
      "leaveDetail": "Отключиться от текущей сессии совместной работы и закрыть рабочее пространство.",
      "loginFailed": "Не удалось войти в систему.",
      "loginSuccessful": "Вход успешен.",
      "noAuth": "Сервер не предоставляет метод аутентификации.",
      "optional": "опционально",
      "selectAuth": "Выберите метод аутентификации",
      "selectCollaboration": "Выберите вариант совместной работы",
      "serverUrl": "URL-адрес сервера",
      "serverUrlDescription": "URL-адрес экземпляра сервера Open Collaboration Tools для сеансов совместной работы в режиме реального времени.",
      "sharedSession": "Совместная сессия",
      "startSession": "Начать или присоединиться к сеансу совместной работы",
      "userWantsToJoin": "Пользователь «{0}» хочет присоединиться к комнате для совместной работы.",
      "whatToDo": "Что вы хотели бы делать с другими участниками проекта?"
    },
    "core": {
      "about": {
        "compatibility": "{0} Совместимость",
        "defaultApi": "API {0} по умолчанию",
        "listOfExtensions": "Список расширений"
      },
      "common": {
        "closeAll": "Закрыть все вкладки",
        "closeAllTabMain": "Закрыть все вкладки в основной области",
        "closeOtherTabMain": "Закрыть другие вкладки в основной области",
        "closeOthers": "Закрыть другие вкладки",
        "closeRight": "Закрыть вкладки справа",
        "closeTab": "Закрыть вкладку",
        "closeTabMain": "Закрыть вкладку в основной области",
        "collapseAllTabs": "Свернуть все боковые панели",
        "collapseBottomPanel": "Переключить нижнюю панель",
        "collapseLeftPanel": "Переключить левую панель",
        "collapseRightPanel": "Переключить правую панель",
        "collapseTab": "Свернуть боковую панель",
        "showNextTabGroup": "Перейти к следующей группе вкладок",
        "showNextTabInGroup": "Перейти к следующей вкладке в группе",
        "showPreviousTabGroup": "Перейти к предыдущей группе вкладок",
        "showPreviousTabInGroup": "Перейти к предыдущей вкладке в группе",
        "toggleMaximized": "Переключить в максимальный размер"
      },
      "copyInfo": "Сначала откройте файл, чтобы скопировать его путь",
      "copyWarn": "Пожалуйста, используйте команду копирования браузера или горячую клавишу.",
      "cutWarn": "Пожалуйста, используйте команду «Вырезать» или горячую клавишу браузера.",
      "enhancedPreview": {
        "classic": "Отображение простого предварительного просмотра вкладки с основной информацией.",
        "enhanced": "Отображение расширенного предварительного просмотра вкладки с дополнительной информацией.",
        "visual": "Отображение визуального предварительного просмотра вкладки."
      },
      "file": {
        "browse": "Обзор"
      },
      "highlightModifiedTabs": "Управляет отображением верхней границы на измененных (грязных) вкладках редактора.",
      "keybinding": {
        "duplicateModifierError": "Невозможно проанализировать связь клавиш {0} Дублирующиеся модификаторы",
        "metaError": "Не удается проанализировать связь клавиш {0} meta предназначена только для OSX",
        "unrecognizedKeyError": "Нераспознанная клавиша {0} в {1}"
      },
      "keybindingStatus": "{0} была нажата, ожидание дальнейших нажатий клавиш",
      "keyboard": {
        "choose": "Выбрать раскладку клавиатуры",
        "chooseLayout": "Выберите раскладку клавиатуры",
        "current": "(текущая версия: {0})",
        "currentLayout": " - текущая компоновка",
        "mac": "Клавиатуры Mac",
        "pc": "Клавиатуры для ПК",
        "tryDetect": "Попытайтесь определить раскладку клавиатуры по информации браузера и нажатым клавишам."
      },
      "navigator": {
        "clipboardWarn": "Доступ к буферу обмена запрещен. Проверьте разрешения вашего браузера.",
        "clipboardWarnFirefox": "API буфера обмена недоступен. Его можно включить с помощью настройки «{0}» на странице «{1}». Затем перезагрузите Theia. Обратите внимание, что это позволит FireFox получить полный доступ к системному буферу обмена."
      },
      "offline": "Офлайн",
      "pasteWarn": "Пожалуйста, используйте команду «Вставить» или горячую клавишу браузера.",
      "quitMessage": "Несохраненные изменения не будут сохранены.",
      "resetWorkbenchLayout": "Сбросить макет рабочей среды",
      "searchbox": {
        "close": "Закрыть (Escape)",
        "next": "Далее (вниз)",
        "previous": "Назад (Вверх)",
        "showAll": "Показать все элементы",
        "showOnlyMatching": "Показать только соответствующие элементы"
      },
      "secondaryWindow": {
        "alwaysOnTop": "Когда эта функция включена, второе окно остается поверх всех других окон, включая окна других приложений.",
        "description": "Устанавливает начальное положение и размер извлеченного вторичного окна.",
        "fullSize": "Положение и размер извлеченного виджета будут такими же, как и в запущенном приложении Theia.",
        "halfWidth": "Положение и размер извлеченного виджета будут составлять половину ширины запущенного приложения Theia.",
        "originalSize": "Положение и размер извлеченного виджета будут такими же, как у исходного виджета."
      },
      "severity": {
        "log": "Журнал"
      },
      "silentNotifications": "Управляет подавлением всплывающих уведомлений.",
      "tabDefaultSize": "Указывает размер вкладок по умолчанию.",
      "tabMaximize": "Управляет максимальным размером вкладок при двойном щелчке.",
      "tabMinimumSize": "Указывает минимальный размер вкладок.",
      "tabShrinkToFit": "Сжимать вкладки, чтобы они помещались в доступном пространстве.",
      "window": {
        "tabCloseIconPlacement": {
          "description": "Размещайте значки закрытия на заголовках вкладок в начале или в конце вкладки. По умолчанию на всех платформах они находятся в конце.",
          "end": "Разместите значок закрытия в конце метки. В языках, пишущихся слева направо, это правая сторона вкладки.",
          "start": "Разместите значок закрытия в начале метки. В языках, которые пишутся слева направо, это левая сторона вкладки."
        }
      },
      "window.menuBarVisibility": "Меню отображается в виде компактной кнопки на боковой панели. Это значение игнорируется, если {0} имеет значение {1}."
    },
    "debug": {
      "TheiaIDE": "Theia IDE",
      "addConfigurationPlaceholder": "Выберите корневую папку рабочей среды, чтобы добавить конфигурацию в",
      "breakpoint": "точка останова",
      "cannotRunToThisLocation": "Не удалось запустить текущий поток в указанном месте.",
      "compound-cycle": "Конфигурация запуска «{0}» содержит цикл с самим собой.",
      "conditionalBreakpoint": "Условная точка останова",
      "conditionalBreakpointsNotSupported": "Условные точки останова не поддерживаются этим типом отладки.",
      "confirmRunToShiftedPosition_msg": "Целевая позиция будет сдвинута на Ln {0} , Col {1}. Все равно запустить?",
      "confirmRunToShiftedPosition_title": "Невозможно запустить текущий поток точно в указанном месте",
      "consoleFilter": "Фильтр (например, текст, !исключить)",
      "consoleFilterAriaLabel": "Фильтр вывода консоли отладки",
      "consoleFilterTooltip": "Фильтруйте вывод консоли по тексту. Разделяйте несколько терминов запятыми. Добавьте префикс `!`, чтобы исключить термин.\n\nПримеры:\n\n- `text` — показать строки, содержащие «text»\n- `text, other` — показать строки, содержащие «text» или «other»\n- `!text` — скрыть строки, содержащие «text»\n- `text, !other` — показать «text», но скрыть «other»",
      "consoleSessionSelectorTooltip": "Переключение между сеансами отладки. Каждый сеанс отладки имеет свой собственный вывод в консоль.",
      "consoleSeverityTooltip": "Фильтрация вывода консоли по уровню серьезности. Будут отображаться только сообщения с выбранным уровнем серьезности.",
      "continueAll": "Продолжить Все",
      "copyExpressionValue": "Копировать значение выражения",
      "couldNotRunTask": "Не удалось выполнить задачу «{0}».",
      "dataBreakpoint": "точка останова данных",
      "debugConfiguration": "Конфигурация отладки",
      "debugRestricted": "Отладка отключена в ограниченном режиме.",
      "debugSessionInitializationFailed": "Инициализация сеанса отладки не удалась. Подробности см. в консоли.",
      "debugSessionTypeNotSupported": "Тип сеанса отладки «{0}» не поддерживается.",
      "debugToolbarMenu": "Меню панели инструментов отладки",
      "debugVariableInput": "Установить значение {0}",
      "disableSelectedBreakpoints": "Отключить выбранные точки останова",
      "disabledBreakpoint": "Отключено {0}",
      "enableSelectedBreakpoints": "Включить выбранные точки останова",
      "entry": "запись",
      "errorStartingDebugSession": "Произошла ошибка при запуске сеанса отладки, проверьте журналы для получения более подробной информации.",
      "exception": "исключение",
      "functionBreakpoint": "точка останова функции",
      "goto": "goto",
      "htiConditionalBreakpointsNotSupported": "Условные точки останова, не поддерживаемые этим типом отладки",
      "instruction-breakpoint": "Инструкция «Точка останова»",
      "instructionBreakpoint": "инструкция breakpoint",
      "logpointsNotSupported": "Лог-точки, не поддерживаемые этим типом отладки",
      "missingConfiguration": "Динамическая конфигурация «{0}: {1}» отсутствует или не применима.",
      "pause": "пауза",
      "pauseAll": "Приостановить все",
      "reveal": "Показать",
      "step": "шаг",
      "taskTerminatedBySignal": "Задача «{0}» завершена сигналом {1}.",
      "taskTerminatedForUnknownReason": "Задача «{0}» завершена по неизвестной причине.",
      "taskTerminatedWithExitCode": "Задача «{0}» завершена с кодом выхода {1}.",
      "threads": "Потоки",
      "toggleTracing": "Включение/отключение отслеживания связи с отладочными адаптерами",
      "unknownSession": "Неизвестная сессия",
      "unverifiedBreakpoint": "Непроверенный {0}"
    },
    "editor": {
      "clearFormatterSetting": "Очистить настройки форматирования",
      "configuredIn": "Настроено в {0}",
      "configuredNotInstalled": "«{0}» настроен в «{1}», но не установлен.",
      "configuredNotInstalledFallbackNamed": "«{0}», настроенный в «{1}», не установлен, используется «{2}».",
      "currentFormatter": "(Текущий)",
      "diffEditor.wordWrap2": "Перенос строк будет выполняться в соответствии с настройкой `#editor.wordWrap#`.",
      "dirtyEncoding": "Файл поврежден. Пожалуйста, сначала сохраните его, прежде чем открывать его с другой кодировкой.",
      "editor.bracketPairColorization.enabled": "Управляет включением или отключением раскраски пар скобок. Используйте `#workbench.colorCustomizations#`, чтобы переопределить цвета выделения скобок.",
      "editor.codeActions.triggerOnFocusChange": "Включите запуск `#editor.codeActionsOnSave#`, когда `#files.autoSave#` установлен в `afterDelay`. Code Actions должен быть установлен в `always`, чтобы запускаться при изменении окна и фокуса.",
      "editor.detectIndentation": "Управляет тем, будут ли `#editor.tabSize#` и `#editor.insertSpaces#` автоматически определяться при открытии файла на основе его содержимого.",
      "editor.experimental.preferTreeSitter": "Управляет включением/выключением анализа Tree Sitter для определенных языков. Этот параметр имеет приоритет над `editor.experimental.treeSitterTelemetry` для указанных языков.",
      "editor.inlayHints.enabled1": "Подсказки отображаются по умолчанию и скрываются при удержании Ctrl+Alt.",
      "editor.inlayHints.enabled2": "Подсказки по вставкам по умолчанию скрыты и отображаются при удержании Ctrl+Alt.",
      "editor.inlayHints.fontFamily": "Управляет семейством шрифтов подсказок в редакторе. Если значение пустое, используется `#editor.fontFamily#`.",
      "editor.inlayHints.fontSize": "Управляет размером шрифта всплывающих подсказок в редакторе. По умолчанию используется `#editor.fontSize#`, если настроенное значение меньше `5` или больше размера шрифта редактора.",
      "editor.inlineSuggest.edits.experimental.enabled": "Управляет включением экспериментальных правок во встроенных предложениях.",
      "editor.inlineSuggest.edits.experimental.onlyShowWhenCloseToCursor": "Управляет отображением встроенных подсказок только в том случае, если курсор находится рядом с подсказкой.",
      "editor.inlineSuggest.edits.experimental.useInterleavedLinesDiff": "Управляет включением экспериментальной функции сравнения чередующихся строк в встроенных предложениях.",
      "editor.inlineSuggest.edits.experimental.useMixedLinesDiff": "Управляет включением экспериментальных правок во встроенных предложениях.",
      "editor.insertSpaces": "Вставлять пробелы при нажатии клавиши `Tab`. Эта настройка переопределяется на основе содержимого файла, когда `#editor.detectIndentation#` включен.",
      "editor.quickSuggestions": "Управляет автоматическим отображением предложений во время ввода текста. Эту настройку можно контролировать при вводе комментариев, строк и другого кода. Быстрое предложение можно настроить для отображения в виде призрачного текста или с помощью виджета предложений. Также обратите внимание на настройку `#editor.suggestOnTriggerCharacters#`, которая управляет тем, запускаются ли предложения при вводе специальных символов.",
      "editor.suggestFontSize": "Размер шрифта для виджета предложений. При установке значения `0` используется значение `#editor.fontSize#`.",
      "editor.suggestLineHeight": "Высота строки для виджета предложений. При установке значения `0` используется значение `#editor.lineHeight#`. Минимальное значение — 8.",
      "editor.tabSize": "Количество пробелов, равное табуляции. Этот параметр переопределяется на основе содержимого файла, когда `#editor.detectIndentation#` включен.",
      "formatOnSaveTimeout": "Время ожидания в миллисекундах, по истечении которого форматирование, выполняемое при сохранении файла, отменяется.",
      "formatter": "Форматировщик",
      "noDefaultConfiguredLabel": "Форматировщик по умолчанию не настроен",
      "noDefaultConfiguredTooltip": "Форматировщик по умолчанию не настроен (доступны форматировщики {0}).",
      "noEditor": "Редактор не активен",
      "noFormatter": "Без форматирования",
      "noFormatterInstalled": "Форматировщик не установлен",
      "noFormattersAvailable": "Для этого языка нет доступных форматеров.",
      "noFormattersInstalledTooltip": "Для этого языка не установлены форматоры.",
      "onlyAvailableFormatter": "Доступный только формат",
      "onlyFormatterInstalled": "{0} (установлен только форматтер)",
      "persistClosedEditors": "Управляет сохранением истории закрытых редакторов для рабочей области при перезагрузке окна.",
      "selectFormatter": "Выбрать формат по умолчанию",
      "selectScope": "Выберите место для сохранения настройки",
      "showAllEditors": "Показать все открытые редакторы",
      "showFormatterInfo": "Показать информацию о форматировании",
      "splitHorizontal": "Разделенный редактор по горизонтали",
      "splitVertical": "Разделенный редактор по вертикали",
      "toggleStickyScroll": "Переключить фиксированную прокрутку",
      "userSettingsDetail": "Применить ко всем рабочим пространствам",
      "workspaceSettingsDetail": "Применить только к текущему рабочему пространству"
    },
    "external-terminal": {
      "cwd": "Выбрать текущий рабочий каталог для нового внешнего терминала"
    },
    "file-search": {
      "toggleIgnoredFiles": " (Нажмите «{0}», чтобы показать/скрыть игнорируемые файлы)"
    },
    "fileDialog": {
      "showHidden": "Показать скрытые файлы"
    },
    "fileSystem": {
      "fileResource": {
        "overWriteBody": "Хотите перезаписать изменения, внесенные в «{0}» в файловой системе?"
      }
    },
    "filesystem": {
      "copiedToClipboard": "Ссылка для скачивания скопирована в буфер обмена.",
      "copyDownloadLink": "Скопировать ссылку для скачивания",
      "dialog": {
        "initialLocation": "Перейти к исходному местоположению",
        "multipleItemMessage": "Вы можете выбрать только один элемент.",
        "navigateBack": "Вернуться назад",
        "navigateForward": "Перейти вперед",
        "navigateUp": "Перейти на один уровень вверх"
      },
      "fileResource": {
        "binaryFileQuery": "Открытие может занять некоторое время и привести к неотзывчивости IDE. Вы все равно хотите открыть «{0}»?",
        "binaryTitle": "Файл является двоичным или использует неподдерживаемую кодировку текста.",
        "largeFileTitle": "Файл слишком велик ({0}).",
        "overwriteTitle": "Файл «{0}» был изменен в файловой системе."
      },
      "filesExclude": "Настройте шаблоны glob для исключения файлов и папок. Например, файловый проводник решает, какие файлы и папки отображать или скрывать, на основе этой настройки.",
      "format": "Формат:",
      "maxConcurrentUploads": "Максимальное количество файлов, которые можно загружать одновременно при загрузке нескольких файлов. 0 означает, что все файлы будут загружены одновременно.",
      "maxFileSizeMB": "Управляет максимальным размером файла в МБ, который можно открыть.",
      "prepareDownload": "Подготовка загрузки...",
      "prepareDownloadLink": "Подготовка ссылки для скачивания...",
      "processedOutOf": "Обработано {0} из {1}",
      "replaceTitle": "Заменить файл",
      "uploadFailed": "Произошла ошибка при загрузке файла. {0}",
      "uploadFiles": "Загрузка файлов",
      "uploadedOutOf": "Загружено с {0} из {1}"
    },
    "getting-started": {
      "ai": {
        "header": "В IDE Theia доступна поддержка ИИ (бета-версия)!",
        "openAIChatView": "Откройте окно AI Chat View, чтобы узнать, как начать!"
      },
      "apiComparator": "{0} Совместимость API",
      "newExtension": "Создание нового расширения",
      "newPlugin": "Создание нового плагина",
      "startup-editor": {
        "welcomePage": "Откройте страницу приветствия, содержащую информацию, которая поможет вам начать работу с {0} и расширениями."
      },
      "telemetry": "Использование данных и телеметрия"
    },
    "git": {
      "aFewSecondsAgo": "несколько секунд назад",
      "addSignedOff": "Добавить «Подписано»",
      "added": "Добавлено",
      "amendReuseMessage": "Чтобы повторно использовать последнее сообщение о фиксации, нажмите «Enter» или «Escape», чтобы отменить.",
      "amendRewrite": "Перепишите предыдущее сообщение о фиксации. Нажмите «Enter» для подтверждения или «Escape» для отмены.",
      "checkoutCreateLocalBranchWithName": "Создайте новую локальную ветвь с именем: {0}. Нажмите «Enter» для подтверждения или «Escape» для отмены.",
      "checkoutProvideBranchName": "Укажите название ветки. ",
      "checkoutSelectRef": "Выберите ссылку для проверки или создайте новую локальную ветвь:",
      "cloneQuickInputLabel": "Укажите расположение репозитория Git. Нажмите «Enter» для подтверждения или «Escape» для отмены.",
      "cloneRepository": "Склонируйте репозиторий Git: {0}. Нажмите «Enter» для подтверждения или «Escape» для отмены.",
      "compareWith": "Сравните с...",
      "compareWithBranchOrTag": "Выберите ветвь или тег для сравнения с текущей активной ветвью {0}:",
      "conflicted": "Конфликт",
      "copied": "Скопировано",
      "diff": "Diff",
      "dirtyDiffLinesLimit": "Не показывать обозначения нечистых различий, если количество строк в редакторе превышает этот предел.",
      "dropStashMessage": "Склад успешно удален.",
      "editorDecorationsEnabled": "Показать украшения git в редакторе.",
      "fetchPickRemote": "Выберите удаленный сервер для загрузки:",
      "gitDecorationsColors": "Используйте цветовую маркировку в навигаторе.",
      "mergeEditor": {
        "currentSideTitle": "Текущий",
        "incomingSideTitle": "Входящий"
      },
      "mergeQuickPickPlaceholder": "Выберите ветвь для слияния с текущей активной ветвью {0}:",
      "missingUserInfo": "Убедитесь, что вы настроили «user.name» и «user.email» в git.",
      "noHistoryForError": "История для {0} отсутствует.",
      "noPreviousCommit": "Нет предыдущих коммитов для изменения",
      "noRepositoriesSelected": "Репозитории не были выбраны.",
      "prepositionIn": "in",
      "renamed": "Переименовано",
      "repositoryNotInitialized": "Репозиторий {0} еще не инициализирован.",
      "stashChanges": "Сохранить изменения. Нажмите «Enter» для подтверждения или «Escape» для отмены.",
      "stashChangesWithMessage": "Сохранить изменения с сообщением: {0}. Нажмите «Enter» для подтверждения или «Escape» для отмены.",
      "tabTitleIndex": "{0} (Индекс)",
      "tabTitleWorkingTree": "{0} (Рабочее дерево)",
      "toggleBlameAnnotations": "Переключить аннотации обвинений",
      "unstaged": "Неподготовленный"
    },
    "keybinding-schema-updater": {
      "deprecation": "Вместо этого используйте клаузу `when`."
    },
    "keymaps": {
      "addKeybindingTitle": "Добавить сочетание клавиш для «{0}»",
      "editKeybinding": "Редактировать настройку клавиш...",
      "editKeybindingTitle": "Редактирование клавиш быстрого доступа для {0}",
      "editWhenExpression": "Редактировать при выражении...",
      "editWhenExpressionTitle": "Редактировать выражение для «{0}»",
      "keybinding": {
        "copy": "Копировать комбинацию клавиш",
        "copyCommandId": "Копировать ID команды клавиши",
        "copyCommandTitle": "Копировать название команды клавиш",
        "edit": "Редактировать настройку клавиш...",
        "editWhenExpression": "Редактировать связь клавиш при выражении..."
      },
      "keybindingCollidesValidation": "в настоящее время происходит конфликт клавиш",
      "requiredKeybindingValidation": "Значение keybinding является обязательным",
      "resetKeybindingConfirmation": "Вы действительно хотите сбросить эту комбинацию клавиш до значения по умолчанию?",
      "resetKeybindingTitle": "Сброс настроек клавиш для {0}",
      "resetMultipleKeybindingsWarning": "Если для этой команды существует несколько сочетаний клавиш, все они будут сброшены."
    },
    "localize": {
      "offlineTooltip": "Невозможно подключиться к бэкенду."
    },
    "markers": {
      "clearAll": "Очистить все",
      "noProblems": "На данный момент в рабочей области не обнаружено никаких проблем.",
      "tabbarDecorationsEnabled": "Показать декораторы проблем (диагностические маркеры) на панелях вкладок."
    },
    "memory-inspector": {
      "addressTooltip": "Место в памяти для отображения, адрес или выражение, оцениваемое как адрес.",
      "ascii": "ASCII",
      "binary": "Двоичный",
      "byteSize": "Размер байта",
      "bytesPerGroup": "Байты на группу",
      "closeSettings": "Закрыть настройки",
      "columns": "Столбцы",
      "command": {
        "createNewMemory": "Создать новый инспектор памяти",
        "createNewRegisterView": "Создать новый регистр просмотра",
        "followPointer": "Следуйте указателю",
        "followPointerMemory": "Следуйте указателю в инспекторе памяти",
        "resetValue": "Сбросить значение",
        "showRegister": "Показать регистр в инспекторе памяти",
        "viewVariable": "Показать переменную в инспекторе памяти"
      },
      "data": "Данные",
      "decimal": "Десятичный",
      "diff": {
        "label": "Diff: {0}"
      },
      "diff-widget": {
        "offset-label": "{0} Смещение",
        "offset-title": "Байты для смещения памяти от {0}"
      },
      "editable": {
        "apply": "Применить изменения",
        "clear": "Очистить изменения"
      },
      "endianness": "Эндианность",
      "extraColumn": "Дополнительная колонка",
      "groupsPerRow": "Группы в строке",
      "hexadecimal": "Шестнадцатеричный",
      "length": "Длина",
      "lengthTooltip": "Количество байтов для извлечения, в десятичной или шестнадцатеричной системе счисления.",
      "memory": {
        "addressField": {
          "memoryReadError": "Введите адрес или выражение в поле «Местоположение»."
        },
        "freeze": "Заморозить просмотр памяти",
        "hideSettings": "Скрыть панель настроек",
        "readError": {
          "bounds": "Превышены границы памяти, результат будет усечен.",
          "noContents": "В настоящее время содержимое памяти недоступно."
        },
        "readLength": {
          "memoryReadError": "Введите длину (десятичное или шестнадцатеричное число) в поле «Длина»."
        },
        "showSettings": "Показать панель настроек",
        "unfreeze": "Разморозить просмотр памяти",
        "userError": "Произошла ошибка при извлечении памяти."
      },
      "memoryCategory": "Инспектор памяти",
      "memoryInspector": "Инспектор памяти",
      "memoryTitle": "Память",
      "octal": "Восьмеричный",
      "offset": "Смещение",
      "offsetTooltip": "Смещение, которое будет добавлено к текущему местоположению в памяти при навигации",
      "provider": {
        "localsError": "Невозможно прочитать локальные переменные. Нет активной сессии отладки.",
        "readError": "Невозможно прочитать память. Нет активной сессии отладки.",
        "writeError": "Невозможно записать в память. Нет активной сессии отладки."
      },
      "register": "Регистрация",
      "register-widget": {
        "filter-placeholder": "Фильтр (начинается с)"
      },
      "registerReadError": "Произошла ошибка при извлечении регистров.",
      "registers": "Регистры",
      "toggleComparisonWidgetVisibility": "Включение/выключение отображения виджета сравнения",
      "utils": {
        "afterBytes": "Вы должны загрузить память в оба виджета, которые хотите сравнить. {0} не имеет загруженной памяти.",
        "bytesMessage": "Вы должны загрузить память в оба виджета, которые хотите сравнить. {0} не имеет загруженной памяти."
      }
    },
    "messages": {
      "notificationTimeout": "Информационные уведомления будут скрыты по истечении этого времени.",
      "toggleNotifications": "Включить/выключить уведомления"
    },
    "mini-browser": {
      "typeUrl": "Введите URL-адрес"
    },
    "monaco": {
      "noSymbolsMatching": "Символы не найдены",
      "typeToSearchForSymbols": "Введите текст для поиска символов"
    },
    "navigator": {
      "autoReveal": "Автоматическое раскрытие",
      "clipboardWarn": "Доступ к буферу обмена запрещен. Проверьте разрешения вашего браузера.",
      "clipboardWarnFirefox": "API буфера обмена недоступен. Его можно включить с помощью настройки «{0}» на странице «{1}». Затем перезагрузите Theia. Обратите внимание, что это позволит FireFox получить полный доступ к системному буферу обмена.",
      "openWithSystemEditor": "Открыть с помощью системного редактора",
      "refresh": "Обновить в проводнике",
      "reveal": "Показать в проводнике",
      "systemEditor": "Системный редактор",
      "toggleHiddenFiles": "Переключение скрытых файлов"
    },
    "output": {
      "clearOutputChannel": "Очистить канал вывода...",
      "closeOutputChannel": "Закрыть канал вывода...",
      "hiddenChannels": "Скрытые каналы",
      "hideOutputChannel": "Скрыть канал вывода...",
      "maxChannelHistory": "Максимальное количество записей в канале вывода.",
      "outputChannels": "Каналы вывода",
      "showOutputChannel": "Показать канал вывода..."
    },
    "plugin": {
      "blockNewTab": "Ваш браузер не позволил открыть новую вкладку"
    },
    "plugin-dev": {
      "alreadyRunning": "Хостируемый экземпляр уже запущен.",
      "debugInstance": "Отладочный экземпляр",
      "debugMode": "Использование inspect или inspect-brk для отладки Node.js",
      "debugPorts": {
        "debugPort": "Порт, который будет использоваться для отладки Node.js на этом сервере",
        "serverName": "Имя сервера хоста плагина, например «hosted-plugin» в «--hosted-plugin-inspect=» или «headless-hosted-plugin» в «--headless-hosted-plugin-inspect=»."
      },
      "devHost": "Хост разработки",
      "failed": "Не удалось запустить размещенный экземпляр плагина: {0}",
      "hostedPlugin": "Хостируемый плагин",
      "hostedPluginRunning": "Хостируемый плагин: запущен",
      "hostedPluginStarting": "Хостируемый плагин: запуск",
      "hostedPluginStopped": "Хостируемый плагин: остановлен",
      "hostedPluginWatching": "Хостируемый плагин: наблюдение",
      "instanceTerminated": "{0} был завершен",
      "launchOutFiles": "Массив шаблонов glob для поиска сгенерированных файлов JavaScript (`${pluginPath}` будет заменено фактическим путем к плагину).",
      "noValidPlugin": "Указанная папка не содержит действительного плагина.",
      "notRunning": "Хостируемый экземпляр не запущен.",
      "pluginFolder": "Папка плагинов установлена в: {0}",
      "preventedNewTab": "Ваш браузер не позволил открыть новую вкладку",
      "restartInstance": "Перезапустить экземпляр",
      "running": "Хостируемый экземпляр работает по адресу:",
      "selectPath": "Выбрать путь",
      "startInstance": "Запустить экземпляр",
      "starting": "Запуск сервера хостируемого экземпляра...",
      "stopInstance": "Остановить экземпляр",
      "unknownTerminated": "Экземпляр был завершен.",
      "watchMode": "Запустить наблюдатель на плагине, находящемся в разработке"
    },
    "plugin-ext": {
      "authentication-main": {
        "loginTitle": "Вход",
        "signedOut": "Успешно вышли из системы."
      },
      "plugins": "Плагины",
      "webviewTrace": "Управляет отслеживанием связи с веб-просмотрщиками.",
      "webviewWarnIfUnsecure": "Предупреждает пользователей о том, что веб-просмотрщики в настоящее время развернуты небезопасным образом."
    },
    "preferences": {
      "ai-features": "Функции искусственного интеллекта",
      "hostedPlugin": "Хостируемый плагин",
      "toolbar": "Панель инструментов"
    },
    "preview": {
      "openByDefault": "По умолчанию открывать предварительный просмотр вместо редактора."
    },
    "property-view": {
      "created": "Создано",
      "directory": "Каталог",
      "lastModified": "Последнее изменение",
      "location": "Местоположение",
      "noProperties": "Свойства недоступны.",
      "properties": "Свойства",
      "symbolicLink": "Символическая ссылка"
    },
    "remote": {
      "dev-container": {
        "connect": "Повторно открыть в контейнере",
        "noDevcontainerFiles": "В рабочей области не найдено файлов devcontainer.json. Убедитесь, что у вас есть каталог .devcontainer с файлом devcontainer.json.",
        "selectDevcontainer": "Выберите файл devcontainer.json"
      },
      "ssh": {
        "connect": "Подключить текущее окно к хосту...",
        "connectToConfigHost": "Подключить текущее окно к хосту в файле конфигурации...",
        "enterHost": "Введите имя хоста SSH",
        "enterUser": "Введите имя пользователя SSH",
        "failure": "Не удалось открыть SSH-соединение с удаленным сервером.",
        "hostPlaceHolder": "Напримерhello@example.com",
        "needsHost": "Введите имя хоста.",
        "needsUser": "Введите имя пользователя.",
        "userPlaceHolder": "Например, hello"
      },
      "sshNoConfigPath": "Не найден путь к конфигурации SSH.",
      "wsl": {
        "connectToWsl": "Подключение к WSL",
        "connectToWslUsingDistro": "Подключиться к WSL с помощью Distro...",
        "noWslDistroFound": "Дистрибутивы WSL не найдены. Сначала установите дистрибутив WSL.",
        "reopenInWsl": "Повторно открыть папку в WSL",
        "selectWSLDistro": "Выберите дистрибутив WSL"
      }
    },
    "scm": {
      "amend": "Изменить",
      "amendHeadCommit": "HEAD Commit",
      "amendLastCommit": "Изменить последнюю фиксацию",
      "changeRepository": "Изменить репозиторий...",
      "config.untrackedChanges": "Управляет поведением неотслеживаемых изменений.",
      "config.untrackedChanges.hidden": "скрытый",
      "config.untrackedChanges.mixed": "смешанный",
      "config.untrackedChanges.separate": "отдельный",
      "dirtyDiff": {
        "close": "Закрыть Изменить Просмотр"
      },
      "history": "История",
      "mergeEditor": {
        "resetConfirmationTitle": "Вы действительно хотите сбросить результат слияния в этом редакторе?"
      },
      "noRepositoryFound": "Репозиторий не найден",
      "unamend": "Без изменений",
      "unamendCommit": "Неизменяемая фиксация"
    },
    "search-in-workspace": {
      "includeIgnoredFiles": "Включить игнорируемые файлы",
      "noFolderSpecified": "Вы не открыли и не указали папку. В настоящее время выполняется поиск только по открытым файлам.",
      "resultSubset": "Это только часть всех результатов. Используйте более конкретный поисковый термин, чтобы сузить список результатов.",
      "searchOnEditorModification": "Поиск в активном редакторе при изменении."
    },
    "secondary-window": {
      "extract-widget": "Переместить вид во второе окно"
    },
    "shell-area": {
      "secondary": "Второе окно"
    },
    "task": {
      "attachTask": "Прикрепить задачу...",
      "circularReferenceDetected": "Обнаружена циклическая ссылка: {0} --> {1}",
      "clearHistory": "Очистить историю",
      "errorKillingTask": "Ошибка при завершении задачи «{0}»: {1}",
      "errorLaunchingTask": "Ошибка при запуске задачи «{0}»: {1}",
      "invalidTaskConfigs": "Обнаружены недействительные конфигурации задач. Откройте файл tasks.json и найдите подробную информацию в окне «Проблемы».",
      "neverScanTaskOutput": "Никогда не сканируйте вывод задачи",
      "noTaskToRun": "Не найдено задач для выполнения. Настроить задачи...",
      "noTasksFound": "Задачи не найдены",
      "notEnoughDataInDependsOn": "Информации, предоставленной в «dependsOn», недостаточно для правильного сопоставления задач!",
      "schema": {
        "commandOptions": {
          "cwd": "Текущий рабочий каталог выполняемой программы или скрипта. Если не указано, используется корневой каталог текущей рабочей области Theia."
        },
        "presentation": {
          "panel": {
            "dedicated": "Терминал предназначен для выполнения конкретной задачи. Если эта задача выполняется повторно, терминал используется повторно. Однако результаты выполнения другой задачи отображаются в другом терминале.",
            "new": "Каждое выполнение этой задачи использует новый чистый терминал.",
            "shared": "Терминал является общим, и результаты выполнения других задач добавляются в тот же терминал."
          },
          "showReuseMessage": "Управляет отображением сообщения «Терминал будет повторно использоваться задачами»."
        },
        "problemMatcherObject": {
          "owner": "Владелец проблемы внутри Theia. Может быть опущен, если указана база. По умолчанию принимает значение «external», если опущен и база не указана."
        }
      },
      "taskAlreadyRunningInTerminal": "Задача уже выполняется в терминале.",
      "taskExitedWithCode": "Задача «{0}» завершилась с кодом {1}.",
      "taskIdLabel": "#{0}",
      "taskRestricted": "Выполнение задач отключено в ограниченном режиме.",
      "taskTerminatedBySignal": "Задача «{0}» была прервана сигналом {1}.",
      "terminalWillBeReusedByTasks": "Терминал будет повторно использоваться задачами."
    },
    "terminal": {
      "defaultProfile": "Профиль по умолчанию, используемый в {0}",
      "enableCopy": "Включите ctrl-c (cmd-c в macOS) для копирования выделенного текста.",
      "enablePaste": "Включите ctrl-v (cmd-v в macOS) для вставки из буфера обмена.",
      "profileArgs": "Аргументы оболочки, которые использует этот профиль.",
      "profileColor": "Идентификатор цвета темы терминала, который будет ассоциироваться с терминалом.",
      "profileDefault": "Выбрать профиль по умолчанию...",
      "profileIcon": "Идентификатор codicon, связанный с иконкой терминала.\nterminal-tmux:\"$(terminal-tmux)\"",
      "profileNew": "Новый терминал (с профилем)...",
      "profilePath": "Путь к оболочке, используемой этим профилем.",
      "profiles": "Профили, которые будут отображаться при создании нового терминала. Установите свойство пути вручную с помощью дополнительных аргументов.\nУстановите существующий профиль в значение `null`, чтобы скрыть его из списка, например: `\"{0}\": null`.",
      "rendererType": "Управляет отображением терминала.",
      "rendererTypeDeprecationMessage": "Тип рендерера больше не поддерживается в качестве опции.",
      "selectProfile": "Выберите профиль для нового терминала",
      "shell.deprecated": "Это устарело, новый рекомендуемый способ настройки оболочки по умолчанию — создать профиль терминала в «terminal.integrated.profiles.{0}» и установить его имя в качестве имени по умолчанию в «terminal.integrated.defaultProfile.{0}».",
      "shellArgsLinux": "Аргументы командной строки, которые следует использовать в терминале Linux.",
      "shellArgsOsx": "Аргументы командной строки, которые следует использовать в терминале macOS.",
      "shellArgsWindows": "Аргументы командной строки, которые необходимо использовать в терминале Windows.",
      "shellLinux": "Путь к оболочке, которую терминал использует в Linux (по умолчанию: «{0}»).",
      "shellOsx": "Путь к оболочке, которую терминал использует в macOS (по умолчанию: «{0}»).",
      "shellWindows": "Путь к оболочке, которую терминал использует в Windows. (по умолчанию: «{0}»)."
    },
    "terminal-manager": {
      "addTerminalToGroup": "Добавить терминал в группу",
      "closeDialog": {
        "message": "После закрытия диспетчера терминалов его макет не может быть восстановлен. Вы уверены, что хотите закрыть диспетчер терминалов?",
        "title": "Хотите закрыть диспетчер терминала?"
      },
      "closeTerminalManager": "Закрыть диспетчер терминалов",
      "createNewTerminalGroup": "Создать новую группу терминалов",
      "createNewTerminalPage": "Создать новую страницу терминала",
      "deleteGroup": "Удалить группу",
      "deletePage": "Удалить страницу",
      "deleteTerminal": "Удалить терминал",
      "group": "Группа",
      "label": "Терминалы",
      "maximizeBottomPanel": "Максимизировать нижнюю панель",
      "minimizeBottomPanel": "Свернуть нижнюю панель",
      "openTerminalManager": "Открыть диспетчер терминалов",
      "page": "Страница",
      "rename": "Переименовать",
      "resetTerminalManagerLayout": "Сбросить макет диспетчера терминалов",
      "tabsDisplay": "Управляет отображением терминалов. «tree» (дерево) отображает несколько терминалов в одном окне с деревом для управления, «tabbed» (вкладки) отображает каждый терминал в отдельном окне на отдельной вкладке.",
      "toggleTreeView": "Переключить деревовидный вид",
      "treeViewLocation": "Расположение дерева терминального менеджера. Применяется только в том случае, если «terminal.grouping.mode» установлено в «tree»."
    },
    "test": {
      "cancelAllTestRuns": "Отменить все тестовые запуски",
      "stackFrameAt": "at",
      "testRunDefaultName": "{0} запустить {1}",
      "testRuns": "Тестовые запуски"
    },
    "toolbar": {
      "addCommand": "Добавить команду на панель инструментов",
      "addCommandPlaceholder": "Найти команду для добавления на панель инструментов",
      "centerColumn": "Центральная колонка",
      "failedUpdate": "Не удалось обновить значение «{0}» в «{1}».",
      "filterIcons": "Значки фильтров",
      "iconSelectDialog": "Выберите значок для «{0}»",
      "iconSet": "Набор значков",
      "insertGroupLeft": "Вставить разделитель групп (слева)",
      "insertGroupRight": "Вставить разделитель групп (справа)",
      "leftColumn": "Левая колонка",
      "openJSON": "Настройка панели инструментов (Открыть JSON)",
      "removeCommand": "Удалить команду из панели инструментов",
      "restoreDefaults": "Восстановить настройки панели инструментов по умолчанию",
      "rightColumn": "Правая колонка",
      "selectIcon": "Выбрать значок",
      "toggleToolbar": "Переключить панель инструментов",
      "toolbarLocationPlaceholder": "Куда вы хотите добавить команду?",
      "useDefaultIcon": "Использовать значок по умолчанию"
    },
    "typehierarchy": {
      "subtypeHierarchy": "Иерархия подтипов",
      "supertypeHierarchy": "Иерархия супертипов"
    },
    "variableResolver": {
      "listAllVariables": "Переменная: Перечислить все"
    },
    "vsx-registry": {
      "confirmDialogMessage": "Расширение «{0}» не проверено и может представлять угрозу безопасности.",
      "confirmDialogTitle": "Вы уверены, что хотите продолжить установку?",
      "downloadCount": "Количество скачиваний: {0}",
      "errorFetching": "Ошибка при загрузке расширений.",
      "errorFetchingConfigurationHint": "Это может быть вызвано проблемами с настройкой сети.",
      "failedInstallingVSIX": "Не удалось установить {0} из VSIX.",
      "invalidVSIX": "Выбранный файл не является действительным плагином «*.vsix».",
      "license": "Лицензия: {0}",
      "onlyShowVerifiedExtensionsDescription": "Это позволяет {0} показывать только проверенные расширения.",
      "onlyShowVerifiedExtensionsTitle": "Показывать только проверенные расширения",
      "recommendedExtensions": "Список названий расширений, рекомендуемых для использования в этой рабочей области.",
      "searchPlaceholder": "Поиск расширений в {0}",
      "showInstalled": "Показать установленные расширения",
      "showRecommendedExtensions": "Управляет отображением уведомлений о рекомендациях по расширению.",
      "vsx-extensions-contribution": {
        "update-version-uninstall-error": "Ошибка при удалении расширения: {0}.",
        "update-version-version-error": "Не удалось установить версию {0} из {1}."
      }
    },
    "webview": {
      "goToReadme": "Перейти к README",
      "messageWarning": "            Шаблон хоста конечной точки {0} был изменен на `{1}`; изменение шаблона может привести к уязвимостям в системе безопасности.             Дополнительную информацию см. в `{2}`."
    },
    "workspace": {
      "bothAreDirectories": "Оба ресурса являются каталогами.",
      "clickToManageTrust": "Нажмите, чтобы управлять настройками доверия.",
      "compareWithEachOther": "Сравнить друг с другом",
      "confirmDeletePermanently.description": "Не удалось удалить «{0}» с помощью корзины. Хотите удалить навсегда?",
      "confirmDeletePermanently.solution": "Вы можете отключить использование корзины в настройках.",
      "confirmDeletePermanently.title": "Ошибка при удалении файла",
      "confirmMessage.delete": "Вы действительно хотите удалить следующие файлы?",
      "confirmMessage.dirtyMultiple": "Вы действительно хотите удалить файлы {0} с несохраненными изменениями?",
      "confirmMessage.dirtySingle": "Вы действительно хотите удалить файл {0} с несохраненными изменениями?",
      "confirmMessage.uriMultiple": "Вы действительно хотите удалить все выбранные файлы {0}?",
      "confirmMessage.uriSingle": "Вы действительно хотите удалить «{0}»?",
      "directoriesCannotBeCompared": "Каталоги не могут быть сопоставлены. {0}",
      "duplicate": "Дубликат",
      "failSaveAs": "Невозможно запустить «{0}» для текущего виджета.",
      "isDirectory": "«{0}» — это каталог.",
      "manageTrustPlaceholder": "Выберите состояние доверия для этой рабочей области",
      "newFilePlaceholder": "Имя файла",
      "newFolderPlaceholder": "Имя папки",
      "noErasure": "Примечание: Ничто не будет удалено с диска.",
      "notWorkspaceFile": "Недействительный файл рабочей области: {0}",
      "openRecentPlaceholder": "Введите название рабочего пространства, которое хотите открыть.",
      "openRecentWorkspace": "Открыть последнее рабочее пространство...",
      "preserveWindow": "Включить открытие рабочих пространств в текущем окне.",
      "removeFolder": "Вы уверены, что хотите удалить следующую папку из рабочей области?",
      "removeFolders": "Вы уверены, что хотите удалить следующие папки из рабочей области?",
      "restrictedModeDescription": "Некоторые функции отключены, поскольку данная рабочая область не является доверенной.",
      "restrictedModeNote": "*Обратите внимание: функция доверия рабочей среды в настоящее время находится в стадии разработки в Theia; не все функции еще интегрированы с доверием рабочей среды*.",
      "schema": {
        "folders": {
          "description": "Корневые папки в рабочей области"
        },
        "title": "Файл рабочей области"
      },
      "trashTitle": "Переместить «{0}» в корзину",
      "trustDialogMessage": "Если вы доверяете авторам, код в этой папке может быть выполнен.\n\nВ противном случае некоторые функции будут отключены.\n\nФункция доверия рабочей области в настоящее время находится в стадии разработки в Theia; не все функции еще интегрированы с доверием рабочей области.\nДля получения подробной информации проверьте индикатор «Ограниченный режим» в строке состояния.",
      "trustEmptyWindow": "Управляет тем, является ли пустая рабочая область доверенной по умолчанию.",
      "trustEnabled": "Управляет включением или отключением доверия рабочей области. Если отключено, все рабочие области являются доверенными.",
      "trustTrustedFolders": "Список URI папок, которые считаются надежными без запроса подтверждения.",
      "untitled-cleanup": "Похоже, что есть много файлов рабочего пространства без названий. Пожалуйста, проверьте {0} и удалите все неиспользуемые файлы.",
      "variables": {
        "cwd": {
          "description": "Текущий рабочий каталог задания при запуске"
        },
        "file": {
          "description": "Путь к текущему открытому файлу"
        },
        "fileBasename": {
          "description": "Базовое имя текущего открытого файла"
        },
        "fileBasenameNoExtension": {
          "description": "Имя текущего открытого файла без расширения"
        },
        "fileDirname": {
          "description": "Имя каталога текущего открытого файла."
        },
        "fileExtname": {
          "description": "Расширение текущего открытого файла"
        },
        "relativeFile": {
          "description": "Путь к текущему открытому файлу относительно корня рабочей области"
        },
        "relativeFileDirname": {
          "description": "Имя каталога текущего открытого файла относительно ${workspaceFolder}"
        },
        "workspaceFolder": {
          "description": "Путь к корневой папке рабочей области"
        },
        "workspaceFolderBasename": {
          "description": "Название корневой папки рабочей области"
        },
        "workspaceRoot": {
          "description": "Путь к корневой папке рабочей области"
        },
        "workspaceRootFolderName": {
          "description": "Название корневой папки рабочей области"
        }
      },
      "workspaceFolderAdded": "Было создано рабочее пространство с несколькими корнями. Хотите сохранить конфигурацию рабочего пространства в виде файла?",
      "workspaceFolderAddedTitle": "Папка добавлена в рабочую область"
    }
  },
  "vsx.disabling": "Отключение",
  "vsx.disabling.extensions": "Отключение {0}...",
  "vsx.enabling": "Включение",
  "vsx.enabling.extension": "Включение {0}..."
}
